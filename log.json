{
    "problems": [
        {
            "title": "Weird Algorithm",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    long long n; // Using long long to handle larger values of n\n    cin >> n;\n    \n    vector<long long> sequence;\n    sequence.push_back(n);\n    \n    while (n != 1) {\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = n * 3 + 1;\n        }\n        sequence.push_back(n);\n    }\n    \n    for (long long num : sequence) {\n        cout << num << \" \";\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.07287907600402832,
            "mean_memory_used": 3558952.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 1
        },
        {
            "title": "Repetitions",
            "solution": "#include <iostream>\n#include <string>\n\nint main() {\n    std::string dna;\n    std::cin >> dna;\n    \n    int n = dna.length();\n    if (n == 0) {\n        std::cout << 0 << std::endl;\n        return 0;\n    }\n\n    int maxLength = 1;\n    int currentLength = 1;\n\n    for (int i = 1; i < n; ++i) {\n        if (dna[i] == dna[i - 1]) {\n            currentLength++;\n        } else {\n            if (currentLength > maxLength) {\n                maxLength = currentLength;\n            }\n            currentLength = 1;\n        }\n    }\n\n    if (currentLength > maxLength) {\n        maxLength = currentLength;\n    }\n\n    std::cout << maxLength << std::endl;\n    return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.08021459976832072,
            "mean_memory_used": 3559080.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2
        },
        {
            "title": "Permutations",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    if (n == 1) {\n        cout << \"1\\n\";\n    } else if (n == 2 || n == 3) {\n        cout << \"NO SOLUTION\\n\";\n    } else {\n        vector<int> even, odd;\n        for (int i = 1; i <= n; ++i) {\n            if (i % 2 == 0) {\n                even.push_back(i);\n            } else {\n                odd.push_back(i);\n            }\n        }\n        \n        for (int x : even) {\n            cout << x << \" \";\n        }\n        for (int x : odd) {\n            cout << x << \" \";\n        }\n        cout << \"\\n\";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 21,
            "total_test_cases": 21,
            "mean_time_taken": 0.08935746692475818,
            "mean_memory_used": 3569987.8095238097,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3
        },
        {
            "title": "Number Spiral",
            "solution": "#include <iostream>\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        ll y, x;\n        cin >> y >> x;\n        ll max_val = max(y, x);\n        ll result;\n\n        if (max_val % 2 == 0) {\n            if (y == max_val) {\n                result = max_val * max_val - (x - 1);\n            } else {\n                result = (max_val - 1) * (max_val - 1) + y;\n            }\n        } else {\n            if (x == max_val) {\n                result = max_val * max_val - (y - 1);\n            } else {\n                result = (max_val - 1) * (max_val - 1) + x;\n            }\n        }\n\n        cout << result << '\\n';\n    }\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 2,
            "mean_time_taken": 0.09253311157226562,
            "mean_memory_used": 3597224.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4
        },
        {
            "title": "Two Knights",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    for (int k = 1; k <= n; ++k) {\n        long long total_ways = (long long)k * k * (k * k - 1) / 2;\n        long long attack_ways = 4 * (k - 1) * (k - 2);\n        cout << total_ways - attack_ways << endl;\n    }\n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 3,
            "mean_time_taken": 0.07931907971700032,
            "mean_memory_used": 3597352.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 5
        },
        {
            "title": "Towers",
            "solution": "#include <iostream>\n#include <set>\n#include <vector>\n\nint main() {\n    int n;\n    std::cin >> n;\n    std::vector<int> cubes(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> cubes[i];\n    }\n\n    std::multiset<int> towers;\n    for (int cube : cubes) {\n        auto it = towers.upper_bound(cube);\n        if (it != towers.end()) {\n            towers.erase(it);\n        }\n        towers.insert(cube);\n    }\n\n    std::cout << towers.size() << std::endl;\n    return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.13864725828170776,
            "mean_memory_used": 3597352.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6
        },
        {
            "title": "Stick Lengths",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    // Read the number of sticks\n    int n;\n    std::cin >> n;\n    \n    // Vector to store the lengths of the sticks\n    std::vector<int> sticks(n);\n    \n    // Read the lengths of the sticks\n    for(int i = 0; i < n; ++i) {\n        std::cin >> sticks[i];\n    }\n    \n    // Sort the lengths to find the median\n    std::sort(sticks.begin(), sticks.end());\n    \n    // Find the median\n    int median = sticks[n / 2];\n    \n    // Calculate the total cost to make all sticks equal to the median length\n    long long total_cost = 0;\n    for(int i = 0; i < n; ++i) {\n        total_cost += std::abs(sticks[i] - median);\n    }\n    \n    // Output the total cost\n    std::cout << total_cost << std::endl;\n    \n    return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.09108187935569069,
            "mean_memory_used": 3597352.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7
        },
        {
            "title": "Permutations II",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countBeautifulPermutations(int n) {\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n    \n    // Base case\n    dp[1][1] = 1;\n\n    for (int i = 2; i <= n; ++i) {\n        for (int j = 1; j <= i; ++j) {\n            for (int k = 1; k < i; ++k) {\n                if (abs(j - k) != 1) {\n                    dp[i][j] = (dp[i][j] + dp[i-1][k]) % MOD;\n                }\n            }\n        }\n    }\n\n    int result = 0;\n    for (int j = 1; j <= n; ++j) {\n        result = (result + dp[n][j]) % MOD;\n    }\n\n    return result;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    cout << countBeautifulPermutations(n) << endl;\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 23,
            "mean_time_taken": 0.35276178691698157,
            "mean_memory_used": 3597352.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7
        },
        {
            "title": "Sliding Window Median",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\nusing namespace std;\n\nclass SlidingWindowMedian {\npublic:\n    SlidingWindowMedian(int k) : k(k) {}\n\n    void addNum(int num) {\n        if (left.empty() || num <= *left.rbegin()) {\n            left.insert(num);\n        } else {\n            right.insert(num);\n        }\n        balanceHeaps();\n    }\n\n    void removeNum(int num) {\n        if (num <= *left.rbegin()) {\n            left.erase(left.find(num));\n        } else {\n            right.erase(right.find(num));\n        }\n        balanceHeaps();\n    }\n\n    int findMedian() {\n        return *left.rbegin();\n    }\n\nprivate:\n    int k;\n    multiset<int> left;\n    multiset<int> right;\n\n    void balanceHeaps() {\n        while (left.size() > right.size() + 1) {\n            right.insert(*left.rbegin());\n            left.erase(--left.end());\n        }\n        while (right.size() > left.size()) {\n            left.insert(*right.begin());\n            right.erase(right.begin());\n        }\n    }\n};\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> nums(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> nums[i];\n    }\n\n    SlidingWindowMedian swm(k);\n    for (int i = 0; i < k; ++i) {\n        swm.addNum(nums[i]);\n    }\n    cout << swm.findMedian() << \" \";\n\n    for (int i = k; i < n; ++i) {\n        swm.addNum(nums[i]);\n        swm.removeNum(nums[i - k]);\n        if(i != n-1) cout << swm.findMedian() << \" \";\n        else cout << swm.findMedian();\n    }\n\n    return 0;\n}",
            "passed_test_cases": 40,
            "total_test_cases": 40,
            "mean_time_taken": 0.13735588788986205,
            "mean_memory_used": 3597352.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8
        },
        {
            "title": "Sliding Window Cost",
            "solution": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nvoid balance(multiset<int>& low, multiset<int>& high) {\n    while (low.size() > high.size() + 1) {\n        high.insert(*low.rbegin());\n        low.erase(prev(low.end()));\n    }\n    while (high.size() > low.size()) {\n        low.insert(*high.begin());\n        high.erase(high.begin());\n    }\n}\n\nll calculate_cost(const multiset<int>& low, const multiset<int>& high, int median) {\n    ll cost = 0;\n    for (int x : low) {\n        cost += abs(x - median);\n    }\n    for (int x : high) {\n        cost += abs(x - median);\n    }\n    return cost;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> x(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> x[i];\n    }\n\n    multiset<int> low, high;\n    vector<ll> result;\n\n    for (int i = 0; i < n; ++i) {\n        if (low.empty() || x[i] <= *low.rbegin()) {\n            low.insert(x[i]);\n        } else {\n            high.insert(x[i]);\n        }\n\n        if (i >= k) {\n            if (x[i - k] <= *low.rbegin()) {\n                low.erase(low.find(x[i - k]));\n            } else {\n                high.erase(high.find(x[i - k]));\n            }\n        }\n\n        balance(low, high);\n\n        if (i >= k - 1) {\n            int median = *low.rbegin();\n            ll cost = calculate_cost(low, high, median);\n            result.push_back(cost);\n        }\n    }\n\n    for (ll cost : result) {\n        cout << cost << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 28,
            "total_test_cases": 34,
            "mean_time_taken": 0.27204519159653606,
            "mean_memory_used": 3597352.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                14,
                15,
                20,
                25,
                32
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8
        },
        {
            "title": "Grid Paths",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n    vector<vector<bool>> isTrap(n + 1, vector<bool>(n + 1, false));\n\n    for (int i = 0; i < m; ++i) {\n        int y, x;\n        cin >> y >> x;\n        isTrap[y][x] = true;\n    }\n\n    dp[1][1] = 1;\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            if (isTrap[i][j]) {\n                dp[i][j] = 0;\n            } else {\n                if (i > 1) dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD;\n                if (j > 1) dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD;\n            }\n        }\n    }\n\n    cout << dp[n][n] << endl;\n\n    return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 20,
            "mean_time_taken": 0.14409294128417968,
            "mean_memory_used": 3597352.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                12,
                14,
                16,
                17,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8
        },
        {
            "title": "Binomial Coefficients",
            "solution": "#include <iostream>\n#include <vector>\n#define MOD 1000000007\nusing namespace std;\n\n// Function to compute (a^b) % mod\nlong long modExp(long long a, long long b, long long mod) {\n    long long res = 1;\n    while (b > 0) {\n        if (b % 2 == 1) {\n            res = (res * a) % mod;\n        }\n        a = (a * a) % mod;\n        b /= 2;\n    }\n    return res;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<pair<int, int>> queries(n);\n    int max_a = 0;\n    \n    for (int i = 0; i < n; ++i) {\n        cin >> queries[i].first >> queries[i].second;\n        if (queries[i].first > max_a) {\n            max_a = queries[i].first;\n        }\n    }\n    \n    vector<long long> fact(max_a + 1), inv_fact(max_a + 1);\n    \n    // Precompute factorials and inverse factorials\n    fact[0] = 1;\n    for (int i = 1; i <= max_a; ++i) {\n        fact[i] = (fact[i-1] * i) % MOD;\n    }\n    \n    inv_fact[max_a] = modExp(fact[max_a], MOD - 2, MOD);\n    for (int i = max_a - 1; i >= 0; --i) {\n        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD;\n    }\n    \n    for (const auto& q : queries) {\n        int a = q.first, b = q.second;\n        if (b > a) {\n            cout << 0 << endl;\n        } else {\n            long long result = (fact[a] * inv_fact[b] % MOD) * inv_fact[a - b] % MOD;\n            cout << result << endl;\n        }\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.11461195078763095,
            "mean_memory_used": 3597352.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9
        },
        {
            "title": "Empty String",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countWaysToEmptyString(string s) {\n    int n = s.length();\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n\n    // Base case: single character substrings\n    for (int i = 0; i < n; ++i) {\n        dp[i][i] = 1;\n    }\n\n    // Fill the DP table\n    for (int len = 2; len <= n; ++len) {\n        for (int i = 0; i <= n - len; ++i) {\n            int j = i + len - 1;\n\n            // If the two ends are the same character, consider removing them together\n            if (s[i] == s[j]) {\n                dp[i][j] = dp[i+1][j-1];\n            }\n\n            // Consider all possible splits of the substring s[i...j]\n            for (int k = i; k < j; ++k) {\n                dp[i][j] = (dp[i][j] + 1LL * dp[i][k] * dp[k+1][j] % MOD) % MOD;\n            }\n        }\n    }\n\n    return dp[0][n-1];\n}\n\nint main() {\n    string s;\n    cin >> s;\n    cout << countWaysToEmptyString(s) << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.16461209456125894,
            "mean_memory_used": 3597352.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9
        },
        {
            "title": "Common Divisors",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    int max_value = 0;\n\n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i];\n        max_value = max(max_value, arr[i]);\n    }\n\n    vector<int> frequency(max_value + 1, 0);\n\n    // Count frequencies of each number in the array\n    for (int i = 0; i < n; ++i) {\n        frequency[arr[i]]++;\n    }\n\n    // Check from the largest possible GCD to the smallest\n    for (int g = max_value; g >= 1; --g) {\n        int count = 0;\n        for (int multiple = g; multiple <= max_value; multiple += g) {\n            count += frequency[multiple];\n        }\n        if (count > 1) {\n            cout << g << endl;\n            return 0;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 17,
            "total_test_cases": 17,
            "mean_time_taken": 0.09330415725708008,
            "mean_memory_used": 3597352.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10
        },
        {
            "title": "Sum of Divisors",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst long long MOD = 1000000007;\n\nlong long sum_of_divisors(long long n) {\n    long long result = 0;\n    for (long long d = 1; d * d <= n; ++d) {\n        long long m = n / d;\n        result = (result + d * (m * (m + 1) / 2) % MOD) % MOD;\n        if (d != m) {\n            long long sum_range = (d * (d - 1) / 2) % MOD; // sum of 1 to d-1\n            result = (result + ((m - d) * (m + d + 1) / 2 - sum_range) % MOD * d % MOD) % MOD;\n        }\n    }\n    return result;\n}\n\nint main() {\n    long long n;\n    cin >> n;\n    cout << sum_of_divisors(n) << endl;\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 18,
            "mean_time_taken": 0.07553406556447347,
            "mean_memory_used": 3597352.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10
        },
        {
            "title": "Missing Number",
            "solution": "#include <iostream>\n#include <vector>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    // Calculate the sum of the first n natural numbers\n    long long total_sum = n * (n + 1) / 2;\n\n    // Read the n-1 numbers and compute their sum\n    long long current_sum = 0;\n    for (int i = 0; i < n - 1; ++i) {\n        int number;\n        std::cin >> number;\n        current_sum += number;\n    }\n\n    // The missing number is the difference between the total sum and the current sum\n    long long missing_number = total_sum - current_sum;\n    \n    // Output the missing number\n    std::cout << missing_number << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 9,
            "total_test_cases": 14,
            "mean_time_taken": 0.08059603827340263,
            "mean_memory_used": 3597352.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                6,
                8,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10
        },
        {
            "title": "Apartments",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    int n, m, k;\n    std::cin >> n >> m >> k;\n    \n    std::vector<int> applicants(n);\n    std::vector<int> apartments(m);\n    \n    for (int i = 0; i < n; ++i) {\n        std::cin >> applicants[i];\n    }\n    \n    for (int i = 0; i < m; ++i) {\n        std::cin >> apartments[i];\n    }\n    \n    std::sort(applicants.begin(), applicants.end());\n    std::sort(apartments.begin(), apartments.end());\n    \n    int i = 0, j = 0;\n    int matches = 0;\n    \n    while (i < n && j < m) {\n        if (std::abs(applicants[i] - apartments[j]) <= k) {\n            // Found a match\n            ++matches;\n            ++i;\n            ++j;\n        } else if (apartments[j] < applicants[i] - k) {\n            // Apartment is too small\n            ++j;\n        } else {\n            // Applicant's requirement is too large\n            ++i;\n        }\n    }\n    \n    std::cout << matches << std::endl;\n    \n    return 0;\n}",
            "passed_test_cases": 19,
            "total_test_cases": 19,
            "mean_time_taken": 0.1273036003112793,
            "mean_memory_used": 3597352.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11
        },
        {
            "title": "Array Division",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool canDivide(const vector<int>& arr, int n, int k, long long maxSum) {\n    long long currentSum = 0;\n    int subarrays = 1; // Start with one subarray\n    for (int i = 0; i < n; ++i) {\n        if (currentSum + arr[i] > maxSum) {\n            ++subarrays;\n            currentSum = arr[i]; // Start a new subarray\n            if (subarrays > k) {\n                return false; // More subarrays than allowed\n            }\n        } else {\n            currentSum += arr[i];\n        }\n    }\n    return true;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> arr(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i];\n    }\n    \n    long long low = *max_element(arr.begin(), arr.end());\n    long long high = accumulate(arr.begin(), arr.end(), 0LL);\n    long long result = high;\n    \n    while (low <= high) {\n        long long mid = low + (high - low) / 2;\n        if (canDivide(arr, n, k, mid)) {\n            result = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    \n    cout << result << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11
        },
        {
            "title": "Writing Numbers",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to calculate digit frequencies from 1 to x\nvector<long long> digitFrequencies(long long x) {\n    vector<long long> freq(10, 0);\n    for (long long i = 1; i <= x; i++) {\n        long long num = i;\n        while (num > 0) {\n            freq[num % 10]++;\n            num /= 10;\n        }\n    }\n    return freq;\n}\n\n// Function to check if a number x can be written with the given digit press limit n\nbool canWriteNumber(long long x, long long n) {\n    vector<long long> freq = digitFrequencies(x);\n    for (int i = 0; i < 10; i++) {\n        if (freq[i] > n) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    long long n;\n    cin >> n;\n\n    long long low = 1, high = 10 * n, result = 1;\n    while (low <= high) {\n        long long mid = low + (high - low) / 2;\n        if (canWriteNumber(mid, n)) {\n            result = mid;\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n\n    cout << result << endl;\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 21,
            "mean_time_taken": 0.48021359670729863,
            "mean_memory_used": 3597352.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                5,
                7,
                9,
                10,
                14,
                17,
                18,
                19,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11
        },
        {
            "title": "Shortest Subsequence",
            "solution": "#include <iostream>\n#include <unordered_set>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.length();\n    \n    unordered_set<string> subsequences_of_length_1;\n    unordered_set<string> subsequences_of_length_2;\n    \n    // Collect all subsequences of length 1\n    for (char c : s) {\n        string single_char(1, c);\n        subsequences_of_length_1.insert(single_char);\n    }\n    \n    // Collect all subsequences of length 2\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            string two_chars = \"\";\n            two_chars += s[i];\n            two_chars += s[j];\n            subsequences_of_length_2.insert(two_chars);\n        }\n    }\n    \n    // Check for missing single characters\n    string bases = \"ACGT\";\n    for (char c : bases) {\n        string single_char(1, c);\n        if (subsequences_of_length_1.find(single_char) == subsequences_of_length_1.end()) {\n            cout << single_char << endl;\n            return 0;\n        }\n    }\n    \n    // Check for missing two-character combinations\n    for (char c1 : bases) {\n        for (char c2 : bases) {\n            string two_chars = \"\";\n            two_chars += c1;\n            two_chars += c2;\n            if (subsequences_of_length_2.find(two_chars) == subsequences_of_length_2.end()) {\n                cout << two_chars << endl;\n                return 0;\n            }\n        }\n    }\n    \n    // Check for missing three-character combinations\n    for (char c1 : bases) {\n        for (char c2 : bases) {\n            for (char c3 : bases) {\n                string three_chars = \"\";\n                three_chars += c1;\n                three_chars += c2;\n                three_chars += c3;\n                // Use sliding window to check if three_chars is a subsequence\n                int k = 0;\n                for (char c : s) {\n                    if (c == three_chars[k]) {\n                        k++;\n                        if (k == 3) break;\n                    }\n                }\n                if (k != 3) {\n                    cout << three_chars << endl;\n                    return 0;\n                }\n            }\n        }\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 10,
            "mean_time_taken": 0.5516721248626709,
            "mean_memory_used": 3597352.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                6,
                7,
                8,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11
        },
        {
            "title": "Ferris Wheel",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    int n, x;\n    std::cin >> n >> x;\n    std::vector<int> weights(n);\n    \n    for (int i = 0; i < n; ++i) {\n        std::cin >> weights[i];\n    }\n    \n    std::sort(weights.begin(), weights.end());\n    \n    int i = 0, j = n - 1;\n    int gondolas = 0;\n    \n    while (i <= j) {\n        if (weights[i] + weights[j] <= x) {\n            i++;\n        }\n        j--;\n        gondolas++;\n    }\n    \n    std::cout << gondolas << std::endl;\n    \n    return 0;\n}",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.11221540891207181,
            "mean_memory_used": 3597352.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12
        },
        {
            "title": "Concert Tickets",
            "solution": "#include <iostream>\n#include <vector>\n#include <set>\n\nint main() {\n    int n, m;\n    std::cin >> n >> m;\n\n    std::multiset<int> ticket_prices;\n    std::vector<int> customer_offers(m);\n    \n    // Reading ticket prices\n    for (int i = 0; i < n; ++i) {\n        int price;\n        std::cin >> price;\n        ticket_prices.insert(price);\n    }\n    \n    // Reading customer offers\n    for (int i = 0; i < m; ++i) {\n        std::cin >> customer_offers[i];\n    }\n    \n    // Process each customer\n    for (int i = 0; i < m; ++i) {\n        int offer = customer_offers[i];\n        auto it = ticket_prices.upper_bound(offer); // Find the first element greater than offer\n        \n        if (it == ticket_prices.begin()) {\n            // No ticket can be afforded by this customer\n            std::cout << -1 << std::endl;\n        } else {\n            // Move the iterator back to the largest element <= offer\n            --it;\n            std::cout << *it << std::endl;\n            ticket_prices.erase(it); // Remove that ticket from the set\n        }\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.21649924191561612,
            "mean_memory_used": 3597352.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13
        }
    ],
    "total_passed_problems": 13
}