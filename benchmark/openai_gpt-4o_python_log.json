{
    "problems": [
        {
            "title": "Acyclic Graph Edges",
            "category": "Additional Problems",
            "solution": "from collections import deque, defaultdict\n\ndef acyclic_graph_edges(n, m, edges):\n    # Step 1: Initialize adjacency list and in-degree count\n    adj = defaultdict(list)\n    in_degree = [0] * (n + 1)\n    \n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n        in_degree[u] += 1\n        in_degree[v] += 1\n    \n    # Step 2: Initialize deque for Kahn's algorithm and find nodes with zero in-degree\n    zero_degree_nodes = deque()\n    for i in range(1, n + 1):\n        if in_degree[i] == 1:\n            zero_degree_nodes.append(i)\n    \n    # Step 3: Perform topological sort\n    topo_order = []\n    while zero_degree_nodes:\n        node = zero_degree_nodes.popleft()\n        topo_order.append(node)\n        for neighbor in adj[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 1:\n                zero_degree_nodes.append(neighbor)\n    \n    # Step 4: Assign direction to edges based on topological order\n    position = {node: idx for idx, node in enumerate(topo_order)}\n    directed_edges = []\n    \n    for u, v in edges:\n        if position[u] < position[v]:\n            directed_edges.append((u, v))\n        else:\n            directed_edges.append((v, u))\n    \n    return directed_edges\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\nedges = []\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    edges.append((u, v))\n    index += 2\n\n# Get the result\nresult = acyclic_graph_edges(n, m, edges)\n\n# Print the result\nfor u, v in result:\n    print(u, v)\n",
            "passed_test_cases": 1,
            "total_test_cases": 4,
            "mean_time_taken": 0.18723011016845703,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/AcyclicGraphEdges_shot_1.py\", line 57, in <module>\n    result = acyclic_graph_edges(n, m, edges)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/AcyclicGraphEdges_shot_1.py\", line 35, in acyclic_graph_edges\n    if position[u] < position[v]:\nKeyError: 9\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/AcyclicGraphEdges_shot_1.py\", line 57, in <module>\n    result = acyclic_graph_edges(n, m, edges)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/AcyclicGraphEdges_shot_1.py\", line 35, in acyclic_graph_edges\n    if position[u] < position[v]:\nKeyError: 4\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/AcyclicGraphEdges_shot_1.py\", line 57, in <module>\n    result = acyclic_graph_edges(n, m, edges)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/AcyclicGraphEdges_shot_1.py\", line 35, in acyclic_graph_edges\n    if position[u] < position[v]:\nKeyError: 89133\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        }
    ],
    "total_passed_problems": 0,
    "initial_config": {
        "ignore_time_limits": false,
        "model": "gpt-4o",
        "provider": "openai",
        "categories": [],
        "shots": 1
    }
}