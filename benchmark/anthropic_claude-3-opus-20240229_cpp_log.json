{
    "problems": [
        {
            "title": "Acyclic Graph Edges",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\nvector<pair<int, int>> edges;\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            edges.push_back({u, v});\n            dfs(v);\n        } else {\n            edges.push_back({v, u});\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    adj.resize(n + 1);\n    visited.resize(n + 1, false);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            dfs(i);\n        }\n    }\n\n    for (auto edge : edges) {\n        cout << edge.first << \" \" << edge.second << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.17661255598068237,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Advertisement",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> k(n);\n    for (int i = 0; i < n; i++) {\n        cin >> k[i];\n    }\n\n    int maxArea = 0;\n    int left = 0, right = n - 1;\n    int height = min(k[left], k[right]);\n\n    while (left < right) {\n        int area = height * (right - left + 1);\n        maxArea = max(maxArea, area);\n\n        if (k[left] < k[right]) {\n            left++;\n            height = min(height, k[left]);\n        } else {\n            right--;\n            height = min(height, k[right]);\n        }\n    }\n\n    cout << maxArea << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 11,
            "mean_time_taken": 0.10055349089882591,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Another Game",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n;\n        cin >> n;\n\n        long long total = 0;\n        for (int i = 0; i < n; i++) {\n            int x;\n            cin >> x;\n            total += x;\n        }\n\n        if (total % 2 == 0) {\n            cout << \"second\" << endl;\n        } else {\n            cout << \"first\" << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 3,
            "mean_time_taken": 0.1187902291615804,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Apartments",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    vector<int> b(m);\n    for (int i = 0; i < m; i++) {\n        cin >> b[i];\n    }\n\n    sort(a.begin(), a.end());\n    sort(b.begin(), b.end());\n\n    int count = 0;\n    int i = 0, j = 0;\n\n    while (i < n && j < m) {\n        if (b[j] - k <= a[i] && a[i] <= b[j] + k) {\n            count++;\n            i++;\n            j++;\n        } else if (a[i] < b[j] - k) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n\n    cout << count << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 19,
            "total_test_cases": 19,
            "mean_time_taken": 0.14306108575118215,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 1,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Apple Division",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nvoid solve(int index, long long sum1, long long sum2, long long& min_diff, const vector<int>& apples) {\n    if (index == apples.size()) {\n        min_diff = min(min_diff, abs(sum1 - sum2));\n        return;\n    }\n    \n    solve(index + 1, sum1 + apples[index], sum2, min_diff, apples);\n    solve(index + 1, sum1, sum2 + apples[index], min_diff, apples);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<int> apples(n);\n    long long total_weight = 0;\n    \n    for (int i = 0; i < n; i++) {\n        cin >> apples[i];\n        total_weight += apples[i];\n    }\n    \n    long long min_diff = total_weight;\n    solve(0, 0, 0, min_diff, apples);\n    \n    cout << min_diff << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 18,
            "total_test_cases": 18,
            "mean_time_taken": 0.09043457772996691,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Apples and Bananas",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int k, n, m;\n    cin >> k >> n >> m;\n\n    vector<int> apples(n);\n    vector<int> bananas(m);\n\n    for (int i = 0; i < n; i++) {\n        cin >> apples[i];\n    }\n\n    for (int i = 0; i < m; i++) {\n        cin >> bananas[i];\n    }\n\n    vector<int> apple_count(k + 1, 0);\n    vector<int> banana_count(k + 1, 0);\n\n    for (int i = 0; i < n; i++) {\n        apple_count[apples[i]]++;\n    }\n\n    for (int i = 0; i < m; i++) {\n        banana_count[bananas[i]]++;\n    }\n\n    vector<int> result(2 * k + 1, 0);\n\n    for (int w = 2; w <= 2 * k; w++) {\n        for (int i = 1; i <= k; i++) {\n            if (i <= w - i && w - i <= k) {\n                result[w] += apple_count[i] * banana_count[w - i];\n            }\n        }\n    }\n\n    for (int w = 2; w <= 2 * k; w++) {\n        cout << result[w] << \" \";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.7213623921076456,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Area of Rectangles",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<int, pair<int, int>>> events;\n\n    for (int i = 0; i < n; i++) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        events.push_back({x1, {y1, y2}});\n        events.push_back({x2, {y1, y2}});\n    }\n\n    sort(events.begin(), events.end());\n\n    long long total_area = 0;\n    int prev_x = events[0].first;\n    set<int> active_y;\n\n    for (const auto& event : events) {\n        int x = event.first;\n        int y1 = event.second.first;\n        int y2 = event.second.second;\n\n        if (active_y.empty()) {\n            active_y.insert(y1);\n            active_y.insert(y2);\n        } else {\n            if (active_y.count(y1) > 0) {\n                active_y.erase(y1);\n                active_y.erase(y2);\n            } else {\n                active_y.insert(y1);\n                active_y.insert(y2);\n            }\n        }\n\n        int height = *active_y.rbegin() - *active_y.begin();\n        total_area += static_cast<long long>(x - prev_x) * height;\n        prev_x = x;\n    }\n\n    cout << total_area << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.21760110855102538,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Array Description",
            "category": "Dynamic Programming",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> x(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i];\n    }\n\n    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\n\n    if (x[0] == 0) {\n        fill(dp[1].begin() + 1, dp[1].end(), 1);\n    } else {\n        dp[1][x[0]] = 1;\n    }\n\n    for (int i = 1; i < n; i++) {\n        if (x[i] == 0) {\n            for (int j = 1; j <= m; j++) {\n                dp[i + 1][j] = dp[i][j];\n                if (j > 1) {\n                    dp[i + 1][j] = (dp[i + 1][j] + dp[i][j - 1]) % MOD;\n                }\n                if (j < m) {\n                    dp[i + 1][j] = (dp[i + 1][j] + dp[i][j + 1]) % MOD;\n                }\n            }\n        } else {\n            dp[i + 1][x[i]] = dp[i][x[i]];\n            if (x[i] > 1) {\n                dp[i + 1][x[i]] = (dp[i + 1][x[i]] + dp[i][x[i] - 1]) % MOD;\n            }\n            if (x[i] < m) {\n                dp[i + 1][x[i]] = (dp[i + 1][x[i]] + dp[i][x[i] + 1]) % MOD;\n            }\n        }\n    }\n\n    int answer = 0;\n    for (int i = 1; i <= m; i++) {\n        answer = (answer + dp[n][i]) % MOD;\n    }\n    cout << answer << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 29,
            "total_test_cases": 29,
            "mean_time_taken": 0.1254935100160796,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Array Division",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool canDivide(const vector<int>& arr, int maxSum, int k) {\n    int subarrays = 1;\n    int currentSum = 0;\n\n    for (int num : arr) {\n        if (currentSum + num > maxSum) {\n            subarrays++;\n            currentSum = num;\n        } else {\n            currentSum += num;\n        }\n    }\n\n    return subarrays <= k;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> arr(n);\n    int maxElement = 0;\n    long long totalSum = 0;\n\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n        maxElement = max(maxElement, arr[i]);\n        totalSum += arr[i];\n    }\n\n    int left = maxElement;\n    int right = totalSum;\n    int result = 0;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (canDivide(arr, mid, k)) {\n            result = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 18,
            "mean_time_taken": 0.10758137702941895,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                7,
                10,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Beautiful Subgrids",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int grid[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            char c;\n            cin >> c;\n            grid[i][j] = c - '0';\n        }\n    }\n\n    int count = 0;\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - 1; j++) {\n            for (int k = i + 1; k < n; k++) {\n                for (int l = j + 1; l < n; l++) {\n                    if (grid[i][j] && grid[i][l] && grid[k][j] && grid[k][l]) {\n                        count++;\n                    }\n                }\n            }\n        }\n    }\n\n    cout << count << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 8,
            "mean_time_taken": 0.135152667760849,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Binary Subsequences",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    // Find the smallest k such that 2^k >= n\n    int k = ceil(log2(n));\n\n    // Generate a binary number with k bits that represents n-1\n    int result = (1 << k) | (n - 1);\n\n    // Print the binary number\n    for (int i = k - 1; i >= 0; i--) {\n        cout << ((result >> i) & 1);\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 12,
            "mean_time_taken": 0.08858243624369304,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Binomial Coefficients",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int MAXN = 1e6 + 1;\n\nint dp[MAXN][MAXN];\n\nint main() {\n    // Initialize base cases\n    for (int i = 0; i < MAXN; i++) {\n        dp[i][0] = 1;\n        dp[i][i] = 1;\n    }\n\n    // Fill the dp array\n    for (int i = 2; i < MAXN; i++) {\n        for (int j = 1; j < i; j++) {\n            dp[i][j] = (dp[i-1][j-1] + dp[i-1][j]) % MOD;\n        }\n    }\n\n    int n;\n    cin >> n;\n\n    while (n--) {\n        int a, b;\n        cin >> a >> b;\n        cout << dp[a][b] << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Bit Inversions",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main() {\n    string bits;\n    cin >> bits;\n    int m;\n    cin >> m;\n    vector<int> changes(m);\n    for (int i = 0; i < m; i++) {\n        cin >> changes[i];\n    }\n    \n    vector<int> result;\n    for (int i = 0; i < m; i++) {\n        int pos = changes[i] - 1;\n        bits[pos] = (bits[pos] == '0') ? '1' : '0';\n        \n        int currentLength = 1;\n        int maxLength = 1;\n        for (int j = 1; j < bits.length(); j++) {\n            if (bits[j] == bits[j - 1]) {\n                currentLength++;\n            } else {\n                maxLength = max(maxLength, currentLength);\n                currentLength = 1;\n            }\n        }\n        maxLength = max(maxLength, currentLength);\n        result.push_back(maxLength);\n    }\n    \n    for (int i = 0; i < result.size(); i++) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 12,
            "mean_time_taken": 0.6433900992075602,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                7,
                9,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bit Problem",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int x[n];\n    for (int i = 0; i < n; i++) {\n        cin >> x[i];\n    }\n\n    int count[1000001] = {0};\n    for (int i = 0; i < n; i++) {\n        count[x[i]]++;\n    }\n\n    for (int i = 0; i < n; i++) {\n        int bitOR = 0, bitAND = 0, bitANDNot0 = 0;\n        for (int j = 1; j <= 1000000; j++) {\n            if ((x[i] | j) == x[i]) {\n                bitOR += count[j];\n            }\n            if ((x[i] & j) == x[i]) {\n                bitAND += count[j];\n            }\n            if ((x[i] & j) != 0) {\n                bitANDNot0 += count[j];\n            }\n        }\n        cout << bitOR << \" \" << bitAND << \" \" << bitANDNot0 << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 2,
            "mean_time_taken": 0.6779601573944092,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bit Strings",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long modularExponentiation(long long base, long long exponent) {\n    long long result = 1;\n    while (exponent > 0) {\n        if (exponent % 2 == 1) {\n            result = (result * base) % MOD;\n        }\n        base = (base * base) % MOD;\n        exponent /= 2;\n    }\n    return result;\n}\n\nint main() {\n    long long n;\n    cin >> n;\n    \n    long long bitStrings = modularExponentiation(2, n);\n    cout << bitStrings << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.08970852692921956,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Bit Substrings",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<int> countSubstrings(const string& s) {\n    int n = s.length();\n    vector<int> result(n + 1, 0);\n\n    for (int k = 0; k <= n; k++) {\n        int count = 0;\n        int left = 0;\n        int right = 0;\n\n        while (right < n) {\n            if (s[right] == '1') {\n                count++;\n            }\n\n            while (count > k) {\n                if (s[left] == '1') {\n                    count--;\n                }\n                left++;\n            }\n\n            if (count == k) {\n                result[k] += right - left + 1;\n            }\n\n            right++;\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    string s;\n    cin >> s;\n\n    vector<int> result = countSubstrings(s);\n\n    for (int i = 0; i <= s.length(); i++) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 8,
            "mean_time_taken": 0.6829473078250885,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Book Shop",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> price(n);\n    for (int i = 0; i < n; i++) {\n        cin >> price[i];\n    }\n\n    vector<int> pages(n);\n    for (int i = 0; i < n; i++) {\n        cin >> pages[i];\n    }\n\n    vector<vector<int>> dp(n + 1, vector<int>(x + 1, 0));\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= x; j++) {\n            dp[i][j] = dp[i - 1][j];\n            if (j >= price[i - 1]) {\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - price[i - 1]] + pages[i - 1]);\n            }\n        }\n    }\n\n    cout << dp[n][x] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 15,
            "mean_time_taken": 0.6078876972198486,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                7,
                9,
                11,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Book Shop II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> h(n + 1), s(n + 1), k(n + 1);\n    for (int i = 1; i <= n; i++) {\n        cin >> h[i];\n    }\n    for (int i = 1; i <= n; i++) {\n        cin >> s[i];\n    }\n    for (int i = 1; i <= n; i++) {\n        cin >> k[i];\n    }\n\n    vector<vector<int>> dp(n + 1, vector<int>(x + 1, 0));\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= x; j++) {\n            if (h[i] > j) {\n                dp[i][j] = dp[i - 1][j];\n            } else {\n                for (int c = 0; c <= k[i]; c++) {\n                    int price = c * h[i];\n                    if (price > j) {\n                        break;\n                    }\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - price] + c * s[i]);\n                }\n            }\n        }\n    }\n\n    cout << dp[n][x] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 10,
            "mean_time_taken": 0.5945859432220459,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bracket Sequences I",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long modPow(long long base, long long exp) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1)\n            result = (result * base) % MOD;\n        base = (base * base) % MOD;\n        exp >>= 1;\n    }\n    return result;\n}\n\nlong long modInverse(long long n) {\n    return modPow(n, MOD - 2);\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    long long fact[2 * n + 1];\n    fact[0] = 1;\n    for (int i = 1; i <= 2 * n; i++)\n        fact[i] = (fact[i - 1] * i) % MOD;\n\n    long long numerator = fact[2 * n];\n    long long denominator = (fact[n + 1] * fact[n]) % MOD;\n    long long catalan = (numerator * modInverse(denominator)) % MOD;\n\n    cout << catalan << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 17,
            "mean_time_taken": 0.10223188119776108,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bracket Sequences II",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countSequences(int n, string prefix) {\n    int k = prefix.length();\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n    dp[0][0] = 1;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= i; j++) {\n            if (j > 0)\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD;\n            if (j < i)\n                dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MOD;\n            if (i <= k && prefix[i - 1] == '(')\n                dp[i][j] = (j > 0) ? dp[i - 1][j - 1] : 0;\n            if (i <= k && prefix[i - 1] == ')')\n                dp[i][j] = (j < i) ? dp[i - 1][j + 1] : 0;\n        }\n    }\n\n    int answer = 0;\n    for (int j = 0; j <= n; j++) {\n        answer = (answer + dp[n][j]) % MOD;\n    }\n    return answer;\n}\n\nint main() {\n    int n;\n    string prefix;\n    cin >> n >> prefix;\n    cout << countSequences(n, prefix) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 11,
            "mean_time_taken": 0.21256351470947266,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                8,
                9,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Building Roads",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass DSU {\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n\npublic:\n    DSU(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    DSU dsu(n);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--; // Convert to 0-based indexing\n        dsu.unite(a, b);\n    }\n\n    int components = 0;\n    for (int i = 0; i < n; i++) {\n        if (dsu.find(i) == i) {\n            components++;\n        }\n    }\n\n    int newRoads = components - 1;\n    cout << newRoads << endl;\n\n    if (newRoads > 0) {\n        int prevComponent = dsu.find(0);\n        for (int i = 1; i < n; i++) {\n            int currentComponent = dsu.find(i);\n            if (currentComponent != prevComponent) {\n                cout << prevComponent + 1 << \" \" << currentComponent + 1 << endl;\n                prevComponent = currentComponent;\n                newRoads--;\n                if (newRoads == 0) {\n                    break;\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 12,
            "mean_time_taken": 0.12033710877100627,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Building Teams",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1e5 + 5;\nvector<int> adj[MAX_N];\nint team[MAX_N];\n\nbool dfs(int node, int t) {\n    team[node] = t;\n    for (int neighbor : adj[node]) {\n        if (team[neighbor] == t) {\n            return false;\n        }\n        if (team[neighbor] == 0 && !dfs(neighbor, 3 - t)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    bool possible = true;\n    for (int i = 1; i <= n; i++) {\n        if (team[i] == 0) {\n            if (!dfs(i, 1)) {\n                possible = false;\n                break;\n            }\n        }\n    }\n\n    if (possible) {\n        for (int i = 1; i <= n; i++) {\n            cout << team[i] << \" \";\n        }\n        cout << endl;\n    } else {\n        cout << \"IMPOSSIBLE\" << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.1453171730041504,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 5,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Candy Lottery",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    double expected_max = 0.0;\n    double prev_prob = 0.0;\n\n    for (int x = 1; x <= k; x++) {\n        double prob = pow((double)x / k, n);\n        expected_max += x * (prob - prev_prob);\n        prev_prob = prob;\n    }\n\n    cout << fixed << setprecision(6) << expected_max << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.08850388867514473,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Chess Tournament",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> games(n);\n    int total_games = 0;\n\n    for (int i = 0; i < n; i++) {\n        cin >> games[i];\n        total_games += games[i];\n    }\n\n    if (total_games % 2 != 0) {\n        cout << \"IMPOSSIBLE\" << endl;\n        return 0;\n    }\n\n    vector<pair<int, int>> pairings;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            while (games[i] > 0 && games[j] > 0) {\n                pairings.push_back({i + 1, j + 1});\n                games[i]--;\n                games[j]--;\n            }\n        }\n    }\n\n    if (pairings.size() != total_games / 2) {\n        cout << \"IMPOSSIBLE\" << endl;\n        return 0;\n    }\n\n    cout << pairings.size() << endl;\n    for (auto p : pairings) {\n        cout << p.first << \" \" << p.second << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 21,
            "mean_time_taken": 0.3181386221022833,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Chessboard and Queens",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int N = 8;\nchar board[N][N];\nint count = 0;\n\nbool is_valid(int row, int col) {\n    // Check if there is a queen in the same column\n    for (int i = 0; i < row; i++) {\n        if (board[i][col] == 'Q')\n            return false;\n    }\n\n    // Check if there is a queen in the upper-left diagonal\n    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n        if (board[i][j] == 'Q')\n            return false;\n    }\n\n    // Check if there is a queen in the upper-right diagonal\n    for (int i = row - 1, j = col + 1; i >= 0 && j < N; i--, j++) {\n        if (board[i][j] == 'Q')\n            return false;\n    }\n\n    return true;\n}\n\nvoid solve(int row) {\n    if (row == N) {\n        count++;\n        return;\n    }\n\n    for (int col = 0; col < N; col++) {\n        if (board[row][col] == '.' && is_valid(row, col)) {\n            board[row][col] = 'Q';\n            solve(row + 1);\n            board[row][col] = '.';\n        }\n    }\n}\n\nint main() {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> board[i][j];\n        }\n    }\n\n    solve(0);\n    cout << count << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.092671799659729,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Christmas Party",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n;\n    cin >> n;\n\n    long long dp[n+1];\n    dp[0] = 1;\n    dp[1] = 0;\n\n    for (int i = 2; i <= n; i++) {\n        dp[i] = (i-1) * (dp[i-1] + dp[i-2]) % MOD;\n    }\n\n    cout << dp[n] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 15,
            "total_test_cases": 15,
            "mean_time_taken": 0.09254239400227865,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Coding Company",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countDivisions(int index, int teams, int penaltySum, vector<int>& skillLevels, int x) {\n    if (index == skillLevels.size()) {\n        return (penaltySum <= x) ? 1 : 0;\n    }\n\n    int result = 0;\n    for (int i = 1; index + i <= skillLevels.size(); i++) {\n        int penalty = skillLevels[index + i - 1] - skillLevels[index];\n        if (penaltySum + penalty > x) {\n            break;\n        }\n        result = (result + countDivisions(index + i, teams + 1, penaltySum + penalty, skillLevels, x)) % MOD;\n    }\n\n    return result;\n}\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> skillLevels(n);\n    for (int i = 0; i < n; i++) {\n        cin >> skillLevels[i];\n    }\n\n    sort(skillLevels.begin(), skillLevels.end());\n\n    int validDivisions = countDivisions(0, 0, 0, skillLevels, x);\n    cout << validDivisions << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 15,
            "mean_time_taken": 0.47018230756123863,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                11,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Arrangement",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int total_moves = 0;\n    for (int i = 0; i < 2 * n; i++) {\n        int coins;\n        cin >> coins;\n        total_moves += abs(coins - 1);\n    }\n\n    cout << total_moves << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 10,
            "mean_time_taken": 0.10272974967956543,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Collector",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> k(n);\n    for (int i = 0; i < n; i++) {\n        cin >> k[i];\n    }\n\n    vector<int> dp(n);\n    for (int i = 0; i < n; i++) {\n        dp[i] = k[i];\n    }\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        dp[b] = max(dp[b], dp[a] + k[b]);\n    }\n\n    int maxCoins = 0;\n    for (int i = 0; i < n; i++) {\n        maxCoins = max(maxCoins, dp[i]);\n    }\n\n    cout << maxCoins << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 14,
            "mean_time_taken": 0.11509920869554792,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Combinations I",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> coins(n);\n    for (int i = 0; i < n; i++) {\n        cin >> coins[i];\n    }\n\n    vector<int> dp(x + 1, 0);\n    dp[0] = 1;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = coins[i]; j <= x; j++) {\n            dp[j] = (dp[j] + dp[j - coins[i]]) % MOD;\n        }\n    }\n\n    cout << dp[x] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 13,
            "mean_time_taken": 0.23250568830049956,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                6,
                7,
                8,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Combinations II",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> coins(n);\n    for (int i = 0; i < n; i++) {\n        cin >> coins[i];\n    }\n\n    vector<vector<int>> dp(n, vector<int>(x + 1, 0));\n    dp[0][0] = 1;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= x; j++) {\n            if (i > 0) {\n                dp[i][j] = dp[i - 1][j];\n            }\n            if (j >= coins[i]) {\n                dp[i][j] = (dp[i][j] + dp[i][j - coins[i]]) % MOD;\n            }\n        }\n    }\n\n    cout << dp[n - 1][x] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 15,
            "mean_time_taken": 0.5488955974578857,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                6,
                7,
                8,
                9,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Grid",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<vector<bool>> coins(n, vector<bool>(n));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            char c;\n            cin >> c;\n            coins[i][j] = (c == 'o');\n        }\n    }\n\n    int moves = 0;\n    vector<pair<int, int>> moves_performed;\n\n    for (int i = 0; i < n; i++) {\n        bool row_has_coin = false;\n        for (int j = 0; j < n; j++) {\n            if (coins[i][j]) {\n                row_has_coin = true;\n                break;\n            }\n        }\n        if (row_has_coin) {\n            moves++;\n            moves_performed.push_back({1, i + 1});\n            for (int j = 0; j < n; j++) {\n                coins[i][j] = false;\n            }\n        }\n    }\n\n    for (int j = 0; j < n; j++) {\n        bool col_has_coin = false;\n        for (int i = 0; i < n; i++) {\n            if (coins[i][j]) {\n                col_has_coin = true;\n                break;\n            }\n        }\n        if (col_has_coin) {\n            moves++;\n            moves_performed.push_back({2, j + 1});\n            for (int i = 0; i < n; i++) {\n                coins[i][j] = false;\n            }\n        }\n    }\n\n    cout << moves << endl;\n    for (auto move : moves_performed) {\n        cout << move.first << \" \" << move.second << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 10,
            "mean_time_taken": 0.09078903198242187,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Piles",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int a, b;\n        cin >> a >> b;\n        \n        if ((a + b) % 3 == 0 && min(a, b) * 2 >= max(a, b)) {\n            cout << \"YES\\n\";\n        } else {\n            cout << \"NO\\n\";\n        }\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 3,
            "mean_time_taken": 0.14263494809468588,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Collecting Numbers",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int pos[n + 1] = {0};\n    for (int i = 1; i <= n; i++) {\n        int x;\n        cin >> x;\n        pos[x] = i;\n    }\n\n    int rounds = 1;\n    for (int i = 2; i <= n; i++) {\n        if (pos[i] < pos[i - 1]) {\n            rounds++;\n        }\n    }\n\n    cout << rounds << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 4,
            "mean_time_taken": 0.11793839931488037,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Collecting Numbers II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    vector<int> pos(n + 1);\n    for (int i = 0; i < n; i++) {\n        pos[arr[i]] = i;\n    }\n\n    int rounds = 1;\n    for (int i = 1; i < n; i++) {\n        if (pos[i] > pos[i + 1]) {\n            rounds++;\n        }\n    }\n\n    while (m--) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n\n        int num1 = arr[a], num2 = arr[b];\n        swap(arr[a], arr[b]);\n        swap(pos[num1], pos[num2]);\n\n        if ((a > 0 && num2 < arr[a - 1] && num1 >= arr[a - 1]) ||\n            (a < n - 1 && num2 > arr[a + 1] && num1 <= arr[a + 1])) {\n            rounds++;\n        }\n        else if ((a > 0 && num1 < arr[a - 1] && num2 >= arr[a - 1]) ||\n                 (a < n - 1 && num1 > arr[a + 1] && num2 <= arr[a + 1])) {\n            rounds--;\n        }\n\n        if ((b > 0 && num1 < arr[b - 1] && num2 >= arr[b - 1]) ||\n            (b < n - 1 && num1 > arr[b + 1] && num2 <= arr[b + 1])) {\n            rounds++;\n        }\n        else if ((b > 0 && num2 < arr[b - 1] && num1 >= arr[b - 1]) ||\n                 (b < n - 1 && num2 > arr[b + 1] && num1 <= arr[b + 1])) {\n            rounds--;\n        }\n\n        cout << rounds << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.2527807950973511,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Common Divisors",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint gcd(int a, int b) {\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    int x[n];\n    for (int i = 0; i < n; i++) {\n        cin >> x[i];\n    }\n\n    int maxGCD = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            maxGCD = max(maxGCD, gcd(x[i], x[j]));\n        }\n    }\n\n    cout << maxGCD << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 17,
            "mean_time_taken": 0.5910408216364244,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                5,
                6,
                7,
                9,
                11,
                14,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Company Queries I",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> boss(n + 1);\n    for (int i = 2; i <= n; i++) {\n        cin >> boss[i];\n    }\n\n    int log_n = log2(n) + 1;\n    vector<vector<int>> up(n + 1, vector<int>(log_n));\n    for (int i = 1; i <= n; i++) {\n        up[i][0] = boss[i];\n    }\n\n    for (int j = 1; j < log_n; j++) {\n        for (int i = 1; i <= n; i++) {\n            up[i][j] = up[up[i][j - 1]][j - 1];\n        }\n    }\n\n    while (q--) {\n        int x, k;\n        cin >> x >> k;\n\n        int ans = x;\n        for (int j = log_n - 1; j >= 0; j--) {\n            if (k & (1 << j)) {\n                ans = up[ans][j];\n                if (ans == 0) {\n                    break;\n                }\n            }\n        }\n\n        cout << (ans != 0 ? ans : -1) << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.20478411821218637,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Company Queries II",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nconst int MAXLOG = 20;\n\nint n, q;\nvector<int> boss(MAXN);\nvector<int> depth(MAXN);\nvector<vector<int>> parent(MAXN, vector<int>(MAXLOG));\n\nvoid dfs(int u) {\n    for (int i = 1; i < MAXLOG; i++) {\n        parent[u][i] = parent[parent[u][i-1]][i-1];\n    }\n    for (int v = 2; v <= n; v++) {\n        if (boss[v] == u) {\n            depth[v] = depth[u] + 1;\n            parent[v][0] = u;\n            dfs(v);\n        }\n    }\n}\n\nint lca(int a, int b) {\n    if (depth[a] < depth[b]) {\n        swap(a, b);\n    }\n    int diff = depth[a] - depth[b];\n    for (int i = MAXLOG - 1; i >= 0; i--) {\n        if (diff & (1 << i)) {\n            a = parent[a][i];\n        }\n    }\n    if (a == b) {\n        return a;\n    }\n    for (int i = MAXLOG - 1; i >= 0; i--) {\n        if (parent[a][i] != parent[b][i]) {\n            a = parent[a][i];\n            b = parent[b][i];\n        }\n    }\n    return parent[a][0];\n}\n\nint main() {\n    cin >> n >> q;\n    for (int i = 2; i <= n; i++) {\n        cin >> boss[i];\n    }\n    depth[1] = 0;\n    dfs(1);\n    while (q--) {\n        int a, b;\n        cin >> a >> b;\n        cout << lca(a, b) << '\\n';\n    }\n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 12,
            "mean_time_taken": 0.5791909098625183,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                7,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Concert Tickets",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> h(n);\n    for (int i = 0; i < n; i++) {\n        cin >> h[i];\n    }\n\n    vector<int> t(m);\n    for (int i = 0; i < m; i++) {\n        cin >> t[i];\n    }\n\n    sort(h.begin(), h.end());\n\n    for (int i = 0; i < m; i++) {\n        auto it = upper_bound(h.begin(), h.end(), t[i]);\n        if (it == h.begin()) {\n            cout << -1 << endl;\n        } else {\n            cout << *(--it) << endl;\n            h.erase(it);\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.34659539569507947,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Convex Hull",
            "category": "Geometry",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Counting Bishops",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countBishopPlacements(int n, int k) {\n    int diagonals = 2 * n - 1;\n    vector<vector<int>> dp(diagonals, vector<int>(k + 1, 0));\n\n    // Base cases\n    for (int i = 0; i < diagonals; i++) {\n        dp[i][0] = 1;\n    }\n    dp[0][1] = 1;\n\n    // Fill the DP table\n    for (int i = 1; i < diagonals; i++) {\n        for (int j = 1; j <= k; j++) {\n            dp[i][j] = (dp[i - 1][j] + (i >= j ? dp[i - 1][j - 1] : 0)) % MOD;\n        }\n    }\n\n    return dp[diagonals - 1][k];\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    cout << countBishopPlacements(n, k) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 13,
            "mean_time_taken": 0.10902170034555289,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                8,
                9,
                10,
                11,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Bits",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\ntypedef long long ll;\n\nll countOnes(ll n) {\n    if (n == 0)\n        return 0;\n    \n    ll p = 1;\n    while (p <= n)\n        p *= 2;\n    p /= 2;\n    \n    return p - 1 + (n - p + 1) + countOnes(n - p);\n}\n\nint main() {\n    ll n;\n    cin >> n;\n    cout << countOnes(n) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 21,
            "mean_time_taken": 0.08774880000523158,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                14,
                15,
                17,
                18,
                19,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Coprime Pairs",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX = 1e6 + 5;\nint freq[MAX];\n\nvector<int> sieve() {\n    vector<bool> isPrime(MAX, true);\n    vector<int> primes;\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i < MAX; i++) {\n        if (isPrime[i]) {\n            primes.push_back(i);\n            for (int j = i * i; j < MAX; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    return primes;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        freq[x]++;\n    }\n\n    vector<int> primes = sieve();\n    long long result = (long long)n * (n - 1) / 2;\n\n    for (int mask = 1; mask < (1 << primes.size()); mask++) {\n        int prod = 1;\n        for (int i = 0; i < primes.size(); i++) {\n            if (mask & (1 << i)) {\n                prod *= primes[i];\n            }\n        }\n        int pairs = freq[1] * (freq[1] - 1) / 2 + freq[prod] * (freq[prod] - 1) / 2;\n        if (__builtin_popcount(mask) % 2 == 0) {\n            result -= pairs;\n        } else {\n            result += pairs;\n        }\n    }\n\n    cout << result << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.20563983917236328,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Divisors",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MAX = 1000001;\n\nint main() {\n    int n;\n    cin >> n;\n    int arr[n];\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    int divisors[MAX] = {0};\n    for (int i = 1; i < MAX; i++) {\n        for (int j = i; j < MAX; j += i) {\n            divisors[j]++;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        cout << divisors[arr[i]] << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 16,
            "mean_time_taken": 0.14239370822906494,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                7,
                13,
                14,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Grids",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long fastPow(long long base, long long exp) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1)\n            result = (result * base) % MOD;\n        base = (base * base) % MOD;\n        exp /= 2;\n    }\n    return result;\n}\n\nint main() {\n    long long n;\n    cin >> n;\n\n    if (n == 1)\n        cout << 2 << endl;\n    else if (n == 2)\n        cout << 6 << endl;\n    else {\n        long long totalGrids = fastPow(2, n * n);\n        long long specialGrids = fastPow(2, n * n / 2);\n        long long result = (totalGrids + 4 * specialGrids) % MOD;\n        result = (result * fastPow(4, MOD - 2)) % MOD;  // Multiply by modular inverse of 4\n        cout << result << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 12,
            "mean_time_taken": 0.09082931280136108,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Necklaces",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long gcd(long long a, long long b) {\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n}\n\nlong long binexp(long long a, long long b) {\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = (res * a) % MOD;\n        a = (a * a) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    long long count = 0;\n    for (int i = 0; i < n; i++) {\n        int g = gcd(i, n);\n        count = (count + binexp(m, n / g)) % MOD;\n    }\n\n    count = (count * binexp(n, MOD - 2)) % MOD;\n    cout << count << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 10,
            "mean_time_taken": 0.11084649562835694,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                8,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Numbers",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nvector<vector<vector<int>>> dp(20, vector<vector<int>>(10, vector<int>(2, -1)));\n\nint count(long long n, int last_digit, bool tight) {\n    if (n == 0)\n        return 1;\n\n    int len = to_string(n).length();\n\n    if (dp[len][last_digit + 1][tight] != -1)\n        return dp[len][last_digit + 1][tight];\n\n    int ans = 0;\n    int limit = tight ? to_string(n)[0] - '0' : 9;\n\n    for (int i = 0; i <= limit; i++) {\n        if (last_digit == i)\n            continue;\n        ans = (ans + count(n % (long long)pow(10, len - 1), i, tight && (i == limit))) % MOD;\n    }\n\n    return dp[len][last_digit + 1][tight] = ans;\n}\n\nint main() {\n    long long a, b;\n    cin >> a >> b;\n    cout << (count(b, -1, true) - count(a - 1, -1, true) + MOD) % MOD << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Counting Paths",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nconst int MAXLOG = 20;\n\nvector<int> adj[MAXN];\nint up[MAXN][MAXLOG];\nint depth[MAXN];\nint cnt[MAXN];\n\nvoid dfs(int u, int p) {\n    depth[u] = depth[p] + 1;\n    up[u][0] = p;\n    for (int i = 1; i < MAXLOG; i++) {\n        up[u][i] = up[up[u][i-1]][i-1];\n    }\n    for (int v : adj[u]) {\n        if (v != p) {\n            dfs(v, u);\n        }\n    }\n}\n\nint lca(int u, int v) {\n    if (depth[u] < depth[v]) {\n        swap(u, v);\n    }\n    int diff = depth[u] - depth[v];\n    for (int i = MAXLOG - 1; i >= 0; i--) {\n        if (diff & (1 << i)) {\n            u = up[u][i];\n        }\n    }\n    if (u == v) {\n        return u;\n    }\n    for (int i = MAXLOG - 1; i >= 0; i--) {\n        if (up[u][i] != up[v][i]) {\n            u = up[u][i];\n            v = up[v][i];\n        }\n    }\n    return up[u][0];\n}\n\nvoid increment(int u, int v) {\n    int l = lca(u, v);\n    while (u != l) {\n        cnt[u]++;\n        u = up[u][0];\n    }\n    while (v != l) {\n        cnt[v]++;\n        v = up[v][0];\n    }\n    cnt[l]++;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(1, 0);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        increment(u, v);\n    }\n    for (int i = 1; i <= n; i++) {\n        cout << cnt[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 13,
            "mean_time_taken": 0.5109189657064584,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                5,
                6,
                8,
                10,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Patterns",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> computePrefix(const string& pattern) {\n    int m = pattern.length();\n    vector<int> prefix(m, 0);\n    int j = 0;\n    for (int i = 1; i < m; i++) {\n        while (j > 0 && pattern[i] != pattern[j]) {\n            j = prefix[j - 1];\n        }\n        if (pattern[i] == pattern[j]) {\n            j++;\n        }\n        prefix[i] = j;\n    }\n    return prefix;\n}\n\nint countOccurrences(const string& text, const string& pattern) {\n    int n = text.length();\n    int m = pattern.length();\n    vector<int> prefix = computePrefix(pattern);\n    int count = 0;\n    int j = 0;\n    for (int i = 0; i < n; i++) {\n        while (j > 0 && text[i] != pattern[j]) {\n            j = prefix[j - 1];\n        }\n        if (text[i] == pattern[j]) {\n            j++;\n        }\n        if (j == m) {\n            count++;\n            j = prefix[j - 1];\n        }\n    }\n    return count;\n}\n\nint main() {\n    string text;\n    cin >> text;\n    int k;\n    cin >> k;\n    vector<string> patterns(k);\n    for (int i = 0; i < k; i++) {\n        cin >> patterns[i];\n    }\n    for (const string& pattern : patterns) {\n        int count = countOccurrences(text, pattern);\n        cout << count << endl;\n    }\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 11,
            "mean_time_taken": 0.7732574289495294,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                7,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Reorders",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; i++) {\n        result = (result * i) % MOD;\n    }\n    return result;\n}\n\nint countReorders(string s) {\n    int n = s.length();\n    vector<int> freq(26, 0);\n    for (char c : s) {\n        freq[c - 'a']++;\n    }\n\n    long long result = factorial(n);\n    for (int i = 0; i < 26; i++) {\n        if (freq[i] > (n + 1) / 2) {\n            return 0;\n        }\n        result = (result * factorial(freq[i])) % MOD;\n    }\n\n    for (int i = 0; i < 26; i++) {\n        if (freq[i] > 1) {\n            long long arrangements = factorial(n - freq[i]);\n            arrangements = (arrangements * factorial(freq[i])) % MOD;\n            result = (result * arrangements) % MOD;\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    cout << countReorders(s) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 9,
            "mean_time_taken": 0.09000481499565972,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Rooms",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAXN = 1000;\n\nint n, m;\nchar grid[MAXN][MAXN];\nbool visited[MAXN][MAXN];\n\nvoid dfs(int x, int y) {\n    visited[x][y] = true;\n\n    // Check adjacent squares\n    int dx[] = {-1, 0, 1, 0};\n    int dy[] = {0, 1, 0, -1};\n\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n\n        if (nx >= 0 && nx < n && ny >= 0 && ny < m && grid[nx][ny] == '.' && !visited[nx][ny]) {\n            dfs(nx, ny);\n        }\n    }\n}\n\nint main() {\n    cin >> n >> m;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n            visited[i][j] = false;\n        }\n    }\n\n    int rooms = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == '.' && !visited[i][j]) {\n                rooms++;\n                dfs(i, j);\n            }\n        }\n    }\n\n    cout << rooms << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 15,
            "total_test_cases": 19,
            "mean_time_taken": 0.10995357914974815,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                7,
                8,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Sequences",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countSequences(int n, int k) {\n    vector<vector<int>> dp(n + 1, vector<int>(1 << k, 0));\n    dp[0][(1 << k) - 1] = 1;\n\n    for (int i = 1; i <= n; i++) {\n        for (int mask = 0; mask < (1 << k); mask++) {\n            for (int j = 1; j <= k; j++) {\n                if ((mask & (1 << (j - 1))) == 0) {\n                    dp[i][mask] = (dp[i][mask] + dp[i - 1][mask | (1 << (j - 1))]) % MOD;\n                }\n            }\n        }\n    }\n\n    return dp[n][(1 << k) - 1];\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    cout << countSequences(n, k) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.11636126041412354,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Tilings",
            "category": "Dynamic Programming",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countTilings(int n, int m) {\n    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\n\n    for (int j = 0; j <= m; j++) {\n        dp[0][j] = 1;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            dp[i][j] = dp[i - 1][j];\n            if (j >= 2) {\n                dp[i][j] = (dp[i][j] + dp[i][j - 2]) % MOD;\n            }\n        }\n    }\n\n    return dp[n][m];\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    cout << countTilings(n, m) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 15,
            "mean_time_taken": 0.08607672055562338,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                11,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Towers",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int t;\n    cin >> t;\n\n    vector<int> dp(1000001);\n    dp[1] = 2;\n    dp[2] = 8;\n\n    for (int i = 3; i <= 1000000; i++) {\n        dp[i] = (dp[i-1] + dp[i-2]) % MOD;\n    }\n\n    while (t--) {\n        int n;\n        cin >> n;\n        cout << dp[n] << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.10254991054534912,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Course Schedule",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> adj[100005];\nbool visited[100005];\nbool inStack[100005];\nvector<int> order;\n\nbool dfs(int node) {\n    visited[node] = true;\n    inStack[node] = true;\n    \n    for (int neighbor : adj[node]) {\n        if (inStack[neighbor]) {\n            return false;\n        }\n        if (!visited[neighbor] && !dfs(neighbor)) {\n            return false;\n        }\n    }\n    \n    inStack[node] = false;\n    order.push_back(node);\n    return true;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        if (!visited[i] && !dfs(i)) {\n            cout << \"IMPOSSIBLE\" << endl;\n            return 0;\n        }\n    }\n    \n    reverse(order.begin(), order.end());\n    \n    for (int course : order) {\n        cout << course << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 16,
            "mean_time_taken": 0.1280188411474228,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                5,
                6,
                8,
                9,
                10,
                11,
                12,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Course Schedule II",
            "category": "Additional Problems",
            "solution": "#include <vector>\n#include <queue>\n\nusing namespace std;\n\nvector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n    vector<vector<int>> graph(numCourses);\n    vector<int> inDegree(numCourses, 0);\n    \n    // Build the adjacency list and calculate in-degrees\n    for (const auto& prereq : prerequisites) {\n        int a = prereq[0];\n        int b = prereq[1];\n        graph[a].push_back(b);\n        inDegree[b]++;\n    }\n    \n    queue<int> q;\n    \n    // Enqueue courses with in-degree 0\n    for (int i = 0; i < numCourses; i++) {\n        if (inDegree[i] == 0) {\n            q.push(i);\n        }\n    }\n    \n    vector<int> order;\n    \n    while (!q.empty()) {\n        int course = q.front();\n        q.pop();\n        order.push_back(course);\n        \n        // Decrement in-degree of neighbors and enqueue if in-degree becomes 0\n        for (int neighbor : graph[course]) {\n            inDegree[neighbor]--;\n            if (inDegree[neighbor] == 0) {\n                q.push(neighbor);\n            }\n        }\n    }\n    \n    // Check if all courses are completed\n    if (order.size() == numCourses) {\n        return order;\n    } else {\n        return {};\n    }\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Creating Offices",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> adj[200005];\nvector<int> offices;\n\nint dfs(int u, int p, int depth) {\n    if (depth >= d) {\n        offices.push_back(u);\n        return 1;\n    }\n    \n    for (int v : adj[u]) {\n        if (v != p) {\n            if (dfs(v, u, depth + 1)) {\n                return 1;\n            }\n        }\n    }\n    \n    return 0;\n}\n\nint main() {\n    int n, d;\n    cin >> n >> d;\n    \n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        if (find(offices.begin(), offices.end(), i) == offices.end()) {\n            dfs(i, -1, 0);\n        }\n    }\n    \n    cout << offices.size() << endl;\n    for (int office : offices) {\n        cout << office << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Creating Strings",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <set>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nset<string> generatePermutations(string str) {\n    set<string> permutations;\n    generatePermutationsHelper(str, \"\", permutations);\n    return permutations;\n}\n\nvoid generatePermutationsHelper(string str, string current, set<string>& permutations) {\n    if (current.length() == str.length()) {\n        permutations.insert(current);\n        return;\n    }\n\n    for (char c : str) {\n        if (current.find(c) == string::npos) {\n            generatePermutationsHelper(str, current + c, permutations);\n        }\n    }\n}\n\nint main() {\n    string str;\n    cin >> str;\n\n    set<string> permutations = generatePermutations(str);\n    vector<string> result(permutations.begin(), permutations.end());\n    sort(result.begin(), result.end());\n\n    cout << result.size() << endl;\n    for (string s : result) {\n        cout << s << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Creating Strings II",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long modExp(long long base, long long exp) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1)\n            result = (result * base) % MOD;\n        base = (base * base) % MOD;\n        exp /= 2;\n    }\n    return result;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.length();\n\n    vector<int> count(26, 0);\n    for (char c : s)\n        count[c - 'a']++;\n\n    vector<long long> fact(n + 1, 1);\n    for (int i = 1; i <= n; i++)\n        fact[i] = (fact[i - 1] * i) % MOD;\n\n    long long denominator = 1;\n    for (int i = 0; i < 26; i++)\n        denominator = (denominator * fact[count[i]]) % MOD;\n\n    long long result = fact[n] * modExp(denominator, MOD - 2) % MOD;\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.09961207707722981,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Critical Cities",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nvector<int> adj[MAXN];\nbool reachable[MAXN], reachable_reverse[MAXN];\n\nvoid dfs(int u) {\n    reachable[u] = true;\n    for (int v : adj[u]) {\n        if (!reachable[v]) {\n            dfs(v);\n        }\n    }\n}\n\nvoid dfs_reverse(int u) {\n    reachable_reverse[u] = true;\n    for (int v : adj[u]) {\n        if (!reachable_reverse[v]) {\n            dfs_reverse(v);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n\n    dfs(1);\n    dfs_reverse(n);\n\n    vector<int> critical;\n    for (int i = 1; i <= n; i++) {\n        if (reachable[i] && reachable_reverse[i]) {\n            critical.push_back(i);\n        }\n    }\n\n    int k = critical.size();\n    cout << k << endl;\n    for (int city : critical) {\n        cout << city << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 14,
            "mean_time_taken": 0.13438825947897776,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Cut and Paste",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    string s;\n    cin >> s;\n\n    vector<pair<int, int>> operations;\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        operations.push_back({a, b});\n    }\n\n    for (auto op : operations) {\n        int a = op.first;\n        int b = op.second;\n        string substring = s.substr(a - 1, b - a + 1);\n        s.erase(a - 1, b - a + 1);\n        s.append(substring);\n    }\n\n    cout << s << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 7,
            "mean_time_taken": 0.38056860651288715,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Cycle Finding",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n    int a, b, c;\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<Edge> edges(m);\n    for (int i = 0; i < m; i++) {\n        cin >> edges[i].a >> edges[i].b >> edges[i].c;\n    }\n\n    vector<long long> dist(n + 1, LLONG_MAX);\n    dist[1] = 0;\n    vector<int> parent(n + 1, -1);\n\n    int last_node = -1;\n    for (int i = 0; i < n; i++) {\n        last_node = -1;\n        for (Edge e : edges) {\n            if (dist[e.a] + e.c < dist[e.b]) {\n                dist[e.b] = dist[e.a] + e.c;\n                parent[e.b] = e.a;\n                last_node = e.b;\n            }\n        }\n    }\n\n    if (last_node == -1) {\n        cout << \"NO\" << endl;\n    } else {\n        cout << \"YES\" << endl;\n        vector<int> cycle;\n        int node = last_node;\n        while (node != -1 && find(cycle.begin(), cycle.end(), node) == cycle.end()) {\n            cycle.push_back(node);\n            node = parent[node];\n        }\n        cycle.push_back(node);\n        reverse(cycle.begin(), cycle.end());\n        for (int i = 0; i < cycle.size(); i++) {\n            cout << cycle[i] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 11,
            "total_test_cases": 27,
            "mean_time_taken": 0.11355472494054723,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                5,
                7,
                9,
                11,
                12,
                13,
                14,
                17,
                18,
                19,
                21,
                23,
                24,
                25,
                26
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Cyclic Array",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    int count = 0;\n    long long sum = 0;\n    int j = 0;\n\n    // Concatenate the array with itself\n    for (int i = 0; i < 2 * n; i++) {\n        sum += arr[i % n];\n\n        while (sum > k) {\n            sum -= arr[j % n];\n            j++;\n        }\n\n        count++;\n    }\n\n    // Minimum number of subarrays is count / 2\n    cout << count / 2 << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 21,
            "mean_time_taken": 0.09408396766299293,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "De Bruijn Sequence",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstring deBruijnSequence(int n) {\n    int total = 1 << n;  // Total number of substrings (2^n)\n    vector<bool> visited(total, false);  // Track visited substrings\n    string sequence;\n\n    // Function to generate the De Bruijn sequence recursively\n    function<void(int, int)> generateSequence = [&](int current, int depth) {\n        if (depth == n) {\n            if (n == 1 || current != 0) {\n                sequence.push_back('0' + current);\n            }\n            return;\n        }\n\n        for (int i = 0; i < 2; i++) {\n            int next = (current << 1) | i;\n            if (!visited[next]) {\n                visited[next] = true;\n                generateSequence(next, depth + 1);\n                sequence.push_back('0' + i);\n            }\n        }\n    };\n\n    generateSequence(0, 0);\n    return sequence.substr(0, total + n - 1);  // Return the minimum-length sequence\n}\n\nint main() {\n    int n;\n    cin >> n;\n    string sequence = deBruijnSequence(n);\n    cout << sequence << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Dice Combinations",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int dp[n + 1];\n    dp[0] = 1;\n\n    for (int i = 1; i <= n; i++) {\n        dp[i] = 0;\n        for (int j = 1; j <= 6 && i - j >= 0; j++) {\n            dp[i] = (dp[i] + dp[i - j]) % MOD;\n        }\n    }\n\n    cout << dp[n] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 20,
            "total_test_cases": 20,
            "mean_time_taken": 0.09405692815780639,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Dice Probability",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <iomanip>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, a, b;\n    cin >> n >> a >> b;\n\n    vector<vector<long long>> dp(n+1, vector<long long>(6*n+1, 0));\n    dp[0][0] = 1;\n    for (int j = 1; j <= 6; j++) {\n        dp[1][j] = 1;\n    }\n\n    for (int i = 2; i <= n; i++) {\n        for (int j = i; j <= 6*i; j++) {\n            for (int k = 1; k <= 6; k++) {\n                if (j-k >= 0) {\n                    dp[i][j] += dp[i-1][j-k];\n                }\n            }\n        }\n    }\n\n    long long favorableOutcomes = 0;\n    for (int j = a; j <= b; j++) {\n        favorableOutcomes += dp[n][j];\n    }\n\n    long long totalOutcomes = 1;\n    for (int i = 0; i < n; i++) {\n        totalOutcomes *= 6;\n    }\n\n    double probability = static_cast<double>(favorableOutcomes) / totalOutcomes;\n    cout << fixed << setprecision(6) << probability << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 17,
            "mean_time_taken": 0.09190647742327522,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                5,
                6,
                9,
                11,
                15,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Digit Queries",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int q;\n    cin >> q;\n\n    while (q--) {\n        long long k;\n        cin >> k;\n\n        long long len = 1;\n        long long count = 9;\n        while (k > len * count) {\n            k -= len * count;\n            len++;\n            count *= 10;\n        }\n\n        long long num = (k - 1) / len;\n        long long pos = (k - 1) % len;\n        long long actual_num = pow(10, len - 1) + num;\n\n        string num_str = to_string(actual_num);\n        cout << num_str[pos] << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Distance Queries",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nconst int MAXLOG = 20;\n\nvector<int> adj[MAXN];\nint depth[MAXN];\nint parent[MAXN][MAXLOG];\n\nvoid dfs(int u, int p, int d) {\n    depth[u] = d;\n    parent[u][0] = p;\n    for (int v : adj[u]) {\n        if (v != p) {\n            dfs(v, u, d + 1);\n        }\n    }\n}\n\nvoid precompute(int n) {\n    for (int i = 1; i < MAXLOG; i++) {\n        for (int u = 1; u <= n; u++) {\n            parent[u][i] = parent[parent[u][i - 1]][i - 1];\n        }\n    }\n}\n\nint lca(int u, int v) {\n    if (depth[u] < depth[v]) {\n        swap(u, v);\n    }\n    int diff = depth[u] - depth[v];\n    for (int i = MAXLOG - 1; i >= 0; i--) {\n        if (diff & (1 << i)) {\n            u = parent[u][i];\n        }\n    }\n    if (u == v) {\n        return u;\n    }\n    for (int i = MAXLOG - 1; i >= 0; i--) {\n        if (parent[u][i] != parent[v][i]) {\n            u = parent[u][i];\n            v = parent[v][i];\n        }\n    }\n    return parent[u][0];\n}\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(1, 0, 0);\n    precompute(n);\n    while (q--) {\n        int u, v;\n        cin >> u >> v;\n        int lc = lca(u, v);\n        int dist = depth[u] + depth[v] - 2 * depth[lc];\n        cout << dist << endl;\n    }\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 11,
            "mean_time_taken": 0.2324671745300293,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Colors",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nvector<int> adj[MAXN];\nint color[MAXN];\nint answer[MAXN];\n\nvoid dfs(int node, int parent, unordered_set<int>& distinct_colors) {\n    for (int child : adj[node]) {\n        if (child != parent) {\n            dfs(child, node, distinct_colors);\n        }\n    }\n    distinct_colors.insert(color[node]);\n    answer[node] = distinct_colors.size();\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    for (int i = 1; i <= n; i++) {\n        cin >> color[i];\n    }\n\n    for (int i = 1; i < n; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    unordered_set<int> distinct_colors;\n    dfs(1, 0, distinct_colors);\n\n    for (int i = 1; i <= n; i++) {\n        cout << answer[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 15,
            "mean_time_taken": 0.22755287488301595,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Numbers",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <set>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    set<int> distinctValues;\n\n    for (int i = 0; i < n; i++) {\n        int value;\n        cin >> value;\n        distinctValues.insert(value);\n    }\n\n    cout << distinctValues.size() << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 15,
            "total_test_cases": 15,
            "mean_time_taken": 0.1506432056427002,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Distinct Routes",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<vector<int>> paths;\n\nvoid dfs(int u, int dest, vector<int>& path, vector<bool>& used) {\n    path.push_back(u);\n    if (u == dest) {\n        paths.push_back(path);\n    } else {\n        for (int v : adj[u]) {\n            if (!used[v]) {\n                used[v] = true;\n                dfs(v, dest, path, used);\n                used[v] = false;\n            }\n        }\n    }\n    path.pop_back();\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    adj.resize(n + 1);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n    vector<int> path;\n    vector<bool> used(n + 1, false);\n    dfs(1, n, path, used);\n    sort(paths.begin(), paths.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a.size() > b.size();\n    });\n    int k = paths.size();\n    cout << k << endl;\n    for (int i = 0; i < k; i++) {\n        cout << paths[i].size() << endl;\n        for (int j = 0; j < paths[i].size(); j++) {\n            cout << paths[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 18,
            "mean_time_taken": 0.30257532331678605,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                8,
                10,
                12,
                13,
                14,
                15,
                16,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Routes II",
            "category": "Advanced Techniques",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Distinct Substrings",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct TrieNode {\n    TrieNode* children[26];\n    TrieNode() {\n        for (int i = 0; i < 26; i++)\n            children[i] = nullptr;\n    }\n};\n\nint countDistinctSubstrings(string str) {\n    int n = str.length();\n    TrieNode* root = new TrieNode();\n    int count = 0;\n\n    for (int i = 0; i < n; i++) {\n        TrieNode* node = root;\n        for (int j = i; j < n; j++) {\n            int index = str[j] - 'a';\n            if (node->children[index] == nullptr) {\n                node->children[index] = new TrieNode();\n                count++;\n            }\n            node = node->children[index];\n        }\n    }\n\n    return count + 1; // +1 for empty substring\n}\n\nint main() {\n    string str;\n    cin >> str;\n    cout << countDistinctSubstrings(str) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 7,
            "mean_time_taken": 0.5390000683920724,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Values Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    vector<pair<int, int>> queries(q);\n    for (int i = 0; i < q; i++) {\n        int a, b;\n        cin >> a >> b;\n        queries[i] = {a, b};\n    }\n\n    vector<int> distinctCounts;\n    for (const auto& query : queries) {\n        int a = query.first;\n        int b = query.second;\n\n        unordered_set<int> distinctValues;\n        for (int i = a - 1; i <= b - 1; i++) {\n            distinctValues.insert(arr[i]);\n        }\n\n        distinctCounts.push_back(distinctValues.size());\n    }\n\n    for (int count : distinctCounts) {\n        cout << count << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 14,
            "mean_time_taken": 0.8427742038454328,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distributing Apples",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long factorial[2000001];\n\nlong long power(long long a, long long b) {\n    long long res = 1;\n    while (b) {\n        if (b & 1)\n            res = (res * a) % MOD;\n        a = (a * a) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nlong long modInverse(long long a) {\n    return power(a, MOD - 2);\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    factorial[0] = 1;\n    for (int i = 1; i <= n + m; i++) {\n        factorial[i] = (factorial[i - 1] * i) % MOD;\n    }\n\n    long long numerator = factorial[n + m - 1];\n    long long denominator = (factorial[m] * factorial[n - 1]) % MOD;\n    long long result = (numerator * modInverse(denominator)) % MOD;\n\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.09238079878000113,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Divisor Analysis",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long power(long long base, long long exp) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1)\n            result = (result * base) % MOD;\n        base = (base * base) % MOD;\n        exp /= 2;\n    }\n    return result;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    long long num_divisors = 1;\n    long long sum_divisors = 1;\n    long long product_divisors = 1;\n\n    for (int i = 0; i < n; i++) {\n        int x, k;\n        cin >> x >> k;\n\n        num_divisors = (num_divisors * (k + 1)) % MOD;\n\n        long long sum_term = (power(x, k + 1) - 1 + MOD) % MOD;\n        sum_term = (sum_term * power(x - 1, MOD - 2)) % MOD;\n        sum_divisors = (sum_divisors * sum_term) % MOD;\n\n        long long product_term = power(x, (k * (k + 1) / 2) % (MOD - 1));\n        product_divisors = (product_divisors * product_term) % MOD;\n    }\n\n    cout << num_divisors << \" \" << sum_divisors << \" \" << product_divisors << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 7,
            "mean_time_taken": 0.10532147543770927,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Download Speed",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nconst int INF = INT_MAX;\n\nint bfs(vector<vector<int>>& residualGraph, vector<int>& parent, int source, int sink) {\n    int n = residualGraph.size();\n    fill(parent.begin(), parent.end(), -1);\n    parent[source] = -2;\n    queue<pair<int, int>> q;\n    q.push({source, INF});\n\n    while (!q.empty()) {\n        int u = q.front().first;\n        int flow = q.front().second;\n        q.pop();\n\n        for (int v = 0; v < n; v++) {\n            if (parent[v] == -1 && residualGraph[u][v] > 0) {\n                parent[v] = u;\n                int newFlow = min(flow, residualGraph[u][v]);\n                if (v == sink)\n                    return newFlow;\n                q.push({v, newFlow});\n            }\n        }\n    }\n\n    return 0;\n}\n\nint maxFlow(vector<vector<int>>& graph, int source, int sink) {\n    int n = graph.size();\n    vector<vector<int>> residualGraph = graph;\n    vector<int> parent(n);\n    int maxFlow = 0;\n\n    while (int flow = bfs(residualGraph, parent, source, sink)) {\n        maxFlow += flow;\n        int v = sink;\n        while (v != source) {\n            int u = parent[v];\n            residualGraph[u][v] -= flow;\n            residualGraph[v][u] += flow;\n            v = u;\n        }\n    }\n\n    return maxFlow;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> graph(n, vector<int>(n, 0));\n\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--, b--;\n        graph[a][b] = c;\n    }\n\n    int maxDownloadSpeed = maxFlow(graph, 0, n - 1);\n    cout << maxDownloadSpeed << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 16,
            "total_test_cases": 21,
            "mean_time_taken": 0.15030889284043086,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                7,
                10,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Dynamic Connectivity",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass DisjointSet {\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n\npublic:\n    DisjointSet(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unionSets(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n};\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    DisjointSet ds(n);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        ds.unionSets(a, b);\n    }\n\n    int components = 0;\n    for (int i = 0; i < n; i++) {\n        if (ds.find(i) == i) {\n            components++;\n        }\n    }\n\n    cout << components << \" \";\n\n    for (int i = 0; i < k; i++) {\n        int t, a, b;\n        cin >> t >> a >> b;\n        a--, b--;\n\n        if (t == 1) {\n            if (ds.find(a) != ds.find(b)) {\n                ds.unionSets(a, b);\n                components--;\n            }\n        } else {\n            if (ds.find(a) == ds.find(b)) {\n                ds.unionSets(a, a);\n                components++;\n            }\n        }\n\n        cout << components << \" \";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 7,
            "mean_time_taken": 0.16756752559116908,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Dynamic Range Minimum Queries",
            "category": "Range Queries",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Dynamic Range Sum Queries",
            "category": "Range Queries",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Edit Distance",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint editDistance(const string& s1, const string& s2) {\n    int n = s1.length();\n    int m = s2.length();\n    vector<vector<int>> dp(n + 1, vector<int>(m + 1));\n\n    for (int i = 0; i <= n; i++) {\n        dp[i][0] = i;\n    }\n    for (int j = 0; j <= m; j++) {\n        dp[0][j] = j;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            if (s1[i - 1] == s2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = min(dp[i - 1][j] + 1, min(dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1));\n            }\n        }\n    }\n\n    return dp[n][m];\n}\n\nint main() {\n    string s1, s2;\n    cin >> s1 >> s2;\n    cout << editDistance(s1, s2) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 17,
            "total_test_cases": 17,
            "mean_time_taken": 0.2464456978966208,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Elevator Rides",
            "category": "Dynamic Programming",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nint solve(int n, int x, vector<int>& w) {\n    vector<int> dp(1 << n, INT_MAX);\n    dp[0] = 0;\n\n    for (int mask = 1; mask < (1 << n); mask++) {\n        int totalWeight = 0;\n        for (int i = 0; i < n; i++) {\n            if (mask & (1 << i)) {\n                totalWeight += w[i];\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (mask & (1 << i)) {\n                int newWeight = totalWeight - w[i];\n                if (newWeight <= x) {\n                    dp[mask] = min(dp[mask], dp[mask ^ (1 << i)] + 1);\n                }\n            }\n        }\n    }\n\n    return dp[(1 << n) - 1];\n}\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> w(n);\n    for (int i = 0; i < n; i++) {\n        cin >> w[i];\n    }\n\n    int minRides = solve(n, x, w);\n    cout << minRides << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 39,
            "mean_time_taken": 0.18529261075533354,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                35,
                36,
                37,
                38,
                39
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Empty String",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countWays(string s) {\n    int n = s.length();\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n\n    for (int len = 2; len <= n; len++) {\n        for (int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            if (s[i] == s[i+1]) {\n                dp[i][j] = (i+2 <= j ? dp[i+2][j] : 1) + 1;\n            }\n            for (int k = i; k < j; k++) {\n                dp[i][j] = (dp[i][j] + 1LL * dp[i][k] * dp[k+1][j]) % MOD;\n            }\n        }\n    }\n\n    return dp[0][n-1];\n}\n\nint main() {\n    string s;\n    cin >> s;\n    cout << countWays(s) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 12,
            "mean_time_taken": 0.1685421864191691,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Eulerian Subgraphs",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countEulerianSubgraphs(int n, const vector<vector<int>>& edges) {\n    vector<int> degree(n + 1, 0);\n\n    // Count the degree of each node\n    for (const auto& edge : edges) {\n        int u = edge[0], v = edge[1];\n        degree[u]++;\n        degree[v]++;\n    }\n\n    // Calculate the number of choices for each node\n    long long result = 1;\n    for (int i = 1; i <= n; i++) {\n        result = (result * (degree[i] / 2 + 1)) % MOD;\n    }\n\n    return result;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> edges(m, vector<int>(2));\n    for (int i = 0; i < m; i++) {\n        cin >> edges[i][0] >> edges[i][1];\n    }\n\n    int result = countEulerianSubgraphs(n, edges);\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 0.12581761678059897,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Even Outdegree Edges",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<pair<int, int>> edges(m);\n    for (int i = 0; i < m; i++) {\n        cin >> edges[i].first >> edges[i].second;\n    }\n\n    if (m % 2 != 0) {\n        cout << \"IMPOSSIBLE\" << endl;\n    } else {\n        for (int i = 0; i < m; i += 2) {\n            cout << edges[i].first << \" \" << edges[i].second << endl;\n            cout << edges[i + 1].second << \" \" << edges[i + 1].first << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 8,
            "mean_time_taken": 0.1680050492286682,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Exponentiation",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long modExp(long long a, long long b, long long MOD) {\n    if (b == 0) {\n        return 1;\n    }\n    if (b % 2 == 0) {\n        long long x = modExp(a, b / 2, MOD);\n        return (x * x) % MOD;\n    } else {\n        long long x = modExp(a, b - 1, MOD);\n        return (a * x) % MOD;\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    while (n--) {\n        long long a, b;\n        cin >> a >> b;\n        cout << modExp(a, b, MOD) << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 3,
            "mean_time_taken": 0.2445380687713623,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Exponentiation II",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long binExpMod(long long a, long long b, long long m) {\n    a %= m;\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = (res * a) % m;\n        a = (a * a) % m;\n        b >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    while (n--) {\n        long long a, b, c;\n        cin >> a >> b >> c;\n        if (a == 0 && b == 0)\n            cout << 1 << endl;\n        else {\n            long long exp = binExpMod(b, c, MOD - 1);\n            long long result = binExpMod(a, exp, MOD);\n            cout << result << endl;\n        }\n    }\n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 13,
            "mean_time_taken": 0.14760430042560285,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Factory Machines",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nlong long count_products(long long time, const vector<int>& k) {\n    long long count = 0;\n    for (int i = 0; i < k.size(); i++) {\n        count += time / k[i];\n    }\n    return count;\n}\n\nint main() {\n    int n, t;\n    cin >> n >> t;\n\n    vector<int> k(n);\n    for (int i = 0; i < n; i++) {\n        cin >> k[i];\n    }\n\n    long long low = 1;\n    long long high = *max_element(k.begin(), k.end()) * (long long)t;\n\n    while (low <= high) {\n        long long mid = (low + high) / 2;\n        long long count = count_products(mid, k);\n\n        if (count >= t) {\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n\n    cout << low << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 17,
            "total_test_cases": 18,
            "mean_time_taken": 0.1005634864171346,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Ferris Wheel",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> weights(n);\n    for (int i = 0; i < n; i++) {\n        cin >> weights[i];\n    }\n\n    sort(weights.begin(), weights.end());\n\n    int left = 0, right = n - 1;\n    int gondolas = 0;\n\n    while (left <= right) {\n        if (left == right) {\n            gondolas++;\n            break;\n        }\n\n        if (weights[left] + weights[right] <= x) {\n            left++;\n        }\n\n        right--;\n        gondolas++;\n    }\n\n    cout << gondolas << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.1285714552952693,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Fibonacci Numbers",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    long long n;\n    cin >> n;\n    \n    long long a = 0, b = 1;\n    \n    for (long long i = 0; i < n; i++) {\n        long long c = (a + b) % MOD;\n        a = b;\n        b = c;\n    }\n    \n    cout << a << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 12,
            "mean_time_taken": 0.5668445030848185,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                7,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Filling Trominos",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MAXN = 100;\nchar grid[MAXN][MAXN];\n\nvoid fill_tromino(int row, int col, int size, char ch) {\n    if (size == 1) {\n        grid[row][col] = ch;\n        return;\n    }\n\n    int half_size = size / 2;\n    char ch1 = ch, ch2 = ch + 1, ch3 = ch + 2, ch4 = ch + 3;\n\n    fill_tromino(row, col, half_size, ch1);\n    fill_tromino(row, col + half_size, half_size, ch2);\n    fill_tromino(row + half_size, col, half_size, ch3);\n    fill_tromino(row + half_size, col + half_size, half_size, ch4);\n\n    if (size == 2) {\n        grid[row + 1][col] = ch1;\n        grid[row][col + 1] = ch2;\n        grid[row + 1][col + 1] = ch3;\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n\n        if ((n * m) % 3 != 0) {\n            cout << \"NO\\n\";\n        } else {\n            cout << \"YES\\n\";\n            fill_tromino(0, 0, max(n, m), 'A');\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    cout << grid[i][j];\n                }\n                cout << \"\\n\";\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.10088711977005005,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding Borders",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> computeFailureFunction(const string& s) {\n    int n = s.length();\n    vector<int> f(n);\n    f[0] = 0;\n    \n    for (int i = 1; i < n; i++) {\n        int j = f[i - 1];\n        while (j > 0 && s[i] != s[j])\n            j = f[j - 1];\n        if (s[i] == s[j])\n            j++;\n        f[i] = j;\n    }\n    \n    return f;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    \n    vector<int> f = computeFailureFunction(s);\n    vector<int> borderLengths;\n    \n    for (int i = 1; i < s.length(); i++) {\n        if (f[i] > 0)\n            borderLengths.push_back(f[i]);\n    }\n    \n    sort(borderLengths.begin(), borderLengths.end());\n    \n    for (int len : borderLengths)\n        cout << len << \" \";\n    \n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 11,
            "mean_time_taken": 0.18041437322443182,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding Patterns",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    string s;\n    cin >> s;\n\n    int k;\n    cin >> k;\n\n    vector<string> patterns(k);\n    for (int i = 0; i < k; i++) {\n        cin >> patterns[i];\n    }\n\n    for (const string& pattern : patterns) {\n        if (s.find(pattern) != string::npos) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 15,
            "total_test_cases": 17,
            "mean_time_taken": 0.35681453873129454,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                8,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding Periods",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> computeLPS(string pattern) {\n    int m = pattern.length();\n    vector<int> lps(m);\n    int len = 0;\n    lps[0] = 0;\n    int i = 1;\n    while (i < m) {\n        if (pattern[i] == pattern[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        } else {\n            if (len != 0) {\n                len = lps[len - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    return lps;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.length();\n    vector<int> lps = computeLPS(s);\n    vector<int> periods;\n    int period = n - lps[n - 1];\n    while (period <= n) {\n        if (n % period == 0) {\n            periods.push_back(period);\n        }\n        if (lps[n - 1] == 0) {\n            break;\n        }\n        n = lps[n - 1];\n        period = n - lps[n - 1];\n    }\n    for (int i = 0; i < periods.size(); i++) {\n        cout << periods[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 14,
            "mean_time_taken": 0.11004274232046944,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding a Centroid",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nvector<int> adj[MAXN];\nint subtree_size[MAXN];\nint n;\n\nvoid dfs(int u, int parent) {\n    subtree_size[u] = 1;\n    for (int v : adj[u]) {\n        if (v != parent) {\n            dfs(v, u);\n            subtree_size[u] += subtree_size[v];\n        }\n    }\n}\n\nint find_centroid() {\n    dfs(1, 0);\n    for (int u = 1; u <= n; u++) {\n        bool is_centroid = true;\n        for (int v : adj[u]) {\n            if (subtree_size[v] > n / 2) {\n                is_centroid = false;\n                break;\n            }\n        }\n        if (is_centroid && (n - subtree_size[u]) <= n / 2) {\n            return u;\n        }\n    }\n    return -1; // No centroid found (should not happen for a valid tree)\n}\n\nint main() {\n    cin >> n;\n    for (int i = 1; i < n; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    int centroid = find_centroid();\n    cout << centroid << endl;\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 16,
            "mean_time_taken": 0.1495857983827591,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Fixed-Length Paths I",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<vector<int>> adj;\nint cnt = 0;\n\nvoid dfs(int node, int parent, int pathLen, int k) {\n    if (pathLen == k) {\n        cnt++;\n        return;\n    }\n    \n    for (int neighbor : adj[node]) {\n        if (neighbor != parent) {\n            dfs(neighbor, node, pathLen + 1, k);\n        }\n    }\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    \n    adj.resize(n + 1);\n    \n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        dfs(i, -1, 0, k);\n    }\n    \n    cout << cnt / 2 << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 9,
            "total_test_cases": 20,
            "mean_time_taken": 0.6078458070755005,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                8,
                9,
                12,
                16,
                18,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Fixed-Length Paths II",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<vector<int>> adj;\nint ans = 0;\n\nvoid dfs(int u, int parent, int depth, int k1, int k2) {\n    if (depth >= k1 && depth <= k2) {\n        ans++;\n    }\n    if (depth > k2) {\n        return;\n    }\n    for (int v : adj[u]) {\n        if (v != parent) {\n            dfs(v, u, depth + 1, k1, k2);\n        }\n    }\n}\n\nint main() {\n    int n, k1, k2;\n    cin >> n >> k1 >> k2;\n\n    adj.resize(n + 1);\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    for (int i = 1; i <= n; i++) {\n        dfs(i, -1, 0, k1, k2);\n    }\n\n    cout << ans / 2 << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 23,
            "mean_time_taken": 0.5826651739037555,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                14,
                16,
                19,
                20,
                21,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Flight Discount",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\ntypedef pair<long long, int> pli;\n\nlong long dijkstra(int start, int end, vector<vector<pli>>& graph) {\n    int n = graph.size();\n    vector<long long> dist(n, LLONG_MAX);\n    vector<long long> dist_coupon(n, LLONG_MAX);\n\n    priority_queue<pli, vector<pli>, greater<pli>> pq;\n    pq.push({0, start});\n    dist[start] = 0;\n\n    while (!pq.empty()) {\n        int u = pq.top().second;\n        long long cost = pq.top().first;\n        pq.pop();\n\n        if (u == end)\n            return min(dist[end], dist_coupon[end]);\n\n        if (cost > dist_coupon[u])\n            continue;\n\n        for (auto& edge : graph[u]) {\n            int v = edge.second;\n            long long weight = edge.first;\n\n            if (cost + weight < dist[v]) {\n                dist[v] = cost + weight;\n                pq.push({dist[v], v});\n            }\n\n            long long coupon_cost = cost + weight / 2;\n            if (coupon_cost < dist_coupon[v]) {\n                dist_coupon[v] = coupon_cost;\n                pq.push({dist_coupon[v], v});\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<pli>> graph(n);\n\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--, b--;\n        graph[a].push_back({c, b});\n    }\n\n    long long min_cost = dijkstra(0, n - 1, graph);\n    cout << min_cost << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 24,
            "mean_time_taken": 0.1489331821600596,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Flight Route Requests",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid dfs(int city, vector<bool>& visited, vector<vector<int>>& adj) {\n    visited[city] = true;\n    for (int neighbor : adj[city]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, visited, adj);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> adj(n + 1);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n\n    int totalConnections = 0;\n    for (int city = 1; city <= n; city++) {\n        vector<bool> visited(n + 1, false);\n        dfs(city, visited, adj);\n\n        int connections = 0;\n        for (int neighbor : adj[city]) {\n            if (!visited[neighbor]) {\n                connections++;\n            }\n        }\n        totalConnections += connections;\n    }\n\n    cout << totalConnections << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 17,
            "mean_time_taken": 0.29151258749120373,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Flight Routes",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef pair<int, vector<int>> piv;\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<vector<pii>> graph(n + 1);\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        graph[a].push_back({b, c});\n    }\n\n    priority_queue<piv, vector<piv>, greater<piv>> pq;\n    pq.push({0, {1}});\n\n    vector<int> prices;\n    while (!pq.empty() && prices.size() < k) {\n        auto [price, route] = pq.top();\n        pq.pop();\n\n        int last_city = route.back();\n        if (last_city == n) {\n            prices.push_back(price);\n        }\n\n        if (prices.size() == k) {\n            break;\n        }\n\n        for (auto [neighbor, flight_price] : graph[last_city]) {\n            vector<int> new_route = route;\n            new_route.push_back(neighbor);\n            pq.push({price + flight_price, new_route});\n        }\n    }\n\n    for (int price : prices) {\n        cout << price << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 17,
            "mean_time_taken": 0.6209666308234719,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                5,
                6,
                7,
                8,
                9,
                11,
                14,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Flight Routes Check",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nvector<int> adj[MAXN];\nbool visited[MAXN];\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n\n    for (int i = 1; i <= n; i++) {\n        fill(visited, visited + n + 1, false);\n        dfs(i);\n\n        for (int j = 1; j <= n; j++) {\n            if (!visited[j]) {\n                cout << \"NO\" << endl;\n                cout << i << \" \" << j << endl;\n                return 0;\n            }\n        }\n    }\n\n    cout << \"YES\" << endl;\n    return 0;\n}\n",
            "passed_test_cases": 14,
            "total_test_cases": 20,
            "mean_time_taken": 0.3865662932395935,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                6,
                8,
                14,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Food Division",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    vector<int> b(n);\n    for (int i = 0; i < n; i++) {\n        cin >> b[i];\n    }\n\n    vector<int> diff(n);\n    for (int i = 0; i < n; i++) {\n        diff[i] = a[i] - b[i];\n    }\n\n    int steps = 0;\n    for (int i = 0; i < n; i++) {\n        if (diff[i] > 0) {\n            steps += diff[i];\n        } else {\n            steps -= diff[i];\n        }\n    }\n\n    cout << steps / 2 << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 5,
            "mean_time_taken": 0.11299762725830079,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Forbidden Cities",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nvector<int> adj[MAXN];\nbool visited[MAXN];\n\nbool dfs(int curr, int dest, int forbidden) {\n    if (curr == forbidden)\n        return false;\n    if (curr == dest)\n        return true;\n    \n    visited[curr] = true;\n    \n    for (int next : adj[curr]) {\n        if (!visited[next] && dfs(next, dest, forbidden))\n            return true;\n    }\n    \n    return false;\n}\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    \n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    \n    while (q--) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        \n        fill(visited, visited + n + 1, false);\n        \n        if (dfs(a, b, c))\n            cout << \"YES\\n\";\n        else\n            cout << \"NO\\n\";\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 9,
            "total_test_cases": 14,
            "mean_time_taken": 0.4336705207824707,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                5,
                6,
                8,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Forest Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<vector<char>> forest(n, vector<char>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> forest[i][j];\n        }\n    }\n\n    vector<vector<int>> prefix_sum(n + 1, vector<int>(n + 1, 0));\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            prefix_sum[i][j] = (forest[i - 1][j - 1] == '*') + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1];\n        }\n    }\n\n    while (q--) {\n        int y1, x1, y2, x2;\n        cin >> y1 >> x1 >> y2 >> x2;\n\n        int trees = prefix_sum[y2][x2] - prefix_sum[y1 - 1][x2] - prefix_sum[y2][x1 - 1] + prefix_sum[y1 - 1][x1 - 1];\n        cout << trees << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 3,
            "mean_time_taken": 0.22847827275594076,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Forest Queries II",
            "category": "Range Queries",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Functional Graph Distribution",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<vector<long long>> stirling(n + 1, vector<long long>(n + 1, 0));\n    stirling[0][0] = 1;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= i; j++) {\n            stirling[i][j] = (stirling[i - 1][j - 1] + j * stirling[i - 1][j]) % MOD;\n        }\n    }\n\n    for (int k = 1; k <= n; k++) {\n        long long result = stirling[n][k];\n        for (int i = 0; i < n; i++) {\n            result = (result * k) % MOD;\n        }\n        cout << result << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.16139519214630127,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Game Routes",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countRoutes(int n, vector<vector<int>>& teleporters) {\n    vector<vector<int>> adj(n + 1);\n    for (const auto& t : teleporters) {\n        adj[t[0]].push_back(t[1]);\n    }\n\n    vector<int> dp(n + 1, 0);\n    dp[1] = 1;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j : adj[i]) {\n            dp[j] = (dp[j] + dp[i]) % MOD;\n        }\n    }\n\n    return dp[n];\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> teleporters(m, vector<int>(2));\n    for (int i = 0; i < m; i++) {\n        cin >> teleporters[i][0] >> teleporters[i][1];\n    }\n\n    int ways = countRoutes(n, teleporters);\n    cout << ways << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 15,
            "mean_time_taken": 0.13584294319152831,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                5,
                6,
                8,
                9,
                10,
                11,
                12,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Giant Pizza",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<pair<char, int>>> wishes(n, vector<pair<char, int>>(2));\n    for (int i = 0; i < n; i++) {\n        char sign1, sign2;\n        int topping1, topping2;\n        cin >> sign1 >> topping1 >> sign2 >> topping2;\n        wishes[i][0] = {sign1, topping1};\n        wishes[i][1] = {sign2, topping2};\n    }\n\n    vector<char> toppings(m, '-');\n\n    for (int i = 0; i < n; i++) {\n        bool satisfied = false;\n        for (int j = 0; j < 2; j++) {\n            char sign = wishes[i][j].first;\n            int topping = wishes[i][j].second - 1;\n            if ((sign == '+' && toppings[topping] == '+') || (sign == '-' && toppings[topping] == '-')) {\n                satisfied = true;\n                break;\n            }\n        }\n        if (!satisfied) {\n            char sign = wishes[i][0].first;\n            int topping = wishes[i][0].second - 1;\n            if (toppings[topping] != '-' && toppings[topping] != sign) {\n                cout << \"IMPOSSIBLE\" << endl;\n                return 0;\n            }\n            toppings[topping] = sign;\n        }\n    }\n\n    for (char topping : toppings) {\n        cout << topping;\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 22,
            "mean_time_taken": 0.10547679120844061,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Graph Girth",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint bfs(int start, vector<vector<int>>& adj, vector<int>& dist) {\n    queue<int> q;\n    q.push(start);\n    dist[start] = 0;\n\n    while (!q.empty()) {\n        int curr = q.front();\n        q.pop();\n\n        for (int neighbor : adj[curr]) {\n            if (dist[neighbor] == INF) {\n                dist[neighbor] = dist[curr] + 1;\n                q.push(neighbor);\n            } else if (dist[neighbor] >= dist[curr]) {\n                return dist[curr] + dist[neighbor] + 1;\n            }\n        }\n    }\n\n    return INF;\n}\n\nint findGirth(int n, vector<vector<int>>& adj) {\n    int girth = INF;\n\n    for (int i = 1; i <= n; i++) {\n        vector<int> dist(n + 1, INF);\n        int cycleLen = bfs(i, adj, dist);\n        girth = min(girth, cycleLen);\n    }\n\n    return (girth == INF) ? -1 : girth;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> adj(n + 1);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    int girth = findGirth(n, adj);\n    cout << girth << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 17,
            "total_test_cases": 20,
            "mean_time_taken": 0.15049535036087036,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                10,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Graph Paths I",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countPaths(int u, int k, vector<vector<int>>& adj) {\n    if (k == 0) {\n        return u == adj.size() - 1;\n    }\n    \n    int count = 0;\n    for (int v = 0; v < adj.size(); v++) {\n        if (adj[u][v]) {\n            count = (count + countPaths(v, k - 1, adj)) % MOD;\n        }\n    }\n    \n    return count;\n}\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n    \n    vector<vector<int>> adj(n, vector<int>(n, 0));\n    \n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a - 1][b - 1] = 1;\n    }\n    \n    cout << countPaths(0, k, adj) << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 14,
            "mean_time_taken": 0.11459810393197196,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                7,
                8,
                10,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Graph Paths II",
            "category": "Mathematics",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<vector<pair<int, int>>> graph(n + 1);\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        graph[a].push_back({b, c});\n    }\n\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1, INF));\n    dp[1][0] = 0;\n\n    for (int j = 1; j <= k; j++) {\n        for (int i = 1; i <= n; i++) {\n            for (auto [u, w] : graph[i]) {\n                if (j > 0) {\n                    dp[u][j] = min(dp[u][j], dp[i][j - 1] + w);\n                }\n            }\n        }\n    }\n\n    int ans = dp[n][k];\n    if (ans == INF) ans = -1;\n    cout << ans << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 15,
            "mean_time_taken": 0.12644664446512857,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                9,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Gray Code",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid generateGrayCode(int n, vector<string>& grayCode) {\n    if (n == 1) {\n        grayCode.push_back(\"0\");\n        grayCode.push_back(\"1\");\n        return;\n    }\n\n    generateGrayCode(n - 1, grayCode);\n\n    int size = grayCode.size();\n    for (int i = size - 1; i >= 0; i--) {\n        grayCode.push_back(grayCode[i]);\n    }\n\n    for (int i = 0; i < size; i++) {\n        grayCode[i] = \"0\" + grayCode[i];\n    }\n\n    for (int i = size; i < 2 * size; i++) {\n        grayCode[i] = \"1\" + grayCode[i];\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<string> grayCode;\n    generateGrayCode(n, grayCode);\n\n    for (string code : grayCode) {\n        cout << code << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 16,
            "total_test_cases": 16,
            "mean_time_taken": 0.09373582899570465,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Grid Completion",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countWays(vector<string>& grid, int row, int col, vector<bool>& rowA, vector<bool>& rowB, vector<bool>& colA, vector<bool>& colB) {\n    int n = grid.size();\n    \n    if (row == n) {\n        return 1;\n    }\n    \n    if (col == n) {\n        return countWays(grid, row + 1, 0, rowA, rowB, colA, colB);\n    }\n    \n    if (grid[row][col] == 'A') {\n        rowA[row] = true;\n        colA[col] = true;\n        return countWays(grid, row, col + 1, rowA, rowB, colA, colB);\n    }\n    \n    if (grid[row][col] == 'B') {\n        rowB[row] = true;\n        colB[col] = true;\n        return countWays(grid, row, col + 1, rowA, rowB, colA, colB);\n    }\n    \n    int ways = 0;\n    \n    if (!rowA[row] && !colA[col]) {\n        rowA[row] = true;\n        colA[col] = true;\n        ways = (ways + countWays(grid, row, col + 1, rowA, rowB, colA, colB)) % MOD;\n        rowA[row] = false;\n        colA[col] = false;\n    }\n    \n    if (!rowB[row] && !colB[col]) {\n        rowB[row] = true;\n        colB[col] = true;\n        ways = (ways + countWays(grid, row, col + 1, rowA, rowB, colA, colB)) % MOD;\n        rowB[row] = false;\n        colB[col] = false;\n    }\n    \n    return ways;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<string> grid(n);\n    for (int i = 0; i < n; i++) {\n        cin >> grid[i];\n    }\n    \n    vector<bool> rowA(n, false), rowB(n, false), colA(n, false), colB(n, false);\n    \n    int ways = countWays(grid, 0, 0, rowA, rowB, colA, colB);\n    \n    cout << ways << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.09748625755310059,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Path Construction",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n, m, y1, x1, y2, x2;\n        cin >> n >> m >> y1 >> x1 >> y2 >> x2;\n\n        if ((y1 != y2 || x1 != x2) && n * m > 1) {\n            cout << \"YES\\n\";\n\n            string path = \"\";\n            int x = x1, y = y1;\n\n            // Move horizontally\n            while (x != x2) {\n                path += (x < x2) ? 'R' : 'L';\n                x += (x < x2) ? 1 : -1;\n            }\n\n            // Move vertically\n            while (y != y2) {\n                path += (y < y2) ? 'D' : 'U';\n                y += (y < y2) ? 1 : -1;\n            }\n\n            // Fill remaining squares\n            int dx[] = {1, -1, -1, 1};\n            int dy[] = {1, 1, -1, -1};\n            int dir = 0;\n\n            while (path.length() < n * m) {\n                int nx = x + dx[dir];\n                int ny = y + dy[dir];\n\n                if (nx < 1 || nx > m || ny < 1 || ny > n) {\n                    dir = (dir + 1) % 4;\n                    continue;\n                }\n\n                path += (dx[dir] == 1) ? 'R' : ((dx[dir] == -1) ? 'L' : ((dy[dir] == 1) ? 'D' : 'U'));\n                x = nx;\n                y = ny;\n            }\n\n            cout << path << \"\\n\";\n        } else {\n            cout << \"NO\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 20,
            "mean_time_taken": 0.13573219776153564,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Paths",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint gridPaths(int n, vector<vector<int>>& traps) {\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n    \n    // Mark the cells with traps as -1\n    for (const auto& trap : traps) {\n        int y = trap[0], x = trap[1];\n        dp[y][x] = -1;\n    }\n    \n    // Set the bottom-right cell as 1\n    dp[n][n] = 1;\n    \n    // Iterate over the cells in reverse order\n    for (int i = n - 1; i >= 1; i--) {\n        for (int j = n - 1; j >= 1; j--) {\n            if (dp[i][j] == -1) continue; // Skip traps\n            \n            // Calculate the number of paths from the current cell\n            dp[i][j] = (dp[i + 1][j] + dp[i][j + 1]) % MOD;\n            if (dp[i][j] < 0) dp[i][j] += MOD;\n        }\n    }\n    \n    return dp[1][1];\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<vector<int>> traps(m, vector<int>(2));\n    for (int i = 0; i < m; i++) {\n        cin >> traps[i][0] >> traps[i][1];\n    }\n    \n    int result = gridPaths(n, traps);\n    cout << result << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 20,
            "mean_time_taken": 0.16679303646087645,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                19
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Paths",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nconst int GRID_SIZE = 7;\n\nint countPaths(string& desc, int row, int col, int index) {\n    if (row == GRID_SIZE - 1 && col == 0 && index == desc.length()) {\n        return 1;\n    }\n    \n    if (row < 0 || row >= GRID_SIZE || col < 0 || col >= GRID_SIZE || index >= desc.length()) {\n        return 0;\n    }\n    \n    char ch = desc[index];\n    int count = 0;\n    \n    if (ch == '?' || ch == 'D') {\n        count += countPaths(desc, row + 1, col, index + 1);\n    }\n    if (ch == '?' || ch == 'U') {\n        count += countPaths(desc, row - 1, col, index + 1);\n    }\n    if (ch == '?' || ch == 'L') {\n        count += countPaths(desc, row, col - 1, index + 1);\n    }\n    if (ch == '?' || ch == 'R') {\n        count += countPaths(desc, row, col + 1, index + 1);\n    }\n    \n    return count;\n}\n\nint main() {\n    string desc;\n    cin >> desc;\n    \n    int totalPaths = countPaths(desc, 0, 0, 0);\n    cout << totalPaths << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 20,
            "mean_time_taken": 1.0403676629066467,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Paths",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint gridPaths(int n, vector<string>& grid) {\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n    \n    if (grid[0][0] == '.') {\n        dp[0][0] = 1;\n    }\n    \n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == '*') {\n                dp[i][j] = 0;\n            } else {\n                dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD;\n            }\n        }\n    }\n    \n    return dp[n-1][n-1];\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<string> grid(n);\n    for (int i = 0; i < n; i++) {\n        cin >> grid[i];\n    }\n    \n    int result = gridPaths(n, grid);\n    cout << result << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 20,
            "mean_time_taken": 0.10910391807556152,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                6,
                7,
                8,
                10,
                11,
                12,
                13,
                14,
                16,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Puzzle I",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int a[n], b[n];\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> b[i];\n    }\n\n    char grid[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            grid[i][j] = '.';\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < a[i]; j++) {\n            grid[i][j] = 'X';\n            b[j]--;\n        }\n    }\n\n    for (int j = 0; j < n; j++) {\n        if (b[j] != 0) {\n            cout << \"-1\" << endl;\n            return 0;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << grid[i][j];\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 12,
            "mean_time_taken": 0.0913145939509074,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                6,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Puzzle II",
            "category": "Additional Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Grundy's Game",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 1e6;\n\nvector<int> grundy(MAX_N + 1);\n\nvoid precompute() {\n    grundy[0] = grundy[1] = 0;\n    for (int i = 2; i <= MAX_N; i++) {\n        vector<bool> used(i);\n        for (int j = 1; j < i; j++) {\n            int k = i - j;\n            if (j != k) {\n                used[grundy[j] ^ grundy[k]] = true;\n            }\n        }\n        grundy[i] = find(used.begin(), used.end(), false) - used.begin();\n    }\n}\n\nint main() {\n    precompute();\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        if (grundy[n] == 0) {\n            cout << \"second\" << endl;\n        } else {\n            cout << \"first\" << endl;\n        }\n    }\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 1.0406362215677898,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Hamiltonian Flights",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int MAXN = 20;\n\nint n, m;\nbool adj[MAXN][MAXN];\nint memo[MAXN][1 << MAXN];\n\nint dfs(int curr, int mask) {\n    if (memo[curr][mask] != -1)\n        return memo[curr][mask];\n\n    if (curr == n - 1 && mask == (1 << n) - 1)\n        return 1;\n\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (adj[curr][i] && !(mask & (1 << i))) {\n            count = (count + dfs(i, mask | (1 << i))) % MOD;\n        }\n    }\n\n    return memo[curr][mask] = count;\n}\n\nint main() {\n    cin >> n >> m;\n    memset(adj, false, sizeof(adj));\n    memset(memo, -1, sizeof(memo));\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        adj[a][b] = true;\n    }\n\n    cout << dfs(0, 1) << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 17,
            "total_test_cases": 20,
            "mean_time_taken": 0.3668330550193787,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                16,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Hamming Distance",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<string> bitStrings(n);\n    for (int i = 0; i < n; i++) {\n        cin >> bitStrings[i];\n    }\n\n    int minHammingDistance = k + 1;\n\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int hammingDistance = 0;\n            for (int m = 0; m < k; m++) {\n                if (bitStrings[i][m] != bitStrings[j][m]) {\n                    hammingDistance++;\n                }\n            }\n            minHammingDistance = min(minHammingDistance, hammingDistance);\n        }\n    }\n\n    cout << minHammingDistance << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 15,
            "mean_time_taken": 0.6737772146860759,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                5,
                6,
                7,
                8,
                9,
                12,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "High Score",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<pair<int, int>>> graph(n + 1);\n    for (int i = 0; i < m; i++) {\n        int a, b, x;\n        cin >> a >> b >> x;\n        graph[a].push_back({b, x});\n    }\n\n    vector<long long> dist(n + 1, LLONG_MIN);\n    dist[1] = 0;\n\n    for (int i = 1; i < n; i++) {\n        for (int u = 1; u <= n; u++) {\n            for (auto edge : graph[u]) {\n                int v = edge.first;\n                int w = edge.second;\n                if (dist[u] != LLONG_MIN && dist[v] < dist[u] + w) {\n                    dist[v] = dist[u] + w;\n                }\n            }\n        }\n    }\n\n    for (int u = 1; u <= n; u++) {\n        for (auto edge : graph[u]) {\n            int v = edge.first;\n            int w = edge.second;\n            if (dist[u] != LLONG_MIN && dist[v] < dist[u] + w) {\n                cout << -1 << endl;\n                return 0;\n            }\n        }\n    }\n\n    cout << dist[n] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 35,
            "total_test_cases": 43,
            "mean_time_taken": 0.11577100531999455,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                6,
                10,
                13,
                14,
                25,
                34,
                36,
                42
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Hotel Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <set>\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    multiset<pair<int, int>> hotels;\n    for (int i = 1; i <= n; i++) {\n        int rooms;\n        cin >> rooms;\n        hotels.insert({rooms, i});\n    }\n\n    while (m--) {\n        int required_rooms;\n        cin >> required_rooms;\n\n        auto it = hotels.lower_bound({required_rooms, 0});\n        if (it != hotels.end()) {\n            cout << it->second << \" \";\n            int rooms = it->first - required_rooms;\n            hotels.erase(it);\n            if (rooms > 0) {\n                hotels.insert({rooms, it->second});\n            }\n        } else {\n            cout << \"0 \";\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 11,
            "mean_time_taken": 0.2545040087266402,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Houses and Schools",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> children(n);\n    for (int i = 0; i < n; i++) {\n        cin >> children[i];\n    }\n\n    vector<long long> prefix(n + 1);\n    for (int i = 1; i <= n; i++) {\n        prefix[i] = prefix[i - 1] + children[i - 1];\n    }\n\n    vector<vector<long long>> dp(n + 1, vector<long long>(k + 1, INF));\n    dp[0][0] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= min(i, k); j++) {\n            for (int p = j - 1; p < i; p++) {\n                long long cost = 0;\n                int median = (p + i) / 2;\n                cost += (prefix[median] - prefix[p]) * (median - p);\n                cost += (prefix[i] - prefix[median]) * (i - median);\n                dp[i][j] = min(dp[i][j], dp[p][j - 1] + cost);\n            }\n        }\n    }\n\n    cout << dp[n][k] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.6791812181472778,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Increasing Array",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    long long moves = 0;\n    long long prev, curr;\n    cin >> prev;\n\n    for (int i = 1; i < n; i++) {\n        cin >> curr;\n        if (curr < prev) {\n            moves += prev - curr;\n            curr = prev;\n        }\n        prev = curr;\n    }\n\n    cout << moves << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 7,
            "mean_time_taken": 0.10526980672563825,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Increasing Array II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    long long prev, curr;\n    cin >> prev;\n    \n    long long total_moves = 0;\n    \n    for (int i = 1; i < n; i++) {\n        cin >> curr;\n        \n        if (curr < prev) {\n            total_moves += prev - curr;\n            curr = prev;\n        }\n        \n        prev = curr;\n    }\n    \n    cout << total_moves << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 7,
            "mean_time_taken": 0.11074413572038923,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Increasing Array Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> x(n + 1);\n    for (int i = 1; i <= n; i++) {\n        cin >> x[i];\n    }\n\n    vector<long long> operations(n + 1);\n    operations[1] = 0;\n    for (int i = 2; i <= n; i++) {\n        if (x[i] >= x[i - 1]) {\n            operations[i] = operations[i - 1];\n        } else {\n            operations[i] = operations[i - 1] + (x[i - 1] - x[i] + 1);\n        }\n    }\n\n    while (q--) {\n        int a, b;\n        cin >> a >> b;\n        cout << operations[b] - operations[a - 1] << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 8,
            "mean_time_taken": 0.23955559730529785,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Increasing Subsequence",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint longestIncreasingSubsequence(vector<int>& arr) {\n    int n = arr.size();\n    vector<int> dp(n, 1);\n\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (arr[i] > arr[j]) {\n                dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n    }\n\n    return *max_element(dp.begin(), dp.end());\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    int longestSubsequenceLength = longestIncreasingSubsequence(arr);\n    cout << longestSubsequenceLength << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 11,
            "total_test_cases": 17,
            "mean_time_taken": 0.4280410794650807,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                9,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Increasing Subsequence II",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nvoid update(vector<long long>& bit, int index, long long value) {\n    while (index < bit.size()) {\n        bit[index] = (bit[index] + value) % MOD;\n        index += index & -index;\n    }\n}\n\nlong long query(vector<long long>& bit, int index) {\n    long long sum = 0;\n    while (index > 0) {\n        sum = (sum + bit[index]) % MOD;\n        index -= index & -index;\n    }\n    return sum;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<int, int>> x(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i].first;\n        x[i].second = i;\n    }\n\n    sort(x.begin(), x.end());\n\n    vector<long long> dp(n, 1);\n    vector<long long> bit(x.back().first + 1, 0);\n\n    for (int i = 0; i < n; i++) {\n        int prev_sum = query(bit, x[i].first - 1);\n        dp[x[i].second] = (dp[x[i].second] + prev_sum) % MOD;\n        update(bit, x[i].first, dp[x[i].second]);\n    }\n\n    long long total = 0;\n    for (int i = 0; i < n; i++) {\n        total = (total + dp[i]) % MOD;\n    }\n\n    cout << total << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 10,
            "mean_time_taken": 0.13491265773773192,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Intersection Points",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nstruct Line {\n    int x1, y1, x2, y2;\n    bool isVertical;\n    \n    Line(int x1, int y1, int x2, int y2) {\n        this->x1 = x1;\n        this->y1 = y1;\n        this->x2 = x2;\n        this->y2 = y2;\n        isVertical = (x1 == x2);\n    }\n};\n\nbool compareLines(const Line& a, const Line& b) {\n    if (a.isVertical != b.isVertical)\n        return a.isVertical;\n    \n    if (a.isVertical)\n        return a.x1 < b.x1;\n    else\n        return a.y1 < b.y1;\n}\n\nint countIntersections(vector<Line>& lines) {\n    int intersections = 0;\n    set<int> activeLines;\n    \n    sort(lines.begin(), lines.end(), compareLines);\n    \n    for (const Line& line : lines) {\n        if (line.isVertical) {\n            for (int y = line.y1; y <= line.y2; y++) {\n                if (activeLines.count(y))\n                    intersections++;\n            }\n        } else {\n            activeLines.insert(line.y1);\n        }\n    }\n    \n    return intersections;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<Line> lines;\n    for (int i = 0; i < n; i++) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        lines.emplace_back(x1, y1, x2, y2);\n    }\n    \n    int intersections = countIntersections(lines);\n    cout << intersections << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 5,
            "mean_time_taken": 0.47547569274902346,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Inverse Inversions",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    int p[n];\n    for (int i = 0; i < n; i++) {\n        p[i] = i + 1;\n    }\n\n    if (k == 0) {\n        for (int i = 0; i < n; i++) {\n            cout << p[i] << \" \";\n        }\n        cout << endl;\n        return 0;\n    }\n\n    for (int i = n - 1; i >= 0 && k > 0; i--) {\n        int max_inversions = n - i - 1;\n        if (k >= max_inversions) {\n            swap(p[i], p[n - 1]);\n            k -= max_inversions;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        cout << p[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 10,
            "mean_time_taken": 0.11176490783691406,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                8,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Inversion Probability",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int r[n];\n    for (int i = 0; i < n; i++) {\n        cin >> r[i];\n    }\n\n    double expected_inversions = 0.0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int ways_greater = (r[i] - 1) * r[j];\n            int total_combinations = r[i] * r[j] * 2;\n            expected_inversions += (double)ways_greater / total_combinations;\n        }\n    }\n\n    cout << fixed << setprecision(6) << expected_inversions << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 20,
            "mean_time_taken": 0.0982101559638977,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                19
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Investigation",
            "category": "Graph Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Josephus Problem I",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    queue<int> q;\n    for (int i = 1; i <= n; i++) {\n        q.push(i);\n    }\n\n    while (!q.empty()) {\n        int removed = q.front();\n        q.pop();\n        cout << removed << \" \";\n\n        if (!q.empty()) {\n            int skipped = q.front();\n            q.pop();\n            q.push(skipped);\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 13,
            "mean_time_taken": 0.09424871664780837,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Josephus Problem II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node* next;\n    Node(int x) : val(x), next(NULL) {}\n};\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    \n    // Create the circular linked list\n    Node* head = new Node(1);\n    Node* curr = head;\n    for (int i = 2; i <= n; i++) {\n        curr->next = new Node(i);\n        curr = curr->next;\n    }\n    curr->next = head;\n    \n    // Remove children from the circle\n    curr = head;\n    while (n > 0) {\n        // Move k steps forward\n        for (int i = 0; i < k; i++) {\n            curr = curr->next;\n        }\n        \n        // Remove the current node\n        Node* temp = curr->next;\n        cout << temp->val << \" \";\n        curr->next = temp->next;\n        delete temp;\n        \n        curr = curr->next;\n        n--;\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 17,
            "mean_time_taken": 0.4331085962407729,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                9,
                11,
                13,
                14,
                15,
                16,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Josephus Queries",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int q;\n    cin >> q;\n\n    while (q--) {\n        int n, k;\n        cin >> n >> k;\n\n        int result = (2 * k) % (n + 1);\n        if (result == 0) {\n            result = n;\n        }\n\n        cout << result << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.17676317691802979,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Knight's Tour",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int N = 8;\nint board[N][N];\nvector<pair<int, int>> moves = {{2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {-2, -1}, {-1, -2}, {1, -2}, {2, -1}};\n\nbool solve(int x, int y, int moveNum) {\n    board[x][y] = moveNum;\n\n    if (moveNum == N * N)\n        return true;\n\n    for (auto move : moves) {\n        int newX = x + move.first;\n        int newY = y + move.second;\n\n        if (newX >= 0 && newX < N && newY >= 0 && newY < N && board[newX][newY] == 0) {\n            if (solve(newX, newY, moveNum + 1))\n                return true;\n            board[newX][newY] = 0;\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int startX, startY;\n    cin >> startX >> startY;\n    startX--, startY--;\n\n    if (solve(startX, startY, 1)) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++)\n                cout << board[i][j] << \" \";\n            cout << endl;\n        }\n    } else {\n        cout << \"No solution found.\" << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 23,
            "mean_time_taken": 0.9775295050247855,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Knuth Division",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    long long total_cost = 0;\n    long long current_sum = 0;\n\n    for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n\n        current_sum += x;\n        total_cost += current_sum;\n    }\n\n    cout << total_cost << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 0.09818784395853679,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Labyrinth",
            "category": "Graph Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Letter Pair Move Game",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    string s;\n    cin >> n >> s;\n\n    vector<string> moves;\n    int left_empty = -1, right_empty = -1;\n\n    // Find the positions of the two empty boxes\n    for (int i = 0; i < 2 * n; i++) {\n        if (s[i] == '.') {\n            if (left_empty == -1)\n                left_empty = i;\n            else\n                right_empty = i;\n        }\n    }\n\n    while (true) {\n        int left_b = -1, right_a = -1;\n\n        // Find the leftmost 'B' and rightmost 'A' between the empty boxes\n        for (int i = left_empty + 1; i < right_empty; i++) {\n            if (s[i] == 'B' && left_b == -1)\n                left_b = i;\n            if (s[i] == 'A')\n                right_a = i;\n        }\n\n        if (left_b != -1 && right_a != -1) {\n            // Swap 'B' with the left empty box and 'A' with the right empty box\n            swap(s[left_empty], s[left_b]);\n            swap(s[right_empty], s[right_a]);\n            moves.push_back(s);\n            left_empty = left_b;\n            right_empty = right_a;\n        } else {\n            break;\n        }\n    }\n\n    bool sorted = true;\n    for (int i = 0; i < 2 * n; i++) {\n        if (s[i] == 'B' && i < n - 1)\n            sorted = false;\n        if (s[i] == 'A' && i >= n - 1)\n            sorted = false;\n    }\n\n    if (sorted) {\n        cout << moves.size() << endl;\n        for (string move : moves)\n            cout << move << endl;\n    } else {\n        cout << \"-1\" << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 24,
            "mean_time_taken": 0.09286161263783772,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                17,
                18,
                20,
                21,
                22,
                24
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Line Segment Intersection",
            "category": "Geometry",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shot": 1
        },
        {
            "title": "List Removals",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> x(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i];\n    }\n\n    vector<int> p(n);\n    for (int i = 0; i < n; i++) {\n        cin >> p[i];\n    }\n\n    vector<int> result;\n\n    for (int i = 0; i < n; i++) {\n        int pos = p[i] - 1;\n        result.push_back(x[pos]);\n        x.erase(x.begin() + pos);\n    }\n\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 9,
            "total_test_cases": 9,
            "mean_time_taken": 0.25259987513224286,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "List of Sums",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> b;\n    for (int i = 0; i < n * (n - 1) / 2; i++) {\n        int x;\n        cin >> x;\n        b.push_back(x);\n    }\n\n    vector<int> a;\n    int minVal = *min_element(b.begin(), b.end());\n    int maxVal = *max_element(b.begin(), b.end());\n\n    int smallestA = minVal - (maxVal - minVal);\n    int largestA = maxVal - minVal;\n\n    unordered_map<int, int> freq;\n    for (int val : b) {\n        freq[val]++;\n    }\n\n    for (int i = smallestA; i <= largestA; i++) {\n        if (freq[i + smallestA] > 0) {\n            a.push_back(i);\n            freq[i + smallestA]--;\n        }\n        if (freq[i + largestA] > 0) {\n            a.push_back(i);\n            freq[i + largestA]--;\n        }\n    }\n\n    for (int val : a) {\n        cout << val << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.4762385368347168,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Longest Flight Route",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> graph(n + 1);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n    }\n\n    vector<int> dp(n + 1, 0);\n    vector<int> prev(n + 1, -1);\n    dp[1] = 1;\n\n    for (int a = 1; a <= n; a++) {\n        for (int b : graph[a]) {\n            if (dp[b] < dp[a] + 1) {\n                dp[b] = dp[a] + 1;\n                prev[b] = a;\n            }\n        }\n    }\n\n    if (dp[n] == 0) {\n        cout << \"IMPOSSIBLE\" << endl;\n    } else {\n        cout << dp[n] << endl;\n        vector<int> path;\n        int city = n;\n        while (city != -1) {\n            path.push_back(city);\n            city = prev[city];\n        }\n        for (int i = path.size() - 1; i >= 0; i--) {\n            cout << path[i] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 15,
            "total_test_cases": 24,
            "mean_time_taken": 0.1311187744140625,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                6,
                9,
                11,
                14,
                15,
                18,
                20,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Longest Palindrome",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring longestPalindrome(string s) {\n    int n = s.length();\n    int start = 0, maxLength = 1;\n\n    for (int i = 0; i < n; i++) {\n        // Odd-length palindrome\n        int left = i, right = i;\n        while (left >= 0 && right < n && s[left] == s[right]) {\n            if (right - left + 1 > maxLength) {\n                start = left;\n                maxLength = right - left + 1;\n            }\n            left--;\n            right++;\n        }\n\n        // Even-length palindrome\n        left = i;\n        right = i + 1;\n        while (left >= 0 && right < n && s[left] == s[right]) {\n            if (right - left + 1 > maxLength) {\n                start = left;\n                maxLength = right - left + 1;\n            }\n            left--;\n            right++;\n        }\n    }\n\n    return s.substr(start, maxLength);\n}\n\nint main() {\n    string s;\n    cin >> s;\n    cout << longestPalindrome(s) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 14,
            "total_test_cases": 19,
            "mean_time_taken": 0.34577827704580205,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                6,
                10,
                14,
                16,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Mail Delivery",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nvector<int> adj[MAXN];\nvector<int> circuit;\n\nvoid findEulerCircuit(int u) {\n    while (!adj[u].empty()) {\n        int v = adj[u].back();\n        adj[u].pop_back();\n        findEulerCircuit(v);\n    }\n    circuit.push_back(u);\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    bool possible = true;\n    for (int i = 1; i <= n; i++) {\n        if (adj[i].size() % 2 != 0) {\n            possible = false;\n            break;\n        }\n    }\n\n    if (!possible) {\n        cout << \"IMPOSSIBLE\" << endl;\n    } else {\n        findEulerCircuit(1);\n        reverse(circuit.begin(), circuit.end());\n        for (int i = 0; i < circuit.size(); i++) {\n            cout << circuit[i] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 16,
            "mean_time_taken": 0.16140007972717285,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Maximum Building I",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<char>> forest(n, vector<char>(m));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> forest[i][j];\n        }\n    }\n\n    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\n    int maxArea = 0;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            if (forest[i - 1][j - 1] == '.') {\n                int width = dp[i][j - 1] + 1;\n                int height = dp[i - 1][j] + 1;\n                dp[i][j] = min(width, height);\n                maxArea = max(maxArea, dp[i][j] * dp[i][j]);\n            }\n        }\n    }\n\n    cout << maxArea << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 12,
            "mean_time_taken": 0.11806869506835938,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Maximum Building II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<char>> forest(n, vector<char>(m));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> forest[i][j];\n        }\n    }\n\n    vector<vector<int>> dp(n, vector<int>(m));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            dp[i][j] = (forest[i][j] == '.');\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 1; j < m; j++) {\n            if (forest[i][j] == '.') {\n                dp[i][j] += dp[i][j-1];\n            } else {\n                dp[i][j] = 0;\n            }\n        }\n    }\n\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (forest[i][j] == '.') {\n                dp[i][j] += dp[i-1][j];\n            } else {\n                dp[i][j] = 0;\n            }\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cout << dp[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 13,
            "mean_time_taken": 0.15443629484910232,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Maximum Subarray Sum",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    long long maxSum = -1e9;\n    long long currentSum = 0;\n\n    for (int x : arr) {\n        currentSum += x;\n        maxSum = max(maxSum, currentSum);\n        currentSum = max(currentSum, 0LL);\n    }\n\n    cout << maxSum << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 15,
            "total_test_cases": 15,
            "mean_time_taken": 0.10758864084879557,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Maximum Subarray Sum II",
            "category": "Sorting and Searching",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n, a, b;\n    cin >> n >> a >> b;\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    vector<long long> prefixSum(n);\n    vector<long long> suffixSum(n);\n\n    prefixSum[0] = arr[0];\n    for (int i = 1; i < n; i++) {\n        prefixSum[i] = arr[i];\n        if (i >= b) {\n            prefixSum[i] = max(prefixSum[i], prefixSum[i - b] + arr[i]);\n        }\n        prefixSum[i] = max(prefixSum[i], prefixSum[i - 1] + arr[i]);\n    }\n\n    suffixSum[n - 1] = arr[n - 1];\n    for (int i = n - 2; i >= 0; i--) {\n        suffixSum[i] = arr[i];\n        if (i <= n - b - 1) {\n            suffixSum[i] = max(suffixSum[i], suffixSum[i + b] + arr[i]);\n        }\n        suffixSum[i] = max(suffixSum[i], suffixSum[i + 1] + arr[i]);\n    }\n\n    long long maxSum = LLONG_MIN;\n    for (int i = a - 1; i < n - a + 1; i++) {\n        maxSum = max(maxSum, prefixSum[i] + suffixSum[i + 1]);\n    }\n\n    cout << maxSum << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 23,
            "mean_time_taken": 0.11238017289534859,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                7,
                8,
                9,
                10,
                12,
                15,
                17,
                18,
                19,
                20,
                22
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Maximum Xor Subarray",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    \n    int max_xor = 0;\n    int current_xor = 0;\n    \n    for (int i = 0; i < n; i++) {\n        current_xor ^= arr[i];\n        max_xor = max(max_xor, current_xor);\n        \n        if (current_xor == 0) {\n            current_xor = 0;\n        }\n    }\n    \n    cout << max_xor << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 14,
            "mean_time_taken": 0.10733796869005476,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                6,
                10,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Meet in the Middle",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid generateSubsets(vector<int>& arr, int start, int end, int sum, vector<int>& subsets) {\n    if (start > end) {\n        subsets.push_back(sum);\n        return;\n    }\n    generateSubsets(arr, start + 1, end, sum, subsets);\n    generateSubsets(arr, start + 1, end, sum + arr[start], subsets);\n}\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    vector<int> left, right;\n    generateSubsets(arr, 0, n / 2 - 1, 0, left);\n    generateSubsets(arr, n / 2, n - 1, 0, right);\n\n    sort(right.begin(), right.end());\n\n    int ans = 0;\n    for (int i = 0; i < left.size(); i++) {\n        int complement = x - left[i];\n        ans += upper_bound(right.begin(), right.end(), complement) - lower_bound(right.begin(), right.end(), complement);\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 35,
            "total_test_cases": 40,
            "mean_time_taken": 0.6332370281219483,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                8,
                11,
                36,
                38
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Message Route",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\nvector<int> adj[MAXN];\nint parent[MAXN];\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    queue<int> q;\n    q.push(1);\n    parent[1] = -1;\n\n    while (!q.empty()) {\n        int curr = q.front();\n        q.pop();\n\n        if (curr == n) {\n            vector<int> path;\n            while (curr != -1) {\n                path.push_back(curr);\n                curr = parent[curr];\n            }\n            reverse(path.begin(), path.end());\n\n            cout << path.size() << endl;\n            for (int node : path) {\n                cout << node << \" \";\n            }\n            cout << endl;\n            return 0;\n        }\n\n        for (int next : adj[curr]) {\n            if (!parent[next]) {\n                parent[next] = curr;\n                q.push(next);\n            }\n        }\n    }\n\n    cout << \"IMPOSSIBLE\" << endl;\n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.14201205968856812,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Minimal Rotation",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<int> computeLPS(string pattern) {\n    int m = pattern.length();\n    vector<int> lps(m);\n    int len = 0;\n    int i = 1;\n\n    while (i < m) {\n        if (pattern[i] == pattern[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        } else {\n            if (len != 0) {\n                len = lps[len - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n\n    return lps;\n}\n\nstring findMinimalRotation(string s) {\n    string concatenated = s + s;\n    vector<int> lps = computeLPS(s);\n\n    int n = s.length();\n    int i = 0;\n    int j = 0;\n\n    while (i < 2 * n) {\n        if (concatenated[i] == s[j]) {\n            i++;\n            j++;\n            if (j == n) {\n                return concatenated.substr(i - n, n);\n            }\n        } else {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n\n    return s;\n}\n\nint main() {\n    string s;\n    cin >> s;\n\n    string minimalRotation = findMinimalRotation(s);\n    cout << minimalRotation << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 20,
            "mean_time_taken": 0.10216236114501953,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                9,
                10,
                12,
                14,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Minimizing Coins",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> coins(n);\n    for (int i = 0; i < n; i++) {\n        cin >> coins[i];\n    }\n\n    vector<int> dp(x + 1, x + 1);\n    dp[0] = 0;\n\n    for (int c : coins) {\n        for (int i = c; i <= x; i++) {\n            dp[i] = min(dp[i], dp[i - c] + 1);\n        }\n    }\n\n    int result = (dp[x] <= x) ? dp[x] : -1;\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 16,
            "total_test_cases": 16,
            "mean_time_taken": 0.21151146292686462,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Minimum Euclidean Distance",
            "category": "Geometry",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<int, int>> points(n);\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        points[i] = {x, y};\n    }\n\n    long long minDist = LLONG_MAX;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int dx = points[i].first - points[j].first;\n            int dy = points[i].second - points[j].second;\n            long long dist = 1LL * dx * dx + 1LL * dy * dy;\n            minDist = min(minDist, dist);\n        }\n    }\n\n    cout << minDist << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 16,
            "total_test_cases": 27,
            "mean_time_taken": 0.49043301299766257,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                4,
                9,
                10,
                12,
                17,
                19,
                20,
                22,
                23,
                24
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Missing Coin Sum",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> coins(n);\n    for (int i = 0; i < n; i++) {\n        cin >> coins[i];\n    }\n\n    sort(coins.begin(), coins.end());\n\n    long long result = 1;\n    for (int i = 0; i < n && coins[i] <= result; i++) {\n        result += coins[i];\n    }\n\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 9,
            "total_test_cases": 9,
            "mean_time_taken": 0.12142822477552626,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 28,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Missing Coin Sum Queries",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<long long> coins(n);\n    for (int i = 0; i < n; i++) {\n        cin >> coins[i];\n    }\n\n    vector<pair<int, int>> queries(q);\n    for (int i = 0; i < q; i++) {\n        cin >> queries[i].first >> queries[i].second;\n    }\n\n    sort(coins.begin(), coins.end());\n\n    vector<long long> prefix_sum(n + 1);\n    for (int i = 1; i <= n; i++) {\n        prefix_sum[i] = prefix_sum[i - 1] + coins[i - 1];\n    }\n\n    for (auto query : queries) {\n        int a = query.first;\n        int b = query.second;\n\n        long long sum = 0;\n        for (int i = a - 1; i < b; i++) {\n            if (coins[i] > sum + 1) {\n                cout << sum + 1 << endl;\n                break;\n            }\n            sum += coins[i];\n        }\n\n        if (sum == prefix_sum[b] - prefix_sum[a - 1]) {\n            cout << sum + 1 << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 8,
            "mean_time_taken": 0.2375173270702362,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 28,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Missing Number",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int sum = (n * (n + 1)) / 2;\n\n    for (int i = 0; i < n - 1; i++) {\n        int num;\n        cin >> num;\n        sum -= num;\n    }\n\n    cout << sum << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 14,
            "mean_time_taken": 0.10080363069261823,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                8,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 28,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Money Sums",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> coins(n);\n    for (int i = 0; i < n; i++) {\n        cin >> coins[i];\n    }\n\n    int maxSum = 0;\n    for (int i = 0; i < n; i++) {\n        maxSum += coins[i];\n    }\n\n    vector<bool> dp(maxSum + 1, false);\n    dp[0] = true;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = maxSum; j >= coins[i]; j--) {\n            if (dp[j - coins[i]]) {\n                dp[j] = true;\n            }\n        }\n    }\n\n    vector<int> possibleSums;\n    for (int i = 1; i <= maxSum; i++) {\n        if (dp[i]) {\n            possibleSums.push_back(i);\n        }\n    }\n\n    int distinctSums = possibleSums.size();\n    cout << distinctSums << endl;\n\n    for (int i = 0; i < distinctSums; i++) {\n        cout << possibleSums[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.1559169842646672,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 29,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Monotone Subsequences",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n\n        if (k == 1 || k == n) {\n            for (int i = 1; i <= n; i++) {\n                cout << i << \" \";\n            }\n        } else if (k == 2 && n > 2) {\n            cout << \"IMPOSSIBLE\";\n        } else {\n            for (int i = 1; i <= k - 1; i++) {\n                cout << i << \" \";\n            }\n            cout << n << \" \";\n            for (int i = k; i <= n - 1; i++) {\n                cout << i << \" \";\n            }\n        }\n\n        cout << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.10132110118865967,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 29,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Monster Game I",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> s(n + 1);\n    for (int i = 1; i <= n; i++) {\n        cin >> s[i];\n    }\n\n    vector<int> f(n + 1);\n    for (int i = 1; i <= n; i++) {\n        cin >> f[i];\n    }\n\n    vector<long long> dp(n + 1);\n    dp[n] = (long long)s[n] * f[n];\n\n    for (int i = n - 1; i >= 1; i--) {\n        dp[i] = min((long long)s[i] * f[i] + dp[i + 1], dp[i + 1]);\n    }\n\n    cout << dp[1] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 5,
            "mean_time_taken": 0.13701882362365722,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 29,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Monster Game II",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> s(n + 1);\n    vector<int> f(n + 1);\n\n    for (int i = 1; i <= n; i++) {\n        cin >> s[i];\n    }\n\n    for (int i = 1; i <= n; i++) {\n        cin >> f[i];\n    }\n\n    vector<long long> dp(n + 1);\n    dp[n] = static_cast<long long>(s[n]) * x;\n\n    for (int i = n - 1; i >= 1; i--) {\n        long long kill = static_cast<long long>(s[i]) * x + dp[i + 1];\n        long long escape = dp[i + 1];\n        dp[i] = min(kill, escape);\n        x = f[i];\n    }\n\n    cout << dp[1] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 8,
            "mean_time_taken": 0.13705173134803772,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 29,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Monsters",
            "category": "Graph Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 29,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Movie Festival",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<int, int>> movies(n);\n    for (int i = 0; i < n; i++) {\n        cin >> movies[i].first >> movies[i].second;\n    }\n\n    sort(movies.begin(), movies.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        return a.second < b.second;\n    });\n\n    int count = 0;\n    int last_end_time = 0;\n\n    for (const auto& movie : movies) {\n        if (movie.first >= last_end_time) {\n            count++;\n            last_end_time = movie.second;\n        }\n    }\n\n    cout << count << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.1344964937730269,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 30,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Movie Festival II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<pair<int, int>> movies(n);\n    for (int i = 0; i < n; i++) {\n        cin >> movies[i].first >> movies[i].second;\n    }\n\n    sort(movies.begin(), movies.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        return a.second < b.second;\n    });\n\n    priority_queue<int, vector<int>, greater<int>> pq;\n    int count = 0;\n\n    for (const auto& movie : movies) {\n        if (pq.size() < k) {\n            pq.push(movie.second);\n            count++;\n        } else if (pq.top() <= movie.first) {\n            pq.pop();\n            pq.push(movie.second);\n            count++;\n        }\n    }\n\n    cout << count << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 9,
            "total_test_cases": 13,
            "mean_time_taken": 0.1434922951918382,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                5,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 30,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Movie Festival Queries",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<pair<int, int>> movies(n);\n    for (int i = 0; i < n; i++) {\n        cin >> movies[i].second >> movies[i].first;\n    }\n\n    sort(movies.begin(), movies.end());\n\n    vector<pair<int, int>> queries(q);\n    for (int i = 0; i < q; i++) {\n        cin >> queries[i].first >> queries[i].second;\n    }\n\n    for (auto query : queries) {\n        int arrival = query.first;\n        int leaving = query.second;\n\n        auto it = lower_bound(movies.begin(), movies.end(), make_pair(arrival, 0));\n        int idx = it - movies.begin();\n\n        int maxMovies = 0;\n        for (int i = idx; i < n; i++) {\n            if (movies[i].second > leaving) {\n                break;\n            }\n            maxMovies++;\n        }\n\n        cout << maxMovies << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 5,
            "mean_time_taken": 0.6645820617675782,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 30,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Moving Robots",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\nconst int SIZE = 8;\nconst int PRECISION = 6;\n\ndouble dp[SIZE][SIZE][101];\n\nint main() {\n    int k;\n    cin >> k;\n\n    // Initialize the base case\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            dp[i][j][0] = 1.0;\n        }\n    }\n\n    // Iterate for k turns\n    for (int t = 1; t <= k; t++) {\n        for (int i = 0; i < SIZE; i++) {\n            for (int j = 0; j < SIZE; j++) {\n                dp[i][j][t] = 0.0;\n\n                // Update probabilities based on valid moves\n                if (i > 0) dp[i][j][t] += 0.25 * dp[i-1][j][t-1];\n                if (i < SIZE-1) dp[i][j][t] += 0.25 * dp[i+1][j][t-1];\n                if (j > 0) dp[i][j][t] += 0.25 * dp[i][j-1][t-1];\n                if (j < SIZE-1) dp[i][j][t] += 0.25 * dp[i][j+1][t-1];\n            }\n        }\n    }\n\n    // Calculate the expected number of empty squares\n    double p = dp[0][0][k];\n    double expected = SIZE * SIZE * pow(1 - p, SIZE * SIZE);\n\n    // Round the result to six decimal places\n    cout << fixed << setprecision(PRECISION) << expected << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 16,
            "mean_time_taken": 0.09228627383708954,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 30,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Multiplication Table",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int target = (n * n + 1) / 2; // The rank of the middle element\n    int count = 0; // Count of elements less than or equal to the current number\n    int result;\n\n    for (int i = 1; i <= n; i++) {\n        count += min(n, i); // i appears min(n, i) times in the table\n        if (count >= target) {\n            result = i;\n            break;\n        }\n    }\n\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 8,
            "mean_time_taken": 0.09554654359817505,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 30,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Nearest Smaller Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    stack<int> st;\n    vector<int> ans(n);\n\n    for (int i = 0; i < n; i++) {\n        while (!st.empty() && arr[i] < arr[st.top()]) {\n            st.pop();\n        }\n\n        if (st.empty()) {\n            ans[i] = 0;\n        } else {\n            ans[i] = st.top() + 1;\n        }\n\n        st.push(i);\n    }\n\n    for (int i = 0; i < n; i++) {\n        cout << ans[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 13,
            "mean_time_taken": 0.11626373804532565,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                8,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 30,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Necessary Cities",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nvector<int> adj[MAXN];\nbool visited[MAXN];\nint disc[MAXN], low[MAXN];\nbool isArticulation[MAXN];\nint timer;\n\nvoid dfs(int u, int parent) {\n    visited[u] = true;\n    disc[u] = low[u] = ++timer;\n    int children = 0;\n\n    for (int v : adj[u]) {\n        if (v == parent) continue;\n        if (!visited[v]) {\n            dfs(v, u);\n            low[u] = min(low[u], low[v]);\n            if (low[v] >= disc[u] && parent != -1)\n                isArticulation[u] = true;\n            ++children;\n        } else {\n            low[u] = min(low[u], disc[v]);\n        }\n    }\n\n    if (parent == -1 && children > 1)\n        isArticulation[u] = true;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    timer = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (!visited[i])\n            dfs(i, -1);\n    }\n\n    vector<int> articulationPoints;\n    for (int i = 1; i <= n; ++i) {\n        if (isArticulation[i])\n            articulationPoints.push_back(i);\n    }\n\n    cout << articulationPoints.size() << endl;\n    for (int i : articulationPoints)\n        cout << i << \" \";\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 8,
            "mean_time_taken": 0.1172390878200531,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 30,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Necessary Roads",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nvector<int> adj[MAXN];\nint disc[MAXN], low[MAXN], timer;\nvector<pair<int, int>> bridges;\n\nvoid dfs(int u, int parent) {\n    disc[u] = low[u] = ++timer;\n    for (int v : adj[u]) {\n        if (v == parent) continue;\n        if (!disc[v]) {\n            dfs(v, u);\n            low[u] = min(low[u], low[v]);\n            if (low[v] > disc[u]) {\n                bridges.push_back({u, v});\n            }\n        } else {\n            low[u] = min(low[u], disc[v]);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    \n    timer = 0;\n    for (int i = 1; i <= n; i++) {\n        if (!disc[i]) {\n            dfs(i, -1);\n        }\n    }\n    \n    cout << bridges.size() << endl;\n    for (auto bridge : bridges) {\n        cout << bridge.first << \" \" << bridge.second << endl;\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 5,
            "mean_time_taken": 0.13463692665100097,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 31,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Nested Ranges Check",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<int, int>> ranges(n);\n    vector<int> indices(n);\n\n    for (int i = 0; i < n; i++) {\n        cin >> ranges[i].first >> ranges[i].second;\n        indices[i] = i;\n    }\n\n    vector<pair<int, int>> sorted_ranges = ranges;\n    sort(sorted_ranges.begin(), sorted_ranges.end(), [](const auto& a, const auto& b) {\n        if (a.first == b.first)\n            return a.second > b.second;\n        return a.first < b.first;\n    });\n\n    vector<int> contains(n, 0);\n    int max_end = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        if (sorted_ranges[i].second >= max_end)\n            max_end = sorted_ranges[i].second;\n        else\n            contains[indices[i]] = 1;\n    }\n\n    vector<int> contained(n, 0);\n    int min_end = 1e9;\n    for (int i = 0; i < n; i++) {\n        if (sorted_ranges[i].second <= min_end)\n            min_end = sorted_ranges[i].second;\n        else\n            contained[indices[i]] = 1;\n    }\n\n    for (int i = 0; i < n; i++)\n        cout << contains[i] << \" \";\n    cout << endl;\n\n    for (int i = 0; i < n; i++)\n        cout << contained[i] << \" \";\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.1673754851023356,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 31,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Nested Ranges Count",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i];\n    }\n    \n    vector<int> contains(n, 0), contained(n, 0);\n    vector<int> order(n);\n    for (int i = 0; i < n; i++) {\n        order[i] = i;\n    }\n    \n    sort(order.begin(), order.end(), [&](int i, int j) {\n        return y[i] < y[j];\n    });\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (x[order[j]] >= x[order[i]]) {\n                contains[order[i]]++;\n                contained[order[j]]++;\n            } else {\n                break;\n            }\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        cout << contains[i] << \" \";\n    }\n    cout << endl;\n    \n    for (int i = 0; i < n; i++) {\n        cout << contained[i] << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 12,
            "mean_time_taken": 0.3860318462053935,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 31,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Network Breakdown",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass DisjointSet {\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n\npublic:\n    DisjointSet(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unionSet(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n\n    int countSets() {\n        int count = 0;\n        for (int i = 0; i < parent.size(); i++) {\n            if (parent[i] == i) {\n                count++;\n            }\n        }\n        return count;\n    }\n};\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    DisjointSet ds(n);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        ds.unionSet(a - 1, b - 1);\n    }\n\n    for (int i = 0; i < k; i++) {\n        int a, b;\n        cin >> a >> b;\n        ds.unionSet(a - 1, b - 1);\n        cout << ds.countSets() << \" \";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 13,
            "mean_time_taken": 0.529458266038161,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 31,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Network Renovation",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<vector<int>> adj(n + 1);\n    vector<int> degree(n + 1, 0);\n\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n        degree[a]++;\n        degree[b]++;\n    }\n\n    vector<pair<int, int>> new_connections;\n\n    for (int i = 1; i <= n; i++) {\n        if (degree[i] == 1) {\n            for (int j = 1; j <= n; j++) {\n                if (i != j && degree[j] < n - 1) {\n                    new_connections.emplace_back(i, j);\n                    degree[i]++;\n                    degree[j]++;\n                    break;\n                }\n            }\n        }\n    }\n\n    cout << new_connections.size() << endl;\n    for (const auto& connection : new_connections) {\n        cout << connection.first << \" \" << connection.second << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 21,
            "mean_time_taken": 0.10998621441069104,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 31,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "New Flight Routes",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    adj.resize(n + 1);\n    visited.resize(n + 1, false);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n\n    int components = 0;\n    vector<int> componentStarts;\n\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            dfs(i);\n            components++;\n            componentStarts.push_back(i);\n        }\n    }\n\n    int newFlights = components - 1;\n    cout << newFlights << endl;\n\n    for (int i = 0; i < newFlights; i++) {\n        cout << componentStarts[i] << \" \" << componentStarts[i + 1] << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 26,
            "mean_time_taken": 0.1219713779596182,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                26
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 31,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "New Roads Queries",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass DisjointSet {\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n\npublic:\n    DisjointSet(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unionSets(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n};\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n\n    DisjointSet ds(n);\n    vector<pair<int, int>> roads(m);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        roads[i] = {a - 1, b - 1};\n    }\n\n    for (int i = 0; i < q; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n\n        int day = -1;\n        for (int j = 0; j < m; j++) {\n            ds.unionSets(roads[j].first, roads[j].second);\n            if (ds.find(a) == ds.find(b)) {\n                day = j + 1;\n                break;\n            }\n        }\n\n        cout << day << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 7,
            "mean_time_taken": 0.38111444881984163,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 31,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Nim Game I",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n;\n        cin >> n;\n\n        int xorSum = 0;\n        for (int i = 0; i < n; i++) {\n            int x;\n            cin >> x;\n            xorSum ^= x;\n        }\n\n        if (xorSum != 0) {\n            cout << \"first\" << endl;\n        } else {\n            cout << \"second\" << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 4,
            "mean_time_taken": 0.11882013082504272,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Nim Game II",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n;\n        cin >> n;\n\n        int xorSum = 0;\n        for (int i = 0; i < n; i++) {\n            int x;\n            cin >> x;\n            xorSum ^= x;\n        }\n\n        if (xorSum != 0) {\n            cout << \"first\" << endl;\n        } else {\n            cout << \"second\" << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.1423601508140564,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Number Grid",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int y, x;\n    cin >> y >> x;\n\n    int value = max(x, y);\n\n    cout << value << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 20,
            "mean_time_taken": 0.09171860218048096,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                7,
                8,
                9,
                10,
                11,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Number Spiral",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        long long y, x;\n        cin >> y >> x;\n\n        long long layer = max(y, x);\n        long long topLeft = (layer % 2 == 1) ? (layer * layer) : ((layer - 1) * (layer - 1) + 1);\n\n        long long num;\n        if (layer % 2 == 1) {\n            if (y == layer)\n                num = topLeft - (layer - x);\n            else\n                num = topLeft - (layer - y) + 1;\n        } else {\n            if (x == layer)\n                num = topLeft + (layer - y);\n            else\n                num = topLeft + (layer - x) - 1;\n        }\n\n        cout << num << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.19034206867218018,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "One Bit Positions",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.length();\n    \n    vector<int> ans(n - 1, 0);\n    \n    for (int i = 0; i < n; i++) {\n        if (s[i] == '1') {\n            for (int j = i - 1; j >= 0; j--) {\n                if (s[j] == '1') {\n                    ans[i - j - 1]++;\n                }\n            }\n        }\n    }\n    \n    for (int i = 0; i < n - 1; i++) {\n        cout << ans[i] << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 5,
            "mean_time_taken": 0.852089262008667,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Palindrome Queries",
            "category": "String Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Palindrome Reorder",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    string s;\n    cin >> s;\n    int freq[26] = {0}; // Frequency count of each character\n    \n    // Count the frequency of each character\n    for (char c : s) {\n        freq[c - 'A']++;\n    }\n    \n    int oddCount = 0;\n    char oddChar;\n    for (int i = 0; i < 26; i++) {\n        if (freq[i] % 2 != 0) {\n            oddCount++;\n            oddChar = 'A' + i;\n        }\n    }\n    \n    if (oddCount > 1) {\n        cout << \"NO SOLUTION\" << endl;\n    } else {\n        string firstHalf = \"\", secondHalf = \"\";\n        for (int i = 0; i < 26; i++) {\n            if (freq[i] % 2 == 0) {\n                string half(freq[i] / 2, 'A' + i);\n                firstHalf += half;\n                secondHalf = half + secondHalf;\n            }\n        }\n        \n        if (oddCount == 1) {\n            string middle(freq[oddChar - 'A'], oddChar);\n            cout << firstHalf + middle + secondHalf << endl;\n        } else {\n            cout << firstHalf + secondHalf << endl;\n        }\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 16,
            "total_test_cases": 17,
            "mean_time_taken": 0.09939746295704562,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Parcel Delivery",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\nconst int INF = INT_MAX;\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<vector<int>> edges;\n    for (int i = 0; i < m; i++) {\n        int a, b, r, c;\n        cin >> a >> b >> r >> c;\n        edges.push_back({a - 1, b - 1, r, c});\n    }\n\n    vector<long long> dist(n, INF);\n    dist[0] = 0;\n\n    for (int i = 0; i < k; i++) {\n        vector<long long> new_dist(dist);\n        for (auto edge : edges) {\n            int a = edge[0], b = edge[1], r = edge[2], c = edge[3];\n            if (dist[a] != INF && dist[a] + c < new_dist[b] && r > 0) {\n                new_dist[b] = dist[a] + c;\n                edge[2]--;\n            }\n        }\n        dist = new_dist;\n    }\n\n    if (dist[n - 1] == INF) {\n        cout << -1 << endl;\n    } else {\n        cout << dist[n - 1] << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 13,
            "mean_time_taken": 0.09991189149709848,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Path Queries",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid dfs(int node, int parent, vector<vector<int>>& adj, vector<int>& values) {\n    for (int child : adj[node]) {\n        if (child != parent) {\n            values[child] += values[node];\n            dfs(child, node, adj, values);\n        }\n    }\n}\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> values(n + 1);\n    for (int i = 1; i <= n; i++) {\n        cin >> values[i];\n    }\n\n    vector<vector<int>> adj(n + 1);\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    dfs(1, 0, adj, values);\n\n    while (q--) {\n        int type, s, x;\n        cin >> type >> s;\n\n        if (type == 1) {\n            cin >> x;\n            int diff = x - values[s];\n            values[s] = x;\n            dfs(s, 0, adj, values);\n        } else {\n            cout << values[s] << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.4141978740692139,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Path Queries II",
            "category": "Tree Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Pattern Positions",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    string s;\n    cin >> s;\n\n    int k;\n    cin >> k;\n\n    vector<string> patterns(k);\n    for (int i = 0; i < k; i++) {\n        cin >> patterns[i];\n    }\n\n    for (const string& pattern : patterns) {\n        size_t pos = s.find(pattern);\n        if (pos != string::npos) {\n            cout << pos + 1 << endl;\n        } else {\n            cout << -1 << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 9,
            "total_test_cases": 10,
            "mean_time_taken": 0.3062418460845947,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Permutation Inversions",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countPermutations(int n, int k) {\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\n    dp[1][0] = 1;\n\n    for (int i = 2; i <= n; i++) {\n        vector<int> prefix(k + 1, 0);\n        prefix[0] = dp[i-1][0];\n        for (int j = 1; j <= k; j++) {\n            prefix[j] = (prefix[j-1] + dp[i-1][j]) % MOD;\n        }\n\n        for (int j = 0; j <= k; j++) {\n            if (j-i >= 0) {\n                dp[i][j] = (prefix[j] - prefix[j-i] + MOD) % MOD;\n            } else {\n                dp[i][j] = prefix[j];\n            }\n        }\n    }\n\n    return dp[n][k];\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    cout << countPermutations(n, k) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 16,
            "total_test_cases": 16,
            "mean_time_taken": 0.16275554895401,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 33,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Permutations",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    if (n == 1) {\n        cout << 1 << endl;\n    } else if (n < 4) {\n        cout << \"NO SOLUTION\" << endl;\n    } else {\n        for (int i = 2; i <= n; i += 2) {\n            cout << i << \" \";\n        }\n        for (int i = 1; i <= n; i += 2) {\n            cout << i << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 21,
            "total_test_cases": 21,
            "mean_time_taken": 0.10193865639822823,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 34,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Permutations II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countBeautifulPermutations(int n) {\n    vector<long long> prev(n + 1, 0), curr(n + 1, 0);\n\n    // Base case: dp(1, j) = 1 for all j\n    for (int j = 1; j <= n; j++) {\n        prev[j] = 1;\n    }\n\n    // Calculate dp(i, j) for i > 1\n    for (int i = 2; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            curr[j] = 0;\n            for (int k = 1; k <= n; k++) {\n                if (k != j - 1 && k != j + 1) {\n                    curr[j] = (curr[j] + prev[k]) % MOD;\n                }\n            }\n        }\n        prev = curr;\n    }\n\n    // Sum up dp(n, j) for all j to get the final answer\n    long long answer = 0;\n    for (int j = 1; j <= n; j++) {\n        answer = (answer + prev[j]) % MOD;\n    }\n\n    return answer;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    cout << countBeautifulPermutations(n) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 23,
            "mean_time_taken": 0.3975352722665538,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 34,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Pizzeria Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid buildTree(vector<int>& tree, vector<int>& prices, int node, int start, int end) {\n    if (start == end) {\n        tree[node] = prices[start];\n        return;\n    }\n    int mid = (start + end) / 2;\n    buildTree(tree, prices, 2 * node, start, mid);\n    buildTree(tree, prices, 2 * node + 1, mid + 1, end);\n    tree[node] = min(tree[2 * node], tree[2 * node + 1]);\n}\n\nvoid updateTree(vector<int>& tree, int node, int start, int end, int index, int value) {\n    if (start == end) {\n        tree[node] = value;\n        return;\n    }\n    int mid = (start + end) / 2;\n    if (index <= mid)\n        updateTree(tree, 2 * node, start, mid, index, value);\n    else\n        updateTree(tree, 2 * node + 1, mid + 1, end, index, value);\n    tree[node] = min(tree[2 * node], tree[2 * node + 1]);\n}\n\nint queryTree(vector<int>& tree, int node, int start, int end, int left, int right) {\n    if (left > end || right < start)\n        return INT_MAX;\n    if (left <= start && end <= right)\n        return tree[node];\n    int mid = (start + end) / 2;\n    int leftQuery = queryTree(tree, 2 * node, start, mid, left, right);\n    int rightQuery = queryTree(tree, 2 * node + 1, mid + 1, end, left, right);\n    return min(leftQuery, rightQuery);\n}\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> prices(n);\n    for (int i = 0; i < n; i++)\n        cin >> prices[i];\n\n    vector<int> tree(4 * n);\n    buildTree(tree, prices, 1, 0, n - 1);\n\n    while (q--) {\n        int type, k, x;\n        cin >> type >> k;\n        k--;\n\n        if (type == 1) {\n            cin >> x;\n            updateTree(tree, 1, 0, n - 1, k, x);\n        } else {\n            int leftMin = queryTree(tree, 1, 0, n - 1, 0, k);\n            int rightMin = queryTree(tree, 1, 0, n - 1, k, n - 1);\n            int minPrice = min(leftMin + k, rightMin + n - 1 - k);\n            cout << minPrice << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 34,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Planets Cycles",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> teleporters;\nvector<int> cycleLengths;\nvector<bool> visited;\n\nint findCycleLength(int planet) {\n    int length = 0;\n    while (!visited[planet]) {\n        visited[planet] = true;\n        planet = teleporters[planet];\n        length++;\n    }\n    return length;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    teleporters.resize(n + 1);\n    cycleLengths.resize(n + 1, 0);\n    visited.resize(n + 1, false);\n    \n    for (int i = 1; i <= n; i++) {\n        cin >> teleporters[i];\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            cycleLengths[i] = findCycleLength(i);\n        }\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        cout << cycleLengths[i] << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 14,
            "mean_time_taken": 0.11322447231837682,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 34,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Planets Queries I",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nconst int MAXK = 30;\n\nint n, q;\nvector<int> teleporter(MAXN);\nvector<vector<int>> lift(MAXN, vector<int>(MAXK));\n\nvoid precompute() {\n    for (int i = 1; i <= n; i++) {\n        lift[i][0] = teleporter[i];\n    }\n\n    for (int j = 1; j < MAXK; j++) {\n        for (int i = 1; i <= n; i++) {\n            lift[i][j] = lift[lift[i][j-1]][j-1];\n        }\n    }\n}\n\nint query(int x, int k) {\n    for (int j = MAXK - 1; j >= 0; j--) {\n        if (k & (1 << j)) {\n            x = lift[x][j];\n        }\n    }\n    return x;\n}\n\nint main() {\n    cin >> n >> q;\n\n    for (int i = 1; i <= n; i++) {\n        cin >> teleporter[i];\n    }\n\n    precompute();\n\n    while (q--) {\n        int x, k;\n        cin >> x >> k;\n        cout << query(x, k) << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.26336174744826096,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Planets Queries II",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 2e5 + 5;\nvector<int> adj[MAX];\nint component[MAX];\n\nvoid dfs(int u, int comp) {\n    component[u] = comp;\n    for (int v : adj[u]) {\n        if (component[v] == 0) {\n            dfs(v, comp);\n        }\n    }\n}\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    for (int i = 1; i <= n; i++) {\n        int t;\n        cin >> t;\n        adj[i].push_back(t);\n    }\n\n    int comp = 0;\n    for (int i = 1; i <= n; i++) {\n        if (component[i] == 0) {\n            comp++;\n            dfs(i, comp);\n        }\n    }\n\n    while (q--) {\n        int a, b;\n        cin >> a >> b;\n\n        if (component[a] != component[b]) {\n            cout << \"-1\\n\";\n        } else {\n            int dist = 0;\n            while (a != b) {\n                a = adj[a][0];\n                dist++;\n            }\n            cout << dist << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 15,
            "mean_time_taken": 0.4199368476867676,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                8,
                9,
                10,
                11,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Planets and Kingdoms",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nvector<int> adj[MAXN], adj_rev[MAXN];\nbool visited[MAXN];\nint kingdom[MAXN];\nstack<int> st;\n\nvoid dfs1(int u) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v])\n            dfs1(v);\n    }\n    st.push(u);\n}\n\nvoid dfs2(int u, int k) {\n    visited[u] = true;\n    kingdom[u] = k;\n    for (int v : adj_rev[u]) {\n        if (!visited[v])\n            dfs2(v, k);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj_rev[b].push_back(a);\n    }\n\n    memset(visited, false, sizeof(visited));\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i])\n            dfs1(i);\n    }\n\n    memset(visited, false, sizeof(visited));\n    int k = 0;\n    while (!st.empty()) {\n        int u = st.top();\n        st.pop();\n        if (!visited[u]) {\n            k++;\n            dfs2(u, k);\n        }\n    }\n\n    cout << k << endl;\n    for (int i = 1; i <= n; i++)\n        cout << kingdom[i] << \" \";\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.15347743034362793,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 36,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Playlist",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <unordered_set>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int playlist[n];\n    for (int i = 0; i < n; i++) {\n        cin >> playlist[i];\n    }\n\n    unordered_set<int> unique_songs;\n    int left = 0, right = 0;\n    int max_length = 0;\n\n    while (right < n) {\n        if (unique_songs.find(playlist[right]) == unique_songs.end()) {\n            unique_songs.insert(playlist[right]);\n            max_length = max(max_length, (int)unique_songs.size());\n            right++;\n        } else {\n            unique_songs.erase(playlist[left]);\n            left++;\n        }\n    }\n\n    cout << max_length << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 19,
            "total_test_cases": 20,
            "mean_time_taken": 0.18253302574157715,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                1
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 36,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Point Location Test",
            "category": "Geometry",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int x1, y1, x2, y2, x3, y3;\n        cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\n        long long cross_product = (long long)(x2 - x1) * (y3 - y1) - (long long)(y2 - y1) * (x3 - x1);\n\n        if (cross_product > 0) {\n            cout << \"LEFT\" << endl;\n        } else if (cross_product < 0) {\n            cout << \"RIGHT\" << endl;\n        } else {\n            cout << \"TOUCH\" << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 6,
            "mean_time_taken": 0.16984530289967856,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 37,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Point in Polygon",
            "category": "Geometry",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int, int> Point;\n\nbool onSegment(Point p, Point q, Point r) {\n    if (q.first <= max(p.first, r.first) && q.first >= min(p.first, r.first) &&\n        q.second <= max(p.second, r.second) && q.second >= min(p.second, r.second))\n        return true;\n    return false;\n}\n\nstring pointInPolygon(Point p, vector<Point>& polygon) {\n    int n = polygon.size();\n    bool onEdge = false;\n    int count = 0;\n\n    for (int i = 0; i < n; i++) {\n        Point q = polygon[i];\n        Point r = polygon[(i + 1) % n];\n\n        if (onSegment(q, p, r))\n            return \"BOUNDARY\";\n\n        int x = q.first, y = q.second;\n        int u = r.first, v = r.second;\n\n        if (((y > p.second) != (v > p.second)) &&\n            (p.first < (u - x) * (p.second - y) / (v - y) + x))\n            count++;\n    }\n\n    return (count % 2 == 1) ? \"INSIDE\" : \"OUTSIDE\";\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<Point> polygon(n);\n    for (int i = 0; i < n; i++)\n        cin >> polygon[i].first >> polygon[i].second;\n\n    vector<Point> points(m);\n    for (int i = 0; i < m; i++)\n        cin >> points[i].first >> points[i].second;\n\n    for (int i = 0; i < m; i++)\n        cout << pointInPolygon(points[i], polygon) << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 8,
            "mean_time_taken": 0.09166255593299866,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 37,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Police Chase",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nconst int INF = INT_MAX;\n\nstruct Edge {\n    int u, v;\n};\n\nvector<vector<int>> adj;\nvector<Edge> edges;\n\nint bfs(int s, int t, vector<int>& parent) {\n    fill(parent.begin(), parent.end(), -1);\n    parent[s] = -2;\n    queue<pair<int, int>> q;\n    q.push({s, INF});\n\n    while (!q.empty()) {\n        int u = q.front().first;\n        int flow = q.front().second;\n        q.pop();\n\n        for (int v : adj[u]) {\n            if (parent[v] == -1) {\n                parent[v] = u;\n                int new_flow = min(flow, 1);\n                if (v == t)\n                    return new_flow;\n                q.push({v, new_flow});\n            }\n        }\n    }\n\n    return 0;\n}\n\nint maxFlow(int s, int t) {\n    int flow = 0;\n    vector<int> parent(adj.size());\n    int new_flow;\n\n    while ((new_flow = bfs(s, t, parent))) {\n        flow += new_flow;\n        int cur = t;\n        while (cur != s) {\n            int prev = parent[cur];\n            adj[prev].erase(find(adj[prev].begin(), adj[prev].end(), cur));\n            adj[cur].push_back(prev);\n            cur = prev;\n        }\n    }\n\n    return flow;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    adj.resize(n + 1);\n    edges.resize(m);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n        edges[i] = {a, b};\n    }\n\n    int min_cut = maxFlow(1, n);\n\n    cout << min_cut << endl;\n    for (Edge e : edges) {\n        if (find(adj[e.u].begin(), adj[e.u].end(), e.v) == adj[e.u].end())\n            cout << e.u << \" \" << e.v << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 37,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Polygon Area",
            "category": "Geometry",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> x(n);\n    vector<int> y(n);\n\n    for (int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i];\n    }\n\n    long long area = 0;\n\n    for (int i = 0; i < n - 1; i++) {\n        area += (long long)x[i] * y[i+1] - (long long)x[i+1] * y[i];\n    }\n\n    area += (long long)x[n-1] * y[0] - (long long)x[0] * y[n-1];\n\n    area = abs(area);\n\n    cout << area << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 5,
            "mean_time_taken": 0.09428281784057617,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 38,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Polygon Lattice Points",
            "category": "Geometry",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<int, int>> vertices(n);\n    for (int i = 0; i < n; i++) {\n        cin >> vertices[i].first >> vertices[i].second;\n    }\n\n    int boundary_points = 0;\n    for (int i = 0; i < n; i++) {\n        int x1 = vertices[i].first;\n        int y1 = vertices[i].second;\n        int x2 = vertices[(i + 1) % n].first;\n        int y2 = vertices[(i + 1) % n].second;\n\n        boundary_points += gcd(abs(x2 - x1), abs(y2 - y1)) - 1;\n    }\n\n    double area = 0;\n    for (int i = 0; i < n; i++) {\n        int x1 = vertices[i].first;\n        int y1 = vertices[i].second;\n        int x2 = vertices[(i + 1) % n].first;\n        int y2 = vertices[(i + 1) % n].second;\n\n        area += (x1 * y2 - x2 * y1);\n    }\n    area = abs(area) / 2;\n\n    int interior_points = area - boundary_points / 2 + 1;\n\n    cout << interior_points << \" \" << boundary_points << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 5,
            "mean_time_taken": 0.08964948654174805,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 38,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Polynomial Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<long long> arr(n + 1);\n    for (int i = 1; i <= n; i++) {\n        cin >> arr[i];\n    }\n\n    vector<long long> prefixSum(n + 2);\n    for (int i = 1; i <= n; i++) {\n        prefixSum[i] = prefixSum[i - 1] + arr[i];\n    }\n\n    while (q--) {\n        int type, a, b;\n        cin >> type >> a >> b;\n\n        if (type == 1) {\n            arr[a] += 1;\n            arr[b + 1] -= (b - a + 1);\n        } else {\n            long long sum = prefixSum[b] - prefixSum[a - 1];\n            cout << sum << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 0.19611787796020508,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 38,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Prefix Sum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<long long> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    vector<long long> prefixSum(n + 1, 0);\n    for (int i = 1; i <= n; i++) {\n        prefixSum[i] = prefixSum[i - 1] + arr[i - 1];\n    }\n\n    while (q--) {\n        int type;\n        cin >> type;\n\n        if (type == 1) {\n            int k, u;\n            cin >> k >> u;\n            long long diff = u - arr[k - 1];\n            arr[k - 1] = u;\n            for (int i = k; i <= n; i++) {\n                prefixSum[i] += diff;\n            }\n        } else {\n            int a, b;\n            cin >> a >> b;\n            long long maxPrefixSum = prefixSum[b] - prefixSum[a - 1];\n            cout << maxPrefixSum << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.2752366860707601,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 38,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Prime Multiples",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nlong long countDivisibleIntegers(long long n, const vector<int>& primes) {\n    long long result = 0;\n    int k = primes.size();\n\n    for (int mask = 1; mask < (1 << k); mask++) {\n        long long prod = 1;\n        int subsetSize = 0;\n\n        for (int i = 0; i < k; i++) {\n            if (mask & (1 << i)) {\n                prod *= primes[i];\n                subsetSize++;\n            }\n        }\n\n        long long count = n / prod;\n\n        if (subsetSize % 2 == 1) {\n            result += count;\n        } else {\n            result -= count;\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    long long n;\n    int k;\n    cin >> n >> k;\n\n    vector<int> primes(k);\n    for (int i = 0; i < k; i++) {\n        cin >> primes[i];\n    }\n\n    long long result = countDivisibleIntegers(n, primes);\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 5,
            "mean_time_taken": 0.12350916862487793,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 38,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Programmers and Artists",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int a, b, n;\n    cin >> a >> b >> n;\n\n    vector<int> programmers;\n    vector<int> artists;\n\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        programmers.push_back(x);\n        artists.push_back(y);\n    }\n\n    sort(programmers.rbegin(), programmers.rend());\n    sort(artists.rbegin(), artists.rend());\n\n    long long sum = 0;\n\n    for (int i = 0; i < a; i++) {\n        sum += programmers[i];\n    }\n\n    for (int i = 0; i < b; i++) {\n        sum += artists[i];\n    }\n\n    cout << sum << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 11,
            "mean_time_taken": 0.15605024857954544,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 38,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Projects",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<tuple<int, int, int>> projects;\n    for (int i = 0; i < n; i++) {\n        int a, b, p;\n        cin >> a >> b >> p;\n        projects.emplace_back(b, a, p);\n    }\n    \n    sort(projects.begin(), projects.end());\n    \n    vector<int> dp(n);\n    for (int i = 0; i < n; i++) {\n        auto [endDay, startDay, reward] = projects[i];\n        \n        int prevProject = -1;\n        for (int j = i - 1; j >= 0; j--) {\n            if (get<0>(projects[j]) < startDay) {\n                prevProject = j;\n                break;\n            }\n        }\n        \n        if (prevProject != -1) {\n            dp[i] = max(dp[i], dp[prevProject] + reward);\n        } else {\n            dp[i] = max(dp[i], reward);\n        }\n        \n        if (i > 0) {\n            dp[i] = max(dp[i], dp[i - 1]);\n        }\n    }\n    \n    cout << dp[n - 1] << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 14,
            "mean_time_taken": 0.2726023367473057,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                5,
                6,
                8,
                10,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 38,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Pr\u00fcfer Code",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> pruferCode(n - 2);\n    for (int i = 0; i < n - 2; i++) {\n        cin >> pruferCode[i];\n    }\n\n    vector<int> degree(n + 1, 1);\n    for (int i = 0; i < n - 2; i++) {\n        degree[pruferCode[i]]++;\n    }\n\n    set<int> leaves;\n    for (int i = 1; i <= n; i++) {\n        if (degree[i] == 1) {\n            leaves.insert(i);\n        }\n    }\n\n    vector<pair<int, int>> edges;\n    for (int i = 0; i < n - 2; i++) {\n        int x = pruferCode[i];\n        int y = *leaves.begin();\n        edges.push_back({x, y});\n        degree[x]--;\n        degree[y]--;\n        if (degree[x] == 1) {\n            leaves.insert(x);\n        }\n        leaves.erase(y);\n    }\n\n    int last_leaf = *leaves.begin();\n    int other_leaf = *leaves.rbegin();\n    edges.push_back({last_leaf, other_leaf});\n\n    for (auto edge : edges) {\n        cout << edge.first << \" \" << edge.second << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.1897358244115656,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 39,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Pyramid Array",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long count_inversions(vector<int>& arr, int start, int end) {\n    long long inversions = 0;\n    for (int i = start; i < end; i++) {\n        for (int j = i + 1; j <= end; j++) {\n            if (arr[i] > arr[j]) {\n                inversions++;\n            }\n        }\n    }\n    return inversions;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    int max_pos = max_element(arr.begin(), arr.end()) - arr.begin();\n    long long inversions_left = count_inversions(arr, 0, max_pos - 1);\n    long long inversions_right = count_inversions(arr, max_pos + 1, n - 1);\n\n    cout << inversions_left + inversions_right << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 39,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Range Queries and Copies",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<vector<int>> arrays(1, vector<int>(n));\n    for (int i = 0; i < n; i++) {\n        cin >> arrays[0][i];\n    }\n\n    while (q--) {\n        int type, k, a, b, x;\n        cin >> type >> k;\n        k--;\n\n        if (type == 1) {\n            cin >> a >> x;\n            a--;\n            arrays[k][a] = x;\n        } else if (type == 2) {\n            cin >> a >> b;\n            a--, b--;\n            long long sum = 0;\n            for (int i = a; i <= b; i++) {\n                sum += arrays[k][i];\n            }\n            cout << sum << endl;\n        } else {\n            arrays.push_back(arrays[k]);\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 7,
            "mean_time_taken": 0.24425159181867326,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n"
            ],
            "failed_test_cases": [
                2,
                4,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 39,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Range Update Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    vector<long long> diff(n + 1, 0);\n\n    while (q--) {\n        int type;\n        cin >> type;\n\n        if (type == 1) {\n            int a, b, u;\n            cin >> a >> b >> u;\n            diff[a - 1] += u;\n            diff[b] -= u;\n        } else {\n            int k;\n            cin >> k;\n            long long result = 0;\n            for (int i = 0; i < k; i++) {\n                result += arr[i] + diff[i];\n            }\n            cout << result << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 0.46262343724568683,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 39,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Range Updates and Sums",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    vector<long long> diff(n + 1, 0);\n\n    while (q--) {\n        int type, a, b;\n        cin >> type >> a >> b;\n        a--, b--;\n\n        if (type == 1) {\n            long long x;\n            cin >> x;\n            diff[a] += x;\n            diff[b + 1] -= x;\n        } else if (type == 2) {\n            long long x;\n            cin >> x;\n            diff[a] += x - arr[a];\n            diff[b + 1] -= x - arr[b];\n            for (int i = a; i <= b; i++) {\n                arr[i] = x;\n            }\n        } else {\n            long long sum = 0;\n            for (int i = 0; i <= b; i++) {\n                sum += diff[i];\n            }\n            for (int i = a; i <= b; i++) {\n                sum += arr[i];\n            }\n            cout << sum << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 4,
            "mean_time_taken": 0.5917872786521912,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 39,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Range Xor Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> x(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i];\n    }\n\n    vector<int> prefix_xor(n + 1);\n    prefix_xor[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        prefix_xor[i] = prefix_xor[i - 1] ^ x[i - 1];\n    }\n\n    while (q--) {\n        int a, b;\n        cin >> a >> b;\n\n        int xor_sum = prefix_xor[b] ^ prefix_xor[a - 1];\n        cout << xor_sum << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 2,
            "mean_time_taken": 0.18066978454589844,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Reachability Queries",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 5e4 + 5;\nvector<int> adj[MAXN];\nbool visited[MAXN];\n\nvoid dfs(int node) {\n    visited[node] = true;\n    for (int neighbor : adj[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor);\n        }\n    }\n}\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n\n    // Process edges and populate adjacency list\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n\n    // Process queries\n    for (int i = 0; i < q; i++) {\n        int a, b;\n        cin >> a >> b;\n\n        // Reset visited array\n        fill(visited, visited + n + 1, false);\n\n        // Perform DFS traversal starting from node a\n        dfs(a);\n\n        // Check if node b is reachable\n        if (visited[b]) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 7,
            "mean_time_taken": 0.7704739230019706,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Reachable Nodes",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 5e4 + 5;\nvector<int> adj[MAXN];\nbool visited[MAXN];\n\nvoid dfs(int node, int& count) {\n    visited[node] = true;\n    count++;\n    for (int neighbor : adj[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, count);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n\n    vector<int> reachable(n + 1);\n    for (int i = 1; i <= n; i++) {\n        memset(visited, false, sizeof(visited));\n        int count = 0;\n        dfs(i, count);\n        reachable[i] = count;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        cout << reachable[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 4,
            "mean_time_taken": 0.6770809888839722,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Reading Books",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> books(n);\n    for (int i = 0; i < n; i++) {\n        cin >> books[i];\n    }\n\n    sort(books.begin(), books.end());\n\n    long long time_kotivalo = 0;\n    long long time_justiina = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (time_kotivalo <= time_justiina) {\n            time_kotivalo += books[i];\n        } else {\n            time_justiina += books[i];\n        }\n    }\n\n    cout << max(time_kotivalo, time_justiina) << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 13,
            "mean_time_taken": 0.10464119911193848,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Rectangle Cutting",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> memo;\n\nint dp(int a, int b) {\n    if (a == b) {\n        return 0;\n    }\n    \n    if (memo[a][b] != -1) {\n        return memo[a][b];\n    }\n    \n    int result = INT_MAX;\n    \n    for (int i = 1; i < a; i++) {\n        result = min(result, 1 + dp(i, b) + dp(a - i, b));\n    }\n    \n    for (int i = 1; i < b; i++) {\n        result = min(result, 1 + dp(a, i) + dp(a, b - i));\n    }\n    \n    memo[a][b] = result;\n    return result;\n}\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n    \n    memo.assign(a + 1, vector<int>(b + 1, -1));\n    \n    cout << dp(a, b) << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Removal Game",
            "category": "Dynamic Programming",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> x(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i];\n    }\n    \n    vector<vector<int>> dp(n, vector<int>(n));\n    \n    // Base cases\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = x[i];\n    }\n    \n    // Fill the dp array\n    for (int len = 2; len <= n; len++) {\n        for (int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            int score1 = x[i] + min(dp[i+2][j], dp[i+1][j-1]);\n            int score2 = x[j] + min(dp[i+1][j-1], dp[i][j-2]);\n            dp[i][j] = max(score1, score2);\n        }\n    }\n    \n    // Maximum score for the first player\n    cout << dp[0][n-1] << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 14,
            "mean_time_taken": 0.1596348966870989,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Removing Digits",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    int steps = 0;\n    while (n > 0) {\n        int maxDigit = 0;\n        int temp = n;\n        while (temp > 0) {\n            maxDigit = max(maxDigit, temp % 10);\n            temp /= 10;\n        }\n        \n        n -= maxDigit;\n        steps++;\n    }\n    \n    cout << steps << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.08990997927529472,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 41,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Removing Digits II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint findMaxDigit(long long n) {\n    int maxDigit = 0;\n    while (n > 0) {\n        int digit = n % 10;\n        maxDigit = max(maxDigit, digit);\n        n /= 10;\n    }\n    return maxDigit;\n}\n\nint main() {\n    long long n;\n    cin >> n;\n\n    int steps = 0;\n    while (n > 0) {\n        int maxDigit = findMaxDigit(n);\n        n -= maxDigit;\n        steps++;\n    }\n\n    cout << steps << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 9,
            "mean_time_taken": 0.5494092570410835,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                5,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 41,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Repeating Substring",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> buildSuffixArray(const string& s) {\n    int n = s.length();\n    vector<int> suffixArray(n);\n    vector<pair<char, int>> suffixes(n);\n\n    for (int i = 0; i < n; i++) {\n        suffixes[i] = {s[i], i};\n    }\n\n    sort(suffixes.begin(), suffixes.end());\n\n    for (int i = 0; i < n; i++) {\n        suffixArray[i] = suffixes[i].second;\n    }\n\n    return suffixArray;\n}\n\nvector<int> buildLCPArray(const string& s, const vector<int>& suffixArray) {\n    int n = s.length();\n    vector<int> lcpArray(n - 1);\n    vector<int> inverseSuffixArray(n);\n\n    for (int i = 0; i < n; i++) {\n        inverseSuffixArray[suffixArray[i]] = i;\n    }\n\n    int len = 0;\n    for (int i = 0; i < n; i++) {\n        if (inverseSuffixArray[i] == n - 1) {\n            len = 0;\n            continue;\n        }\n\n        int j = suffixArray[inverseSuffixArray[i] + 1];\n        while (i + len < n && j + len < n && s[i + len] == s[j + len]) {\n            len++;\n        }\n\n        lcpArray[inverseSuffixArray[i]] = len;\n        if (len > 0) {\n            len--;\n        }\n    }\n\n    return lcpArray;\n}\n\nstring findLongestRepeatingSubstring(const string& s) {\n    vector<int> suffixArray = buildSuffixArray(s);\n    vector<int> lcpArray = buildLCPArray(s, suffixArray);\n\n    int maxLen = 0;\n    int maxIndex = -1;\n\n    for (int i = 0; i < lcpArray.size(); i++) {\n        if (lcpArray[i] > maxLen) {\n            maxLen = lcpArray[i];\n            maxIndex = i;\n        }\n    }\n\n    if (maxLen == 0) {\n        return \"-1\";\n    }\n\n    return s.substr(suffixArray[maxIndex], maxLen);\n}\n\nint main() {\n    string s;\n    cin >> s;\n\n    string longestRepeatingSubstring = findLongestRepeatingSubstring(s);\n    cout << longestRepeatingSubstring << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 8,
            "mean_time_taken": 0.11383575201034546,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 41,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Repetitions",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.length();\n    \n    int maxLen = 1;\n    int currentLen = 1;\n    \n    for (int i = 1; i < n; i++) {\n        if (s[i] == s[i - 1]) {\n            currentLen++;\n        } else {\n            maxLen = max(maxLen, currentLen);\n            currentLen = 1;\n        }\n    }\n    \n    maxLen = max(maxLen, currentLen);\n    \n    cout << maxLen << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.09833312034606934,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Required Substring",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n;\n    string pattern;\n    cin >> n >> pattern;\n\n    int m = pattern.length();\n\n    if (n < m) {\n        cout << 0 << endl;\n    } else if (n == m) {\n        cout << 1 << endl;\n    } else {\n        long long count = 0;\n\n        // Pattern at the beginning or end\n        count += 2 * pow(26, n - m);\n        count %= MOD;\n\n        // Pattern in the middle\n        count += (n - m - 1) * pow(26, n - m - 1);\n        count %= MOD;\n\n        cout << count << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Restaurant Customers",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<int, int>> events;\n    for (int i = 0; i < n; i++) {\n        int arrival, leaving;\n        cin >> arrival >> leaving;\n        events.push_back({arrival, 1});\n        events.push_back({leaving, -1});\n    }\n\n    sort(events.begin(), events.end());\n\n    int max_customers = 0;\n    int current_customers = 0;\n    int i = 0, j = 0;\n\n    while (i < events.size()) {\n        if (i < n && events[i].second == 1) {\n            current_customers++;\n            max_customers = max(max_customers, current_customers);\n            i++;\n        } else {\n            current_customers--;\n            j++;\n        }\n    }\n\n    cout << max_customers << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 1.0407371520996094,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Reversal Sorting",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> x(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i];\n    }\n\n    vector<pair<int, int>> reversals;\n\n    for (int j = 0; j < n; j++) {\n        int min_index = min_element(x.begin() + j, x.end()) - x.begin();\n        if (min_index != j) {\n            reverse(x.begin() + j, x.begin() + min_index + 1);\n            reversals.push_back({j, min_index});\n        }\n    }\n\n    cout << reversals.size() << endl;\n    for (auto reversal : reversals) {\n        cout << reversal.first + 1 << \" \" << reversal.second + 1 << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 12,
            "mean_time_taken": 0.406447172164917,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                5,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Reversals and Sums",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<long long> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    vector<long long> prefixSum(n + 1);\n    prefixSum[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        prefixSum[i] = prefixSum[i - 1] + arr[i - 1];\n    }\n\n    for (int i = 0; i < m; i++) {\n        int t, a, b;\n        cin >> t >> a >> b;\n\n        if (t == 1) {\n            reverse(arr.begin() + a - 1, arr.begin() + b);\n            for (int j = a; j <= n; j++) {\n                prefixSum[j] = prefixSum[j - 1] + arr[j - 1];\n            }\n        } else if (t == 2) {\n            cout << prefixSum[b] - prefixSum[a - 1] << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 4,
            "mean_time_taken": 0.5674172043800354,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Road Construction",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass DSU {\nprivate:\n    vector<int> parent;\n    vector<int> size;\n\npublic:\n    DSU(int n) {\n        parent.resize(n);\n        size.resize(n, 1);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (size[rootX] < size[rootY]) {\n                swap(rootX, rootY);\n            }\n            parent[rootY] = rootX;\n            size[rootX] += size[rootY];\n        }\n    }\n\n    int getSize(int x) {\n        return size[find(x)];\n    }\n\n    int getNumComponents() {\n        int count = 0;\n        for (int i = 0; i < parent.size(); i++) {\n            if (parent[i] == i) {\n                count++;\n            }\n        }\n        return count;\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    DSU dsu(n);\n    int maxSize = 1;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n\n        if (dsu.find(a) != dsu.find(b)) {\n            dsu.unite(a, b);\n            maxSize = max(maxSize, dsu.getSize(a));\n        }\n\n        int numComponents = dsu.getNumComponents();\n        cout << numComponents << \" \" << maxSize << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 8,
            "mean_time_taken": 0.5636033117771149,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Road Reparation",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Edge {\n    int u, v, weight;\n    Edge(int u, int v, int weight) : u(u), v(v), weight(weight) {}\n};\n\nclass DisjointSet {\nprivate:\n    vector<int> parent, rank;\n\npublic:\n    DisjointSet(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unionSet(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<Edge> edges;\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        edges.emplace_back(a - 1, b - 1, c);\n    }\n\n    sort(edges.begin(), edges.end(), [](const Edge& a, const Edge& b) {\n        return a.weight < b.weight;\n    });\n\n    DisjointSet ds(n);\n    int totalCost = 0;\n    int edgesUsed = 0;\n\n    for (const Edge& edge : edges) {\n        if (ds.find(edge.u) != ds.find(edge.v)) {\n            ds.unionSet(edge.u, edge.v);\n            totalCost += edge.weight;\n            edgesUsed++;\n        }\n    }\n\n    if (edgesUsed == n - 1) {\n        cout << totalCost << endl;\n    } else {\n        cout << \"IMPOSSIBLE\" << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 9,
            "total_test_cases": 16,
            "mean_time_taken": 0.14500881731510162,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                5,
                6,
                7,
                9,
                11,
                13,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Robot Path",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <set>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    set<pair<int, int>> visited;\n    int x = 0, y = 0;\n    visited.insert({x, y});\n\n    int total_distance = 0;\n\n    for (int i = 0; i < n; i++) {\n        char d;\n        int distance;\n        cin >> d >> distance;\n\n        int dx = 0, dy = 0;\n        if (d == 'U')\n            dy = distance;\n        else if (d == 'D')\n            dy = -distance;\n        else if (d == 'L')\n            dx = -distance;\n        else if (d == 'R')\n            dx = distance;\n\n        while (distance--) {\n            x += dx;\n            y += dy;\n\n            if (visited.count({x, y})) {\n                break;\n            }\n\n            visited.insert({x, y});\n            total_distance++;\n        }\n\n        if (visited.count({x, y})) {\n            break;\n        }\n    }\n\n    cout << total_distance << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 35,
            "mean_time_taken": 0.1529130186353411,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                33,
                34,
                35
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Room Allocation",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<int, int>> customers(n);\n    for (int i = 0; i < n; i++) {\n        cin >> customers[i].first >> customers[i].second;\n    }\n\n    sort(customers.begin(), customers.end());\n\n    priority_queue<int, vector<int>, greater<int>> pq;\n    int rooms = 0;\n    vector<int> roomAllocation(n);\n\n    for (int i = 0; i < n; i++) {\n        if (pq.empty() || customers[i].first < pq.top()) {\n            rooms++;\n            pq.push(customers[i].second);\n            roomAllocation[i] = rooms;\n        } else {\n            pq.pop();\n            pq.push(customers[i].second);\n            roomAllocation[i] = pq.size();\n        }\n    }\n\n    cout << rooms << endl;\n    for (int i = 0; i < n; i++) {\n        cout << roomAllocation[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 12,
            "mean_time_taken": 0.18977381785710654,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Round Trip",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nvector<int> adj[MAXN];\nbool visited[MAXN];\nint parent[MAXN];\n\nvoid dfs(int u, int p, vector<int>& path, bool& found) {\n    visited[u] = true;\n    parent[u] = p;\n    path.push_back(u);\n\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v, u, path, found);\n            if (found) return;\n        } else if (v != p) {\n            found = true;\n            path.push_back(v);\n            return;\n        }\n    }\n\n    path.pop_back();\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            vector<int> path;\n            bool found = false;\n            dfs(i, -1, path, found);\n            if (found) {\n                cout << path.size() << endl;\n                for (int j = 0; j < path.size(); j++) {\n                    cout << path[j] << \" \";\n                }\n                cout << endl;\n                return 0;\n            }\n        }\n    }\n\n    cout << \"IMPOSSIBLE\" << endl;\n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 26,
            "mean_time_taken": 0.12108216835902287,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Round Trip II",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> adj[100005];\nbool visited[100005];\nvector<int> path;\n\nbool dfs(int u, int p) {\n    visited[u] = true;\n    path.push_back(u);\n\n    for (int v : adj[u]) {\n        if (v == p) continue;\n        if (visited[v]) {\n            path.push_back(v);\n            return true;\n        }\n        if (dfs(v, u)) return true;\n    }\n\n    path.pop_back();\n    return false;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i] && dfs(i, -1)) {\n            cout << path.size() << endl;\n            for (int j = 0; j < path.size(); j++) {\n                cout << path[j] << \" \";\n            }\n            cout << endl;\n            return 0;\n        }\n    }\n\n    cout << \"IMPOSSIBLE\" << endl;\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 20,
            "mean_time_taken": 0.11945834159851074,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Salary Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\nusing namespace std;\n\nclass BST {\nprivate:\n    struct Node {\n        int salary;\n        int count;\n        Node* left;\n        Node* right;\n\n        Node(int x) : salary(x), count(1), left(nullptr), right(nullptr) {}\n    };\n\n    Node* root;\n\n    void insertHelper(Node*& node, int salary) {\n        if (node == nullptr) {\n            node = new Node(salary);\n        } else if (salary < node->salary) {\n            insertHelper(node->left, salary);\n        } else if (salary > node->salary) {\n            insertHelper(node->right, salary);\n        } else {\n            node->count++;\n        }\n    }\n\n    void updateHelper(Node*& node, int oldSalary, int newSalary) {\n        if (node == nullptr) {\n            return;\n        }\n        if (oldSalary == node->salary) {\n            if (--node->count == 0) {\n                deleteNode(node);\n            }\n            insertHelper(root, newSalary);\n        } else if (oldSalary < node->salary) {\n            updateHelper(node->left, oldSalary, newSalary);\n        } else {\n            updateHelper(node->right, oldSalary, newSalary);\n        }\n    }\n\n    void deleteNode(Node*& node) {\n        if (node->left == nullptr) {\n            Node* temp = node;\n            node = node->right;\n            delete temp;\n        } else if (node->right == nullptr) {\n            Node* temp = node;\n            node = node->left;\n            delete temp;\n        } else {\n            Node* successor = node->right;\n            while (successor->left != nullptr) {\n                successor = successor->left;\n            }\n            node->salary = successor->salary;\n            node->count = successor->count;\n            successor->count = 0;\n            updateHelper(node->right, successor->salary, successor->salary);\n        }\n    }\n\n    int countHelper(Node* node, int min, int max) {\n        if (node == nullptr) {\n            return 0;\n        }\n        if (node->salary >= min && node->salary <= max) {\n            return node->count + countHelper(node->left, min, max) + countHelper(node->right, min, max);\n        } else if (node->salary < min) {\n            return countHelper(node->right, min, max);\n        } else {\n            return countHelper(node->left, min, max);\n        }\n    }\n\npublic:\n    BST() : root(nullptr) {}\n\n    void insert(int salary) {\n        insertHelper(root, salary);\n    }\n\n    void update(int oldSalary, int newSalary) {\n        updateHelper(root, oldSalary, newSalary);\n    }\n\n    int count(int min, int max) {\n        return countHelper(root, min, max);\n    }\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    BST bst;\n    for (int i = 0; i < n; i++) {\n        int salary;\n        cin >> salary;\n        bst.insert(salary);\n    }\n\n    while (q--) {\n        char queryType;\n        int a, b;\n        cin >> queryType >> a >> b;\n\n        if (queryType == '!') {\n            bst.update(a, b);\n        } else {\n            cout << bst.count(a, b) << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 13,
            "mean_time_taken": 0.4801618502690242,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                5,
                6,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "School Dance",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nconst int INF = INT_MAX;\n\nbool bfs(vector<vector<int>>& adj, vector<int>& parent, int s, int t) {\n    int n = adj.size();\n    vector<bool> visited(n, false);\n    queue<int> q;\n    q.push(s);\n    visited[s] = true;\n    parent[s] = -1;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        for (int v : adj[u]) {\n            if (!visited[v] && adj[u][v] > 0) {\n                q.push(v);\n                parent[v] = u;\n                visited[v] = true;\n            }\n        }\n    }\n\n    return visited[t];\n}\n\nint fordFulkerson(vector<vector<int>>& adj, int s, int t) {\n    int n = adj.size();\n    vector<vector<int>> residual(n, vector<int>(n, 0));\n    for (int u = 0; u < n; u++) {\n        for (int v : adj[u]) {\n            residual[u][v] = 1;\n        }\n    }\n\n    vector<int> parent(n);\n    int maxFlow = 0;\n\n    while (bfs(residual, parent, s, t)) {\n        int pathFlow = INF;\n        for (int v = t; v != s; v = parent[v]) {\n            int u = parent[v];\n            pathFlow = min(pathFlow, residual[u][v]);\n        }\n\n        for (int v = t; v != s; v = parent[v]) {\n            int u = parent[v];\n            residual[u][v] -= pathFlow;\n            residual[v][u] += pathFlow;\n        }\n\n        maxFlow += pathFlow;\n    }\n\n    return maxFlow;\n}\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<pair<int, int>> pairs(k);\n    for (int i = 0; i < k; i++) {\n        cin >> pairs[i].first >> pairs[i].second;\n    }\n\n    int s = 0, t = n + m + 1;\n    vector<vector<int>> adj(n + m + 2);\n\n    for (int i = 0; i < k; i++) {\n        int a = pairs[i].first;\n        int b = pairs[i].second;\n        adj[a].push_back(n + b);\n    }\n\n    for (int i = 1; i <= n; i++) {\n        adj[s].push_back(i);\n    }\n\n    for (int i = 1; i <= m; i++) {\n        adj[n + i].push_back(t);\n    }\n\n    int maxPairs = fordFulkerson(adj, s, t);\n\n    cout << maxPairs << endl;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j : adj[i]) {\n            if (j >= n + 1 && j <= n + m && adj[i][j - n] == 0) {\n                cout << i << \" \" << j - n << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.09002919197082519,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "School Excursion",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> adj[100005];\nbool visited[100005];\nint componentSize;\n\nvoid dfs(int node) {\n    visited[node] = true;\n    componentSize++;\n    for (int neighbor : adj[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    vector<int> componentSizes;\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            componentSize = 0;\n            dfs(i);\n            componentSizes.push_back(componentSize);\n        }\n    }\n\n    string output(n + 1, '0');\n    int numComponents = componentSizes.size();\n    int maxMask = 1 << numComponents;\n\n    for (int mask = 0; mask < maxMask; mask++) {\n        int totalSize = 0;\n        for (int i = 0; i < numComponents; i++) {\n            if (mask & (1 << i)) {\n                totalSize += componentSizes[i];\n            }\n        }\n        output[totalSize] = '1';\n    }\n\n    cout << output.substr(1) << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 13,
            "mean_time_taken": 0.3239550773914044,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                10,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Shortest Routes I",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<pair<int, int>>> adj(n + 1);\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        adj[a].push_back({b, c});\n    }\n\n    vector<int> dist(n + 1, INF);\n    dist[1] = 0;\n\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    pq.push({0, 1});\n\n    while (!pq.empty()) {\n        int d = pq.top().first;\n        int u = pq.top().second;\n        pq.pop();\n\n        if (d > dist[u]) continue;\n\n        for (auto [v, w] : adj[u]) {\n            if (dist[u] + w < dist[v]) {\n                dist[v] = dist[u] + w;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        cout << dist[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 15,
            "total_test_cases": 23,
            "mean_time_taken": 0.18401943082394806,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                8,
                10,
                14,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Shortest Routes II",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n\n    vector<vector<int>> dist(n, vector<int>(n, INF));\n\n    for (int i = 0; i < n; i++) {\n        dist[i][i] = 0;\n    }\n\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--; b--;\n        dist[a][b] = dist[b][a] = c;\n    }\n\n    // Floyd-Warshall algorithm\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n            }\n        }\n    }\n\n    while (q--) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        if (dist[a][b] == INF) {\n            cout << \"-1\\n\";\n        } else {\n            cout << dist[a][b] << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 15,
            "mean_time_taken": 0.6621642112731934,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                9,
                11,
                13,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Shortest Subsequence",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    string sequence;\n    cin >> sequence;\n\n    string result = \"\";\n\n    for (char c : sequence) {\n        if (c != 'A') {\n            result = \"A\";\n            break;\n        }\n    }\n\n    if (result.empty()) {\n        result = \"AA\";\n    }\n\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.09421994686126708,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Signal Processing",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> signal(n);\n    for (int i = 0; i < n; i++) {\n        cin >> signal[i];\n    }\n\n    vector<int> mask(m);\n    for (int i = 0; i < m; i++) {\n        cin >> mask[i];\n    }\n\n    vector<int> result(n + m - 1, 0);\n\n    for (int i = 0; i < n + m - 1; i++) {\n        int sum = 0;\n        for (int j = 0; j <= min(i, m - 1); j++) {\n            if (i - j < n) {\n                sum += signal[i - j] * mask[j];\n            }\n        }\n        result[i] = sum;\n    }\n\n    for (int i = 0; i < n + m - 1; i++) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.725972056388855,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sliding Window Cost",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    vector<long long> costs;\n\n    for (int i = 0; i <= n - k; i++) {\n        int minVal = *min_element(arr.begin() + i, arr.begin() + i + k);\n        int maxVal = *max_element(arr.begin() + i, arr.begin() + i + k);\n\n        long long costMin = 0, costMax = 0;\n        for (int j = i; j < i + k; j++) {\n            costMin += arr[j] - minVal;\n            costMax += maxVal - arr[j];\n        }\n\n        costs.push_back(min(costMin, costMax));\n    }\n\n    for (long long cost : costs) {\n        cout << cost << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 18,
            "total_test_cases": 34,
            "mean_time_taken": 0.26860807923709645,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                4,
                5,
                8,
                11,
                12,
                14,
                15,
                16,
                17,
                18,
                20,
                25,
                29,
                31,
                32
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sliding Window Median",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    \n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    \n    multiset<int> left, right;\n    \n    for (int i = 0; i < k; i++) {\n        left.insert(arr[i]);\n    }\n    \n    for (int i = 0; i < k / 2; i++) {\n        right.insert(*left.rbegin());\n        left.erase(prev(left.end()));\n    }\n    \n    cout << *left.rbegin() << \" \";\n    \n    for (int i = k; i < n; i++) {\n        if (left.find(arr[i - k]) != left.end()) {\n            left.erase(left.find(arr[i - k]));\n        } else {\n            right.erase(right.find(arr[i - k]));\n        }\n        \n        if (arr[i] <= *left.rbegin()) {\n            left.insert(arr[i]);\n        } else {\n            right.insert(arr[i]);\n        }\n        \n        while (left.size() < right.size()) {\n            left.insert(*right.begin());\n            right.erase(right.begin());\n        }\n        \n        while (left.size() > right.size() + 1) {\n            right.insert(*left.rbegin());\n            left.erase(prev(left.end()));\n        }\n        \n        cout << *left.rbegin() << \" \";\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 27,
            "total_test_cases": 40,
            "mean_time_taken": 0.16262646317481994,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                7,
                8,
                10,
                15,
                17,
                26,
                27,
                29,
                33,
                36,
                40
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sorting Methods",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint countInversions(vector<int>& arr) {\n    int n = arr.size();\n    int inversions = 0;\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (arr[i] > arr[j]) {\n                inversions++;\n            }\n        }\n    }\n    return inversions;\n}\n\nint countSwaps(vector<int>& arr) {\n    int n = arr.size();\n    vector<int> sorted_arr = arr;\n    sort(sorted_arr.begin(), sorted_arr.end());\n    int swaps = 0;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] != sorted_arr[i]) {\n            swaps++;\n        }\n    }\n    return swaps;\n}\n\nint longestIncreasingSubsequence(vector<int>& arr) {\n    int n = arr.size();\n    vector<int> dp(n, 1);\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (arr[i] > arr[j]) {\n                dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n    }\n    return *max_element(dp.begin(), dp.end());\n}\n\nint longestNonDecreasingSubsequence(vector<int>& arr) {\n    int n = arr.size();\n    vector<int> dp(n, 1);\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (arr[i] >= arr[j]) {\n                dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n    }\n    return *max_element(dp.begin(), dp.end());\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    int method1 = countInversions(arr);\n    int method2 = countSwaps(arr);\n    int method3 = n - longestIncreasingSubsequence(arr);\n    int method4 = n - longestNonDecreasingSubsequence(arr);\n\n    cout << method1 << \" \" << method2 << \" \" << method3 << \" \" << method4 << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 10,
            "mean_time_taken": 0.5666526317596435,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Special Substrings",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nint countSpecialSubstrings(string s) {\n    int n = s.length();\n    int count = 0;\n    unordered_map<char, int> freq;\n\n    int left = 0, right = 0;\n    while (right < n) {\n        freq[s[right]]++;\n\n        while (left < right && !all_of(freq.begin(), freq.end(), [&](const auto& p) {\n            return p.second == 0 || p.second == freq.begin()->second;\n        })) {\n            freq[s[left]]--;\n            left++;\n        }\n\n        count++;\n        right++;\n    }\n\n    return count;\n}\n\nint main() {\n    string s;\n    cin >> s;\n\n    int result = countSpecialSubstrings(s);\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 8,
            "mean_time_taken": 0.1551501452922821,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Stack Weights",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int left = 0, right = 0;\n\n    for (int i = 0; i < n; i++) {\n        int c, s;\n        cin >> c >> s;\n\n        if (s == 1) {\n            left = max(left, c);\n        } else {\n            right = max(right, c);\n        }\n\n        if (left > right) {\n            cout << \">\" << endl;\n        } else if (right > left) {\n            cout << \"<\" << endl;\n        } else {\n            cout << \"?\" << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 5,
            "mean_time_taken": 0.22021164894104003,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Stair Game",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n;\n        cin >> n;\n\n        long long total_moves = 0;\n        for (int i = 0; i < n; i++) {\n            int balls;\n            cin >> balls;\n            if (i != 0) {\n                total_moves += balls;\n            }\n        }\n\n        if (total_moves % 2 == 0) {\n            cout << \"second\" << endl;\n        } else {\n            cout << \"first\" << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 7,
            "mean_time_taken": 0.11271844591413226,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Static Range Minimum Queries",
            "category": "Range Queries",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    int log_n = log2(n) + 1;\n    vector<vector<int>> st(log_n, vector<int>(n));\n\n    for (int i = 0; i < n; i++) {\n        st[0][i] = arr[i];\n    }\n\n    for (int i = 1; i < log_n; i++) {\n        for (int j = 0; j < n - (1 << i) + 1; j++) {\n            st[i][j] = min(st[i-1][j], st[i-1][j + (1 << (i-1))]);\n        }\n    }\n\n    while (q--) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n\n        int k = log2(b - a + 1);\n        int min_val = st[0][a];\n\n        for (int i = k; i >= 0; i--) {\n            if ((b - a + 1) & (1 << i)) {\n                min_val = min(min_val, st[i][b - (1 << i) + 1]);\n                b -= (1 << i);\n            }\n        }\n\n        cout << min_val << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 4,
            "mean_time_taken": 0.18819177150726318,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Static Range Sum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<long long> x(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i];\n    }\n\n    // Precompute the prefix sums\n    vector<long long> prefix_sum(n + 1);\n    prefix_sum[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        prefix_sum[i] = prefix_sum[i - 1] + x[i - 1];\n    }\n\n    // Process the queries\n    while (q--) {\n        int a, b;\n        cin >> a >> b;\n\n        // Calculate the sum of values in the range [a, b]\n        long long sum = prefix_sum[b] - prefix_sum[a - 1];\n\n        cout << sum << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 2,
            "mean_time_taken": 0.18450868129730225,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 44,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Stick Divisions",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int x, n;\n    cin >> x >> n;\n\n    vector<int> d(n);\n    for (int i = 0; i < n; i++) {\n        cin >> d[i];\n    }\n\n    sort(d.begin(), d.end());\n\n    long long cost = 0;\n    long long curr_length = 0;\n\n    for (int i = 0; i < n; i++) {\n        curr_length += d[i];\n        if (i == n - 1 || curr_length != d[i + 1]) {\n            cost += curr_length;\n            curr_length = 0;\n        }\n    }\n\n    cout << cost << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.12521628538767496,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 44,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Stick Game",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstring stickGame(int n, vector<int>& moves) {\n    vector<bool> dp(n + 1, false);\n\n    for (int i = 1; i <= n; i++) {\n        for (int p : moves) {\n            if (i - p >= 0 && !dp[i - p]) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n\n    string result;\n    for (int i = 1; i <= n; i++) {\n        result += dp[i] ? 'W' : 'L';\n    }\n\n    return result;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> moves(k);\n    for (int i = 0; i < k; i++) {\n        cin >> moves[i];\n    }\n\n    string result = stickGame(n, moves);\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 6,
            "mean_time_taken": 0.33071593443552655,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 44,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Stick Lengths",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<int> sticks(n);\n    for (int i = 0; i < n; i++) {\n        cin >> sticks[i];\n    }\n    \n    sort(sticks.begin(), sticks.end());\n    \n    int targetLength = sticks[n / 2];\n    \n    long long totalCost = 0;\n    for (int i = 0; i < n; i++) {\n        totalCost += abs(sticks[i] - targetLength);\n    }\n    \n    cout << totalCost << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.1102965311570601,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 45,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "String Functions",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    string S;\n    cin >> S;\n    int n = S.length();\n\n    vector<int> z(n), pi(n);\n    z[0] = 0;\n    pi[0] = 0;\n\n    // Compute z function\n    int L = 0, R = 0;\n    for (int i = 1; i < n; i++) {\n        if (i > R) {\n            L = R = i;\n            while (R < n && S[R-L] == S[R]) R++;\n            z[i] = R-L;\n            R--;\n        } else {\n            int k = i-L;\n            if (z[k] < R-i+1) z[i] = z[k];\n            else {\n                L = i;\n                while (R < n && S[R-L] == S[R]) R++;\n                z[i] = R-L;\n                R--;\n            }\n        }\n    }\n\n    // Compute \u03c0 function\n    int len = 0;\n    for (int i = 1; i < n; i++) {\n        while (len > 0 && S[i] != S[len]) len = pi[len-1];\n        if (S[i] == S[len]) len++;\n        pi[i] = len;\n    }\n\n    // Print z function values\n    for (int i = 0; i < n; i++) {\n        cout << z[i] << \" \";\n    }\n    cout << endl;\n\n    // Print \u03c0 function values\n    for (int i = 0; i < n; i++) {\n        cout << pi[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 5,
            "mean_time_taken": 0.21019973754882812,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 46,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "String Matching",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    string str, pattern;\n    cin >> str >> pattern;\n\n    int n = str.length();\n    int m = pattern.length();\n    int count = 0;\n\n    for (int i = 0; i <= n - m; i++) {\n        bool match = true;\n        for (int j = 0; j < m; j++) {\n            if (str[i + j] != pattern[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            count++;\n        }\n    }\n\n    cout << count << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 33,
            "total_test_cases": 37,
            "mean_time_taken": 0.19421872577151736,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                16,
                23,
                26,
                36
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 46,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "String Removals",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countUniqueStrings(string s) {\n    int n = s.length();\n    vector<int> freq(26, 0);\n    for (char c : s) {\n        freq[c - 'a']++;\n    }\n\n    int result = 0;\n    for (int mask = 1; mask < (1 << 26); mask++) {\n        int cnt = 1;\n        int bits = 0;\n        for (int i = 0; i < 26; i++) {\n            if (mask & (1 << i)) {\n                cnt = (1LL * cnt * (freq[i] + 1)) % MOD;\n                bits++;\n            }\n        }\n        if (bits % 2 == 1) {\n            result = (result + cnt) % MOD;\n        } else {\n            result = (result - cnt + MOD) % MOD;\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    cout << countUniqueStrings(s) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 7,
            "mean_time_taken": 1.040135315486363,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 46,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "String Reorder",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <queue>\n#include <unordered_map>\n\nusing namespace std;\n\nstring reorderString(string s) {\n    int n = s.length();\n    unordered_map<char, int> charCount;\n    \n    // Count the frequency of each character\n    for (char c : s) {\n        charCount[c]++;\n    }\n    \n    // Check if it's possible to reorder the string\n    for (auto it : charCount) {\n        if (it.second > (n + 1) / 2) {\n            return \"-1\";\n        }\n    }\n    \n    // Create a priority queue to store characters and their frequencies\n    priority_queue<pair<int, char>> pq;\n    for (auto it : charCount) {\n        pq.push({it.second, it.first});\n    }\n    \n    string result = \"\";\n    pair<int, char> prev = {0, '#'};\n    \n    while (!pq.empty()) {\n        auto curr = pq.top();\n        pq.pop();\n        \n        result += curr.second;\n        curr.first--;\n        \n        if (prev.first > 0) {\n            pq.push(prev);\n        }\n        \n        prev = curr;\n    }\n    \n    return result;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    \n    string reorderedString = reorderString(s);\n    cout << reorderedString << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 15,
            "mean_time_taken": 0.1938453992207845,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8,
                13,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 46,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "String Transform",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring transformBack(string transformed) {\n    int n = transformed.length() - 1;\n    int pos = transformed.find('#');\n    \n    string rotated = transformed.substr(pos + 1) + transformed.substr(0, pos);\n    \n    return rotated;\n}\n\nint main() {\n    string transformed;\n    cin >> transformed;\n    \n    string original = transformBack(transformed);\n    cout << original << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 6,
            "mean_time_taken": 0.1030418872833252,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 46,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Strongly Connected Edges",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\nvector<pair<int, int>> edges;\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            edges.push_back({u, v});\n            dfs(v);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    adj.resize(n + 1);\n    visited.resize(n + 1, false);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    dfs(1);\n\n    if (edges.size() != m) {\n        cout << \"IMPOSSIBLE\" << endl;\n    } else {\n        for (auto edge : edges) {\n            cout << edge.first << \" \" << edge.second << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 11,
            "mean_time_taken": 0.12325217507102272,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                6,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 46,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Distinct Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nint countSubarrays(int arr[], int n, int k) {\n    unordered_map<int, int> freq;\n    int count = 0;\n    int left = 0;\n\n    for (int right = 0; right < n; right++) {\n        freq[arr[right]]++;\n\n        while (freq.size() > k) {\n            freq[arr[left]]--;\n            if (freq[arr[left]] == 0) {\n                freq.erase(arr[left]);\n            }\n            left++;\n        }\n\n        count += right - left + 1;\n    }\n\n    return count;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    int arr[n];\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    int result = countSubarrays(arr, n, k);\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 10,
            "mean_time_taken": 0.1541595458984375,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                5,
                6,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 46,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Divisibility",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint countSubarrays(vector<int>& arr, int n) {\n    int count = 0;\n    vector<int> prefixSum(n);\n    unordered_map<int, int> remainderCount;\n\n    prefixSum[0] = arr[0];\n    for (int i = 1; i < n; i++) {\n        prefixSum[i] = prefixSum[i - 1] + arr[i];\n    }\n\n    for (int i = 0; i < n; i++) {\n        int remainder = (prefixSum[i] % n + n) % n;\n        if (remainder == 0) {\n            count++;\n        }\n        count += remainderCount[remainder];\n        remainderCount[remainder]++;\n    }\n\n    return count;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    int result = countSubarrays(arr, n);\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 10,
            "mean_time_taken": 0.11160180568695069,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 46,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Squares",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    vector<long long> prefixSum(n + 1, 0);\n    for (int i = 1; i <= n; i++) {\n        prefixSum[i] = prefixSum[i - 1] + arr[i - 1];\n    }\n\n    vector<vector<long long>> dp(n + 1, vector<long long>(k + 1, 1e18));\n    dp[0][0] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= min(i, k); j++) {\n            for (int p = j - 1; p < i; p++) {\n                long long subarraySum = prefixSum[i] - prefixSum[p];\n                dp[i][j] = min(dp[i][j], dp[p][j - 1] + subarraySum * subarraySum);\n            }\n        }\n    }\n\n    cout << dp[n][k] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 11,
            "mean_time_taken": 0.6542618274688721,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 46,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Sum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> arr(n + 1);\n    for (int i = 1; i <= n; i++) {\n        cin >> arr[i];\n    }\n\n    long long maxSum = 0, currentSum = 0;\n    for (int i = 1; i <= n; i++) {\n        currentSum = max(0LL, currentSum + arr[i]);\n        maxSum = max(maxSum, currentSum);\n    }\n    cout << maxSum << endl;\n\n    while (m--) {\n        int k, x;\n        cin >> k >> x;\n        arr[k] = x;\n\n        maxSum = 0, currentSum = 0;\n        for (int i = 1; i <= n; i++) {\n            currentSum = max(0LL, currentSum + arr[i]);\n            maxSum = max(maxSum, currentSum);\n        }\n        cout << maxSum << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.4718109766642253,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 46,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Sums I",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    int arr[n];\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    int count = 0;\n    int sum = 0;\n    int left = 0;\n\n    for (int right = 0; right < n; right++) {\n        sum += arr[right];\n\n        while (sum > x) {\n            sum -= arr[left];\n            left++;\n        }\n\n        if (sum == x) {\n            count++;\n            sum -= arr[left];\n            left++;\n        }\n    }\n\n    cout << count << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.1035111943880717,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 47,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Subarray Sums II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nint countSubarrays(int arr[], int n, int x) {\n    unordered_map<int, int> sum_map;\n    int count = 0;\n    int curr_sum = 0;\n    sum_map[0] = 1;\n\n    for (int i = 0; i < n; i++) {\n        curr_sum += arr[i];\n        if (sum_map.find(curr_sum - x) != sum_map.end()) {\n            count += sum_map[curr_sum - x];\n        }\n        sum_map[curr_sum]++;\n    }\n\n    return count;\n}\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n    int arr[n];\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    cout << countSubarrays(arr, n, x) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 24,
            "total_test_cases": 27,
            "mean_time_taken": 0.14507780251679597,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                21,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 47,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subordinates",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> subordinates;\n\nvoid dfs(int employee, const vector<int>& boss) {\n    for (int i = 2; i < boss.size(); i++) {\n        if (boss[i] == employee) {\n            dfs(i, boss);\n            subordinates[employee] += subordinates[i] + 1;\n        }\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> boss(n + 1);\n    for (int i = 2; i <= n; i++) {\n        cin >> boss[i];\n    }\n\n    subordinates.resize(n + 1);\n\n    for (int i = 2; i <= n; i++) {\n        subordinates[boss[i]]++;\n    }\n\n    dfs(1, boss);\n\n    for (int i = 1; i <= n; i++) {\n        cout << subordinates[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.48708266019821167,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 47,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Substring Distribution",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <unordered_set>\n\nusing namespace std;\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.length();\n\n    for (int len = 1; len <= n; len++) {\n        unordered_set<string> distinctSubstrings;\n\n        for (int i = 0; i <= n - len; i++) {\n            string substring = s.substr(i, len);\n            distinctSubstrings.insert(substring);\n        }\n\n        cout << distinctSubstrings.size() << \" \";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 9,
            "mean_time_taken": 0.8305340872870551,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 47,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Substring Order I",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <set>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstring kthSmallestSubstring(string s, int k) {\n    int n = s.length();\n    set<string> substrings;\n\n    // Generate all substrings and insert them into the set\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            substrings.insert(s.substr(i, j - i + 1));\n        }\n    }\n\n    // Convert the set to a vector\n    vector<string> substringVector(substrings.begin(), substrings.end());\n\n    // Sort the vector lexicographically\n    sort(substringVector.begin(), substringVector.end());\n\n    // Return the substring at index k-1\n    return substringVector[k - 1];\n}\n\nint main() {\n    string s;\n    int k;\n    cin >> s >> k;\n\n    string kthSmallest = kthSmallestSubstring(s, k);\n    cout << kthSmallest << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 9,
            "mean_time_taken": 0.4597889052497016,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 47,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Substring Order II",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstring kthSubstring(const string& s, int k) {\n    int n = s.length();\n    vector<string> substrings;\n\n    // Generate all substrings\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            substrings.push_back(s.substr(i, j - i + 1));\n        }\n    }\n\n    // Sort the substrings lexicographically\n    sort(substrings.begin(), substrings.end());\n\n    // Return the kth smallest substring\n    return substrings[k - 1];\n}\n\nint main() {\n    string s;\n    int k;\n\n    cin >> s;\n    cin >> k;\n\n    string result = kthSubstring(s, k);\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 9,
            "mean_time_taken": 0.30030462476942277,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 47,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Substring Reversals",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    string s;\n    cin >> s;\n\n    vector<char> str(s.begin(), s.end());\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n\n        reverse(str.begin() + a, str.begin() + b + 1);\n    }\n\n    string finalStr(str.begin(), str.end());\n    cout << finalStr << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 4,
            "mean_time_taken": 0.5676685571670532,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 47,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subtree Queries",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<long long> values;\nvector<vector<int>> adj;\nvector<long long> subtree_sum;\n\nlong long dfs(int node, int parent) {\n    subtree_sum[node] = values[node];\n    for (int neighbor : adj[node]) {\n        if (neighbor != parent) {\n            subtree_sum[node] += dfs(neighbor, node);\n        }\n    }\n    return subtree_sum[node];\n}\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    values.resize(n + 1);\n    adj.resize(n + 1);\n    subtree_sum.resize(n + 1);\n\n    for (int i = 1; i <= n; i++) {\n        cin >> values[i];\n    }\n\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    dfs(1, -1);\n\n    while (q--) {\n        int type, s;\n        cin >> type >> s;\n        if (type == 1) {\n            long long x;\n            cin >> x;\n            values[s] = x;\n            dfs(1, -1);\n        } else {\n            cout << subtree_sum[s] << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 13,
            "mean_time_taken": 0.36981674341055065,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                8,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 47,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sum of Divisors",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long sumOfDivisors(long long n) {\n    long long sum = 0;\n    for (long long i = 1; i * i <= n; i++) {\n        if (n % i == 0) {\n            sum = (sum + i) % MOD;\n            if (i != n / i) {\n                sum = (sum + n / i) % MOD;\n            }\n        }\n    }\n    return sum;\n}\n\nint main() {\n    long long n;\n    cin >> n;\n\n    long long totalSum = 0;\n    for (long long i = 1; i <= n; i++) {\n        totalSum = (totalSum + sumOfDivisors(i)) % MOD;\n    }\n\n    cout << totalSum << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 11,
            "total_test_cases": 18,
            "mean_time_taken": 0.6225072145462036,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                8,
                12,
                14,
                16,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 47,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sum of Four Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<pair<int, int>> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i].first;\n        a[i].second = i + 1;\n    }\n\n    sort(a.begin(), a.end());\n\n    for (int i = 0; i < n - 3; i++) {\n        for (int j = i + 1; j < n - 2; j++) {\n            int remaining_sum = x - a[i].first - a[j].first;\n            int left = j + 1, right = n - 1;\n\n            while (left < right) {\n                int current_sum = a[left].first + a[right].first;\n\n                if (current_sum == remaining_sum) {\n                    cout << a[i].second << \" \" << a[j].second << \" \"\n                         << a[left].second << \" \" << a[right].second << endl;\n                    return 0;\n                }\n                else if (current_sum < remaining_sum)\n                    left++;\n                else\n                    right--;\n            }\n        }\n    }\n\n    cout << \"IMPOSSIBLE\" << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 28,
            "mean_time_taken": 0.24594357184001378,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                7,
                9,
                11,
                12,
                15,
                16,
                18,
                20,
                21,
                22,
                26,
                27,
                28
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 47,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sum of Three Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    vector<pair<int, int>> indexed_a(n);\n    for (int i = 0; i < n; i++) {\n        indexed_a[i] = {a[i], i};\n    }\n\n    sort(indexed_a.begin(), indexed_a.end());\n\n    for (int i = 0; i < n - 2; i++) {\n        int left = i + 1;\n        int right = n - 1;\n\n        while (left < right) {\n            int sum = indexed_a[i].first + indexed_a[left].first + indexed_a[right].first;\n\n            if (sum == x) {\n                cout << indexed_a[i].second + 1 << \" \"\n                     << indexed_a[left].second + 1 << \" \"\n                     << indexed_a[right].second + 1 << endl;\n                return 0;\n            } else if (sum < x) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n\n    cout << \"IMPOSSIBLE\" << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 27,
            "total_test_cases": 27,
            "mean_time_taken": 0.11536199958236129,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 48,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Sum of Two Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    unordered_map<int, int> complementMap;\n\n    for (int i = 1; i <= n; i++) {\n        int a;\n        cin >> a;\n\n        int complement = x - a;\n        if (complementMap.count(complement) > 0) {\n            cout << complementMap[complement] << \" \" << i << endl;\n            return 0;\n        }\n\n        complementMap[a] = i;\n    }\n\n    cout << \"IMPOSSIBLE\" << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 18,
            "total_test_cases": 27,
            "mean_time_taken": 0.17878916528489855,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                9,
                10,
                11,
                21,
                22,
                24,
                25
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 48,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Swap Game",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    vector<int> grid(9);\n    for (int i = 0; i < 9; i++) {\n        cin >> grid[i];\n    }\n\n    int total_swaps = 0;\n    for (int i = 0; i < 9; i++) {\n        int num = grid[i];\n        int target_pos = num - 1;\n        int current_row = i / 3;\n        int current_col = i % 3;\n        int target_row = target_pos / 3;\n        int target_col = target_pos % 3;\n        total_swaps += abs(current_row - target_row) + abs(current_col - target_col);\n    }\n\n    cout << total_swaps / 2 << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 19,
            "mean_time_taken": 0.088704598577399,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                4,
                6,
                9,
                10,
                11,
                13,
                14,
                15,
                16,
                17,
                18,
                19
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 48,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Swap Round Sorting",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    \n    vector<int> pos(n + 1);\n    for (int i = 0; i < n; i++) {\n        pos[a[i]] = i;\n    }\n    \n    vector<pair<int, int>> swaps;\n    int rounds = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        if (pos[i] != i - 1) {\n            int j = pos[i];\n            while (j != i - 1) {\n                swaps.emplace_back(pos[i], j);\n                swap(pos[a[pos[i]]], pos[a[j]]);\n                swap(a[pos[i]], a[j]);\n                j = pos[i];\n            }\n            rounds++;\n        }\n    }\n    \n    cout << rounds << endl;\n    for (int i = 0; i < swaps.size(); i++) {\n        if (i == 0 || swaps[i].first != swaps[i - 1].first) {\n            cout << swaps.size() - i << endl;\n        }\n        cout << swaps[i].first + 1 << \" \" << swaps[i].second + 1 << endl;\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 15,
            "mean_time_taken": 0.7935505867004394,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                6,
                7,
                9,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 48,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Task Assignment",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <limits>\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\n\nvoid hungarian(vector<vector<int>>& cost, vector<int>& assignment) {\n    int n = cost.size();\n    vector<int> u(n, 0), v(n, 0);\n    vector<int> p(n, -1), way(n, -1);\n\n    for (int i = 0; i < n; ++i) {\n        p[0] = i;\n        int j0 = 0;\n        vector<int> minv(n, INF);\n        vector<bool> used(n, false);\n        do {\n            used[j0] = true;\n            int i0 = p[j0], delta = INF, j1;\n            for (int j = 0; j < n; ++j) {\n                if (!used[j]) {\n                    int cur = cost[i0][j] - u[i0] - v[j];\n                    if (cur < minv[j]) {\n                        minv[j] = cur;\n                        way[j] = j0;\n                    }\n                    if (minv[j] < delta) {\n                        delta = minv[j];\n                        j1 = j;\n                    }\n                }\n            }\n            for (int j = 0; j < n; ++j) {\n                if (used[j]) {\n                    u[p[j]] += delta;\n                    v[j] -= delta;\n                } else {\n                    minv[j] -= delta;\n                }\n            }\n            j0 = j1;\n        } while (p[j0] != -1);\n        do {\n            int j1 = way[j0];\n            p[j0] = p[j1];\n            j0 = j1;\n        } while (j0 != 0);\n    }\n\n    for (int j = 0; j < n; ++j) {\n        assignment[p[j]] = j;\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> cost(n, vector<int>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> cost[i][j];\n        }\n    }\n\n    vector<int> assignment(n);\n    hungarian(cost, assignment);\n\n    int total_cost = 0;\n    for (int i = 0; i < n; ++i) {\n        total_cost += cost[i][assignment[i]];\n    }\n    cout << total_cost << endl;\n    for (int i = 0; i < n; ++i) {\n        cout << i + 1 << \" \" << assignment[i] + 1 << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 1.040749231974284,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 48,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tasks and Deadlines",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<int, int>> tasks(n);\n    for (int i = 0; i < n; i++) {\n        cin >> tasks[i].first >> tasks[i].second;\n    }\n\n    // Sort tasks based on duration in ascending order\n    sort(tasks.begin(), tasks.end());\n\n    long long reward = 0;\n    long long finish_time = 0;\n\n    for (int i = 0; i < n; i++) {\n        finish_time += tasks[i].first;\n        reward += tasks[i].second - finish_time;\n    }\n\n    cout << reward << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 6,
            "mean_time_taken": 0.14711574713389078,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 49,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Teleporters Path",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<int> in_degree, out_degree;\nvector<int> path;\n\nvoid dfs(int u) {\n    while (out_degree[u] > 0) {\n        int v = adj[u][--out_degree[u]];\n        dfs(v);\n    }\n    path.push_back(u);\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    adj.resize(n + 1);\n    in_degree.assign(n + 1, 0);\n    out_degree.assign(n + 1, 0);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        out_degree[a]++;\n        in_degree[b]++;\n    }\n\n    if (out_degree[1] - in_degree[1] != 1 || in_degree[n] - out_degree[n] != 1) {\n        cout << \"IMPOSSIBLE\" << endl;\n        return 0;\n    }\n\n    for (int i = 2; i < n; i++) {\n        if (in_degree[i] != out_degree[i]) {\n            cout << \"IMPOSSIBLE\" << endl;\n            return 0;\n        }\n    }\n\n    dfs(1);\n\n    if (path.size() != m + 1) {\n        cout << \"IMPOSSIBLE\" << endl;\n        return 0;\n    }\n\n    reverse(path.begin(), path.end());\n    for (int i = 0; i < path.size(); i++) {\n        cout << path[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 18,
            "mean_time_taken": 0.1452247036827935,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                4,
                5,
                7,
                9,
                10,
                11,
                12,
                13,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 49,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Throwing Dice",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countWays(long long n) {\n    vector<int> dp(n + 1, 0);\n    dp[0] = 1;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= 6; j++) {\n            if (i >= j) {\n                dp[i] = (dp[i] + dp[i - j]) % MOD;\n            }\n        }\n    }\n\n    return dp[n];\n}\n\nint main() {\n    long long n;\n    cin >> n;\n    cout << countWays(n) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 32,
            "mean_time_taken": 0.12486623972654343,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                6,
                7,
                8,
                10,
                11,
                13,
                15,
                16,
                17,
                21,
                23,
                25,
                26,
                27,
                28,
                29,
                30,
                32
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 49,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tower of Hanoi",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid towerOfHanoi(int n, int source, int destination, int auxiliary, vector<pair<int, int>>& moves) {\n    if (n == 1) {\n        moves.push_back({source, destination});\n        return;\n    }\n    \n    towerOfHanoi(n - 1, source, auxiliary, destination, moves);\n    moves.push_back({source, destination});\n    towerOfHanoi(n - 1, auxiliary, destination, source, moves);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<pair<int, int>> moves;\n    towerOfHanoi(n, 1, 3, 2, moves);\n    \n    cout << moves.size() << endl;\n    for (auto move : moves) {\n        cout << move.first << \" \" << move.second << endl;\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 16,
            "total_test_cases": 16,
            "mean_time_taken": 0.09261375665664673,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 50,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Towers",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> cubes(n);\n    for (int i = 0; i < n; i++) {\n        cin >> cubes[i];\n    }\n\n    vector<int> towers;\n\n    for (int i = 0; i < n; i++) {\n        int cube = cubes[i];\n        auto it = upper_bound(towers.begin(), towers.end(), cube);\n\n        if (it == towers.end()) {\n            towers.push_back(cube);\n        } else {\n            *it = cube;\n        }\n    }\n\n    cout << towers.size() << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.11896785100301106,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 51,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Traffic Lights",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int x, n;\n    cin >> x >> n;\n\n    vector<int> lights(n);\n    for (int i = 0; i < n; i++) {\n        cin >> lights[i];\n    }\n\n    sort(lights.begin(), lights.end());\n\n    int longest = x;\n    int prev = 0;\n\n    for (int i = 0; i < n; i++) {\n        int passage = lights[i] - prev;\n        longest = max(longest, passage);\n        cout << longest << \" \";\n        prev = lights[i];\n    }\n\n    int lastPassage = x - prev;\n    longest = max(longest, lastPassage);\n    cout << longest << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.13744809230168661,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 51,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Trailing Zeros",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n\nint countTrailingZeros(int n) {\n    int count = 0;\n    for (int i = 5; n / i >= 1; i *= 5) {\n        count += n / i;\n    }\n    return count;\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    int trailingZeros = countTrailingZeros(n);\n    std::cout << trailingZeros << std::endl;\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.09094573901249813,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 52,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Tree Diameter",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<vector<int>> adj;\n\nint dfs(int node, int parent) {\n    int maxDist = 0;\n    for (int neighbor : adj[node]) {\n        if (neighbor != parent) {\n            int dist = dfs(neighbor, node);\n            maxDist = max(maxDist, dist + 1);\n        }\n    }\n    return maxDist;\n}\n\nint treeDiameter() {\n    int maxDist = 0;\n    int farthestNode = 0;\n\n    // First DFS traversal to find the farthest node from an arbitrary node\n    int dist = dfs(1, -1);\n    if (dist > maxDist) {\n        maxDist = dist;\n        farthestNode = 1;\n    }\n\n    // Second DFS traversal from the farthest node to find the diameter\n    dist = dfs(farthestNode, -1);\n    maxDist = max(maxDist, dist);\n\n    return maxDist;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    adj.resize(n + 1);\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    int diameter = treeDiameter();\n    cout << diameter << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 18,
            "mean_time_taken": 0.14056470659044054,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                14,
                15,
                16,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 52,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Distances I",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nvector<int> adj[MAXN];\nint dist[MAXN];\n\nvoid dfs(int node, int parent, int depth) {\n    dist[node] = depth;\n    \n    if (adj[node].size() == 1 && adj[node][0] == parent) {\n        // Leaf node\n        return;\n    }\n    \n    for (int neighbor : adj[node]) {\n        if (neighbor != parent) {\n            dfs(neighbor, node, depth + 1);\n            dist[node] = max(dist[node], dist[neighbor] + 1);\n        }\n    }\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n    \n    for (int i = 1; i < n; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    \n    dfs(1, 0, 0);\n    \n    for (int i = 1; i <= n; i++) {\n        cout << dist[i] << \" \";\n    }\n    cout << endl;\n}\n\nint main() {\n    solve();\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 15,
            "mean_time_taken": 0.1596255938212077,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 52,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Distances II",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nvector<int> adj[MAXN];\nint depth[MAXN];\nint subtree_size[MAXN];\nlong long ans[MAXN];\n\nvoid dfs1(int u, int p) {\n    subtree_size[u] = 1;\n    for (int v : adj[u]) {\n        if (v != p) {\n            depth[v] = depth[u] + 1;\n            dfs1(v, u);\n            subtree_size[u] += subtree_size[v];\n        }\n    }\n}\n\nvoid dfs2(int u, int p, int n) {\n    ans[u] = ans[p] - subtree_size[u] + (n - subtree_size[u]);\n    for (int v : adj[u]) {\n        if (v != p) {\n            dfs2(v, u, n);\n        }\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    depth[1] = 0;\n    dfs1(1, 0);\n\n    for (int i = 1; i <= n; i++) {\n        ans[1] += depth[i];\n    }\n\n    dfs2(1, 0, n);\n\n    for (int i = 1; i <= n; i++) {\n        cout << ans[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 14,
            "mean_time_taken": 0.16014787128993443,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 52,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Isomorphism I",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\n\nvector<int> adj1[MAXN], adj2[MAXN];\nint id1[MAXN], id2[MAXN];\n\nvoid dfs(int u, vector<int> adj[], int id[]) {\n    vector<int> child_ids;\n    for (int v : adj[u]) {\n        dfs(v, adj, id);\n        child_ids.push_back(id[v]);\n    }\n    sort(child_ids.begin(), child_ids.end());\n    \n    int hash_val = 0;\n    for (int i : child_ids) {\n        hash_val = hash_val * 31 + i;\n    }\n    id[u] = hash_val;\n}\n\nbool is_isomorphic(int n) {\n    for (int i = 1; i <= n; i++) {\n        if (id1[i] != id2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n;\n        cin >> n;\n        \n        for (int i = 1; i <= n; i++) {\n            adj1[i].clear();\n            adj2[i].clear();\n        }\n        \n        for (int i = 1; i < n; i++) {\n            int u, v;\n            cin >> u >> v;\n            adj1[u].push_back(v);\n        }\n        \n        for (int i = 1; i < n; i++) {\n            int u, v;\n            cin >> u >> v;\n            adj2[u].push_back(v);\n        }\n        \n        dfs(1, adj1, id1);\n        dfs(1, adj2, id2);\n        \n        if (is_isomorphic(n)) {\n            cout << \"YES\\n\";\n        } else {\n            cout << \"NO\\n\";\n        }\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 15,
            "mean_time_taken": 0.14578440984090169,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                6,
                7,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 52,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Isomorphism II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nbool isIsomorphic(int n, vector<vector<int>>& adj1, vector<vector<int>>& adj2) {\n    vector<int> deg1(n + 1), deg2(n + 1);\n    for (int i = 1; i <= n; i++) {\n        deg1[i] = adj1[i].size();\n        deg2[i] = adj2[i].size();\n    }\n    for (int i = 1; i <= n; i++) {\n        sort(adj1[i].begin(), adj1[i].end());\n        sort(adj2[i].begin(), adj2[i].end());\n    }\n    sort(deg1.begin() + 1, deg1.end());\n    sort(deg2.begin() + 1, deg2.end());\n    if (deg1 != deg2)\n        return false;\n\n    vector<bool> visited(n + 1);\n    queue<pair<int, int>> q;\n    q.push({1, 1});\n    while (!q.empty()) {\n        int u1 = q.front().first, u2 = q.front().second;\n        q.pop();\n        visited[u1] = visited[u2] = true;\n        if (adj1[u1].size() != adj2[u2].size())\n            return false;\n        for (int i = 0; i < adj1[u1].size(); i++) {\n            int v1 = adj1[u1][i], v2 = adj2[u2][i];\n            if (visited[v1])\n                continue;\n            if (deg1[v1] != deg2[v2])\n                return false;\n            q.push({v1, v2});\n        }\n    }\n    return true;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<vector<int>> adj1(n + 1), adj2(n + 1);\n        for (int i = 0; i < n - 1; i++) {\n            int u, v;\n            cin >> u >> v;\n            adj1[u].push_back(v);\n            adj1[v].push_back(u);\n        }\n        for (int i = 0; i < n - 1; i++) {\n            int u, v;\n            cin >> u >> v;\n            adj2[u].push_back(v);\n            adj2[v].push_back(u);\n        }\n        cout << (isIsomorphic(n, adj1, adj2) ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 14,
            "mean_time_taken": 0.1916860512324742,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                7,
                8,
                9,
                11,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 52,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Matching",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nvector<int> adj[MAXN];\nint dp[MAXN][2];\n\nvoid dfs(int node, int parent) {\n    dp[node][0] = 0;\n    dp[node][1] = 0;\n\n    for (int child : adj[node]) {\n        if (child != parent) {\n            dfs(child, node);\n            dp[node][0] += max(dp[child][0], dp[child][1]);\n            dp[node][1] += dp[child][0];\n        }\n    }\n\n    dp[node][1] = max(dp[node][1], dp[node][0] + 1);\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    dfs(1, 0);\n\n    cout << max(dp[1][0], dp[1][1]) << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 13,
            "mean_time_taken": 0.15436442081744856,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 52,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Traversals",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node* left;\n    Node* right;\n    Node(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nNode* buildTree(vector<int>& preorder, vector<int>& inorder, int start, int end) {\n    static int preIdx = 0;\n    if (start > end)\n        return NULL;\n    int rootVal = preorder[preIdx++];\n    Node* root = new Node(rootVal);\n    int inIdx = find(inorder.begin(), inorder.end(), rootVal) - inorder.begin();\n    root->left = buildTree(preorder, inorder, start, inIdx - 1);\n    root->right = buildTree(preorder, inorder, inIdx + 1, end);\n    return root;\n}\n\nvoid postorderTraversal(Node* root) {\n    if (root == NULL)\n        return;\n    postorderTraversal(root->left);\n    postorderTraversal(root->right);\n    cout << root->val << \" \";\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> preorder(n), inorder(n);\n    for (int i = 0; i < n; i++)\n        cin >> preorder[i];\n    for (int i = 0; i < n; i++)\n        cin >> inorder[i];\n    Node* root = buildTree(preorder, inorder, 0, n - 1);\n    postorderTraversal(root);\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 12,
            "mean_time_taken": 0.6458110014597574,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                7,
                9,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 52,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Two Knights",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    for (int k = 1; k <= n; k++) {\n        long long total = (long long)k * k * (k * k - 1) / 2;\n        long long attacking = (long long)(k - 1) * (k - 2) * 2;\n        long long result = total - attacking;\n        cout << result << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 3,
            "mean_time_taken": 0.09737626711527507,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                1
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 52,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Two Sets",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    if ((n * (n + 1) / 2) % 2 != 0) {\n        cout << \"NO\" << endl;\n    } else {\n        cout << \"YES\" << endl;\n        vector<int> set1, set2;\n\n        if (n % 2 == 0) {\n            for (int i = 1; i <= n / 2 - 1; i++) {\n                set1.push_back(i);\n            }\n            set1.push_back(n);\n\n            for (int i = n / 2; i < n; i++) {\n                set2.push_back(i);\n            }\n        } else {\n            for (int i = 1; i <= (n - 1) / 2; i++) {\n                set1.push_back(i);\n            }\n            set1.push_back(n);\n\n            for (int i = (n + 1) / 2; i < n; i++) {\n                set2.push_back(i);\n            }\n        }\n\n        cout << set1.size() << endl;\n        for (int num : set1) {\n            cout << num << \" \";\n        }\n        cout << endl;\n\n        cout << set2.size() << endl;\n        for (int num : set2) {\n            cout << num << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 23,
            "mean_time_taken": 0.0942292939061704,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                7,
                9,
                13,
                14,
                16,
                17,
                18,
                21,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 52,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Two Sets II",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countWays(int n, int target) {\n    vector<vector<int>> dp(n + 1, vector<int>(target + 1, 0));\n    dp[0][0] = 1;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= target; j++) {\n            dp[i][j] = dp[i - 1][j];\n            if (j >= i)\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - i]) % MOD;\n        }\n    }\n\n    return dp[n][target];\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    int totalSum = (n * (n + 1)) / 2;\n    if (totalSum % 2 != 0) {\n        cout << 0 << endl;\n    } else {\n        int target = totalSum / 2;\n        int ways = countWays(n, target);\n        cout << (ways * 500000004) % MOD << endl; // Multiply by modular inverse of 2\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 24,
            "mean_time_taken": 0.16798439621925354,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                5,
                8,
                12,
                13,
                15,
                17,
                18,
                20,
                24
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 52,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Two Stacks Sorting",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> input(n);\n    for (int i = 0; i < n; i++) {\n        cin >> input[i];\n    }\n\n    stack<int> stack1, stack2;\n    vector<int> output;\n\n    for (int num : input) {\n        if (stack1.empty() || num < stack1.top()) {\n            stack1.push(num);\n            cout << \"1 \";\n        } else {\n            while (!stack2.empty() && num > stack2.top()) {\n                output.push_back(stack2.top());\n                stack2.pop();\n            }\n            stack2.push(num);\n            cout << \"2 \";\n        }\n    }\n\n    while (!stack1.empty()) {\n        output.push_back(stack1.top());\n        stack1.pop();\n    }\n\n    while (!stack2.empty()) {\n        output.push_back(stack2.top());\n        stack2.pop();\n    }\n\n    bool isSorted = true;\n    for (int i = 1; i < n; i++) {\n        if (output[i] < output[i - 1]) {\n            isSorted = false;\n            break;\n        }\n    }\n\n    if (!isSorted) {\n        cout << \"\\nIMPOSSIBLE\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 14,
            "mean_time_taken": 0.11973817007882255,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 52,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Visiting Cities",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<pair<int, int>>> adj(n + 1);\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        adj[a].push_back({b, c});\n    }\n\n    vector<long long> dist(n + 1, 1e18);\n    dist[1] = 0;\n\n    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\n    pq.push({0, 1});\n\n    while (!pq.empty()) {\n        int u = pq.top().second;\n        pq.pop();\n\n        if (u == n) break;\n\n        for (auto [v, w] : adj[u]) {\n            if (dist[u] + w < dist[v]) {\n                dist[v] = dist[u] + w;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n\n    vector<int> visited;\n    int curr = n;\n    while (curr != 1) {\n        visited.push_back(curr);\n        for (auto [v, w] : adj[curr]) {\n            if (dist[curr] - w == dist[v]) {\n                curr = v;\n                break;\n            }\n        }\n    }\n    visited.push_back(1);\n    reverse(visited.begin(), visited.end());\n\n    cout << visited.size() << endl;\n    for (int city : visited) {\n        cout << city << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 13,
            "mean_time_taken": 1.0474035556499774,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 52,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Weird Algorithm",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    long long n;\n    cin >> n;\n\n    while (n != 1) {\n        cout << n << \" \";\n\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = n * 3 + 1;\n        }\n    }\n\n    cout << n << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.08980027266911098,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 53,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Word Combinations",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    string s;\n    cin >> s;\n    int k;\n    cin >> k;\n\n    int n = s.length();\n    vector<string> words(k);\n    for (int i = 0; i < k; i++) {\n        cin >> words[i];\n    }\n\n    vector<int> dp(n + 1, 0);\n    dp[0] = 1;\n\n    for (int i = 1; i <= n; i++) {\n        for (const string& word : words) {\n            if (i >= word.length() && s.substr(i - word.length(), word.length()) == word) {\n                dp[i] = (dp[i] + dp[i - word.length()]) % MOD;\n            }\n        }\n    }\n\n    cout << dp[n] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 6,
            "mean_time_taken": 0.568179170290629,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 53,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Writing Numbers",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    long long n;\n    cin >> n;\n\n    long long totalPresses = 0;\n    long long currentNumber = 1;\n    int digits = 1;\n\n    while (totalPresses <= n) {\n        long long numbersInGroup = 9 * currentNumber;\n        long long pressesInGroup = numbersInGroup * digits;\n\n        if (totalPresses + pressesInGroup > n) {\n            long long remainingPresses = n - totalPresses;\n            currentNumber += remainingPresses / digits;\n            break;\n        }\n\n        totalPresses += pressesInGroup;\n        currentNumber *= 10;\n        digits++;\n    }\n\n    cout << currentNumber - 1 << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 21,
            "mean_time_taken": 0.08925414085388184,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 53,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Xor Pyramid",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> pyramid(n);\n    for (int i = 0; i < n; i++) {\n        cin >> pyramid[i];\n    }\n\n    while (n > 1) {\n        for (int i = 0; i < n - 1; i++) {\n            pyramid[i] = pyramid[i] ^ pyramid[i + 1];\n        }\n        n--;\n    }\n\n    cout << pyramid[0] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 8,
            "mean_time_taken": 0.6850756704807281,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 53,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        }
    ],
    "total_passed_problems": 53,
    "initial_config": {
        "ignore_time_limits": false,
        "model": "claude-3-opus-20240229",
        "provider": "anthropic",
        "categories": [],
        "shots": 1
    }
}