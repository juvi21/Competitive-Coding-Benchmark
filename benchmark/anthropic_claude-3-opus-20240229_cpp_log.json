{
    "problems": [
        {
            "title": "Acyclic Graph Edges",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\nvector<pair<int, int>> edges;\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            edges.push_back({u, v});\n            dfs(v);\n        } else {\n            edges.push_back({v, u});\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    adj.resize(n + 1);\n    visited.resize(n + 1, false);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            dfs(i);\n        }\n    }\n\n    for (auto edge : edges) {\n        cout << edge.first << \" \" << edge.second << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.17661255598068237,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Advertisement",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> k(n);\n    for (int i = 0; i < n; i++) {\n        cin >> k[i];\n    }\n\n    int maxArea = 0;\n    int left = 0, right = n - 1;\n    int height = min(k[left], k[right]);\n\n    while (left < right) {\n        int area = height * (right - left + 1);\n        maxArea = max(maxArea, area);\n\n        if (k[left] < k[right]) {\n            left++;\n            height = min(height, k[left]);\n        } else {\n            right--;\n            height = min(height, k[right]);\n        }\n    }\n\n    cout << maxArea << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 11,
            "mean_time_taken": 0.10055349089882591,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Another Game",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n;\n        cin >> n;\n\n        long long total = 0;\n        for (int i = 0; i < n; i++) {\n            int x;\n            cin >> x;\n            total += x;\n        }\n\n        if (total % 2 == 0) {\n            cout << \"second\" << endl;\n        } else {\n            cout << \"first\" << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 3,
            "mean_time_taken": 0.1187902291615804,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Apartments",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    vector<int> b(m);\n    for (int i = 0; i < m; i++) {\n        cin >> b[i];\n    }\n\n    sort(a.begin(), a.end());\n    sort(b.begin(), b.end());\n\n    int count = 0;\n    int i = 0, j = 0;\n\n    while (i < n && j < m) {\n        if (b[j] - k <= a[i] && a[i] <= b[j] + k) {\n            count++;\n            i++;\n            j++;\n        } else if (a[i] < b[j] - k) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n\n    cout << count << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 19,
            "total_test_cases": 19,
            "mean_time_taken": 0.14306108575118215,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 1,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Apple Division",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nvoid solve(int index, long long sum1, long long sum2, long long& min_diff, const vector<int>& apples) {\n    if (index == apples.size()) {\n        min_diff = min(min_diff, abs(sum1 - sum2));\n        return;\n    }\n    \n    solve(index + 1, sum1 + apples[index], sum2, min_diff, apples);\n    solve(index + 1, sum1, sum2 + apples[index], min_diff, apples);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<int> apples(n);\n    long long total_weight = 0;\n    \n    for (int i = 0; i < n; i++) {\n        cin >> apples[i];\n        total_weight += apples[i];\n    }\n    \n    long long min_diff = total_weight;\n    solve(0, 0, 0, min_diff, apples);\n    \n    cout << min_diff << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 18,
            "total_test_cases": 18,
            "mean_time_taken": 0.09043457772996691,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Apples and Bananas",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int k, n, m;\n    cin >> k >> n >> m;\n\n    vector<int> apples(n);\n    vector<int> bananas(m);\n\n    for (int i = 0; i < n; i++) {\n        cin >> apples[i];\n    }\n\n    for (int i = 0; i < m; i++) {\n        cin >> bananas[i];\n    }\n\n    vector<int> apple_count(k + 1, 0);\n    vector<int> banana_count(k + 1, 0);\n\n    for (int i = 0; i < n; i++) {\n        apple_count[apples[i]]++;\n    }\n\n    for (int i = 0; i < m; i++) {\n        banana_count[bananas[i]]++;\n    }\n\n    vector<int> result(2 * k + 1, 0);\n\n    for (int w = 2; w <= 2 * k; w++) {\n        for (int i = 1; i <= k; i++) {\n            if (i <= w - i && w - i <= k) {\n                result[w] += apple_count[i] * banana_count[w - i];\n            }\n        }\n    }\n\n    for (int w = 2; w <= 2 * k; w++) {\n        cout << result[w] << \" \";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.7213623921076456,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Area of Rectangles",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<int, pair<int, int>>> events;\n\n    for (int i = 0; i < n; i++) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        events.push_back({x1, {y1, y2}});\n        events.push_back({x2, {y1, y2}});\n    }\n\n    sort(events.begin(), events.end());\n\n    long long total_area = 0;\n    int prev_x = events[0].first;\n    set<int> active_y;\n\n    for (const auto& event : events) {\n        int x = event.first;\n        int y1 = event.second.first;\n        int y2 = event.second.second;\n\n        if (active_y.empty()) {\n            active_y.insert(y1);\n            active_y.insert(y2);\n        } else {\n            if (active_y.count(y1) > 0) {\n                active_y.erase(y1);\n                active_y.erase(y2);\n            } else {\n                active_y.insert(y1);\n                active_y.insert(y2);\n            }\n        }\n\n        int height = *active_y.rbegin() - *active_y.begin();\n        total_area += static_cast<long long>(x - prev_x) * height;\n        prev_x = x;\n    }\n\n    cout << total_area << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.21760110855102538,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Array Description",
            "category": "Dynamic Programming",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> x(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i];\n    }\n\n    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\n\n    if (x[0] == 0) {\n        fill(dp[1].begin() + 1, dp[1].end(), 1);\n    } else {\n        dp[1][x[0]] = 1;\n    }\n\n    for (int i = 1; i < n; i++) {\n        if (x[i] == 0) {\n            for (int j = 1; j <= m; j++) {\n                dp[i + 1][j] = dp[i][j];\n                if (j > 1) {\n                    dp[i + 1][j] = (dp[i + 1][j] + dp[i][j - 1]) % MOD;\n                }\n                if (j < m) {\n                    dp[i + 1][j] = (dp[i + 1][j] + dp[i][j + 1]) % MOD;\n                }\n            }\n        } else {\n            dp[i + 1][x[i]] = dp[i][x[i]];\n            if (x[i] > 1) {\n                dp[i + 1][x[i]] = (dp[i + 1][x[i]] + dp[i][x[i] - 1]) % MOD;\n            }\n            if (x[i] < m) {\n                dp[i + 1][x[i]] = (dp[i + 1][x[i]] + dp[i][x[i] + 1]) % MOD;\n            }\n        }\n    }\n\n    int answer = 0;\n    for (int i = 1; i <= m; i++) {\n        answer = (answer + dp[n][i]) % MOD;\n    }\n    cout << answer << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 29,
            "total_test_cases": 29,
            "mean_time_taken": 0.1254935100160796,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Array Division",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool canDivide(const vector<int>& arr, int maxSum, int k) {\n    int subarrays = 1;\n    int currentSum = 0;\n\n    for (int num : arr) {\n        if (currentSum + num > maxSum) {\n            subarrays++;\n            currentSum = num;\n        } else {\n            currentSum += num;\n        }\n    }\n\n    return subarrays <= k;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> arr(n);\n    int maxElement = 0;\n    long long totalSum = 0;\n\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n        maxElement = max(maxElement, arr[i]);\n        totalSum += arr[i];\n    }\n\n    int left = maxElement;\n    int right = totalSum;\n    int result = 0;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (canDivide(arr, mid, k)) {\n            result = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 18,
            "mean_time_taken": 0.10758137702941895,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                7,
                10,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Beautiful Subgrids",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int grid[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            char c;\n            cin >> c;\n            grid[i][j] = c - '0';\n        }\n    }\n\n    int count = 0;\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - 1; j++) {\n            for (int k = i + 1; k < n; k++) {\n                for (int l = j + 1; l < n; l++) {\n                    if (grid[i][j] && grid[i][l] && grid[k][j] && grid[k][l]) {\n                        count++;\n                    }\n                }\n            }\n        }\n    }\n\n    cout << count << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 8,
            "mean_time_taken": 0.135152667760849,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Binary Subsequences",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    // Find the smallest k such that 2^k >= n\n    int k = ceil(log2(n));\n\n    // Generate a binary number with k bits that represents n-1\n    int result = (1 << k) | (n - 1);\n\n    // Print the binary number\n    for (int i = k - 1; i >= 0; i--) {\n        cout << ((result >> i) & 1);\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 12,
            "mean_time_taken": 0.08858243624369304,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Binomial Coefficients",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int MAXN = 1e6 + 1;\n\nint dp[MAXN][MAXN];\n\nint main() {\n    // Initialize base cases\n    for (int i = 0; i < MAXN; i++) {\n        dp[i][0] = 1;\n        dp[i][i] = 1;\n    }\n\n    // Fill the dp array\n    for (int i = 2; i < MAXN; i++) {\n        for (int j = 1; j < i; j++) {\n            dp[i][j] = (dp[i-1][j-1] + dp[i-1][j]) % MOD;\n        }\n    }\n\n    int n;\n    cin >> n;\n\n    while (n--) {\n        int a, b;\n        cin >> a >> b;\n        cout << dp[a][b] << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Bit Inversions",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main() {\n    string bits;\n    cin >> bits;\n    int m;\n    cin >> m;\n    vector<int> changes(m);\n    for (int i = 0; i < m; i++) {\n        cin >> changes[i];\n    }\n    \n    vector<int> result;\n    for (int i = 0; i < m; i++) {\n        int pos = changes[i] - 1;\n        bits[pos] = (bits[pos] == '0') ? '1' : '0';\n        \n        int currentLength = 1;\n        int maxLength = 1;\n        for (int j = 1; j < bits.length(); j++) {\n            if (bits[j] == bits[j - 1]) {\n                currentLength++;\n            } else {\n                maxLength = max(maxLength, currentLength);\n                currentLength = 1;\n            }\n        }\n        maxLength = max(maxLength, currentLength);\n        result.push_back(maxLength);\n    }\n    \n    for (int i = 0; i < result.size(); i++) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 12,
            "mean_time_taken": 0.6433900992075602,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                7,
                9,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bit Problem",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int x[n];\n    for (int i = 0; i < n; i++) {\n        cin >> x[i];\n    }\n\n    int count[1000001] = {0};\n    for (int i = 0; i < n; i++) {\n        count[x[i]]++;\n    }\n\n    for (int i = 0; i < n; i++) {\n        int bitOR = 0, bitAND = 0, bitANDNot0 = 0;\n        for (int j = 1; j <= 1000000; j++) {\n            if ((x[i] | j) == x[i]) {\n                bitOR += count[j];\n            }\n            if ((x[i] & j) == x[i]) {\n                bitAND += count[j];\n            }\n            if ((x[i] & j) != 0) {\n                bitANDNot0 += count[j];\n            }\n        }\n        cout << bitOR << \" \" << bitAND << \" \" << bitANDNot0 << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 2,
            "mean_time_taken": 0.6779601573944092,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bit Strings",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long modularExponentiation(long long base, long long exponent) {\n    long long result = 1;\n    while (exponent > 0) {\n        if (exponent % 2 == 1) {\n            result = (result * base) % MOD;\n        }\n        base = (base * base) % MOD;\n        exponent /= 2;\n    }\n    return result;\n}\n\nint main() {\n    long long n;\n    cin >> n;\n    \n    long long bitStrings = modularExponentiation(2, n);\n    cout << bitStrings << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.08970852692921956,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Bit Substrings",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<int> countSubstrings(const string& s) {\n    int n = s.length();\n    vector<int> result(n + 1, 0);\n\n    for (int k = 0; k <= n; k++) {\n        int count = 0;\n        int left = 0;\n        int right = 0;\n\n        while (right < n) {\n            if (s[right] == '1') {\n                count++;\n            }\n\n            while (count > k) {\n                if (s[left] == '1') {\n                    count--;\n                }\n                left++;\n            }\n\n            if (count == k) {\n                result[k] += right - left + 1;\n            }\n\n            right++;\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    string s;\n    cin >> s;\n\n    vector<int> result = countSubstrings(s);\n\n    for (int i = 0; i <= s.length(); i++) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 8,
            "mean_time_taken": 0.6829473078250885,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Book Shop",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> price(n);\n    for (int i = 0; i < n; i++) {\n        cin >> price[i];\n    }\n\n    vector<int> pages(n);\n    for (int i = 0; i < n; i++) {\n        cin >> pages[i];\n    }\n\n    vector<vector<int>> dp(n + 1, vector<int>(x + 1, 0));\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= x; j++) {\n            dp[i][j] = dp[i - 1][j];\n            if (j >= price[i - 1]) {\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - price[i - 1]] + pages[i - 1]);\n            }\n        }\n    }\n\n    cout << dp[n][x] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 15,
            "mean_time_taken": 0.6078876972198486,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                7,
                9,
                11,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Book Shop II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> h(n + 1), s(n + 1), k(n + 1);\n    for (int i = 1; i <= n; i++) {\n        cin >> h[i];\n    }\n    for (int i = 1; i <= n; i++) {\n        cin >> s[i];\n    }\n    for (int i = 1; i <= n; i++) {\n        cin >> k[i];\n    }\n\n    vector<vector<int>> dp(n + 1, vector<int>(x + 1, 0));\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= x; j++) {\n            if (h[i] > j) {\n                dp[i][j] = dp[i - 1][j];\n            } else {\n                for (int c = 0; c <= k[i]; c++) {\n                    int price = c * h[i];\n                    if (price > j) {\n                        break;\n                    }\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - price] + c * s[i]);\n                }\n            }\n        }\n    }\n\n    cout << dp[n][x] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 10,
            "mean_time_taken": 0.5945859432220459,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bracket Sequences I",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long modPow(long long base, long long exp) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1)\n            result = (result * base) % MOD;\n        base = (base * base) % MOD;\n        exp >>= 1;\n    }\n    return result;\n}\n\nlong long modInverse(long long n) {\n    return modPow(n, MOD - 2);\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    long long fact[2 * n + 1];\n    fact[0] = 1;\n    for (int i = 1; i <= 2 * n; i++)\n        fact[i] = (fact[i - 1] * i) % MOD;\n\n    long long numerator = fact[2 * n];\n    long long denominator = (fact[n + 1] * fact[n]) % MOD;\n    long long catalan = (numerator * modInverse(denominator)) % MOD;\n\n    cout << catalan << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 17,
            "mean_time_taken": 0.10223188119776108,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bracket Sequences II",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countSequences(int n, string prefix) {\n    int k = prefix.length();\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n    dp[0][0] = 1;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= i; j++) {\n            if (j > 0)\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD;\n            if (j < i)\n                dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MOD;\n            if (i <= k && prefix[i - 1] == '(')\n                dp[i][j] = (j > 0) ? dp[i - 1][j - 1] : 0;\n            if (i <= k && prefix[i - 1] == ')')\n                dp[i][j] = (j < i) ? dp[i - 1][j + 1] : 0;\n        }\n    }\n\n    int answer = 0;\n    for (int j = 0; j <= n; j++) {\n        answer = (answer + dp[n][j]) % MOD;\n    }\n    return answer;\n}\n\nint main() {\n    int n;\n    string prefix;\n    cin >> n >> prefix;\n    cout << countSequences(n, prefix) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 11,
            "mean_time_taken": 0.21256351470947266,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                8,
                9,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Building Roads",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass DSU {\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n\npublic:\n    DSU(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    DSU dsu(n);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--; // Convert to 0-based indexing\n        dsu.unite(a, b);\n    }\n\n    int components = 0;\n    for (int i = 0; i < n; i++) {\n        if (dsu.find(i) == i) {\n            components++;\n        }\n    }\n\n    int newRoads = components - 1;\n    cout << newRoads << endl;\n\n    if (newRoads > 0) {\n        int prevComponent = dsu.find(0);\n        for (int i = 1; i < n; i++) {\n            int currentComponent = dsu.find(i);\n            if (currentComponent != prevComponent) {\n                cout << prevComponent + 1 << \" \" << currentComponent + 1 << endl;\n                prevComponent = currentComponent;\n                newRoads--;\n                if (newRoads == 0) {\n                    break;\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 12,
            "mean_time_taken": 0.12033710877100627,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Building Teams",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1e5 + 5;\nvector<int> adj[MAX_N];\nint team[MAX_N];\n\nbool dfs(int node, int t) {\n    team[node] = t;\n    for (int neighbor : adj[node]) {\n        if (team[neighbor] == t) {\n            return false;\n        }\n        if (team[neighbor] == 0 && !dfs(neighbor, 3 - t)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    bool possible = true;\n    for (int i = 1; i <= n; i++) {\n        if (team[i] == 0) {\n            if (!dfs(i, 1)) {\n                possible = false;\n                break;\n            }\n        }\n    }\n\n    if (possible) {\n        for (int i = 1; i <= n; i++) {\n            cout << team[i] << \" \";\n        }\n        cout << endl;\n    } else {\n        cout << \"IMPOSSIBLE\" << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.1453171730041504,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 5,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Candy Lottery",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    double expected_max = 0.0;\n    double prev_prob = 0.0;\n\n    for (int x = 1; x <= k; x++) {\n        double prob = pow((double)x / k, n);\n        expected_max += x * (prob - prev_prob);\n        prev_prob = prob;\n    }\n\n    cout << fixed << setprecision(6) << expected_max << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.08850388867514473,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Chess Tournament",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> games(n);\n    int total_games = 0;\n\n    for (int i = 0; i < n; i++) {\n        cin >> games[i];\n        total_games += games[i];\n    }\n\n    if (total_games % 2 != 0) {\n        cout << \"IMPOSSIBLE\" << endl;\n        return 0;\n    }\n\n    vector<pair<int, int>> pairings;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            while (games[i] > 0 && games[j] > 0) {\n                pairings.push_back({i + 1, j + 1});\n                games[i]--;\n                games[j]--;\n            }\n        }\n    }\n\n    if (pairings.size() != total_games / 2) {\n        cout << \"IMPOSSIBLE\" << endl;\n        return 0;\n    }\n\n    cout << pairings.size() << endl;\n    for (auto p : pairings) {\n        cout << p.first << \" \" << p.second << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 21,
            "mean_time_taken": 0.3181386221022833,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Chessboard and Queens",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int N = 8;\nchar board[N][N];\nint count = 0;\n\nbool is_valid(int row, int col) {\n    // Check if there is a queen in the same column\n    for (int i = 0; i < row; i++) {\n        if (board[i][col] == 'Q')\n            return false;\n    }\n\n    // Check if there is a queen in the upper-left diagonal\n    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n        if (board[i][j] == 'Q')\n            return false;\n    }\n\n    // Check if there is a queen in the upper-right diagonal\n    for (int i = row - 1, j = col + 1; i >= 0 && j < N; i--, j++) {\n        if (board[i][j] == 'Q')\n            return false;\n    }\n\n    return true;\n}\n\nvoid solve(int row) {\n    if (row == N) {\n        count++;\n        return;\n    }\n\n    for (int col = 0; col < N; col++) {\n        if (board[row][col] == '.' && is_valid(row, col)) {\n            board[row][col] = 'Q';\n            solve(row + 1);\n            board[row][col] = '.';\n        }\n    }\n}\n\nint main() {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> board[i][j];\n        }\n    }\n\n    solve(0);\n    cout << count << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.092671799659729,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Christmas Party",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n;\n    cin >> n;\n\n    long long dp[n+1];\n    dp[0] = 1;\n    dp[1] = 0;\n\n    for (int i = 2; i <= n; i++) {\n        dp[i] = (i-1) * (dp[i-1] + dp[i-2]) % MOD;\n    }\n\n    cout << dp[n] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 15,
            "total_test_cases": 15,
            "mean_time_taken": 0.09254239400227865,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Coding Company",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countDivisions(int index, int teams, int penaltySum, vector<int>& skillLevels, int x) {\n    if (index == skillLevels.size()) {\n        return (penaltySum <= x) ? 1 : 0;\n    }\n\n    int result = 0;\n    for (int i = 1; index + i <= skillLevels.size(); i++) {\n        int penalty = skillLevels[index + i - 1] - skillLevels[index];\n        if (penaltySum + penalty > x) {\n            break;\n        }\n        result = (result + countDivisions(index + i, teams + 1, penaltySum + penalty, skillLevels, x)) % MOD;\n    }\n\n    return result;\n}\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> skillLevels(n);\n    for (int i = 0; i < n; i++) {\n        cin >> skillLevels[i];\n    }\n\n    sort(skillLevels.begin(), skillLevels.end());\n\n    int validDivisions = countDivisions(0, 0, 0, skillLevels, x);\n    cout << validDivisions << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 15,
            "mean_time_taken": 0.47018230756123863,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                11,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Arrangement",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int total_moves = 0;\n    for (int i = 0; i < 2 * n; i++) {\n        int coins;\n        cin >> coins;\n        total_moves += abs(coins - 1);\n    }\n\n    cout << total_moves << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 10,
            "mean_time_taken": 0.10272974967956543,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Collector",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> k(n);\n    for (int i = 0; i < n; i++) {\n        cin >> k[i];\n    }\n\n    vector<int> dp(n);\n    for (int i = 0; i < n; i++) {\n        dp[i] = k[i];\n    }\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        dp[b] = max(dp[b], dp[a] + k[b]);\n    }\n\n    int maxCoins = 0;\n    for (int i = 0; i < n; i++) {\n        maxCoins = max(maxCoins, dp[i]);\n    }\n\n    cout << maxCoins << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 14,
            "mean_time_taken": 0.11509920869554792,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Combinations I",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> coins(n);\n    for (int i = 0; i < n; i++) {\n        cin >> coins[i];\n    }\n\n    vector<int> dp(x + 1, 0);\n    dp[0] = 1;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = coins[i]; j <= x; j++) {\n            dp[j] = (dp[j] + dp[j - coins[i]]) % MOD;\n        }\n    }\n\n    cout << dp[x] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 13,
            "mean_time_taken": 0.23250568830049956,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                6,
                7,
                8,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Combinations II",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> coins(n);\n    for (int i = 0; i < n; i++) {\n        cin >> coins[i];\n    }\n\n    vector<vector<int>> dp(n, vector<int>(x + 1, 0));\n    dp[0][0] = 1;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= x; j++) {\n            if (i > 0) {\n                dp[i][j] = dp[i - 1][j];\n            }\n            if (j >= coins[i]) {\n                dp[i][j] = (dp[i][j] + dp[i][j - coins[i]]) % MOD;\n            }\n        }\n    }\n\n    cout << dp[n - 1][x] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 15,
            "mean_time_taken": 0.5488955974578857,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                6,
                7,
                8,
                9,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Grid",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<vector<bool>> coins(n, vector<bool>(n));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            char c;\n            cin >> c;\n            coins[i][j] = (c == 'o');\n        }\n    }\n\n    int moves = 0;\n    vector<pair<int, int>> moves_performed;\n\n    for (int i = 0; i < n; i++) {\n        bool row_has_coin = false;\n        for (int j = 0; j < n; j++) {\n            if (coins[i][j]) {\n                row_has_coin = true;\n                break;\n            }\n        }\n        if (row_has_coin) {\n            moves++;\n            moves_performed.push_back({1, i + 1});\n            for (int j = 0; j < n; j++) {\n                coins[i][j] = false;\n            }\n        }\n    }\n\n    for (int j = 0; j < n; j++) {\n        bool col_has_coin = false;\n        for (int i = 0; i < n; i++) {\n            if (coins[i][j]) {\n                col_has_coin = true;\n                break;\n            }\n        }\n        if (col_has_coin) {\n            moves++;\n            moves_performed.push_back({2, j + 1});\n            for (int i = 0; i < n; i++) {\n                coins[i][j] = false;\n            }\n        }\n    }\n\n    cout << moves << endl;\n    for (auto move : moves_performed) {\n        cout << move.first << \" \" << move.second << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 10,
            "mean_time_taken": 0.09078903198242187,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Piles",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int a, b;\n        cin >> a >> b;\n        \n        if ((a + b) % 3 == 0 && min(a, b) * 2 >= max(a, b)) {\n            cout << \"YES\\n\";\n        } else {\n            cout << \"NO\\n\";\n        }\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 3,
            "mean_time_taken": 0.14263494809468588,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Collecting Numbers",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int pos[n + 1] = {0};\n    for (int i = 1; i <= n; i++) {\n        int x;\n        cin >> x;\n        pos[x] = i;\n    }\n\n    int rounds = 1;\n    for (int i = 2; i <= n; i++) {\n        if (pos[i] < pos[i - 1]) {\n            rounds++;\n        }\n    }\n\n    cout << rounds << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 4,
            "mean_time_taken": 0.11793839931488037,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Collecting Numbers II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    vector<int> pos(n + 1);\n    for (int i = 0; i < n; i++) {\n        pos[arr[i]] = i;\n    }\n\n    int rounds = 1;\n    for (int i = 1; i < n; i++) {\n        if (pos[i] > pos[i + 1]) {\n            rounds++;\n        }\n    }\n\n    while (m--) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n\n        int num1 = arr[a], num2 = arr[b];\n        swap(arr[a], arr[b]);\n        swap(pos[num1], pos[num2]);\n\n        if ((a > 0 && num2 < arr[a - 1] && num1 >= arr[a - 1]) ||\n            (a < n - 1 && num2 > arr[a + 1] && num1 <= arr[a + 1])) {\n            rounds++;\n        }\n        else if ((a > 0 && num1 < arr[a - 1] && num2 >= arr[a - 1]) ||\n                 (a < n - 1 && num1 > arr[a + 1] && num2 <= arr[a + 1])) {\n            rounds--;\n        }\n\n        if ((b > 0 && num1 < arr[b - 1] && num2 >= arr[b - 1]) ||\n            (b < n - 1 && num1 > arr[b + 1] && num2 <= arr[b + 1])) {\n            rounds++;\n        }\n        else if ((b > 0 && num2 < arr[b - 1] && num1 >= arr[b - 1]) ||\n                 (b < n - 1 && num2 > arr[b + 1] && num1 <= arr[b + 1])) {\n            rounds--;\n        }\n\n        cout << rounds << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.2527807950973511,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Common Divisors",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint gcd(int a, int b) {\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    int x[n];\n    for (int i = 0; i < n; i++) {\n        cin >> x[i];\n    }\n\n    int maxGCD = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            maxGCD = max(maxGCD, gcd(x[i], x[j]));\n        }\n    }\n\n    cout << maxGCD << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 17,
            "mean_time_taken": 0.5910408216364244,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                5,
                6,
                7,
                9,
                11,
                14,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Company Queries I",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> boss(n + 1);\n    for (int i = 2; i <= n; i++) {\n        cin >> boss[i];\n    }\n\n    int log_n = log2(n) + 1;\n    vector<vector<int>> up(n + 1, vector<int>(log_n));\n    for (int i = 1; i <= n; i++) {\n        up[i][0] = boss[i];\n    }\n\n    for (int j = 1; j < log_n; j++) {\n        for (int i = 1; i <= n; i++) {\n            up[i][j] = up[up[i][j - 1]][j - 1];\n        }\n    }\n\n    while (q--) {\n        int x, k;\n        cin >> x >> k;\n\n        int ans = x;\n        for (int j = log_n - 1; j >= 0; j--) {\n            if (k & (1 << j)) {\n                ans = up[ans][j];\n                if (ans == 0) {\n                    break;\n                }\n            }\n        }\n\n        cout << (ans != 0 ? ans : -1) << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.20478411821218637,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Company Queries II",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nconst int MAXLOG = 20;\n\nint n, q;\nvector<int> boss(MAXN);\nvector<int> depth(MAXN);\nvector<vector<int>> parent(MAXN, vector<int>(MAXLOG));\n\nvoid dfs(int u) {\n    for (int i = 1; i < MAXLOG; i++) {\n        parent[u][i] = parent[parent[u][i-1]][i-1];\n    }\n    for (int v = 2; v <= n; v++) {\n        if (boss[v] == u) {\n            depth[v] = depth[u] + 1;\n            parent[v][0] = u;\n            dfs(v);\n        }\n    }\n}\n\nint lca(int a, int b) {\n    if (depth[a] < depth[b]) {\n        swap(a, b);\n    }\n    int diff = depth[a] - depth[b];\n    for (int i = MAXLOG - 1; i >= 0; i--) {\n        if (diff & (1 << i)) {\n            a = parent[a][i];\n        }\n    }\n    if (a == b) {\n        return a;\n    }\n    for (int i = MAXLOG - 1; i >= 0; i--) {\n        if (parent[a][i] != parent[b][i]) {\n            a = parent[a][i];\n            b = parent[b][i];\n        }\n    }\n    return parent[a][0];\n}\n\nint main() {\n    cin >> n >> q;\n    for (int i = 2; i <= n; i++) {\n        cin >> boss[i];\n    }\n    depth[1] = 0;\n    dfs(1);\n    while (q--) {\n        int a, b;\n        cin >> a >> b;\n        cout << lca(a, b) << '\\n';\n    }\n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 12,
            "mean_time_taken": 0.5791909098625183,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                7,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Concert Tickets",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> h(n);\n    for (int i = 0; i < n; i++) {\n        cin >> h[i];\n    }\n\n    vector<int> t(m);\n    for (int i = 0; i < m; i++) {\n        cin >> t[i];\n    }\n\n    sort(h.begin(), h.end());\n\n    for (int i = 0; i < m; i++) {\n        auto it = upper_bound(h.begin(), h.end(), t[i]);\n        if (it == h.begin()) {\n            cout << -1 << endl;\n        } else {\n            cout << *(--it) << endl;\n            h.erase(it);\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.34659539569507947,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Convex Hull",
            "category": "Geometry",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Counting Bishops",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countBishopPlacements(int n, int k) {\n    int diagonals = 2 * n - 1;\n    vector<vector<int>> dp(diagonals, vector<int>(k + 1, 0));\n\n    // Base cases\n    for (int i = 0; i < diagonals; i++) {\n        dp[i][0] = 1;\n    }\n    dp[0][1] = 1;\n\n    // Fill the DP table\n    for (int i = 1; i < diagonals; i++) {\n        for (int j = 1; j <= k; j++) {\n            dp[i][j] = (dp[i - 1][j] + (i >= j ? dp[i - 1][j - 1] : 0)) % MOD;\n        }\n    }\n\n    return dp[diagonals - 1][k];\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    cout << countBishopPlacements(n, k) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 13,
            "mean_time_taken": 0.10902170034555289,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                8,
                9,
                10,
                11,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Bits",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\ntypedef long long ll;\n\nll countOnes(ll n) {\n    if (n == 0)\n        return 0;\n    \n    ll p = 1;\n    while (p <= n)\n        p *= 2;\n    p /= 2;\n    \n    return p - 1 + (n - p + 1) + countOnes(n - p);\n}\n\nint main() {\n    ll n;\n    cin >> n;\n    cout << countOnes(n) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 21,
            "mean_time_taken": 0.08774880000523158,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                14,
                15,
                17,
                18,
                19,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Coprime Pairs",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX = 1e6 + 5;\nint freq[MAX];\n\nvector<int> sieve() {\n    vector<bool> isPrime(MAX, true);\n    vector<int> primes;\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i < MAX; i++) {\n        if (isPrime[i]) {\n            primes.push_back(i);\n            for (int j = i * i; j < MAX; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    return primes;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        freq[x]++;\n    }\n\n    vector<int> primes = sieve();\n    long long result = (long long)n * (n - 1) / 2;\n\n    for (int mask = 1; mask < (1 << primes.size()); mask++) {\n        int prod = 1;\n        for (int i = 0; i < primes.size(); i++) {\n            if (mask & (1 << i)) {\n                prod *= primes[i];\n            }\n        }\n        int pairs = freq[1] * (freq[1] - 1) / 2 + freq[prod] * (freq[prod] - 1) / 2;\n        if (__builtin_popcount(mask) % 2 == 0) {\n            result -= pairs;\n        } else {\n            result += pairs;\n        }\n    }\n\n    cout << result << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.20563983917236328,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Divisors",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MAX = 1000001;\n\nint main() {\n    int n;\n    cin >> n;\n    int arr[n];\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    int divisors[MAX] = {0};\n    for (int i = 1; i < MAX; i++) {\n        for (int j = i; j < MAX; j += i) {\n            divisors[j]++;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        cout << divisors[arr[i]] << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 16,
            "mean_time_taken": 0.14239370822906494,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                7,
                13,
                14,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Grids",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long fastPow(long long base, long long exp) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1)\n            result = (result * base) % MOD;\n        base = (base * base) % MOD;\n        exp /= 2;\n    }\n    return result;\n}\n\nint main() {\n    long long n;\n    cin >> n;\n\n    if (n == 1)\n        cout << 2 << endl;\n    else if (n == 2)\n        cout << 6 << endl;\n    else {\n        long long totalGrids = fastPow(2, n * n);\n        long long specialGrids = fastPow(2, n * n / 2);\n        long long result = (totalGrids + 4 * specialGrids) % MOD;\n        result = (result * fastPow(4, MOD - 2)) % MOD;  // Multiply by modular inverse of 4\n        cout << result << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 12,
            "mean_time_taken": 0.09082931280136108,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Necklaces",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long gcd(long long a, long long b) {\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n}\n\nlong long binexp(long long a, long long b) {\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = (res * a) % MOD;\n        a = (a * a) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    long long count = 0;\n    for (int i = 0; i < n; i++) {\n        int g = gcd(i, n);\n        count = (count + binexp(m, n / g)) % MOD;\n    }\n\n    count = (count * binexp(n, MOD - 2)) % MOD;\n    cout << count << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 10,
            "mean_time_taken": 0.11084649562835694,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                8,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Numbers",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nvector<vector<vector<int>>> dp(20, vector<vector<int>>(10, vector<int>(2, -1)));\n\nint count(long long n, int last_digit, bool tight) {\n    if (n == 0)\n        return 1;\n\n    int len = to_string(n).length();\n\n    if (dp[len][last_digit + 1][tight] != -1)\n        return dp[len][last_digit + 1][tight];\n\n    int ans = 0;\n    int limit = tight ? to_string(n)[0] - '0' : 9;\n\n    for (int i = 0; i <= limit; i++) {\n        if (last_digit == i)\n            continue;\n        ans = (ans + count(n % (long long)pow(10, len - 1), i, tight && (i == limit))) % MOD;\n    }\n\n    return dp[len][last_digit + 1][tight] = ans;\n}\n\nint main() {\n    long long a, b;\n    cin >> a >> b;\n    cout << (count(b, -1, true) - count(a - 1, -1, true) + MOD) % MOD << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Counting Paths",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nconst int MAXLOG = 20;\n\nvector<int> adj[MAXN];\nint up[MAXN][MAXLOG];\nint depth[MAXN];\nint cnt[MAXN];\n\nvoid dfs(int u, int p) {\n    depth[u] = depth[p] + 1;\n    up[u][0] = p;\n    for (int i = 1; i < MAXLOG; i++) {\n        up[u][i] = up[up[u][i-1]][i-1];\n    }\n    for (int v : adj[u]) {\n        if (v != p) {\n            dfs(v, u);\n        }\n    }\n}\n\nint lca(int u, int v) {\n    if (depth[u] < depth[v]) {\n        swap(u, v);\n    }\n    int diff = depth[u] - depth[v];\n    for (int i = MAXLOG - 1; i >= 0; i--) {\n        if (diff & (1 << i)) {\n            u = up[u][i];\n        }\n    }\n    if (u == v) {\n        return u;\n    }\n    for (int i = MAXLOG - 1; i >= 0; i--) {\n        if (up[u][i] != up[v][i]) {\n            u = up[u][i];\n            v = up[v][i];\n        }\n    }\n    return up[u][0];\n}\n\nvoid increment(int u, int v) {\n    int l = lca(u, v);\n    while (u != l) {\n        cnt[u]++;\n        u = up[u][0];\n    }\n    while (v != l) {\n        cnt[v]++;\n        v = up[v][0];\n    }\n    cnt[l]++;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(1, 0);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        increment(u, v);\n    }\n    for (int i = 1; i <= n; i++) {\n        cout << cnt[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 13,
            "mean_time_taken": 0.5109189657064584,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                5,
                6,
                8,
                10,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Patterns",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> computePrefix(const string& pattern) {\n    int m = pattern.length();\n    vector<int> prefix(m, 0);\n    int j = 0;\n    for (int i = 1; i < m; i++) {\n        while (j > 0 && pattern[i] != pattern[j]) {\n            j = prefix[j - 1];\n        }\n        if (pattern[i] == pattern[j]) {\n            j++;\n        }\n        prefix[i] = j;\n    }\n    return prefix;\n}\n\nint countOccurrences(const string& text, const string& pattern) {\n    int n = text.length();\n    int m = pattern.length();\n    vector<int> prefix = computePrefix(pattern);\n    int count = 0;\n    int j = 0;\n    for (int i = 0; i < n; i++) {\n        while (j > 0 && text[i] != pattern[j]) {\n            j = prefix[j - 1];\n        }\n        if (text[i] == pattern[j]) {\n            j++;\n        }\n        if (j == m) {\n            count++;\n            j = prefix[j - 1];\n        }\n    }\n    return count;\n}\n\nint main() {\n    string text;\n    cin >> text;\n    int k;\n    cin >> k;\n    vector<string> patterns(k);\n    for (int i = 0; i < k; i++) {\n        cin >> patterns[i];\n    }\n    for (const string& pattern : patterns) {\n        int count = countOccurrences(text, pattern);\n        cout << count << endl;\n    }\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 11,
            "mean_time_taken": 0.7732574289495294,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                7,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Reorders",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; i++) {\n        result = (result * i) % MOD;\n    }\n    return result;\n}\n\nint countReorders(string s) {\n    int n = s.length();\n    vector<int> freq(26, 0);\n    for (char c : s) {\n        freq[c - 'a']++;\n    }\n\n    long long result = factorial(n);\n    for (int i = 0; i < 26; i++) {\n        if (freq[i] > (n + 1) / 2) {\n            return 0;\n        }\n        result = (result * factorial(freq[i])) % MOD;\n    }\n\n    for (int i = 0; i < 26; i++) {\n        if (freq[i] > 1) {\n            long long arrangements = factorial(n - freq[i]);\n            arrangements = (arrangements * factorial(freq[i])) % MOD;\n            result = (result * arrangements) % MOD;\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    cout << countReorders(s) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 9,
            "mean_time_taken": 0.09000481499565972,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Rooms",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAXN = 1000;\n\nint n, m;\nchar grid[MAXN][MAXN];\nbool visited[MAXN][MAXN];\n\nvoid dfs(int x, int y) {\n    visited[x][y] = true;\n\n    // Check adjacent squares\n    int dx[] = {-1, 0, 1, 0};\n    int dy[] = {0, 1, 0, -1};\n\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n\n        if (nx >= 0 && nx < n && ny >= 0 && ny < m && grid[nx][ny] == '.' && !visited[nx][ny]) {\n            dfs(nx, ny);\n        }\n    }\n}\n\nint main() {\n    cin >> n >> m;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n            visited[i][j] = false;\n        }\n    }\n\n    int rooms = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == '.' && !visited[i][j]) {\n                rooms++;\n                dfs(i, j);\n            }\n        }\n    }\n\n    cout << rooms << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 15,
            "total_test_cases": 19,
            "mean_time_taken": 0.10995357914974815,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                7,
                8,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Sequences",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countSequences(int n, int k) {\n    vector<vector<int>> dp(n + 1, vector<int>(1 << k, 0));\n    dp[0][(1 << k) - 1] = 1;\n\n    for (int i = 1; i <= n; i++) {\n        for (int mask = 0; mask < (1 << k); mask++) {\n            for (int j = 1; j <= k; j++) {\n                if ((mask & (1 << (j - 1))) == 0) {\n                    dp[i][mask] = (dp[i][mask] + dp[i - 1][mask | (1 << (j - 1))]) % MOD;\n                }\n            }\n        }\n    }\n\n    return dp[n][(1 << k) - 1];\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    cout << countSequences(n, k) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.11636126041412354,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Tilings",
            "category": "Dynamic Programming",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countTilings(int n, int m) {\n    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\n\n    for (int j = 0; j <= m; j++) {\n        dp[0][j] = 1;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            dp[i][j] = dp[i - 1][j];\n            if (j >= 2) {\n                dp[i][j] = (dp[i][j] + dp[i][j - 2]) % MOD;\n            }\n        }\n    }\n\n    return dp[n][m];\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    cout << countTilings(n, m) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 15,
            "mean_time_taken": 0.08607672055562338,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                11,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Towers",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int t;\n    cin >> t;\n\n    vector<int> dp(1000001);\n    dp[1] = 2;\n    dp[2] = 8;\n\n    for (int i = 3; i <= 1000000; i++) {\n        dp[i] = (dp[i-1] + dp[i-2]) % MOD;\n    }\n\n    while (t--) {\n        int n;\n        cin >> n;\n        cout << dp[n] << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.10254991054534912,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Course Schedule",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> adj[100005];\nbool visited[100005];\nbool inStack[100005];\nvector<int> order;\n\nbool dfs(int node) {\n    visited[node] = true;\n    inStack[node] = true;\n    \n    for (int neighbor : adj[node]) {\n        if (inStack[neighbor]) {\n            return false;\n        }\n        if (!visited[neighbor] && !dfs(neighbor)) {\n            return false;\n        }\n    }\n    \n    inStack[node] = false;\n    order.push_back(node);\n    return true;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        if (!visited[i] && !dfs(i)) {\n            cout << \"IMPOSSIBLE\" << endl;\n            return 0;\n        }\n    }\n    \n    reverse(order.begin(), order.end());\n    \n    for (int course : order) {\n        cout << course << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 16,
            "mean_time_taken": 0.1280188411474228,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                5,
                6,
                8,
                9,
                10,
                11,
                12,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Course Schedule II",
            "category": "Additional Problems",
            "solution": "#include <vector>\n#include <queue>\n\nusing namespace std;\n\nvector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n    vector<vector<int>> graph(numCourses);\n    vector<int> inDegree(numCourses, 0);\n    \n    // Build the adjacency list and calculate in-degrees\n    for (const auto& prereq : prerequisites) {\n        int a = prereq[0];\n        int b = prereq[1];\n        graph[a].push_back(b);\n        inDegree[b]++;\n    }\n    \n    queue<int> q;\n    \n    // Enqueue courses with in-degree 0\n    for (int i = 0; i < numCourses; i++) {\n        if (inDegree[i] == 0) {\n            q.push(i);\n        }\n    }\n    \n    vector<int> order;\n    \n    while (!q.empty()) {\n        int course = q.front();\n        q.pop();\n        order.push_back(course);\n        \n        // Decrement in-degree of neighbors and enqueue if in-degree becomes 0\n        for (int neighbor : graph[course]) {\n            inDegree[neighbor]--;\n            if (inDegree[neighbor] == 0) {\n                q.push(neighbor);\n            }\n        }\n    }\n    \n    // Check if all courses are completed\n    if (order.size() == numCourses) {\n        return order;\n    } else {\n        return {};\n    }\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Creating Offices",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> adj[200005];\nvector<int> offices;\n\nint dfs(int u, int p, int depth) {\n    if (depth >= d) {\n        offices.push_back(u);\n        return 1;\n    }\n    \n    for (int v : adj[u]) {\n        if (v != p) {\n            if (dfs(v, u, depth + 1)) {\n                return 1;\n            }\n        }\n    }\n    \n    return 0;\n}\n\nint main() {\n    int n, d;\n    cin >> n >> d;\n    \n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        if (find(offices.begin(), offices.end(), i) == offices.end()) {\n            dfs(i, -1, 0);\n        }\n    }\n    \n    cout << offices.size() << endl;\n    for (int office : offices) {\n        cout << office << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Creating Strings",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <set>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nset<string> generatePermutations(string str) {\n    set<string> permutations;\n    generatePermutationsHelper(str, \"\", permutations);\n    return permutations;\n}\n\nvoid generatePermutationsHelper(string str, string current, set<string>& permutations) {\n    if (current.length() == str.length()) {\n        permutations.insert(current);\n        return;\n    }\n\n    for (char c : str) {\n        if (current.find(c) == string::npos) {\n            generatePermutationsHelper(str, current + c, permutations);\n        }\n    }\n}\n\nint main() {\n    string str;\n    cin >> str;\n\n    set<string> permutations = generatePermutations(str);\n    vector<string> result(permutations.begin(), permutations.end());\n    sort(result.begin(), result.end());\n\n    cout << result.size() << endl;\n    for (string s : result) {\n        cout << s << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Creating Strings II",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long modExp(long long base, long long exp) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1)\n            result = (result * base) % MOD;\n        base = (base * base) % MOD;\n        exp /= 2;\n    }\n    return result;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.length();\n\n    vector<int> count(26, 0);\n    for (char c : s)\n        count[c - 'a']++;\n\n    vector<long long> fact(n + 1, 1);\n    for (int i = 1; i <= n; i++)\n        fact[i] = (fact[i - 1] * i) % MOD;\n\n    long long denominator = 1;\n    for (int i = 0; i < 26; i++)\n        denominator = (denominator * fact[count[i]]) % MOD;\n\n    long long result = fact[n] * modExp(denominator, MOD - 2) % MOD;\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.09961207707722981,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Critical Cities",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nvector<int> adj[MAXN];\nbool reachable[MAXN], reachable_reverse[MAXN];\n\nvoid dfs(int u) {\n    reachable[u] = true;\n    for (int v : adj[u]) {\n        if (!reachable[v]) {\n            dfs(v);\n        }\n    }\n}\n\nvoid dfs_reverse(int u) {\n    reachable_reverse[u] = true;\n    for (int v : adj[u]) {\n        if (!reachable_reverse[v]) {\n            dfs_reverse(v);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n\n    dfs(1);\n    dfs_reverse(n);\n\n    vector<int> critical;\n    for (int i = 1; i <= n; i++) {\n        if (reachable[i] && reachable_reverse[i]) {\n            critical.push_back(i);\n        }\n    }\n\n    int k = critical.size();\n    cout << k << endl;\n    for (int city : critical) {\n        cout << city << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 14,
            "mean_time_taken": 0.13438825947897776,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Cut and Paste",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    string s;\n    cin >> s;\n\n    vector<pair<int, int>> operations;\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        operations.push_back({a, b});\n    }\n\n    for (auto op : operations) {\n        int a = op.first;\n        int b = op.second;\n        string substring = s.substr(a - 1, b - a + 1);\n        s.erase(a - 1, b - a + 1);\n        s.append(substring);\n    }\n\n    cout << s << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 7,
            "mean_time_taken": 0.38056860651288715,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Cycle Finding",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n    int a, b, c;\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<Edge> edges(m);\n    for (int i = 0; i < m; i++) {\n        cin >> edges[i].a >> edges[i].b >> edges[i].c;\n    }\n\n    vector<long long> dist(n + 1, LLONG_MAX);\n    dist[1] = 0;\n    vector<int> parent(n + 1, -1);\n\n    int last_node = -1;\n    for (int i = 0; i < n; i++) {\n        last_node = -1;\n        for (Edge e : edges) {\n            if (dist[e.a] + e.c < dist[e.b]) {\n                dist[e.b] = dist[e.a] + e.c;\n                parent[e.b] = e.a;\n                last_node = e.b;\n            }\n        }\n    }\n\n    if (last_node == -1) {\n        cout << \"NO\" << endl;\n    } else {\n        cout << \"YES\" << endl;\n        vector<int> cycle;\n        int node = last_node;\n        while (node != -1 && find(cycle.begin(), cycle.end(), node) == cycle.end()) {\n            cycle.push_back(node);\n            node = parent[node];\n        }\n        cycle.push_back(node);\n        reverse(cycle.begin(), cycle.end());\n        for (int i = 0; i < cycle.size(); i++) {\n            cout << cycle[i] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 11,
            "total_test_cases": 27,
            "mean_time_taken": 0.11355472494054723,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                5,
                7,
                9,
                11,
                12,
                13,
                14,
                17,
                18,
                19,
                21,
                23,
                24,
                25,
                26
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Cyclic Array",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    int count = 0;\n    long long sum = 0;\n    int j = 0;\n\n    // Concatenate the array with itself\n    for (int i = 0; i < 2 * n; i++) {\n        sum += arr[i % n];\n\n        while (sum > k) {\n            sum -= arr[j % n];\n            j++;\n        }\n\n        count++;\n    }\n\n    // Minimum number of subarrays is count / 2\n    cout << count / 2 << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 21,
            "mean_time_taken": 0.09408396766299293,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "De Bruijn Sequence",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstring deBruijnSequence(int n) {\n    int total = 1 << n;  // Total number of substrings (2^n)\n    vector<bool> visited(total, false);  // Track visited substrings\n    string sequence;\n\n    // Function to generate the De Bruijn sequence recursively\n    function<void(int, int)> generateSequence = [&](int current, int depth) {\n        if (depth == n) {\n            if (n == 1 || current != 0) {\n                sequence.push_back('0' + current);\n            }\n            return;\n        }\n\n        for (int i = 0; i < 2; i++) {\n            int next = (current << 1) | i;\n            if (!visited[next]) {\n                visited[next] = true;\n                generateSequence(next, depth + 1);\n                sequence.push_back('0' + i);\n            }\n        }\n    };\n\n    generateSequence(0, 0);\n    return sequence.substr(0, total + n - 1);  // Return the minimum-length sequence\n}\n\nint main() {\n    int n;\n    cin >> n;\n    string sequence = deBruijnSequence(n);\n    cout << sequence << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Dice Combinations",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int dp[n + 1];\n    dp[0] = 1;\n\n    for (int i = 1; i <= n; i++) {\n        dp[i] = 0;\n        for (int j = 1; j <= 6 && i - j >= 0; j++) {\n            dp[i] = (dp[i] + dp[i - j]) % MOD;\n        }\n    }\n\n    cout << dp[n] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 20,
            "total_test_cases": 20,
            "mean_time_taken": 0.09405692815780639,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Dice Probability",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <iomanip>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, a, b;\n    cin >> n >> a >> b;\n\n    vector<vector<long long>> dp(n+1, vector<long long>(6*n+1, 0));\n    dp[0][0] = 1;\n    for (int j = 1; j <= 6; j++) {\n        dp[1][j] = 1;\n    }\n\n    for (int i = 2; i <= n; i++) {\n        for (int j = i; j <= 6*i; j++) {\n            for (int k = 1; k <= 6; k++) {\n                if (j-k >= 0) {\n                    dp[i][j] += dp[i-1][j-k];\n                }\n            }\n        }\n    }\n\n    long long favorableOutcomes = 0;\n    for (int j = a; j <= b; j++) {\n        favorableOutcomes += dp[n][j];\n    }\n\n    long long totalOutcomes = 1;\n    for (int i = 0; i < n; i++) {\n        totalOutcomes *= 6;\n    }\n\n    double probability = static_cast<double>(favorableOutcomes) / totalOutcomes;\n    cout << fixed << setprecision(6) << probability << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 17,
            "mean_time_taken": 0.09190647742327522,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                5,
                6,
                9,
                11,
                15,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Digit Queries",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int q;\n    cin >> q;\n\n    while (q--) {\n        long long k;\n        cin >> k;\n\n        long long len = 1;\n        long long count = 9;\n        while (k > len * count) {\n            k -= len * count;\n            len++;\n            count *= 10;\n        }\n\n        long long num = (k - 1) / len;\n        long long pos = (k - 1) % len;\n        long long actual_num = pow(10, len - 1) + num;\n\n        string num_str = to_string(actual_num);\n        cout << num_str[pos] << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Distance Queries",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nconst int MAXLOG = 20;\n\nvector<int> adj[MAXN];\nint depth[MAXN];\nint parent[MAXN][MAXLOG];\n\nvoid dfs(int u, int p, int d) {\n    depth[u] = d;\n    parent[u][0] = p;\n    for (int v : adj[u]) {\n        if (v != p) {\n            dfs(v, u, d + 1);\n        }\n    }\n}\n\nvoid precompute(int n) {\n    for (int i = 1; i < MAXLOG; i++) {\n        for (int u = 1; u <= n; u++) {\n            parent[u][i] = parent[parent[u][i - 1]][i - 1];\n        }\n    }\n}\n\nint lca(int u, int v) {\n    if (depth[u] < depth[v]) {\n        swap(u, v);\n    }\n    int diff = depth[u] - depth[v];\n    for (int i = MAXLOG - 1; i >= 0; i--) {\n        if (diff & (1 << i)) {\n            u = parent[u][i];\n        }\n    }\n    if (u == v) {\n        return u;\n    }\n    for (int i = MAXLOG - 1; i >= 0; i--) {\n        if (parent[u][i] != parent[v][i]) {\n            u = parent[u][i];\n            v = parent[v][i];\n        }\n    }\n    return parent[u][0];\n}\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(1, 0, 0);\n    precompute(n);\n    while (q--) {\n        int u, v;\n        cin >> u >> v;\n        int lc = lca(u, v);\n        int dist = depth[u] + depth[v] - 2 * depth[lc];\n        cout << dist << endl;\n    }\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 11,
            "mean_time_taken": 0.2324671745300293,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Colors",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nvector<int> adj[MAXN];\nint color[MAXN];\nint answer[MAXN];\n\nvoid dfs(int node, int parent, unordered_set<int>& distinct_colors) {\n    for (int child : adj[node]) {\n        if (child != parent) {\n            dfs(child, node, distinct_colors);\n        }\n    }\n    distinct_colors.insert(color[node]);\n    answer[node] = distinct_colors.size();\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    for (int i = 1; i <= n; i++) {\n        cin >> color[i];\n    }\n\n    for (int i = 1; i < n; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    unordered_set<int> distinct_colors;\n    dfs(1, 0, distinct_colors);\n\n    for (int i = 1; i <= n; i++) {\n        cout << answer[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 15,
            "mean_time_taken": 0.22755287488301595,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Numbers",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <set>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    set<int> distinctValues;\n\n    for (int i = 0; i < n; i++) {\n        int value;\n        cin >> value;\n        distinctValues.insert(value);\n    }\n\n    cout << distinctValues.size() << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 15,
            "total_test_cases": 15,
            "mean_time_taken": 0.1506432056427002,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Distinct Routes",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<vector<int>> paths;\n\nvoid dfs(int u, int dest, vector<int>& path, vector<bool>& used) {\n    path.push_back(u);\n    if (u == dest) {\n        paths.push_back(path);\n    } else {\n        for (int v : adj[u]) {\n            if (!used[v]) {\n                used[v] = true;\n                dfs(v, dest, path, used);\n                used[v] = false;\n            }\n        }\n    }\n    path.pop_back();\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    adj.resize(n + 1);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n    vector<int> path;\n    vector<bool> used(n + 1, false);\n    dfs(1, n, path, used);\n    sort(paths.begin(), paths.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a.size() > b.size();\n    });\n    int k = paths.size();\n    cout << k << endl;\n    for (int i = 0; i < k; i++) {\n        cout << paths[i].size() << endl;\n        for (int j = 0; j < paths[i].size(); j++) {\n            cout << paths[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 18,
            "mean_time_taken": 0.30257532331678605,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                8,
                10,
                12,
                13,
                14,
                15,
                16,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Routes II",
            "category": "Advanced Techniques",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Distinct Substrings",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct TrieNode {\n    TrieNode* children[26];\n    TrieNode() {\n        for (int i = 0; i < 26; i++)\n            children[i] = nullptr;\n    }\n};\n\nint countDistinctSubstrings(string str) {\n    int n = str.length();\n    TrieNode* root = new TrieNode();\n    int count = 0;\n\n    for (int i = 0; i < n; i++) {\n        TrieNode* node = root;\n        for (int j = i; j < n; j++) {\n            int index = str[j] - 'a';\n            if (node->children[index] == nullptr) {\n                node->children[index] = new TrieNode();\n                count++;\n            }\n            node = node->children[index];\n        }\n    }\n\n    return count + 1; // +1 for empty substring\n}\n\nint main() {\n    string str;\n    cin >> str;\n    cout << countDistinctSubstrings(str) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 7,
            "mean_time_taken": 0.5390000683920724,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Values Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    vector<pair<int, int>> queries(q);\n    for (int i = 0; i < q; i++) {\n        int a, b;\n        cin >> a >> b;\n        queries[i] = {a, b};\n    }\n\n    vector<int> distinctCounts;\n    for (const auto& query : queries) {\n        int a = query.first;\n        int b = query.second;\n\n        unordered_set<int> distinctValues;\n        for (int i = a - 1; i <= b - 1; i++) {\n            distinctValues.insert(arr[i]);\n        }\n\n        distinctCounts.push_back(distinctValues.size());\n    }\n\n    for (int count : distinctCounts) {\n        cout << count << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 14,
            "mean_time_taken": 0.8427742038454328,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distributing Apples",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long factorial[2000001];\n\nlong long power(long long a, long long b) {\n    long long res = 1;\n    while (b) {\n        if (b & 1)\n            res = (res * a) % MOD;\n        a = (a * a) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nlong long modInverse(long long a) {\n    return power(a, MOD - 2);\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    factorial[0] = 1;\n    for (int i = 1; i <= n + m; i++) {\n        factorial[i] = (factorial[i - 1] * i) % MOD;\n    }\n\n    long long numerator = factorial[n + m - 1];\n    long long denominator = (factorial[m] * factorial[n - 1]) % MOD;\n    long long result = (numerator * modInverse(denominator)) % MOD;\n\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.09238079878000113,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Divisor Analysis",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long power(long long base, long long exp) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1)\n            result = (result * base) % MOD;\n        base = (base * base) % MOD;\n        exp /= 2;\n    }\n    return result;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    long long num_divisors = 1;\n    long long sum_divisors = 1;\n    long long product_divisors = 1;\n\n    for (int i = 0; i < n; i++) {\n        int x, k;\n        cin >> x >> k;\n\n        num_divisors = (num_divisors * (k + 1)) % MOD;\n\n        long long sum_term = (power(x, k + 1) - 1 + MOD) % MOD;\n        sum_term = (sum_term * power(x - 1, MOD - 2)) % MOD;\n        sum_divisors = (sum_divisors * sum_term) % MOD;\n\n        long long product_term = power(x, (k * (k + 1) / 2) % (MOD - 1));\n        product_divisors = (product_divisors * product_term) % MOD;\n    }\n\n    cout << num_divisors << \" \" << sum_divisors << \" \" << product_divisors << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 7,
            "mean_time_taken": 0.10532147543770927,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Download Speed",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nconst int INF = INT_MAX;\n\nint bfs(vector<vector<int>>& residualGraph, vector<int>& parent, int source, int sink) {\n    int n = residualGraph.size();\n    fill(parent.begin(), parent.end(), -1);\n    parent[source] = -2;\n    queue<pair<int, int>> q;\n    q.push({source, INF});\n\n    while (!q.empty()) {\n        int u = q.front().first;\n        int flow = q.front().second;\n        q.pop();\n\n        for (int v = 0; v < n; v++) {\n            if (parent[v] == -1 && residualGraph[u][v] > 0) {\n                parent[v] = u;\n                int newFlow = min(flow, residualGraph[u][v]);\n                if (v == sink)\n                    return newFlow;\n                q.push({v, newFlow});\n            }\n        }\n    }\n\n    return 0;\n}\n\nint maxFlow(vector<vector<int>>& graph, int source, int sink) {\n    int n = graph.size();\n    vector<vector<int>> residualGraph = graph;\n    vector<int> parent(n);\n    int maxFlow = 0;\n\n    while (int flow = bfs(residualGraph, parent, source, sink)) {\n        maxFlow += flow;\n        int v = sink;\n        while (v != source) {\n            int u = parent[v];\n            residualGraph[u][v] -= flow;\n            residualGraph[v][u] += flow;\n            v = u;\n        }\n    }\n\n    return maxFlow;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> graph(n, vector<int>(n, 0));\n\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--, b--;\n        graph[a][b] = c;\n    }\n\n    int maxDownloadSpeed = maxFlow(graph, 0, n - 1);\n    cout << maxDownloadSpeed << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 16,
            "total_test_cases": 21,
            "mean_time_taken": 0.15030889284043086,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                7,
                10,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Dynamic Connectivity",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass DisjointSet {\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n\npublic:\n    DisjointSet(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unionSets(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n};\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    DisjointSet ds(n);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        ds.unionSets(a, b);\n    }\n\n    int components = 0;\n    for (int i = 0; i < n; i++) {\n        if (ds.find(i) == i) {\n            components++;\n        }\n    }\n\n    cout << components << \" \";\n\n    for (int i = 0; i < k; i++) {\n        int t, a, b;\n        cin >> t >> a >> b;\n        a--, b--;\n\n        if (t == 1) {\n            if (ds.find(a) != ds.find(b)) {\n                ds.unionSets(a, b);\n                components--;\n            }\n        } else {\n            if (ds.find(a) == ds.find(b)) {\n                ds.unionSets(a, a);\n                components++;\n            }\n        }\n\n        cout << components << \" \";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 7,
            "mean_time_taken": 0.16756752559116908,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Dynamic Range Minimum Queries",
            "category": "Range Queries",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Dynamic Range Sum Queries",
            "category": "Range Queries",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Edit Distance",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint editDistance(const string& s1, const string& s2) {\n    int n = s1.length();\n    int m = s2.length();\n    vector<vector<int>> dp(n + 1, vector<int>(m + 1));\n\n    for (int i = 0; i <= n; i++) {\n        dp[i][0] = i;\n    }\n    for (int j = 0; j <= m; j++) {\n        dp[0][j] = j;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            if (s1[i - 1] == s2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = min(dp[i - 1][j] + 1, min(dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1));\n            }\n        }\n    }\n\n    return dp[n][m];\n}\n\nint main() {\n    string s1, s2;\n    cin >> s1 >> s2;\n    cout << editDistance(s1, s2) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 17,
            "total_test_cases": 17,
            "mean_time_taken": 0.2464456978966208,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Elevator Rides",
            "category": "Dynamic Programming",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nint solve(int n, int x, vector<int>& w) {\n    vector<int> dp(1 << n, INT_MAX);\n    dp[0] = 0;\n\n    for (int mask = 1; mask < (1 << n); mask++) {\n        int totalWeight = 0;\n        for (int i = 0; i < n; i++) {\n            if (mask & (1 << i)) {\n                totalWeight += w[i];\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (mask & (1 << i)) {\n                int newWeight = totalWeight - w[i];\n                if (newWeight <= x) {\n                    dp[mask] = min(dp[mask], dp[mask ^ (1 << i)] + 1);\n                }\n            }\n        }\n    }\n\n    return dp[(1 << n) - 1];\n}\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> w(n);\n    for (int i = 0; i < n; i++) {\n        cin >> w[i];\n    }\n\n    int minRides = solve(n, x, w);\n    cout << minRides << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 39,
            "mean_time_taken": 0.18529261075533354,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                35,
                36,
                37,
                38,
                39
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Empty String",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countWays(string s) {\n    int n = s.length();\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n\n    for (int len = 2; len <= n; len++) {\n        for (int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            if (s[i] == s[i+1]) {\n                dp[i][j] = (i+2 <= j ? dp[i+2][j] : 1) + 1;\n            }\n            for (int k = i; k < j; k++) {\n                dp[i][j] = (dp[i][j] + 1LL * dp[i][k] * dp[k+1][j]) % MOD;\n            }\n        }\n    }\n\n    return dp[0][n-1];\n}\n\nint main() {\n    string s;\n    cin >> s;\n    cout << countWays(s) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 12,
            "mean_time_taken": 0.1685421864191691,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Eulerian Subgraphs",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countEulerianSubgraphs(int n, const vector<vector<int>>& edges) {\n    vector<int> degree(n + 1, 0);\n\n    // Count the degree of each node\n    for (const auto& edge : edges) {\n        int u = edge[0], v = edge[1];\n        degree[u]++;\n        degree[v]++;\n    }\n\n    // Calculate the number of choices for each node\n    long long result = 1;\n    for (int i = 1; i <= n; i++) {\n        result = (result * (degree[i] / 2 + 1)) % MOD;\n    }\n\n    return result;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> edges(m, vector<int>(2));\n    for (int i = 0; i < m; i++) {\n        cin >> edges[i][0] >> edges[i][1];\n    }\n\n    int result = countEulerianSubgraphs(n, edges);\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 0.12581761678059897,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Even Outdegree Edges",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<pair<int, int>> edges(m);\n    for (int i = 0; i < m; i++) {\n        cin >> edges[i].first >> edges[i].second;\n    }\n\n    if (m % 2 != 0) {\n        cout << \"IMPOSSIBLE\" << endl;\n    } else {\n        for (int i = 0; i < m; i += 2) {\n            cout << edges[i].first << \" \" << edges[i].second << endl;\n            cout << edges[i + 1].second << \" \" << edges[i + 1].first << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 8,
            "mean_time_taken": 0.1680050492286682,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Exponentiation",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long modExp(long long a, long long b, long long MOD) {\n    if (b == 0) {\n        return 1;\n    }\n    if (b % 2 == 0) {\n        long long x = modExp(a, b / 2, MOD);\n        return (x * x) % MOD;\n    } else {\n        long long x = modExp(a, b - 1, MOD);\n        return (a * x) % MOD;\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    while (n--) {\n        long long a, b;\n        cin >> a >> b;\n        cout << modExp(a, b, MOD) << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 3,
            "mean_time_taken": 0.2445380687713623,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Exponentiation II",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long binExpMod(long long a, long long b, long long m) {\n    a %= m;\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = (res * a) % m;\n        a = (a * a) % m;\n        b >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    while (n--) {\n        long long a, b, c;\n        cin >> a >> b >> c;\n        if (a == 0 && b == 0)\n            cout << 1 << endl;\n        else {\n            long long exp = binExpMod(b, c, MOD - 1);\n            long long result = binExpMod(a, exp, MOD);\n            cout << result << endl;\n        }\n    }\n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 13,
            "mean_time_taken": 0.14760430042560285,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Factory Machines",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nlong long count_products(long long time, const vector<int>& k) {\n    long long count = 0;\n    for (int i = 0; i < k.size(); i++) {\n        count += time / k[i];\n    }\n    return count;\n}\n\nint main() {\n    int n, t;\n    cin >> n >> t;\n\n    vector<int> k(n);\n    for (int i = 0; i < n; i++) {\n        cin >> k[i];\n    }\n\n    long long low = 1;\n    long long high = *max_element(k.begin(), k.end()) * (long long)t;\n\n    while (low <= high) {\n        long long mid = (low + high) / 2;\n        long long count = count_products(mid, k);\n\n        if (count >= t) {\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n\n    cout << low << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 17,
            "total_test_cases": 18,
            "mean_time_taken": 0.1005634864171346,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Ferris Wheel",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> weights(n);\n    for (int i = 0; i < n; i++) {\n        cin >> weights[i];\n    }\n\n    sort(weights.begin(), weights.end());\n\n    int left = 0, right = n - 1;\n    int gondolas = 0;\n\n    while (left <= right) {\n        if (left == right) {\n            gondolas++;\n            break;\n        }\n\n        if (weights[left] + weights[right] <= x) {\n            left++;\n        }\n\n        right--;\n        gondolas++;\n    }\n\n    cout << gondolas << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.1285714552952693,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Fibonacci Numbers",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    long long n;\n    cin >> n;\n    \n    long long a = 0, b = 1;\n    \n    for (long long i = 0; i < n; i++) {\n        long long c = (a + b) % MOD;\n        a = b;\n        b = c;\n    }\n    \n    cout << a << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 12,
            "mean_time_taken": 0.5668445030848185,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                7,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Filling Trominos",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MAXN = 100;\nchar grid[MAXN][MAXN];\n\nvoid fill_tromino(int row, int col, int size, char ch) {\n    if (size == 1) {\n        grid[row][col] = ch;\n        return;\n    }\n\n    int half_size = size / 2;\n    char ch1 = ch, ch2 = ch + 1, ch3 = ch + 2, ch4 = ch + 3;\n\n    fill_tromino(row, col, half_size, ch1);\n    fill_tromino(row, col + half_size, half_size, ch2);\n    fill_tromino(row + half_size, col, half_size, ch3);\n    fill_tromino(row + half_size, col + half_size, half_size, ch4);\n\n    if (size == 2) {\n        grid[row + 1][col] = ch1;\n        grid[row][col + 1] = ch2;\n        grid[row + 1][col + 1] = ch3;\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n\n        if ((n * m) % 3 != 0) {\n            cout << \"NO\\n\";\n        } else {\n            cout << \"YES\\n\";\n            fill_tromino(0, 0, max(n, m), 'A');\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    cout << grid[i][j];\n                }\n                cout << \"\\n\";\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.10088711977005005,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding Borders",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> computeFailureFunction(const string& s) {\n    int n = s.length();\n    vector<int> f(n);\n    f[0] = 0;\n    \n    for (int i = 1; i < n; i++) {\n        int j = f[i - 1];\n        while (j > 0 && s[i] != s[j])\n            j = f[j - 1];\n        if (s[i] == s[j])\n            j++;\n        f[i] = j;\n    }\n    \n    return f;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    \n    vector<int> f = computeFailureFunction(s);\n    vector<int> borderLengths;\n    \n    for (int i = 1; i < s.length(); i++) {\n        if (f[i] > 0)\n            borderLengths.push_back(f[i]);\n    }\n    \n    sort(borderLengths.begin(), borderLengths.end());\n    \n    for (int len : borderLengths)\n        cout << len << \" \";\n    \n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 11,
            "mean_time_taken": 0.18041437322443182,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding Patterns",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    string s;\n    cin >> s;\n\n    int k;\n    cin >> k;\n\n    vector<string> patterns(k);\n    for (int i = 0; i < k; i++) {\n        cin >> patterns[i];\n    }\n\n    for (const string& pattern : patterns) {\n        if (s.find(pattern) != string::npos) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 15,
            "total_test_cases": 17,
            "mean_time_taken": 0.35681453873129454,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                8,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding Periods",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> computeLPS(string pattern) {\n    int m = pattern.length();\n    vector<int> lps(m);\n    int len = 0;\n    lps[0] = 0;\n    int i = 1;\n    while (i < m) {\n        if (pattern[i] == pattern[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        } else {\n            if (len != 0) {\n                len = lps[len - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    return lps;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.length();\n    vector<int> lps = computeLPS(s);\n    vector<int> periods;\n    int period = n - lps[n - 1];\n    while (period <= n) {\n        if (n % period == 0) {\n            periods.push_back(period);\n        }\n        if (lps[n - 1] == 0) {\n            break;\n        }\n        n = lps[n - 1];\n        period = n - lps[n - 1];\n    }\n    for (int i = 0; i < periods.size(); i++) {\n        cout << periods[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 14,
            "mean_time_taken": 0.11004274232046944,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding a Centroid",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nvector<int> adj[MAXN];\nint subtree_size[MAXN];\nint n;\n\nvoid dfs(int u, int parent) {\n    subtree_size[u] = 1;\n    for (int v : adj[u]) {\n        if (v != parent) {\n            dfs(v, u);\n            subtree_size[u] += subtree_size[v];\n        }\n    }\n}\n\nint find_centroid() {\n    dfs(1, 0);\n    for (int u = 1; u <= n; u++) {\n        bool is_centroid = true;\n        for (int v : adj[u]) {\n            if (subtree_size[v] > n / 2) {\n                is_centroid = false;\n                break;\n            }\n        }\n        if (is_centroid && (n - subtree_size[u]) <= n / 2) {\n            return u;\n        }\n    }\n    return -1; // No centroid found (should not happen for a valid tree)\n}\n\nint main() {\n    cin >> n;\n    for (int i = 1; i < n; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    int centroid = find_centroid();\n    cout << centroid << endl;\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 16,
            "mean_time_taken": 0.1495857983827591,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Fixed-Length Paths I",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<vector<int>> adj;\nint cnt = 0;\n\nvoid dfs(int node, int parent, int pathLen, int k) {\n    if (pathLen == k) {\n        cnt++;\n        return;\n    }\n    \n    for (int neighbor : adj[node]) {\n        if (neighbor != parent) {\n            dfs(neighbor, node, pathLen + 1, k);\n        }\n    }\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    \n    adj.resize(n + 1);\n    \n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        dfs(i, -1, 0, k);\n    }\n    \n    cout << cnt / 2 << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 9,
            "total_test_cases": 20,
            "mean_time_taken": 0.6078458070755005,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                8,
                9,
                12,
                16,
                18,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Fixed-Length Paths II",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<vector<int>> adj;\nint ans = 0;\n\nvoid dfs(int u, int parent, int depth, int k1, int k2) {\n    if (depth >= k1 && depth <= k2) {\n        ans++;\n    }\n    if (depth > k2) {\n        return;\n    }\n    for (int v : adj[u]) {\n        if (v != parent) {\n            dfs(v, u, depth + 1, k1, k2);\n        }\n    }\n}\n\nint main() {\n    int n, k1, k2;\n    cin >> n >> k1 >> k2;\n\n    adj.resize(n + 1);\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    for (int i = 1; i <= n; i++) {\n        dfs(i, -1, 0, k1, k2);\n    }\n\n    cout << ans / 2 << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 23,
            "mean_time_taken": 0.5826651739037555,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                14,
                16,
                19,
                20,
                21,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Flight Discount",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\ntypedef pair<long long, int> pli;\n\nlong long dijkstra(int start, int end, vector<vector<pli>>& graph) {\n    int n = graph.size();\n    vector<long long> dist(n, LLONG_MAX);\n    vector<long long> dist_coupon(n, LLONG_MAX);\n\n    priority_queue<pli, vector<pli>, greater<pli>> pq;\n    pq.push({0, start});\n    dist[start] = 0;\n\n    while (!pq.empty()) {\n        int u = pq.top().second;\n        long long cost = pq.top().first;\n        pq.pop();\n\n        if (u == end)\n            return min(dist[end], dist_coupon[end]);\n\n        if (cost > dist_coupon[u])\n            continue;\n\n        for (auto& edge : graph[u]) {\n            int v = edge.second;\n            long long weight = edge.first;\n\n            if (cost + weight < dist[v]) {\n                dist[v] = cost + weight;\n                pq.push({dist[v], v});\n            }\n\n            long long coupon_cost = cost + weight / 2;\n            if (coupon_cost < dist_coupon[v]) {\n                dist_coupon[v] = coupon_cost;\n                pq.push({dist_coupon[v], v});\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<pli>> graph(n);\n\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--, b--;\n        graph[a].push_back({c, b});\n    }\n\n    long long min_cost = dijkstra(0, n - 1, graph);\n    cout << min_cost << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 24,
            "mean_time_taken": 0.1489331821600596,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Flight Route Requests",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid dfs(int city, vector<bool>& visited, vector<vector<int>>& adj) {\n    visited[city] = true;\n    for (int neighbor : adj[city]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, visited, adj);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> adj(n + 1);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n\n    int totalConnections = 0;\n    for (int city = 1; city <= n; city++) {\n        vector<bool> visited(n + 1, false);\n        dfs(city, visited, adj);\n\n        int connections = 0;\n        for (int neighbor : adj[city]) {\n            if (!visited[neighbor]) {\n                connections++;\n            }\n        }\n        totalConnections += connections;\n    }\n\n    cout << totalConnections << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 17,
            "mean_time_taken": 0.29151258749120373,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Flight Routes",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef pair<int, vector<int>> piv;\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<vector<pii>> graph(n + 1);\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        graph[a].push_back({b, c});\n    }\n\n    priority_queue<piv, vector<piv>, greater<piv>> pq;\n    pq.push({0, {1}});\n\n    vector<int> prices;\n    while (!pq.empty() && prices.size() < k) {\n        auto [price, route] = pq.top();\n        pq.pop();\n\n        int last_city = route.back();\n        if (last_city == n) {\n            prices.push_back(price);\n        }\n\n        if (prices.size() == k) {\n            break;\n        }\n\n        for (auto [neighbor, flight_price] : graph[last_city]) {\n            vector<int> new_route = route;\n            new_route.push_back(neighbor);\n            pq.push({price + flight_price, new_route});\n        }\n    }\n\n    for (int price : prices) {\n        cout << price << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 17,
            "mean_time_taken": 0.6209666308234719,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                5,
                6,
                7,
                8,
                9,
                11,
                14,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Flight Routes Check",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nvector<int> adj[MAXN];\nbool visited[MAXN];\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n\n    for (int i = 1; i <= n; i++) {\n        fill(visited, visited + n + 1, false);\n        dfs(i);\n\n        for (int j = 1; j <= n; j++) {\n            if (!visited[j]) {\n                cout << \"NO\" << endl;\n                cout << i << \" \" << j << endl;\n                return 0;\n            }\n        }\n    }\n\n    cout << \"YES\" << endl;\n    return 0;\n}\n",
            "passed_test_cases": 14,
            "total_test_cases": 20,
            "mean_time_taken": 0.3865662932395935,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                6,
                8,
                14,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Food Division",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    vector<int> b(n);\n    for (int i = 0; i < n; i++) {\n        cin >> b[i];\n    }\n\n    vector<int> diff(n);\n    for (int i = 0; i < n; i++) {\n        diff[i] = a[i] - b[i];\n    }\n\n    int steps = 0;\n    for (int i = 0; i < n; i++) {\n        if (diff[i] > 0) {\n            steps += diff[i];\n        } else {\n            steps -= diff[i];\n        }\n    }\n\n    cout << steps / 2 << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 5,
            "mean_time_taken": 0.11299762725830079,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Forbidden Cities",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nvector<int> adj[MAXN];\nbool visited[MAXN];\n\nbool dfs(int curr, int dest, int forbidden) {\n    if (curr == forbidden)\n        return false;\n    if (curr == dest)\n        return true;\n    \n    visited[curr] = true;\n    \n    for (int next : adj[curr]) {\n        if (!visited[next] && dfs(next, dest, forbidden))\n            return true;\n    }\n    \n    return false;\n}\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    \n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    \n    while (q--) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        \n        fill(visited, visited + n + 1, false);\n        \n        if (dfs(a, b, c))\n            cout << \"YES\\n\";\n        else\n            cout << \"NO\\n\";\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 9,
            "total_test_cases": 14,
            "mean_time_taken": 0.4336705207824707,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                5,
                6,
                8,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Forest Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<vector<char>> forest(n, vector<char>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> forest[i][j];\n        }\n    }\n\n    vector<vector<int>> prefix_sum(n + 1, vector<int>(n + 1, 0));\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            prefix_sum[i][j] = (forest[i - 1][j - 1] == '*') + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1];\n        }\n    }\n\n    while (q--) {\n        int y1, x1, y2, x2;\n        cin >> y1 >> x1 >> y2 >> x2;\n\n        int trees = prefix_sum[y2][x2] - prefix_sum[y1 - 1][x2] - prefix_sum[y2][x1 - 1] + prefix_sum[y1 - 1][x1 - 1];\n        cout << trees << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 3,
            "mean_time_taken": 0.22847827275594076,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Forest Queries II",
            "category": "Range Queries",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Functional Graph Distribution",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<vector<long long>> stirling(n + 1, vector<long long>(n + 1, 0));\n    stirling[0][0] = 1;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= i; j++) {\n            stirling[i][j] = (stirling[i - 1][j - 1] + j * stirling[i - 1][j]) % MOD;\n        }\n    }\n\n    for (int k = 1; k <= n; k++) {\n        long long result = stirling[n][k];\n        for (int i = 0; i < n; i++) {\n            result = (result * k) % MOD;\n        }\n        cout << result << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.16139519214630127,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Game Routes",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countRoutes(int n, vector<vector<int>>& teleporters) {\n    vector<vector<int>> adj(n + 1);\n    for (const auto& t : teleporters) {\n        adj[t[0]].push_back(t[1]);\n    }\n\n    vector<int> dp(n + 1, 0);\n    dp[1] = 1;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j : adj[i]) {\n            dp[j] = (dp[j] + dp[i]) % MOD;\n        }\n    }\n\n    return dp[n];\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> teleporters(m, vector<int>(2));\n    for (int i = 0; i < m; i++) {\n        cin >> teleporters[i][0] >> teleporters[i][1];\n    }\n\n    int ways = countRoutes(n, teleporters);\n    cout << ways << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 15,
            "mean_time_taken": 0.13584294319152831,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                5,
                6,
                8,
                9,
                10,
                11,
                12,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Giant Pizza",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<pair<char, int>>> wishes(n, vector<pair<char, int>>(2));\n    for (int i = 0; i < n; i++) {\n        char sign1, sign2;\n        int topping1, topping2;\n        cin >> sign1 >> topping1 >> sign2 >> topping2;\n        wishes[i][0] = {sign1, topping1};\n        wishes[i][1] = {sign2, topping2};\n    }\n\n    vector<char> toppings(m, '-');\n\n    for (int i = 0; i < n; i++) {\n        bool satisfied = false;\n        for (int j = 0; j < 2; j++) {\n            char sign = wishes[i][j].first;\n            int topping = wishes[i][j].second - 1;\n            if ((sign == '+' && toppings[topping] == '+') || (sign == '-' && toppings[topping] == '-')) {\n                satisfied = true;\n                break;\n            }\n        }\n        if (!satisfied) {\n            char sign = wishes[i][0].first;\n            int topping = wishes[i][0].second - 1;\n            if (toppings[topping] != '-' && toppings[topping] != sign) {\n                cout << \"IMPOSSIBLE\" << endl;\n                return 0;\n            }\n            toppings[topping] = sign;\n        }\n    }\n\n    for (char topping : toppings) {\n        cout << topping;\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 22,
            "mean_time_taken": 0.10547679120844061,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Graph Girth",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint bfs(int start, vector<vector<int>>& adj, vector<int>& dist) {\n    queue<int> q;\n    q.push(start);\n    dist[start] = 0;\n\n    while (!q.empty()) {\n        int curr = q.front();\n        q.pop();\n\n        for (int neighbor : adj[curr]) {\n            if (dist[neighbor] == INF) {\n                dist[neighbor] = dist[curr] + 1;\n                q.push(neighbor);\n            } else if (dist[neighbor] >= dist[curr]) {\n                return dist[curr] + dist[neighbor] + 1;\n            }\n        }\n    }\n\n    return INF;\n}\n\nint findGirth(int n, vector<vector<int>>& adj) {\n    int girth = INF;\n\n    for (int i = 1; i <= n; i++) {\n        vector<int> dist(n + 1, INF);\n        int cycleLen = bfs(i, adj, dist);\n        girth = min(girth, cycleLen);\n    }\n\n    return (girth == INF) ? -1 : girth;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> adj(n + 1);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    int girth = findGirth(n, adj);\n    cout << girth << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 17,
            "total_test_cases": 20,
            "mean_time_taken": 0.15049535036087036,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                10,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Graph Paths I",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countPaths(int u, int k, vector<vector<int>>& adj) {\n    if (k == 0) {\n        return u == adj.size() - 1;\n    }\n    \n    int count = 0;\n    for (int v = 0; v < adj.size(); v++) {\n        if (adj[u][v]) {\n            count = (count + countPaths(v, k - 1, adj)) % MOD;\n        }\n    }\n    \n    return count;\n}\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n    \n    vector<vector<int>> adj(n, vector<int>(n, 0));\n    \n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a - 1][b - 1] = 1;\n    }\n    \n    cout << countPaths(0, k, adj) << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 14,
            "mean_time_taken": 0.11459810393197196,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                7,
                8,
                10,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Graph Paths II",
            "category": "Mathematics",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<vector<pair<int, int>>> graph(n + 1);\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        graph[a].push_back({b, c});\n    }\n\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1, INF));\n    dp[1][0] = 0;\n\n    for (int j = 1; j <= k; j++) {\n        for (int i = 1; i <= n; i++) {\n            for (auto [u, w] : graph[i]) {\n                if (j > 0) {\n                    dp[u][j] = min(dp[u][j], dp[i][j - 1] + w);\n                }\n            }\n        }\n    }\n\n    int ans = dp[n][k];\n    if (ans == INF) ans = -1;\n    cout << ans << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 15,
            "mean_time_taken": 0.12644664446512857,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                9,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Gray Code",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid generateGrayCode(int n, vector<string>& grayCode) {\n    if (n == 1) {\n        grayCode.push_back(\"0\");\n        grayCode.push_back(\"1\");\n        return;\n    }\n\n    generateGrayCode(n - 1, grayCode);\n\n    int size = grayCode.size();\n    for (int i = size - 1; i >= 0; i--) {\n        grayCode.push_back(grayCode[i]);\n    }\n\n    for (int i = 0; i < size; i++) {\n        grayCode[i] = \"0\" + grayCode[i];\n    }\n\n    for (int i = size; i < 2 * size; i++) {\n        grayCode[i] = \"1\" + grayCode[i];\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<string> grayCode;\n    generateGrayCode(n, grayCode);\n\n    for (string code : grayCode) {\n        cout << code << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 16,
            "total_test_cases": 16,
            "mean_time_taken": 0.09373582899570465,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Grid Completion",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countWays(vector<string>& grid, int row, int col, vector<bool>& rowA, vector<bool>& rowB, vector<bool>& colA, vector<bool>& colB) {\n    int n = grid.size();\n    \n    if (row == n) {\n        return 1;\n    }\n    \n    if (col == n) {\n        return countWays(grid, row + 1, 0, rowA, rowB, colA, colB);\n    }\n    \n    if (grid[row][col] == 'A') {\n        rowA[row] = true;\n        colA[col] = true;\n        return countWays(grid, row, col + 1, rowA, rowB, colA, colB);\n    }\n    \n    if (grid[row][col] == 'B') {\n        rowB[row] = true;\n        colB[col] = true;\n        return countWays(grid, row, col + 1, rowA, rowB, colA, colB);\n    }\n    \n    int ways = 0;\n    \n    if (!rowA[row] && !colA[col]) {\n        rowA[row] = true;\n        colA[col] = true;\n        ways = (ways + countWays(grid, row, col + 1, rowA, rowB, colA, colB)) % MOD;\n        rowA[row] = false;\n        colA[col] = false;\n    }\n    \n    if (!rowB[row] && !colB[col]) {\n        rowB[row] = true;\n        colB[col] = true;\n        ways = (ways + countWays(grid, row, col + 1, rowA, rowB, colA, colB)) % MOD;\n        rowB[row] = false;\n        colB[col] = false;\n    }\n    \n    return ways;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<string> grid(n);\n    for (int i = 0; i < n; i++) {\n        cin >> grid[i];\n    }\n    \n    vector<bool> rowA(n, false), rowB(n, false), colA(n, false), colB(n, false);\n    \n    int ways = countWays(grid, 0, 0, rowA, rowB, colA, colB);\n    \n    cout << ways << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.09748625755310059,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Path Construction",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n, m, y1, x1, y2, x2;\n        cin >> n >> m >> y1 >> x1 >> y2 >> x2;\n\n        if ((y1 != y2 || x1 != x2) && n * m > 1) {\n            cout << \"YES\\n\";\n\n            string path = \"\";\n            int x = x1, y = y1;\n\n            // Move horizontally\n            while (x != x2) {\n                path += (x < x2) ? 'R' : 'L';\n                x += (x < x2) ? 1 : -1;\n            }\n\n            // Move vertically\n            while (y != y2) {\n                path += (y < y2) ? 'D' : 'U';\n                y += (y < y2) ? 1 : -1;\n            }\n\n            // Fill remaining squares\n            int dx[] = {1, -1, -1, 1};\n            int dy[] = {1, 1, -1, -1};\n            int dir = 0;\n\n            while (path.length() < n * m) {\n                int nx = x + dx[dir];\n                int ny = y + dy[dir];\n\n                if (nx < 1 || nx > m || ny < 1 || ny > n) {\n                    dir = (dir + 1) % 4;\n                    continue;\n                }\n\n                path += (dx[dir] == 1) ? 'R' : ((dx[dir] == -1) ? 'L' : ((dy[dir] == 1) ? 'D' : 'U'));\n                x = nx;\n                y = ny;\n            }\n\n            cout << path << \"\\n\";\n        } else {\n            cout << \"NO\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 20,
            "mean_time_taken": 0.13573219776153564,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Paths",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint gridPaths(int n, vector<vector<int>>& traps) {\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n    \n    // Mark the cells with traps as -1\n    for (const auto& trap : traps) {\n        int y = trap[0], x = trap[1];\n        dp[y][x] = -1;\n    }\n    \n    // Set the bottom-right cell as 1\n    dp[n][n] = 1;\n    \n    // Iterate over the cells in reverse order\n    for (int i = n - 1; i >= 1; i--) {\n        for (int j = n - 1; j >= 1; j--) {\n            if (dp[i][j] == -1) continue; // Skip traps\n            \n            // Calculate the number of paths from the current cell\n            dp[i][j] = (dp[i + 1][j] + dp[i][j + 1]) % MOD;\n            if (dp[i][j] < 0) dp[i][j] += MOD;\n        }\n    }\n    \n    return dp[1][1];\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<vector<int>> traps(m, vector<int>(2));\n    for (int i = 0; i < m; i++) {\n        cin >> traps[i][0] >> traps[i][1];\n    }\n    \n    int result = gridPaths(n, traps);\n    cout << result << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 20,
            "mean_time_taken": 0.16679303646087645,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                19
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Paths",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nconst int GRID_SIZE = 7;\n\nint countPaths(string& desc, int row, int col, int index) {\n    if (row == GRID_SIZE - 1 && col == 0 && index == desc.length()) {\n        return 1;\n    }\n    \n    if (row < 0 || row >= GRID_SIZE || col < 0 || col >= GRID_SIZE || index >= desc.length()) {\n        return 0;\n    }\n    \n    char ch = desc[index];\n    int count = 0;\n    \n    if (ch == '?' || ch == 'D') {\n        count += countPaths(desc, row + 1, col, index + 1);\n    }\n    if (ch == '?' || ch == 'U') {\n        count += countPaths(desc, row - 1, col, index + 1);\n    }\n    if (ch == '?' || ch == 'L') {\n        count += countPaths(desc, row, col - 1, index + 1);\n    }\n    if (ch == '?' || ch == 'R') {\n        count += countPaths(desc, row, col + 1, index + 1);\n    }\n    \n    return count;\n}\n\nint main() {\n    string desc;\n    cin >> desc;\n    \n    int totalPaths = countPaths(desc, 0, 0, 0);\n    cout << totalPaths << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 20,
            "mean_time_taken": 1.0403676629066467,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Paths",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint gridPaths(int n, vector<string>& grid) {\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n    \n    if (grid[0][0] == '.') {\n        dp[0][0] = 1;\n    }\n    \n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == '*') {\n                dp[i][j] = 0;\n            } else {\n                dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD;\n            }\n        }\n    }\n    \n    return dp[n-1][n-1];\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<string> grid(n);\n    for (int i = 0; i < n; i++) {\n        cin >> grid[i];\n    }\n    \n    int result = gridPaths(n, grid);\n    cout << result << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 20,
            "mean_time_taken": 0.10910391807556152,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                6,
                7,
                8,
                10,
                11,
                12,
                13,
                14,
                16,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Puzzle I",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int a[n], b[n];\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> b[i];\n    }\n\n    char grid[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            grid[i][j] = '.';\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < a[i]; j++) {\n            grid[i][j] = 'X';\n            b[j]--;\n        }\n    }\n\n    for (int j = 0; j < n; j++) {\n        if (b[j] != 0) {\n            cout << \"-1\" << endl;\n            return 0;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << grid[i][j];\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 12,
            "mean_time_taken": 0.0913145939509074,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                6,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        }
    ],
    "total_passed_problems": 22,
    "initial_config": {
        "ignore_time_limits": false,
        "model": "claude-3-opus-20240229",
        "provider": "anthropic",
        "categories": [],
        "shots": 1
    }
}