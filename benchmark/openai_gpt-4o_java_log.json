{
    "problems": [
        {
            "title": "Acyclic Graph Edges",
            "category": "Additional Problems",
            "solution": "import java.util.*;\n\npublic class AcyclicGraphEdges {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        \n        List<List<Integer>> adj = new ArrayList<>();\n        List<int[]> edges = new ArrayList<>();\n        \n        for (int i = 0; i <= n; i++) {\n            adj.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < m; i++) {\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            adj.get(a).add(b);\n            adj.get(b).add(a);\n            edges.add(new int[]{a, b});\n        }\n        \n        int[] inDegree = new int[n + 1];\n        List<Integer> topoOrder = topologicalSort(n, adj, inDegree);\n        \n        if (topoOrder.size() != n) {\n            System.out.println(\"Graph is not acyclic\");\n            return;\n        }\n        \n        Map<Integer, Integer> position = new HashMap<>();\n        for (int i = 0; i < topoOrder.size(); i++) {\n            position.put(topoOrder.get(i), i);\n        }\n        \n        for (int[] edge : edges) {\n            int a = edge[0];\n            int b = edge[1];\n            if (position.get(a) < position.get(b)) {\n                System.out.println(a + \" \" + b);\n            } else {\n                System.out.println(b + \" \" + a);\n            }\n        }\n    }\n    \n    private static List<Integer> topologicalSort(int n, List<List<Integer>> adj, int[] inDegree) {\n        List<Integer> order = new ArrayList<>();\n        Queue<Integer> queue = new LinkedList<>();\n        \n        for (int i = 1; i <= n; i++) {\n            for (int v : adj.get(i)) {\n                inDegree[v]++;\n            }\n        }\n        \n        for (int i = 1; i <= n; i++) {\n            if (inDegree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n        \n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            order.add(u);\n            \n            for (int v : adj.get(u)) {\n                inDegree[v]--;\n                if (inDegree[v] == 0) {\n                    queue.offer(v);\n                }\n            }\n        }\n        \n        return order;\n    }\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.10366803407669067,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Advertisement",
            "category": "Additional Problems",
            "solution": "import java.util.Scanner;\nimport java.util.Stack;\n\npublic class Advertisement {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] heights = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            heights[i] = scanner.nextInt();\n        }\n        \n        System.out.println(maxRectangleArea(heights));\n    }\n    \n    public static int maxRectangleArea(int[] heights) {\n        Stack<Integer> stack = new Stack<>();\n        int maxArea = 0;\n        int index = 0;\n        \n        while (index < heights.length) {\n            if (stack.isEmpty() || heights[stack.peek()] <= heights[index]) {\n                stack.push(index++);\n            } else {\n                int height = heights[stack.pop()];\n                int width = stack.isEmpty() ? index : index - stack.peek() - 1;\n                maxArea = Math.max(maxArea, height * width);\n            }\n        }\n        \n        while (!stack.isEmpty()) {\n            int height = heights[stack.pop()];\n            int width = stack.isEmpty() ? index : index - stack.peek() - 1;\n            maxArea = Math.max(maxArea, height * width);\n        }\n        \n        return maxArea;\n    }\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 11,
            "mean_time_taken": 0.09785962104797363,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Another Game",
            "category": "Mathematics",
            "solution": "import java.util.Scanner;\n\npublic class AnotherGame {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int t = sc.nextInt();  // number of test cases\n        \n        for (int i = 0; i < t; i++) {\n            int n = sc.nextInt();  // number of heaps\n            long totalCoins = 0;  // to store the sum of coins in each heap\n            \n            for (int j = 0; j < n; j++) {\n                totalCoins += sc.nextInt();\n            }\n            \n            // Determine the winner\n            if (totalCoins % 2 == 1) {\n                System.out.println(\"first\");\n            } else {\n                System.out.println(\"second\");\n            }\n        }\n        \n        sc.close();\n    }\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 0.0987549622853597,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Apartments",
            "category": "Sorting and Searching",
            "solution": "import java.util.*;\n\npublic class Apartments {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        // Read n, m, and k\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int k = scanner.nextInt();\n\n        // Read desired apartment sizes of applicants\n        int[] applicants = new int[n];\n        for (int i = 0; i < n; i++) {\n            applicants[i] = scanner.nextInt();\n        }\n\n        // Read sizes of available apartments\n        int[] apartments = new int[m];\n        for (int i = 0; i < m; i++) {\n            apartments[i] = scanner.nextInt();\n        }\n\n        // Sort both arrays\n        Arrays.sort(applicants);\n        Arrays.sort(apartments);\n\n        // Two pointers technique\n        int i = 0, j = 0;\n        int count = 0;\n        \n        while (i < n && j < m) {\n            if (apartments[j] < applicants[i] - k) {\n                // Apartment is too small, move to the next apartment\n                j++;\n            } else if (apartments[j] > applicants[i] + k) {\n                // Apartment is too big, move to the next applicant\n                i++;\n            } else {\n                // Apartment is suitable\n                count++;\n                i++;\n                j++;\n            }\n        }\n\n        // Output the result\n        System.out.println(count);\n\n        scanner.close();\n    }\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 19,
            "mean_time_taken": 0.10533271337810315,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Apple Division",
            "category": "Introductory Problems",
            "solution": "import java.util.Scanner;\n\npublic class AppleDivision {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] weights = new int[n];\n        for (int i = 0; i < n; i++) {\n            weights[i] = scanner.nextInt();\n        }\n        scanner.close();\n        \n        long totalSum = 0;\n        for (int weight : weights) {\n            totalSum += weight;\n        }\n\n        long minDifference = Long.MAX_VALUE;\n        \n        // There are 2^n possible subsets\n        int totalSubsets = 1 << n;\n        \n        for (int i = 0; i < totalSubsets; i++) {\n            long subsetSum = 0;\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) != 0) {\n                    subsetSum += weights[j];\n                }\n            }\n            long currentDifference = Math.abs((totalSum - subsetSum) - subsetSum);\n            minDifference = Math.min(minDifference, currentDifference);\n        }\n        \n        System.out.println(minDifference);\n    }\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 18,
            "mean_time_taken": 0.1063325007756551,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Apples and Bananas",
            "category": "Advanced Techniques",
            "solution": "import java.util.Scanner;\n\npublic class ApplesAndBananas {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Read k, n, m\n        int k = sc.nextInt();\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        \n        // Read apples weights\n        int[] apples = new int[n];\n        for (int i = 0; i < n; i++) {\n            apples[i] = sc.nextInt();\n        }\n        \n        // Read bananas weights\n        int[] bananas = new int[m];\n        for (int i = 0; i < m; i++) {\n            bananas[i] = sc.nextInt();\n        }\n\n        // Frequency arrays\n        int[] appleCount = new int[k + 1];\n        int[] bananaCount = new int[k + 1];\n        \n        // Fill frequency arrays\n        for (int i = 0; i < n; i++) {\n            appleCount[apples[i]]++;\n        }\n        \n        for (int i = 0; i < m; i++) {\n            bananaCount[bananas[i]]++;\n        }\n        \n        // Result array for sums from 2 to 2k\n        int[] result = new int[2 * k + 1];\n        \n        // Calculate the number of ways for each possible sum\n        for (int i = 1; i <= k; i++) {\n            for (int j = 1; j <= k; j++) {\n                result[i + j] += appleCount[i] * bananaCount[j];\n            }\n        }\n        \n        // Print the results for sums from 2 to 2k\n        for (int w = 2; w <= 2 * k; w++) {\n            System.out.print(result[w] + \" \");\n        }\n    }\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.10434365272521973,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Area of Rectangles",
            "category": "Additional Problems",
            "solution": "import java.util.*;\n\npublic class UnionAreaOfRectangles {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        List<Event> events = new ArrayList<>();\n        Set<Integer> yCoords = new TreeSet<>();\n        \n        for (int i = 0; i < n; i++) {\n            int x1 = sc.nextInt();\n            int y1 = sc.nextInt();\n            int x2 = sc.nextInt();\n            int y2 = sc.nextInt();\n            events.add(new Event(x1, y1, y2, 1));\n            events.add(new Event(x2, y1, y2, -1));\n            yCoords.add(y1);\n            yCoords.add(y2);\n        }\n\n        List<Integer> yList = new ArrayList<>(yCoords);\n        Collections.sort(yList);\n        Map<Integer, Integer> yMap = new HashMap<>();\n        for (int i = 0; i < yList.size(); i++) {\n            yMap.put(yList.get(i), i);\n        }\n\n        Collections.sort(events);\n\n        SegmentTree segmentTree = new SegmentTree(yList.size());\n        long totalArea = 0;\n        int prevX = events.get(0).x;\n\n        for (Event event : events) {\n            int currX = event.x;\n            totalArea += (long) segmentTree.query() * (currX - prevX);\n            segmentTree.update(yMap.get(event.y1), yMap.get(event.y2), event.type);\n            prevX = currX;\n        }\n\n        System.out.println(totalArea);\n    }\n}\n\nclass Event implements Comparable<Event> {\n    int x, y1, y2, type;\n\n    Event(int x, int y1, int y2, int type) {\n        this.x = x;\n        this.y1 = y1;\n        this.y2 = y2;\n        this.type = type;\n    }\n\n    public int compareTo(Event other) {\n        if (this.x != other.x) {\n            return this.x - other.x;\n        }\n        return this.type - other.type; // Ensure start event comes before end event at same x\n    }\n}\n\nclass SegmentTree {\n    private int[] count, length;\n    private int n;\n\n    SegmentTree(int n) {\n        this.n = n;\n        count = new int[4 * n];\n        length = new int[4 * n];\n    }\n\n    public void update(int l, int r, int type) {\n        update(0, 0, n - 1, l, r - 1, type);\n    }\n\n    private void update(int node, int start, int end, int l, int r, int type) {\n        if (start > r || end < l) {\n            return;\n        }\n        if (start >= l && end <= r) {\n            count[node] += type;\n        } else {\n            int mid = (start + end) / 2;\n            update(2 * node + 1, start, mid, l, r, type);\n            update(2 * node + 2, mid + 1, end, l, r, type);\n        }\n        if (count[node] > 0) {\n            length[node] = end - start + 1;\n        } else if (start == end) {\n            length[node] = 0;\n        } else {\n            length[node] = length[2 * node + 1] + length[2 * node + 2];\n        }\n    }\n\n    public int query() {\n        return length[0];\n    }\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.10243479410807292,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Array Description",
            "category": "Dynamic Programming",
            "solution": "import java.util.Scanner;\n\npublic class ArrayDescription {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int MOD = 1000000007;\n        \n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[] x = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            x[i] = scanner.nextInt();\n        }\n\n        long[][] dp = new long[n][m + 1];\n\n        // Initialize the first row of dp table\n        if (x[0] == 0) {\n            for (int j = 1; j <= m; j++) {\n                dp[0][j] = 1;\n            }\n        } else {\n            dp[0][x[0]] = 1;\n        }\n\n        // Fill the dp table\n        for (int i = 1; i < n; i++) {\n            if (x[i] == 0) {\n                for (int j = 1; j <= m; j++) {\n                    dp[i][j] = (dp[i-1][j] + (j > 1 ? dp[i-1][j-1] : 0) + (j < m ? dp[i-1][j+1] : 0)) % MOD;\n                }\n            } else {\n                int j = x[i];\n                dp[i][j] = (dp[i-1][j] + (j > 1 ? dp[i-1][j-1] : 0) + (j < m ? dp[i-1][j+1] : 0)) % MOD;\n            }\n        }\n\n        // Calculate the result\n        long result = 0;\n        for (int j = 1; j <= m; j++) {\n            result = (result + dp[n-1][j]) % MOD;\n        }\n\n        System.out.println(result);\n    }\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 29,
            "mean_time_taken": 0.10691394477054991,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Array Division",
            "category": "Sorting and Searching",
            "solution": "import java.util.Scanner;\n\npublic class ArrayDivision {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int k = scanner.nextInt();\n        int[] array = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            array[i] = scanner.nextInt();\n        }\n        \n        System.out.println(minimizeMaxSubarraySum(array, n, k));\n    }\n    \n    private static long minimizeMaxSubarraySum(int[] array, int n, int k) {\n        long left = 0;\n        long right = 0;\n        \n        for (int num : array) {\n            left = Math.max(left, num);\n            right += num;\n        }\n        \n        while (left < right) {\n            long mid = left + (right - left) / 2;\n            if (canDivide(array, n, k, mid)) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        \n        return left;\n    }\n    \n    private static boolean canDivide(int[] array, int n, int k, long maxSum) {\n        int subarrayCount = 1;\n        long currentSum = 0;\n        \n        for (int num : array) {\n            if (currentSum + num > maxSum) {\n                subarrayCount++;\n                currentSum = num;\n                if (subarrayCount > k) {\n                    return false;\n                }\n            } else {\n                currentSum += num;\n            }\n        }\n        \n        return true;\n    }\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 18,
            "mean_time_taken": 0.10493384467230903,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Beautiful Subgrids",
            "category": "Advanced Techniques",
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\npublic class BeautifulSubgrids {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        \n        int n = Integer.parseInt(br.readLine());\n        int[][] grid = new int[n][n];\n        \n        for (int i = 0; i < n; i++) {\n            String line = br.readLine();\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = line.charAt(j) - '0';\n            }\n        }\n        \n        long count = 0;\n\n        // Iterate over all pairs of rows\n        for (int row1 = 0; row1 < n; row1++) {\n            for (int row2 = row1 + 1; row2 < n; row2++) {\n                int commonBlackCols = 0;\n\n                for (int col = 0; col < n; col++) {\n                    if (grid[row1][col] == 1 && grid[row2][col] == 1) {\n                        commonBlackCols++;\n                    }\n                }\n\n                if (commonBlackCols > 1) {\n                    count += (long) commonBlackCols * (commonBlackCols - 1) / 2;\n                }\n            }\n        }\n        \n        System.out.println(count);\n    }\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.09855896234512329,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Binary Subsequences",
            "category": "Additional Problems",
            "solution": "import java.util.Scanner;\n\npublic class BinarySubsequences {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        scanner.close();\n\n        // Find the smallest k such that 2^k - 1 >= n\n        int k = 1;\n        while ((1 << k) - 1 < n) {\n            k++;\n        }\n\n        // Generate any bit string of length k. For simplicity, we use '1's followed by '0's\n        StringBuilder bitString = new StringBuilder();\n        for (int i = 0; i < k; i++) {\n            bitString.append((i & 1) == 0 ? '1' : '0'); // Alternating pattern\n        }\n\n        System.out.println(bitString.toString());\n    }\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.09972602128982544,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        }
    ],
    "total_passed_problems": 0,
    "initial_config": {
        "ignore_time_limits": false,
        "model": "gpt-4o",
        "provider": "openai",
        "categories": [],
        "shots": 1
    }
}