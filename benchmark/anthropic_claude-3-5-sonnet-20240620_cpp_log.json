{
    "problems": [
        {
            "title": "Acyclic Graph Edges",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<pair<int, int>> edges(m);\n\n    // Read all edges\n    for (int i = 0; i < m; i++) {\n        cin >> edges[i].first >> edges[i].second;\n    }\n\n    // Output directed edges\n    for (const auto& edge : edges) {\n        int a = edge.first;\n        int b = edge.second;\n        if (a < b) {\n            cout << a << \" \" << b << \"\\n\";\n        } else {\n            cout << b << \" \" << a << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 4,
            "mean_time_taken": 0.10752099752426147,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 1,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Advertisement",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nlong long largestRectangleArea(vector<int>& heights) {\n    stack<int> s;\n    long long maxArea = 0;\n    heights.push_back(0);  // Add a sentinel value to handle the remaining stack at the end\n    int n = heights.size();\n\n    for (int i = 0; i < n; i++) {\n        while (!s.empty() && heights[s.top()] > heights[i]) {\n            int height = heights[s.top()];\n            s.pop();\n            int width = s.empty() ? i : i - s.top() - 1;\n            maxArea = max(maxArea, (long long)height * width);\n        }\n        s.push(i);\n    }\n\n    return maxArea;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> heights(n);\n    for (int i = 0; i < n; i++) {\n        cin >> heights[i];\n    }\n\n    cout << largestRectangleArea(heights) << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.10220683704723012,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Another Game",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid solve_test_case() {\n    int n;\n    cin >> n;\n    \n    int odd_count = 0;\n    for (int i = 0; i < n; ++i) {\n        int x;\n        cin >> x;\n        if (x % 2 == 1) {\n            ++odd_count;\n        }\n    }\n    \n    if (odd_count % 2 == 1) {\n        cout << \"first\\n\";\n    } else {\n        cout << \"second\\n\";\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        solve_test_case();\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 3,
            "mean_time_taken": 0.09580779075622559,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Apartments",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<int> applicants(n);\n    vector<int> apartments(m);\n\n    // Read applicants' desired sizes\n    for (int i = 0; i < n; i++) {\n        cin >> applicants[i];\n    }\n\n    // Read apartment sizes\n    for (int i = 0; i < m; i++) {\n        cin >> apartments[i];\n    }\n\n    // Sort both lists\n    sort(applicants.begin(), applicants.end());\n    sort(apartments.begin(), apartments.end());\n\n    int matches = 0;\n    int i = 0, j = 0;\n\n    // Match applicants with apartments\n    while (i < n && j < m) {\n        if (abs(applicants[i] - apartments[j]) <= k) {\n            // Match found\n            matches++;\n            i++;\n            j++;\n        } else if (applicants[i] < apartments[j]) {\n            // Current apartment is too large, move to next applicant\n            i++;\n        } else {\n            // Current apartment is too small, move to next apartment\n            j++;\n        }\n    }\n\n    // Output the result\n    cout << matches << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 19,
            "total_test_cases": 19,
            "mean_time_taken": 0.1367991472545423,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Apple Division",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<long long> weights(n);\n    long long total_sum = 0;\n    \n    for (int i = 0; i < n; i++) {\n        cin >> weights[i];\n        total_sum += weights[i];\n    }\n    \n    long long min_diff = LLONG_MAX;\n    \n    // Iterate through all possible combinations\n    for (int mask = 0; mask < (1 << n); mask++) {\n        long long group1_sum = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (mask & (1 << i)) {\n                group1_sum += weights[i];\n            }\n        }\n        \n        long long group2_sum = total_sum - group1_sum;\n        long long diff = abs(group1_sum - group2_sum);\n        \n        min_diff = min(min_diff, diff);\n    }\n    \n    cout << min_diff << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 18,
            "total_test_cases": 18,
            "mean_time_taken": 0.10601421197255452,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Apples and Bananas",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int k, n, m;\n    cin >> k >> n >> m;\n\n    // Step 1: Count occurrences of weights for apples and bananas\n    vector<int> apple_count(k + 1, 0);\n    vector<int> banana_count(k + 1, 0);\n\n    for (int i = 0; i < n; i++) {\n        int weight;\n        cin >> weight;\n        apple_count[weight]++;\n    }\n\n    for (int i = 0; i < m; i++) {\n        int weight;\n        cin >> weight;\n        banana_count[weight]++;\n    }\n\n    // Step 2: Calculate the number of ways for each combined weight\n    for (int w = 2; w <= 2 * k; w++) {\n        long long ways = 0;\n        for (int apple_weight = 1; apple_weight <= k && apple_weight < w; apple_weight++) {\n            int banana_weight = w - apple_weight;\n            if (banana_weight <= k) {\n                ways += (long long)apple_count[apple_weight] * banana_count[banana_weight];\n            }\n        }\n        cout << ways << \" \";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 6,
            "mean_time_taken": 0.7195210854212443,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Area of Rectangles",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nstruct Event {\n    int x, y1, y2;\n    bool is_start;\n    Event(int x, int y1, int y2, bool is_start) : x(x), y1(y1), y2(y2), is_start(is_start) {}\n};\n\nbool compare_events(const Event& a, const Event& b) {\n    return a.x < b.x || (a.x == b.x && a.is_start > b.is_start);\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<Event> events;\n    for (int i = 0; i < n; i++) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        events.emplace_back(x1, y1, y2, true);\n        events.emplace_back(x2, y1, y2, false);\n    }\n\n    sort(events.begin(), events.end(), compare_events);\n\n    long long total_area = 0;\n    int prev_x = events[0].x;\n    multiset<pair<int, int>> active_intervals;\n    int active_length = 0;\n\n    for (const auto& event : events) {\n        // Calculate area between previous and current x\n        total_area += (long long)active_length * (event.x - prev_x);\n\n        if (event.is_start) {\n            active_intervals.insert({event.y1, event.y2});\n        } else {\n            active_intervals.erase(active_intervals.find({event.y1, event.y2}));\n        }\n\n        // Recalculate active length\n        active_length = 0;\n        int current_end = -1;\n        for (const auto& interval : active_intervals) {\n            if (interval.first > current_end) {\n                active_length += interval.second - interval.first;\n                current_end = interval.second;\n            } else if (interval.second > current_end) {\n                active_length += interval.second - current_end;\n                current_end = interval.second;\n            }\n        }\n\n        prev_x = event.x;\n    }\n\n    cout << total_area << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 15,
            "mean_time_taken": 0.2929461638132731,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                8,
                9,
                10,
                11,
                12,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Array Description",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<int> x(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i];\n    }\n    \n    vector<vector<int>> dp(n, vector<int>(m + 1, 0));\n    \n    // Initialize the first row\n    if (x[0] == 0) {\n        for (int j = 1; j <= m; j++) {\n            dp[0][j] = 1;\n        }\n    } else {\n        dp[0][x[0]] = 1;\n    }\n    \n    // Fill the DP table\n    for (int i = 1; i < n; i++) {\n        if (x[i] == 0) {\n            for (int j = 1; j <= m; j++) {\n                for (int k = max(1, j - 1); k <= min(m, j + 1); k++) {\n                    dp[i][j] = (dp[i][j] + dp[i-1][k]) % MOD;\n                }\n            }\n        } else {\n            for (int k = max(1, x[i] - 1); k <= min(m, x[i] + 1); k++) {\n                dp[i][x[i]] = (dp[i][x[i]] + dp[i-1][k]) % MOD;\n            }\n        }\n    }\n    \n    // Sum up the final result\n    int result = 0;\n    for (int j = 1; j <= m; j++) {\n        result = (result + dp[n-1][j]) % MOD;\n    }\n    \n    cout << result << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 29,
            "total_test_cases": 29,
            "mean_time_taken": 0.13430842037858634,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 5,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Array Division",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool check(const vector<long long>& arr, int k, long long max_sum) {\n    int count = 1;\n    long long current_sum = 0;\n    for (long long num : arr) {\n        if (num > max_sum) return false;\n        if (current_sum + num > max_sum) {\n            count++;\n            current_sum = num;\n        } else {\n            current_sum += num;\n        }\n    }\n    return count <= k;\n}\n\nlong long binary_search(const vector<long long>& arr, int k) {\n    long long left = *max_element(arr.begin(), arr.end());\n    long long right = 0;\n    for (long long num : arr) right += num;\n    \n    while (left < right) {\n        long long mid = left + (right - left) / 2;\n        if (check(arr, k, mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    \n    vector<long long> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    \n    cout << binary_search(arr, k) << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 18,
            "total_test_cases": 18,
            "mean_time_taken": 0.11987895435757107,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Beautiful Subgrids",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<uint64_t> grid(n, 0);\n    \n    // Read input and create bitset representation\n    for (int i = 0; i < n; i++) {\n        string row;\n        cin >> row;\n        for (int j = 0; j < n; j++) {\n            if (row[j] == '1') {\n                grid[i] |= (1ULL << j);\n            }\n        }\n    }\n\n    long long count = 0;\n\n    // Iterate through all pairs of rows\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            uint64_t common = grid[i] & grid[j];\n            int bits = __builtin_popcountll(common);\n            count += (bits * (bits - 1)) / 2;\n        }\n    }\n\n    cout << count << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 8,
            "mean_time_taken": 0.1851693093776703,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Binary Subsequences",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring solve(int n) {\n    string result = \"\";\n    \n    // Handle the case where n is a power of 2\n    if ((n & (n-1)) == 0) {\n        result += '1';\n        n--;\n    }\n    \n    // Build the string from least significant bit to most significant bit\n    while (n > 0) {\n        if (n & 1) {\n            result += '1';\n        } else {\n            result += '0';\n        }\n        n >>= 1;\n    }\n    \n    // Reverse the string as we built it from right to left\n    reverse(result.begin(), result.end());\n    \n    return result;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    cout << solve(n) << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 12,
            "mean_time_taken": 0.08427182833353679,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Binomial Coefficients",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int MAX_N = 1e6 + 1;\n\nvector<long long> fact(MAX_N), inv_fact(MAX_N);\n\nlong long pow_mod(long long base, long long exp) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp & 1) result = (result * base) % MOD;\n        base = (base * base) % MOD;\n        exp >>= 1;\n    }\n    return result;\n}\n\nvoid precompute() {\n    fact[0] = inv_fact[0] = 1;\n    for (int i = 1; i < MAX_N; i++) {\n        fact[i] = (fact[i-1] * i) % MOD;\n        inv_fact[i] = pow_mod(fact[i], MOD - 2);\n    }\n}\n\nlong long binomial_coefficient(int a, int b) {\n    if (b > a) return 0;\n    return (((fact[a] * inv_fact[b]) % MOD) * inv_fact[a-b]) % MOD;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    precompute();\n\n    int n;\n    cin >> n;\n\n    while (n--) {\n        int a, b;\n        cin >> a >> b;\n        cout << binomial_coefficient(a, b) << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.19282241301103073,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Bit Inversions",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <set>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.length();\n    \n    set<int> changes;\n    changes.insert(0);\n    changes.insert(n);\n    \n    for (int i = 1; i < n; i++) {\n        if (s[i] != s[i-1]) {\n            changes.insert(i);\n        }\n    }\n    \n    int m;\n    cin >> m;\n    \n    auto get_max_length = [&]() {\n        int max_length = 0;\n        auto it = changes.begin();\n        int prev = *it;\n        it++;\n        for (; it != changes.end(); it++) {\n            max_length = max(max_length, *it - prev);\n            prev = *it;\n        }\n        return max_length;\n    };\n    \n    while (m--) {\n        int x;\n        cin >> x;\n        x--;  // 0-based indexing\n        \n        if (changes.count(x)) {\n            changes.erase(x);\n        } else {\n            changes.insert(x);\n        }\n        \n        cout << get_max_length() << \" \";\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.574431300163269,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bit Problem",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nconst int MAX_X = 1e6 + 5;\nconst int MAX_BIT = 20;\n\nint n;\nint arr[MAX_N];\nint freq[MAX_X];\nlong long bit_count[MAX_BIT][2];\n\nvoid precompute() {\n    memset(freq, 0, sizeof(freq));\n    memset(bit_count, 0, sizeof(bit_count));\n\n    for (int i = 0; i < n; i++) {\n        freq[arr[i]]++;\n        for (int j = 0; j < MAX_BIT; j++) {\n            bit_count[j][(arr[i] >> j) & 1]++;\n        }\n    }\n}\n\nvoid solve(int x) {\n    long long or_count = 0, and_count = 0, non_zero_and = 0;\n\n    for (int i = 0; i < MAX_BIT; i++) {\n        if ((x >> i) & 1) {\n            or_count += bit_count[i][1];\n            and_count += bit_count[i][0];\n        } else {\n            non_zero_and += bit_count[i][1];\n        }\n    }\n\n    or_count = n - or_count + freq[x];\n    and_count += freq[x];\n    non_zero_and = n - (and_count - freq[x]);\n\n    cout << or_count << \" \" << and_count << \" \" << non_zero_and << \"\\n\";\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    precompute();\n\n    for (int i = 0; i < n; i++) {\n        solve(arr[i]);\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.12198150157928467,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bit Strings",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n;\n    cin >> n;\n\n    long long result = 1;\n    for (int i = 0; i < n; i++) {\n        result = (result * 2) % MOD;\n    }\n\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.08378853400548299,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Bit Substrings",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.length();\n\n    vector<long long> count(n + 1, 0);\n    int total_zeros = 0;\n    int total_ones = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] == '1') {\n            for (int j = total_ones + 1; j > 0; j--) {\n                count[j] += total_zeros + 1;\n            }\n            total_ones++;\n        } else {\n            total_zeros++;\n        }\n    }\n\n    // Add the count of substrings with 0 ones\n    count[0] = (long long)n * (n + 1) / 2 - accumulate(count.begin() + 1, count.end(), 0LL);\n\n    for (int i = 0; i <= n; i++) {\n        cout << count[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Book Shop",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> price(n + 1), pages(n + 1);\n    for (int i = 1; i <= n; i++) cin >> price[i];\n    for (int i = 1; i <= n; i++) cin >> pages[i];\n\n    // Create and initialize DP table\n    vector<vector<int>> dp(n + 1, vector<int>(x + 1, 0));\n\n    // Fill DP table\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= x; j++) {\n            dp[i][j] = dp[i-1][j]; // Don't buy this book\n            if (j >= price[i]) {\n                // Buy this book if we have enough money\n                dp[i][j] = max(dp[i][j], dp[i-1][j-price[i]] + pages[i]);\n            }\n        }\n    }\n\n    // Print the result\n    cout << dp[n][x] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 15,
            "mean_time_taken": 0.6052419026692708,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                7,
                9,
                11,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Book Shop II",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n    \n    vector<int> h(n), s(n), k(n);\n    \n    for(int i = 0; i < n; i++) cin >> h[i];\n    for(int i = 0; i < n; i++) cin >> s[i];\n    for(int i = 0; i < n; i++) cin >> k[i];\n    \n    vector<int> dp(x + 1, 0);\n    \n    for(int i = 0; i < n; i++) {\n        vector<int> new_dp = dp;\n        for(int j = 1; j <= k[i]; j++) {\n            int cost = j * h[i];\n            int pages = j * s[i];\n            for(int m = x; m >= cost; m--) {\n                new_dp[m] = max(new_dp[m], dp[m - cost] + pages);\n            }\n        }\n        dp = new_dp;\n    }\n    \n    cout << dp[x] << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 10,
            "mean_time_taken": 0.5687710046768188,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bracket Sequences I",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst long long MOD = 1e9 + 7;\n\nlong long modPow(long long base, long long exp) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp & 1) result = (result * base) % MOD;\n        base = (base * base) % MOD;\n        exp >>= 1;\n    }\n    return result;\n}\n\nlong long modInverse(long long n) {\n    return modPow(n, MOD - 2);\n}\n\nlong long nCr(long long n, long long r) {\n    if (r > n) return 0;\n    vector<long long> fact(n + 1, 1);\n    for (int i = 2; i <= n; i++) {\n        fact[i] = (fact[i - 1] * i) % MOD;\n    }\n    return (fact[n] * modInverse((fact[r] * fact[n - r]) % MOD)) % MOD;\n}\n\nint main() {\n    long long n;\n    cin >> n;\n\n    if (n % 2 != 0) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    n /= 2;\n    long long catalan = nCr(2 * n, n);\n    catalan = (catalan * modInverse(n + 1)) % MOD;\n\n    cout << catalan << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 17,
            "total_test_cases": 17,
            "mean_time_taken": 0.0837392666760613,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Bracket Sequences II",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n;\n    string prefix;\n    cin >> n >> prefix;\n\n    int k = prefix.length();\n    int open = 0, closed = 0;\n\n    // Check if prefix is valid\n    for (char c : prefix) {\n        if (c == '(') open++;\n        else closed++;\n        if (closed > open) {\n            cout << 0 << endl;\n            return 0;\n        }\n    }\n\n    int remaining = n - k;\n    int initial_balance = open - closed;\n\n    // DP table\n    vector<vector<long long>> dp(remaining + 1, vector<long long>(n + 1, 0));\n    dp[0][initial_balance] = 1;\n\n    for (int i = 1; i <= remaining; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (j > 0) {\n                dp[i][j] = (dp[i][j] + dp[i-1][j-1]) % MOD;\n            }\n            if (open + j < n/2) {\n                dp[i][j] = (dp[i][j] + dp[i-1][j+1]) % MOD;\n            }\n        }\n    }\n\n    cout << dp[remaining][0] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 11,
            "mean_time_taken": 0.17522764205932617,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                8,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Building Roads",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass DSU {\n    vector<int> parent, rank;\npublic:\n    DSU(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; i++) parent[i] = i;\n    }\n    \n    int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    \n    void unite(int x, int y) {\n        int px = find(x), py = find(y);\n        if (px == py) return;\n        if (rank[px] < rank[py]) parent[px] = py;\n        else if (rank[px] > rank[py]) parent[py] = px;\n        else {\n            parent[py] = px;\n            rank[px]++;\n        }\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    DSU dsu(n);\n    \n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        dsu.unite(a-1, b-1);  // 0-based indexing\n    }\n    \n    vector<int> components;\n    for (int i = 0; i < n; i++) {\n        if (dsu.find(i) == i) {\n            components.push_back(i);\n        }\n    }\n    \n    int new_roads = components.size() - 1;\n    cout << new_roads << endl;\n    \n    for (int i = 1; i < components.size(); i++) {\n        cout << components[i-1] + 1 << \" \" << components[i] + 1 << endl;\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 12,
            "mean_time_taken": 0.1112182339032491,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Building Teams",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int UNASSIGNED = 0;\n\nbool dfs(int pupil, int team, vector<vector<int>>& friends, vector<int>& teams) {\n    teams[pupil] = team;\n    \n    for (int friend_ : friends[pupil]) {\n        if (teams[friend_] == team) return false;\n        if (teams[friend_] == UNASSIGNED && !dfs(friend_, 3 - team, friends, teams)) return false;\n    }\n    \n    return true;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<vector<int>> friends(n + 1);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        friends[a].push_back(b);\n        friends[b].push_back(a);\n    }\n    \n    vector<int> teams(n + 1, UNASSIGNED);\n    \n    for (int i = 1; i <= n; i++) {\n        if (teams[i] == UNASSIGNED) {\n            if (!dfs(i, 1, friends, teams)) {\n                cout << \"IMPOSSIBLE\" << endl;\n                return 0;\n            }\n        }\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        cout << teams[i] << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.13266351222991943,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Candy Lottery",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    double result = 0.0;\n    for (int x = 1; x <= k; x++) {\n        double prob = pow((double)(x - 1) / k, n);\n        result += 1.0 - prob;\n    }\n\n    cout << fixed << setprecision(6) << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.08237172876085554,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Chess Tournament",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<pair<int, int>> players(n);\n    for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        players[i] = {x, i + 1};\n    }\n    \n    sort(players.rbegin(), players.rend());\n    \n    vector<pair<int, int>> games;\n    set<int> available;\n    for (int i = 1; i <= n; i++) {\n        available.insert(i);\n    }\n    \n    for (auto& player : players) {\n        int games_wanted = player.first;\n        int player_id = player.second;\n        \n        available.erase(player_id);\n        \n        for (auto it = available.begin(); games_wanted > 0 && it != available.end(); ) {\n            games.push_back({player_id, *it});\n            it = available.erase(it);\n            games_wanted--;\n        }\n        \n        if (games_wanted > 0) {\n            cout << \"IMPOSSIBLE\" << endl;\n            return 0;\n        }\n    }\n    \n    cout << games.size() << endl;\n    for (auto& game : games) {\n        cout << game.first << \" \" << game.second << endl;\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 21,
            "mean_time_taken": 0.11943509465172178,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Chessboard and Queens",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> board(8);\nint solutions = 0;\n\nbool canPlace(int row, int col) {\n    // Check column\n    for (int i = 0; i < row; i++)\n        if (board[i][col] == 'Q') return false;\n    \n    // Check upper-left diagonal\n    for (int i = row, j = col; i >= 0 && j >= 0; i--, j--)\n        if (board[i][j] == 'Q') return false;\n    \n    // Check upper-right diagonal\n    for (int i = row, j = col; i >= 0 && j < 8; i--, j++)\n        if (board[i][j] == 'Q') return false;\n    \n    return true;\n}\n\nvoid solve(int row) {\n    if (row == 8) {\n        solutions++;\n        return;\n    }\n    \n    for (int col = 0; col < 8; col++) {\n        if (board[row][col] == '.' && canPlace(row, col)) {\n            board[row][col] = 'Q';\n            solve(row + 1);\n            board[row][col] = '.';  // Backtrack\n        }\n    }\n}\n\nint main() {\n    // Read input\n    for (int i = 0; i < 8; i++)\n        cin >> board[i];\n    \n    // Solve\n    solve(0);\n    \n    // Print result\n    cout << solutions << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.08442976474761962,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Christmas Party",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<long long> dp(n + 1, 0);\n    dp[0] = 1;\n    dp[1] = 0;\n\n    for (int i = 2; i <= n; i++) {\n        dp[i] = ((i - 1) * (dp[i-1] + dp[i-2])) % MOD;\n    }\n\n    cout << dp[n] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 15,
            "total_test_cases": 15,
            "mean_time_taken": 0.08501470883687337,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Coding Company",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int MAXN = 100;\nconst int MAXX = 5000;\n\nint n, x;\nint skill[MAXN];\nlong long dp[1 << 20][20][101];\n\nint main() {\n    cin >> n >> x;\n    for (int i = 0; i < n; i++) {\n        cin >> skill[i];\n    }\n    \n    sort(skill, skill + n);\n    \n    dp[0][0][0] = 1;\n    \n    for (int mask = 0; mask < (1 << n); mask++) {\n        for (int last = 0; last < n; last++) {\n            for (int penalty = 0; penalty <= x; penalty++) {\n                if (dp[mask][last][penalty] == 0) continue;\n                \n                int next = last;\n                while (next < n && (mask & (1 << next))) next++;\n                \n                if (next == n) continue;\n                \n                for (int end = next; end < n; end++) {\n                    if (mask & (1 << end)) continue;\n                    \n                    int new_penalty = penalty + skill[end] - skill[next];\n                    if (new_penalty > x) break;\n                    \n                    int new_mask = mask | ((1 << end) - (1 << next));\n                    dp[new_mask][end][new_penalty] += dp[mask][last][penalty];\n                    dp[new_mask][end][new_penalty] %= MOD;\n                }\n            }\n        }\n    }\n    \n    long long ans = 0;\n    for (int last = 0; last < n; last++) {\n        for (int penalty = 0; penalty <= x; penalty++) {\n            ans += dp[(1 << n) - 1][last][penalty];\n            ans %= MOD;\n        }\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Coin Arrangement",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> top(n), bottom(n);\n    for (int i = 0; i < n; i++) cin >> top[i];\n    for (int i = 0; i < n; i++) cin >> bottom[i];\n\n    long long total_moves = 0;\n\n    for (int i = 0; i < n; i++) {\n        // Vertical moves\n        int vertical_moves = min(abs(top[i] - 1), abs(bottom[i] - 1));\n        total_moves += vertical_moves;\n\n        // Horizontal moves\n        int excess_coins = max(0, top[i] + bottom[i] - 2);\n        total_moves += excess_coins;\n    }\n\n    cout << total_moves << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 10,
            "mean_time_taken": 0.0943216323852539,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Collector",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 100005;\n\nvector<int> graph[MAXN], rev_graph[MAXN], scc_graph[MAXN];\nvector<long long> coins(MAXN), scc_coins(MAXN);\nint scc[MAXN], scc_count = 0;\nbool visited[MAXN];\nstack<int> st;\nint n, m;\n\nvoid dfs1(int v) {\n    visited[v] = true;\n    for (int u : graph[v]) {\n        if (!visited[u]) dfs1(u);\n    }\n    st.push(v);\n}\n\nvoid dfs2(int v) {\n    visited[v] = true;\n    scc[v] = scc_count;\n    scc_coins[scc_count] += coins[v];\n    for (int u : rev_graph[v]) {\n        if (!visited[u]) dfs2(u);\n    }\n}\n\nvoid kosaraju() {\n    fill(visited, visited + n + 1, false);\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) dfs1(i);\n    }\n    \n    fill(visited, visited + n + 1, false);\n    while (!st.empty()) {\n        int v = st.top();\n        st.pop();\n        if (!visited[v]) {\n            dfs2(v);\n            scc_count++;\n        }\n    }\n}\n\nvector<long long> dp(MAXN, -1);\n\nlong long max_coins(int v) {\n    if (dp[v] != -1) return dp[v];\n    \n    dp[v] = scc_coins[v];\n    long long max_child = 0;\n    for (int u : scc_graph[v]) {\n        max_child = max(max_child, max_coins(u));\n    }\n    dp[v] += max_child;\n    \n    return dp[v];\n}\n\nint main() {\n    cin >> n >> m;\n    \n    for (int i = 1; i <= n; i++) {\n        cin >> coins[i];\n    }\n    \n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        rev_graph[b].push_back(a);\n    }\n    \n    kosaraju();\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j : graph[i]) {\n            if (scc[i] != scc[j]) {\n                scc_graph[scc[i]].push_back(scc[j]);\n            }\n        }\n    }\n    \n    long long result = 0;\n    for (int i = 0; i < scc_count; i++) {\n        result = max(result, max_coins(i));\n    }\n    \n    cout << result << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.14451416901179723,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Coin Combinations I",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> coins(n);\n    for (int i = 0; i < n; i++) {\n        cin >> coins[i];\n    }\n\n    vector<int> dp(x + 1, 0);\n    dp[0] = 1;\n\n    for (int sum = 1; sum <= x; sum++) {\n        for (int coin : coins) {\n            if (coin <= sum) {\n                dp[sum] = (dp[sum] + dp[sum - coin]) % MOD;\n            }\n        }\n    }\n\n    cout << dp[x] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.37667259803185094,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Coin Combinations II",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint coinCombinations(int n, int x, vector<int>& coins) {\n    vector<int> dp(x + 1, 0);\n    dp[0] = 1;\n\n    for (int coin : coins) {\n        for (int j = coin; j <= x; j++) {\n            dp[j] = (dp[j] + dp[j - coin]) % MOD;\n        }\n    }\n\n    return dp[x];\n}\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> coins(n);\n    for (int i = 0; i < n; i++) {\n        cin >> coins[i];\n    }\n\n    cout << coinCombinations(n, x, coins) << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 15,
            "total_test_cases": 15,
            "mean_time_taken": 0.25812795956929524,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Coin Grid",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MAX_N = 100;\n\nint n;\nbool grid[MAX_N][MAX_N];\nbool matched[MAX_N];\nint match[MAX_N];\nbool visited[MAX_N];\n\nbool dfs(int u) {\n    for (int v = 0; v < n; v++) {\n        if (grid[u][v] && !visited[v]) {\n            visited[v] = true;\n            if (match[v] == -1 || dfs(match[v])) {\n                match[v] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint hungarian() {\n    fill(match, match + n, -1);\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        fill(visited, visited + n, false);\n        if (dfs(i)) result++;\n    }\n    return result;\n}\n\nvoid find_vertex_cover(vector<pair<int, int>>& cover) {\n    vector<bool> row_used(n, false), col_used(n, false);\n    \n    for (int i = 0; i < n; i++) {\n        if (!matched[i]) {\n            fill(visited, visited + n, false);\n            dfs(i);\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        if (!matched[i] && !visited[i]) row_used[i] = true;\n        if (visited[i]) col_used[i] = true;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        if (row_used[i]) cover.push_back({1, i + 1});\n        if (col_used[i]) cover.push_back({2, i + 1});\n    }\n}\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < n; j++) {\n            grid[i][j] = (s[j] == 'o');\n        }\n    }\n\n    int max_matching = hungarian();\n    \n    vector<pair<int, int>> cover;\n    find_vertex_cover(cover);\n    \n    cout << cover.size() << \"\\n\";\n    for (auto move : cover) {\n        cout << move.first << \" \" << move.second << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.08479955196380615,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Piles",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nvoid solve() {\n    long long a, b;\n    cin >> a >> b;\n    \n    if ((a + b) % 3 != 0 || 2 * min(a, b) < max(a, b)) {\n        cout << \"NO\\n\";\n    } else {\n        cout << \"YES\\n\";\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 3,
            "mean_time_taken": 0.09318312009175618,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Collecting Numbers",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<int> positions(n + 1);\n    for (int i = 1; i <= n; i++) {\n        int x;\n        cin >> x;\n        positions[x] = i;\n    }\n    \n    int rounds = 1;\n    for (int i = 2; i <= n; i++) {\n        if (positions[i] < positions[i - 1]) {\n            rounds++;\n        }\n    }\n    \n    cout << rounds << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 4,
            "mean_time_taken": 0.11098271608352661,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Collecting Numbers II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> arr(n + 1);\n    vector<int> pos(n + 1);\n\n    for (int i = 1; i <= n; i++) {\n        cin >> arr[i];\n        pos[arr[i]] = i;\n    }\n\n    auto count_rounds = [&]() {\n        int rounds = 1;\n        for (int i = 1; i <= n; i++) {\n            if (i > 1 && pos[i] < pos[i-1]) rounds++;\n        }\n        return rounds;\n    };\n\n    int rounds = count_rounds();\n\n    while (m--) {\n        int a, b;\n        cin >> a >> b;\n        int x = arr[a], y = arr[b];\n\n        // Swap\n        swap(arr[a], arr[b]);\n        pos[x] = b;\n        pos[y] = a;\n\n        // Check if the swap affects the round count\n        vector<int> to_check = {x-1, x, x+1, y-1, y, y+1};\n        bool recount = false;\n        for (int num : to_check) {\n            if (num >= 1 && num <= n) {\n                if ((num > 1 && pos[num] < pos[num-1]) || \n                    (num < n && pos[num+1] < pos[num])) {\n                    recount = true;\n                    break;\n                }\n            }\n        }\n\n        if (recount) {\n            rounds = count_rounds();\n        }\n\n        cout << rounds << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.6559171676635742,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Common Divisors",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAX_VAL = 1000000;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> freq(MAX_VAL + 1, 0);\n    \n    for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        \n        // Calculate and count all divisors of x\n        for (int j = 1; j <= sqrt(x); j++) {\n            if (x % j == 0) {\n                freq[j]++;\n                if (j != x / j) {\n                    freq[x / j]++;\n                }\n            }\n        }\n    }\n    \n    // Find the largest divisor that appears at least twice\n    for (int i = MAX_VAL; i >= 1; i--) {\n        if (freq[i] >= 2) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 17,
            "total_test_cases": 17,
            "mean_time_taken": 0.3592045166913201,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Company Queries I",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nconst int MAXLOG = 20; // log2(2e5) \u2248 18, we take 20 to be safe\n\nint n, q;\nvector<int> boss(MAXN);\nint dp[MAXN][MAXLOG];\n\nvoid precompute() {\n    for (int i = 1; i <= n; i++) {\n        dp[i][0] = boss[i];\n    }\n    \n    for (int j = 1; j < MAXLOG; j++) {\n        for (int i = 1; i <= n; i++) {\n            if (dp[i][j-1] != -1) {\n                dp[i][j] = dp[dp[i][j-1]][j-1];\n            } else {\n                dp[i][j] = -1;\n            }\n        }\n    }\n}\n\nint query(int x, int k) {\n    for (int j = MAXLOG - 1; j >= 0; j--) {\n        if (k >= (1 << j)) {\n            x = dp[x][j];\n            k -= (1 << j);\n            if (x == -1) return -1;\n        }\n    }\n    return x;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n >> q;\n    \n    boss[1] = -1; // The general director has no boss\n    for (int i = 2; i <= n; i++) {\n        cin >> boss[i];\n    }\n\n    precompute();\n\n    while (q--) {\n        int x, k;\n        cin >> x >> k;\n        cout << query(x, k) << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.11202898392310509,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Company Queries II",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nconst int LOGN = 20; // log2(MAXN)\n\nvector<int> adj[MAXN];\nint up[MAXN][LOGN];\nint depth[MAXN];\n\nvoid dfs(int v, int p) {\n    up[v][0] = p;\n    for (int i = 1; i < LOGN; i++) {\n        up[v][i] = up[up[v][i-1]][i-1];\n    }\n    for (int u : adj[v]) {\n        if (u != p) {\n            depth[u] = depth[v] + 1;\n            dfs(u, v);\n        }\n    }\n}\n\nint lca(int a, int b) {\n    if (depth[a] < depth[b]) {\n        swap(a, b);\n    }\n    int diff = depth[a] - depth[b];\n    for (int i = LOGN - 1; i >= 0; i--) {\n        if (diff & (1 << i)) {\n            a = up[a][i];\n        }\n    }\n    if (a == b) {\n        return a;\n    }\n    for (int i = LOGN - 1; i >= 0; i--) {\n        if (up[a][i] != up[b][i]) {\n            a = up[a][i];\n            b = up[b][i];\n        }\n    }\n    return up[a][0];\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, q;\n    cin >> n >> q;\n\n    for (int i = 2; i <= n; i++) {\n        int boss;\n        cin >> boss;\n        adj[boss].push_back(i);\n        adj[i].push_back(boss);\n    }\n\n    depth[1] = 0;\n    dfs(1, 1);\n\n    while (q--) {\n        int a, b;\n        cin >> a >> b;\n        cout << lca(a, b) << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 11,
            "total_test_cases": 12,
            "mean_time_taken": 0.14522784948349,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Concert Tickets",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n    cin >> n >> m;\n\n    multiset<int> tickets;\n    for (int i = 0; i < n; i++) {\n        int price;\n        cin >> price;\n        tickets.insert(price);\n    }\n\n    for (int i = 0; i < m; i++) {\n        int max_price;\n        cin >> max_price;\n\n        auto it = tickets.upper_bound(max_price);\n        if (it == tickets.begin()) {\n            cout << -1 << \"\\n\";\n        } else {\n            --it;\n            cout << *it << \"\\n\";\n            tickets.erase(it);\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.1664170351895419,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Convex Hull",
            "category": "Geometry",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nstruct Point {\n    long long x, y;\n    Point(long long x = 0, long long y = 0) : x(x), y(y) {}\n};\n\n// Global point needed for sorting points with respect to the first point\nPoint p0;\n\n// A utility function to find next to top in a stack\nPoint nextToTop(vector<Point> &S) {\n    Point p = S.back();\n    S.pop_back();\n    Point res = S.back();\n    S.push_back(p);\n    return res;\n}\n\n// A utility function to swap two points\nvoid swap(Point &p1, Point &p2) {\n    Point temp = p1;\n    p1 = p2;\n    p2 = temp;\n}\n\n// A utility function to return square of distance between p1 and p2\nlong long distSq(Point p1, Point p2) {\n    return (p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y);\n}\n\n// To find orientation of ordered triplet (p, q, r).\n// The function returns following values\n// 0 --> p, q and r are collinear\n// 1 --> Clockwise\n// 2 --> Counterclockwise\nint orientation(Point p, Point q, Point r) {\n    long long val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    if (val == 0) return 0;  // collinear\n    return (val > 0)? 1: 2;  // clock or counterclock wise\n}\n\n// A function used by library function qsort() to sort an array of\n// points with respect to the first point\nbool compare(Point p1, Point p2) {\n    // Find orientation\n    int o = orientation(p0, p1, p2);\n    if (o == 0)\n        return distSq(p0, p2) >= distSq(p0, p1);\n    return (o == 2);\n}\n\n// Prints convex hull of a set of n points.\nvector<Point> convexHull(vector<Point> points) {\n    int n = points.size();\n    // Find the bottommost point\n    int ymin = points[0].y, min = 0;\n    for (int i = 1; i < n; i++) {\n        long long y = points[i].y;\n        // Pick the bottom-most or chose the left most point in case of tie\n        if ((y < ymin) || (ymin == y && points[i].x < points[min].x))\n            ymin = points[i].y, min = i;\n    }\n    // Place the bottom-most point at first position\n    swap(points[0], points[min]);\n    // Sort n-1 points with respect to the first point.\n    p0 = points[0];\n    sort(points.begin() + 1, points.end(), compare);\n    // Create an empty stack and push first three points to it.\n    vector<Point> S;\n    S.push_back(points[0]);\n    S.push_back(points[1]);\n    S.push_back(points[2]);\n    // Process remaining n-3 points\n    for (int i = 3; i < n; i++) {\n        // Keep removing top while the angle formed by\n        // points next-to-top, top, and points[i] makes\n        // a non-left turn\n        while (S.size() > 1 && orientation(nextToTop(S), S.back(), points[i]) != 2)\n            S.pop_back();\n        S.push_back(points[i]);\n    }\n    return S;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> points(n);\n    for (int i = 0; i < n; i++) {\n        cin >> points[i].x >> points[i].y;\n    }\n    vector<Point> hull = convexHull(points);\n    cout << hull.size() << endl;\n    for (Point p : hull) {\n        cout << p.x << \" \" << p.y << endl;\n    }\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 9,
            "mean_time_taken": 0.1502763165367974,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Bishops",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint count_bishops(int n, int k) {\n    vector<vector<long long>> dp(2*n, vector<long long>(k+1, 0));\n    dp[0][0] = 1;\n\n    for (int i = 1; i < 2*n; i++) {\n        int diagonal_length = i <= n ? i : 2*n - i;\n        dp[i][0] = 1;\n        for (int j = 1; j <= k && j <= i; j++) {\n            dp[i][j] = dp[i-1][j];\n            if (j <= diagonal_length) {\n                dp[i][j] = (dp[i][j] + dp[i-1][j-1] * diagonal_length) % MOD;\n            }\n        }\n    }\n\n    long long result = 0;\n    for (int m = 0; m <= k; m++) {\n        result = (result + (long long)dp[2*n-1][m] * dp[2*n-1][k-m]) % MOD;\n    }\n\n    return result;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    cout << count_bishops(n, k) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 13,
            "mean_time_taken": 0.10393971663254958,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Bits",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n\nusing namespace std;\n\nlong long countBits(long long n) {\n    long long total = 0;\n    for (long long i = 1; i <= n; i++) {\n        total += __builtin_popcountll(i);\n    }\n    return total;\n}\n\nint main() {\n    long long n;\n    cin >> n;\n    cout << countBits(n) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 21,
            "mean_time_taken": 0.5806256248837426,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                5,
                7,
                9,
                10,
                14,
                17,
                18,
                19,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Coprime Pairs",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_N = 1e5 + 5;\nconst int MAX_X = 1e6 + 5;\n\nint freq[MAX_X];\nlong long coprime_count[MAX_X];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n;\n\n    memset(freq, 0, sizeof(freq));\n    memset(coprime_count, 0, sizeof(coprime_count));\n\n    for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        freq[x]++;\n    }\n\n    long long total_pairs = 0;\n\n    for (int i = 1; i < MAX_X; i++) {\n        int multiples = 0;\n        for (int j = i; j < MAX_X; j += i) {\n            multiples += freq[j];\n        }\n        coprime_count[i] = 1LL * multiples * (n - multiples);\n\n        for (int j = 2 * i; j < MAX_X; j += i) {\n            coprime_count[i] -= coprime_count[j];\n        }\n\n        total_pairs += coprime_count[i];\n    }\n\n    total_pairs /= 2; // Each pair was counted twice\n\n    cout << total_pairs << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 8,
            "mean_time_taken": 0.12710201740264893,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Divisors",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nconst int MAX_X = 1000001;\n\nstd::vector<int> countDivisors(MAX_X, 0);\n\nvoid precomputeDivisors() {\n    for (int i = 1; i < MAX_X; ++i) {\n        for (int j = i; j < MAX_X; j += i) {\n            countDivisors[j]++;\n        }\n    }\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    precomputeDivisors();\n\n    int n;\n    std::cin >> n;\n\n    while (n--) {\n        int x;\n        std::cin >> x;\n        std::cout << countDivisors[x] << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 16,
            "mean_time_taken": 0.11593744158744812,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                7,
                13,
                14,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Grids",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long modPow(long long base, long long exp) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp & 1)\n            result = (result * base) % MOD;\n        base = (base * base) % MOD;\n        exp >>= 1;\n    }\n    return result;\n}\n\nint main() {\n    long long n;\n    cin >> n;\n\n    long long center = (n % 2 == 1);\n    long long corners = 1;\n    long long edges = (n - 1) / 2;\n    long long remaining = ((n / 2) * (n / 2) - (n / 2)) / 4;\n\n    long long total_cells = center + corners + edges + remaining;\n\n    cout << modPow(2, total_cells) << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.086361030737559,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Necklaces",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long pow_mod(long long base, long long exp, long long modulus) {\n    long long result = 1;\n    base %= modulus;\n    while (exp > 0) {\n        if (exp & 1) result = (result * base) % modulus;\n        base = (base * base) % modulus;\n        exp >>= 1;\n    }\n    return result;\n}\n\nint gcd(int a, int b) {\n    while (b) {\n        a %= b;\n        swap(a, b);\n    }\n    return a;\n}\n\nint count_necklaces(int n, int m) {\n    long long result = 0;\n    for (int i = 0; i < n; i++) {\n        result = (result + pow_mod(m, gcd(i, n), MOD)) % MOD;\n    }\n    result = (result * pow_mod(n, MOD - 2, MOD)) % MOD;\n    return result;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    cout << count_necklaces(n, m) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.09773540496826172,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Counting Numbers",
            "category": "Dynamic Programming",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_DIGITS = 19; // log10(10^18) + 1\nll dp[MAX_DIGITS][10][2];\nvector<int> digits;\n\nll count(int pos, int last, bool tight, const vector<int>& num) {\n    if (pos == num.size()) return 1;\n    \n    if (!tight && dp[pos][last][tight] != -1) return dp[pos][last][tight];\n    \n    ll result = 0;\n    int limit = tight ? num[pos] : 9;\n    \n    for (int digit = 0; digit <= limit; digit++) {\n        if (digit != last || pos == 0) {\n            result += count(pos + 1, digit, tight && (digit == limit), num);\n        }\n    }\n    \n    if (!tight) dp[pos][last][tight] = result;\n    return result;\n}\n\nll solve(ll n) {\n    if (n < 0) return 0;\n    digits.clear();\n    while (n > 0) {\n        digits.push_back(n % 10);\n        n /= 10;\n    }\n    reverse(digits.begin(), digits.end());\n    memset(dp, -1, sizeof(dp));\n    return count(0, 0, true, digits);\n}\n\nint main() {\n    ll a, b;\n    cin >> a >> b;\n    cout << solve(b) - solve(a - 1) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 9,
            "total_test_cases": 16,
            "mean_time_taken": 0.07967610657215118,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                5,
                7,
                11,
                13,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Paths",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nconst int LOG = 20;\n\nvector<int> adj[MAX_N];\nint up[MAX_N][LOG];\nint depth[MAX_N];\nlong long count[MAX_N];\nint n, m;\n\nvoid dfs(int v, int p) {\n    for (int u : adj[v]) {\n        if (u != p) {\n            depth[u] = depth[v] + 1;\n            up[u][0] = v;\n            for (int j = 1; j < LOG; j++) {\n                up[u][j] = up[up[u][j-1]][j-1];\n            }\n            dfs(u, v);\n        }\n    }\n}\n\nint lca(int a, int b) {\n    if (depth[a] < depth[b]) {\n        swap(a, b);\n    }\n    int k = depth[a] - depth[b];\n    for (int j = LOG - 1; j >= 0; j--) {\n        if (k & (1 << j)) {\n            a = up[a][j];\n        }\n    }\n    if (a == b) {\n        return a;\n    }\n    for (int j = LOG - 1; j >= 0; j--) {\n        if (up[a][j] != up[b][j]) {\n            a = up[a][j];\n            b = up[b][j];\n        }\n    }\n    return up[a][0];\n}\n\nvoid count_path(int a, int b) {\n    int l = lca(a, b);\n    while (a != l) {\n        count[a]++;\n        a = up[a][0];\n    }\n    while (b != l) {\n        count[b]++;\n        b = up[b][0];\n    }\n    count[l]++;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n >> m;\n\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    dfs(1, 0);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        count_path(a, b);\n    }\n\n    for (int i = 1; i <= n; i++) {\n        cout << count[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Counting Patterns",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_map>\nusing namespace std;\n\nconst int ALPHABET_SIZE = 26;\n\nstruct Node {\n    unordered_map<char, Node*> children;\n    bool is_end;\n    Node* fail;\n    Node* output;\n    int count;\n    \n    Node() : is_end(false), fail(nullptr), output(nullptr), count(0) {}\n};\n\nclass AhoCorasick {\nprivate:\n    Node* root;\n\n    void build_failure_links() {\n        queue<Node*> q;\n        for (char c = 'a'; c <= 'z'; c++) {\n            if (root->children[c]) {\n                root->children[c]->fail = root;\n                q.push(root->children[c]);\n            }\n        }\n\n        while (!q.empty()) {\n            Node* curr = q.front();\n            q.pop();\n\n            for (char c = 'a'; c <= 'z'; c++) {\n                if (curr->children[c]) {\n                    Node* failure = curr->fail;\n                    while (failure != root && !failure->children[c]) {\n                        failure = failure->fail;\n                    }\n                    if (failure->children[c]) {\n                        failure = failure->children[c];\n                    }\n                    curr->children[c]->fail = failure;\n                    \n                    if (failure->is_end) {\n                        curr->children[c]->output = failure;\n                    } else {\n                        curr->children[c]->output = failure->output;\n                    }\n                    \n                    q.push(curr->children[c]);\n                }\n            }\n        }\n    }\n\npublic:\n    AhoCorasick() : root(new Node()) {}\n\n    void add_pattern(const string& pattern) {\n        Node* node = root;\n        for (char c : pattern) {\n            if (!node->children[c]) {\n                node->children[c] = new Node();\n            }\n            node = node->children[c];\n        }\n        node->is_end = true;\n    }\n\n    void build() {\n        build_failure_links();\n    }\n\n    void search(const string& text) {\n        Node* node = root;\n        for (char c : text) {\n            while (node != root && !node->children[c]) {\n                node = node->fail;\n            }\n            if (node->children[c]) {\n                node = node->children[c];\n            }\n            if (node->is_end) {\n                node->count++;\n            }\n            Node* output = node->output;\n            while (output) {\n                output->count++;\n                output = output->output;\n            }\n        }\n    }\n\n    int get_count(const string& pattern) {\n        Node* node = root;\n        for (char c : pattern) {\n            if (!node->children[c]) {\n                return 0;\n            }\n            node = node->children[c];\n        }\n        return node->count;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    string text;\n    cin >> text;\n\n    int k;\n    cin >> k;\n\n    AhoCorasick ac;\n    vector<string> patterns(k);\n\n    for (int i = 0; i < k; i++) {\n        cin >> patterns[i];\n        ac.add_pattern(patterns[i]);\n    }\n\n    ac.build();\n    ac.search(text);\n\n    for (const string& pattern : patterns) {\n        cout << ac.get_count(pattern) << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 11,
            "mean_time_taken": 0.5549241196025502,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Reorders",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int ALPHA = 26;\n\nint countReorders(const string& s) {\n    int n = s.length();\n    vector<int> freq(ALPHA, 0);\n    for (char c : s) freq[c - 'a']++;\n\n    vector<vector<long long>> dp(n + 1, vector<long long>(ALPHA, 0));\n\n    // Base case\n    for (int j = 0; j < ALPHA; j++) {\n        dp[1][j] = freq[j];\n    }\n\n    // Fill dp table\n    for (int i = 2; i <= n; i++) {\n        for (int j = 0; j < ALPHA; j++) {\n            for (int k = 0; k < ALPHA; k++) {\n                if (j != k) {\n                    dp[i][j] = (dp[i][j] + dp[i-1][k]) % MOD;\n                }\n            }\n        }\n    }\n\n    // Sum up the final answer\n    long long result = 0;\n    for (int j = 0; j < ALPHA; j++) {\n        result = (result + dp[n][j]) % MOD;\n    }\n\n    return result;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    cout << countReorders(s) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 9,
            "mean_time_taken": 0.10094960530598958,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Rooms",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid dfs(vector<vector<char>>& building, int i, int j, int n, int m) {\n    if (i < 0 || i >= n || j < 0 || j >= m || building[i][j] != '.') {\n        return;\n    }\n    \n    building[i][j] = '#';  // Mark as visited\n    \n    // Explore in all 4 directions\n    dfs(building, i-1, j, n, m);  // Up\n    dfs(building, i+1, j, n, m);  // Down\n    dfs(building, i, j-1, n, m);  // Left\n    dfs(building, i, j+1, n, m);  // Right\n}\n\nint countRooms(vector<vector<char>>& building, int n, int m) {\n    int rooms = 0;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (building[i][j] == '.') {\n                rooms++;\n                dfs(building, i, j, n, m);\n            }\n        }\n    }\n    \n    return rooms;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<vector<char>> building(n, vector<char>(m));\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> building[i][j];\n        }\n    }\n    \n    cout << countRooms(building, n, m) << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 15,
            "total_test_cases": 19,
            "mean_time_taken": 0.10573257898029528,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                7,
                8,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Sequences",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int MAXN = 1e6 + 5;\n\nlong long dp[MAXN][101];\nlong long fact[MAXN], inv[MAXN];\n\nlong long power(long long a, long long b) {\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1) res = (res * a) % MOD;\n        a = (a * a) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nvoid precompute() {\n    fact[0] = inv[0] = 1;\n    for (int i = 1; i < MAXN; i++) {\n        fact[i] = (fact[i-1] * i) % MOD;\n        inv[i] = power(fact[i], MOD - 2);\n    }\n}\n\nlong long C(int n, int k) {\n    if (k > n) return 0;\n    return (fact[n] * inv[k] % MOD) * inv[n-k] % MOD;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    precompute();\n\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= min(i, k); j++) {\n            dp[i][j] = (j * dp[i-1][j] % MOD + (k-j+1) * dp[i-1][j-1] % MOD) % MOD;\n        }\n    }\n\n    long long ans = 0;\n    for (int i = k; i <= n; i++) {\n        if ((k-i) % 2 == 0)\n            ans = (ans + C(k, i) * dp[n][i] % MOD) % MOD;\n        else\n            ans = (ans - C(k, i) * dp[n][i] % MOD + MOD) % MOD;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.08135766983032226,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Tilings",
            "category": "Dynamic Programming",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int MAXN = 11;\nconst int MAXM = 1001;\n\nint n, m;\nvector<vector<int>> dp(MAXM, vector<int>(1 << MAXN, 0));\n\nbool isValid(int mask) {\n    return (mask & (mask >> 1)) == 0;\n}\n\nint countTilings() {\n    dp[0][0] = 1;\n\n    for (int col = 0; col < m; col++) {\n        for (int mask = 0; mask < (1 << n); mask++) {\n            if (dp[col][mask] == 0) continue;\n\n            // Try placing vertical tiles\n            dp[col + 1][mask] = (dp[col + 1][mask] + dp[col][mask]) % MOD;\n\n            // Try placing horizontal tiles\n            for (int i = 0; i < n; i++) {\n                if ((mask & (1 << i)) == 0 && i + 1 < n && (mask & (1 << (i + 1))) == 0) {\n                    int newMask = mask | (1 << i) | (1 << (i + 1));\n                    dp[col + 1][newMask] = (dp[col + 1][newMask] + dp[col][mask]) % MOD;\n                }\n            }\n        }\n    }\n\n    return dp[m][0];\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> n >> m;\n\n    cout << countTilings() << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 15,
            "mean_time_taken": 0.08737858136494954,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                11,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Towers",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int MAX_N = 1e6 + 1;\n\nvector<vector<long long>> dp(MAX_N, vector<long long>(2));\n\nvoid precompute() {\n    dp[1][0] = dp[1][1] = 1;\n    for (int i = 2; i < MAX_N; i++) {\n        dp[i][0] = (4 * dp[i-1][0] + dp[i-1][1]) % MOD;\n        dp[i][1] = (dp[i-1][0] + dp[i-1][1]) % MOD;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    precompute();\n\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n;\n        cin >> n;\n        cout << (dp[n][0] + dp[n][1]) % MOD << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.20832675695419312,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Course Schedule",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> graph(n + 1);\n    vector<int> in_degree(n + 1, 0);\n\n    // Read requirements and build graph\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        in_degree[b]++;\n    }\n\n    // Initialize queue with courses having no prerequisites\n    queue<int> q;\n    for (int i = 1; i <= n; i++) {\n        if (in_degree[i] == 0) {\n            q.push(i);\n        }\n    }\n\n    vector<int> result;\n    while (!q.empty()) {\n        int course = q.front();\n        q.pop();\n        result.push_back(course);\n\n        // Process all courses that depend on this course\n        for (int next_course : graph[course]) {\n            in_degree[next_course]--;\n            if (in_degree[next_course] == 0) {\n                q.push(next_course);\n            }\n        }\n    }\n\n    // Check if we've processed all courses\n    if (result.size() == n) {\n        for (int course : result) {\n            cout << course << \" \";\n        }\n        cout << endl;\n    } else {\n        cout << \"IMPOSSIBLE\" << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 16,
            "total_test_cases": 16,
            "mean_time_taken": 0.12253768742084503,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Course Schedule II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nvector<int> topologicalSort(int n, vector<vector<int>>& prerequisites) {\n    vector<vector<int>> graph(n + 1);\n    vector<int> inDegree(n + 1, 0);\n    \n    // Build the graph and calculate in-degrees\n    for (const auto& prereq : prerequisites) {\n        int a = prereq[0], b = prereq[1];\n        graph[a].push_back(b);\n        inDegree[b]++;\n    }\n    \n    // Priority queue to store nodes with in-degree 0\n    priority_queue<int, vector<int>, greater<int>> pq;\n    \n    // Add nodes with in-degree 0 to the priority queue\n    for (int i = 1; i <= n; i++) {\n        if (inDegree[i] == 0) {\n            pq.push(i);\n        }\n    }\n    \n    vector<int> result;\n    \n    // Process nodes\n    while (!pq.empty()) {\n        int course = pq.top();\n        pq.pop();\n        result.push_back(course);\n        \n        // Reduce in-degree of neighbors\n        for (int neighbor : graph[course]) {\n            if (--inDegree[neighbor] == 0) {\n                pq.push(neighbor);\n            }\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<vector<int>> prerequisites(m, vector<int>(2));\n    for (int i = 0; i < m; i++) {\n        cin >> prerequisites[i][0] >> prerequisites[i][1];\n    }\n    \n    vector<int> order = topologicalSort(n, prerequisites);\n    \n    for (int course : order) {\n        cout << course << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 8,
            "mean_time_taken": 0.14773160219192505,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Creating Offices",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\n\nvector<int> adj[MAX_N];\nvector<int> offices;\nint d;\n\npair<int, int> dfs(int node, int parent) {\n    int with_office = 1;\n    int without_office = 0;\n    vector<int> children_without;\n\n    for (int child : adj[node]) {\n        if (child != parent) {\n            auto [child_with, child_without] = dfs(child, node);\n            without_office += max(child_with, child_without);\n            children_without.push_back(child_without);\n        }\n    }\n\n    int total_without = without_office;\n    for (int i = 0; i < children_without.size(); i++) {\n        int curr_with = 1;\n        for (int j = 0; j < children_without.size(); j++) {\n            if (i == j) continue;\n            curr_with += children_without[j];\n        }\n        with_office = max(with_office, curr_with);\n    }\n\n    return {with_office, without_office};\n}\n\nvoid trace(int node, int parent, int place_office, int depth) {\n    if (place_office && depth % d == 0) {\n        offices.push_back(node);\n    }\n\n    for (int child : adj[node]) {\n        if (child != parent) {\n            trace(child, node, !place_office, depth + 1);\n        }\n    }\n}\n\nint main() {\n    int n;\n    cin >> n >> d;\n\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    auto [with_root, without_root] = dfs(1, 0);\n    int max_offices = max(with_root, without_root);\n\n    cout << max_offices << endl;\n\n    trace(1, 0, true, 0);\n    for (int office : offices) {\n        cout << office << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 22,
            "mean_time_taken": 0.2977005026557229,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                16,
                17,
                18,
                19,
                20,
                21,
                22
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Creating Strings",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\nset<string> permutations;\n\nvoid generate_permutations(string& s, int l, int r) {\n    if (l == r) {\n        permutations.insert(s);\n    } else {\n        for (int i = l; i <= r; i++) {\n            swap(s[l], s[i]);\n            generate_permutations(s, l + 1, r);\n            swap(s[l], s[i]);  // backtrack\n        }\n    }\n}\n\nint main() {\n    string s;\n    cin >> s;\n    \n    sort(s.begin(), s.end());  // Sort to handle duplicates\n    \n    generate_permutations(s, 0, s.length() - 1);\n    \n    vector<string> result(permutations.begin(), permutations.end());\n    sort(result.begin(), result.end());\n    \n    cout << result.size() << endl;\n    for (const string& perm : result) {\n        cout << perm << endl;\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 6,
            "mean_time_taken": 0.09521353244781494,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Creating Strings II",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nvector<long long> factorial(1000001, 1);\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.length();\n\n    // Precompute factorials\n    for (int i = 1; i <= n; i++) {\n        factorial[i] = (factorial[i-1] * i) % MOD;\n    }\n\n    // Count character frequencies\n    vector<int> freq(26, 0);\n    for (char c : s) {\n        freq[c - 'a']++;\n    }\n\n    // Calculate result\n    long long result = factorial[n];\n    for (int f : freq) {\n        result = (result * modInverse(factorial[f], MOD)) % MOD;\n    }\n\n    cout << result << endl;\n\n    return 0;\n}\n\n// Function to calculate (a^b) % m\nlong long power(long long a, long long b, long long m) {\n    long long res = 1;\n    a %= m;\n    while (b > 0) {\n        if (b & 1) res = (res * a) % m;\n        a = (a * a) % m;\n        b >>= 1;\n    }\n    return res;\n}\n\n// Function to calculate modular inverse\nlong long modInverse(long long a, long long m) {\n    return power(a, m - 2, m);\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Critical Cities",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 1e5 + 5;\n\nvector<int> graph[MAX_N];\nint disc[MAX_N], low[MAX_N], parent[MAX_N];\nbool visited[MAX_N];\nset<int> critical_cities;\nint timer = 0;\n\nvoid dfs(int u, int n) {\n    visited[u] = true;\n    disc[u] = low[u] = ++timer;\n    int children = 0;\n\n    for (int v : graph[u]) {\n        if (!visited[v]) {\n            children++;\n            parent[v] = u;\n            dfs(v, n);\n\n            low[u] = min(low[u], low[v]);\n\n            if ((u == 1 && children > 1) || (u != 1 && low[v] >= disc[u]))\n                critical_cities.insert(u);\n        }\n        else if (v != parent[u])\n            low[u] = min(low[u], disc[v]);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n    }\n\n    dfs(1, n);\n\n    // Add Syrj\u00e4l\u00e4 and Lehm\u00e4l\u00e4 to critical cities\n    critical_cities.insert(1);\n    critical_cities.insert(n);\n\n    cout << critical_cities.size() << endl;\n    for (int city : critical_cities)\n        cout << city << \" \";\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 14,
            "mean_time_taken": 0.12596610614231654,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Cut and Paste",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <string>\n#include <deque>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    string s;\n    cin >> s;\n    \n    deque<char> dq(s.begin(), s.end());\n    \n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--; // Convert to 0-based indexing\n        \n        vector<char> cut;\n        for (int j = a; j <= b; j++) {\n            cut.push_back(dq[j]);\n        }\n        \n        dq.erase(dq.begin() + a, dq.begin() + b + 1);\n        \n        for (char c : cut) {\n            dq.push_back(c);\n        }\n    }\n    \n    string result(dq.begin(), dq.end());\n    cout << result << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 7,
            "mean_time_taken": 0.5969608170645577,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Cycle Finding",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\nstruct Edge {\n    int from, to, weight;\n};\n\nconst long long INF = 1e18;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<Edge> edges(m);\n    for (int i = 0; i < m; i++) {\n        cin >> edges[i].from >> edges[i].to >> edges[i].weight;\n    }\n\n    vector<long long> dist(n + 1, INF);\n    vector<int> parent(n + 1, -1);\n    dist[1] = 0;\n\n    int x = -1;\n    for (int i = 1; i <= n; i++) {\n        x = -1;\n        for (Edge e : edges) {\n            if (dist[e.from] < INF) {\n                if (dist[e.to] > dist[e.from] + e.weight) {\n                    dist[e.to] = dist[e.from] + e.weight;\n                    parent[e.to] = e.from;\n                    x = e.to;\n                }\n            }\n        }\n    }\n\n    if (x == -1) {\n        cout << \"NO\" << endl;\n    } else {\n        cout << \"YES\" << endl;\n        for (int i = 1; i <= n; i++) {\n            x = parent[x];\n        }\n\n        vector<int> cycle;\n        for (int v = x;; v = parent[v]) {\n            cycle.push_back(v);\n            if (v == x && cycle.size() > 1) {\n                break;\n            }\n        }\n\n        reverse(cycle.begin(), cycle.end());\n\n        for (int v : cycle) {\n            cout << v << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Cyclic Array",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    long long k;\n    cin >> n >> k;\n    \n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    \n    int count = 0;\n    long long sum = 0;\n    int start = 0;\n    int end = 0;\n    \n    for (int i = 0; i < 2 * n; i++) {\n        // Add the current element to the sum\n        sum += arr[i % n];\n        end++;\n        \n        // If sum exceeds k, start a new subarray\n        while (sum > k) {\n            sum -= arr[start % n];\n            start++;\n        }\n        \n        // If we've covered n elements, we're done\n        if (end - start == n) {\n            count++;\n            break;\n        }\n        \n        // If we've reached the end of the doubled array, count a subarray\n        if (i == 2 * n - 1) {\n            count++;\n        }\n    }\n    \n    cout << count << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 21,
            "mean_time_taken": 0.09030997185480028,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                9,
                10,
                12,
                13,
                14,
                15,
                17,
                18,
                19
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "De Bruijn Sequence",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <unordered_set>\n\nusing namespace std;\n\nstring sequence;\nunordered_set<string> visited;\n\nbool generate(int n) {\n    if (visited.size() == (1 << n)) {\n        return sequence.length() == (1 << n) + n - 1;\n    }\n    \n    for (char c : {'0', '1'}) {\n        sequence.push_back(c);\n        string last = sequence.substr(sequence.length() - n);\n        \n        if (visited.find(last) == visited.end()) {\n            visited.insert(last);\n            if (generate(n)) return true;\n            visited.erase(last);\n        }\n        \n        sequence.pop_back();\n    }\n    \n    return false;\n}\n\nstring deBruijn(int n) {\n    if (n == 1) return \"01\";\n    \n    sequence = string(n - 1, '0');\n    visited.clear();\n    generate(n);\n    return sequence;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    cout << deBruijn(n) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.08459510803222656,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Dice Combinations",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> dp(n + 1, 0);\n    dp[0] = 1;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= 6 && i - j >= 0; j++) {\n            dp[i] = (dp[i] + dp[i - j]) % MOD;\n        }\n    }\n\n    cout << dp[n] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 20,
            "total_test_cases": 20,
            "mean_time_taken": 0.09040572643280029,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Dice Probability",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\ndouble diceProbability(int n, int a, int b) {\n    vector<vector<long long>> dp(n + 1, vector<long long>(6 * n + 1, 0));\n    dp[0][0] = 1;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= 6 * n; j++) {\n            for (int k = 1; k <= 6; k++) {\n                if (j >= k) {\n                    dp[i][j] += dp[i - 1][j - k];\n                }\n            }\n        }\n    }\n\n    long long favorable = 0;\n    for (int sum = a; sum <= b; sum++) {\n        favorable += dp[n][sum];\n    }\n\n    long long total = pow(6, n);\n    double probability = static_cast<double>(favorable) / total;\n\n    return probability;\n}\n\nint main() {\n    int n, a, b;\n    cin >> n >> a >> b;\n\n    double result = diceProbability(n, a, b);\n    cout << fixed << setprecision(6) << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 17,
            "mean_time_taken": 0.0828087049372056,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                5,
                6,
                9,
                11,
                15,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Digit Queries",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nchar findDigit(long long k) {\n    long long digits = 1;\n    long long numbers = 9;\n    long long start = 1;\n\n    while (k > digits * numbers) {\n        k -= digits * numbers;\n        digits++;\n        numbers *= 10;\n        start *= 10;\n    }\n\n    start += (k - 1) / digits;\n    string num = to_string(start);\n    return num[(k - 1) % digits];\n}\n\nint main() {\n    int q;\n    cin >> q;\n\n    while (q--) {\n        long long k;\n        cin >> k;\n        cout << findDigit(k) << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 4,
            "mean_time_taken": 0.08930373191833496,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Distance Queries",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nconst int LOGN = 20; // log2(MAXN)\n\nvector<int> adj[MAXN];\nint parent[MAXN], depth[MAXN];\nint up[MAXN][LOGN];\n\nvoid dfs(int v, int p, int d) {\n    parent[v] = p;\n    depth[v] = d;\n    for (int u : adj[v]) {\n        if (u != p) {\n            dfs(u, v, d + 1);\n        }\n    }\n}\n\nvoid build_lca(int n) {\n    for (int v = 1; v <= n; v++) {\n        up[v][0] = parent[v];\n    }\n    for (int j = 1; j < LOGN; j++) {\n        for (int v = 1; v <= n; v++) {\n            up[v][j] = up[up[v][j-1]][j-1];\n        }\n    }\n}\n\nint lca(int a, int b) {\n    if (depth[a] < depth[b]) {\n        swap(a, b);\n    }\n    int k = depth[a] - depth[b];\n    for (int j = LOGN - 1; j >= 0; j--) {\n        if (k & (1 << j)) {\n            a = up[a][j];\n        }\n    }\n    if (a == b) return a;\n    for (int j = LOGN - 1; j >= 0; j--) {\n        if (up[a][j] != up[b][j]) {\n            a = up[a][j];\n            b = up[b][j];\n        }\n    }\n    return parent[a];\n}\n\nint distance(int a, int b) {\n    int c = lca(a, b);\n    return depth[a] + depth[b] - 2 * depth[c];\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    dfs(1, 0, 0);\n    build_lca(n);\n\n    while (q--) {\n        int a, b;\n        cin >> a >> b;\n        cout << distance(a, b) << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 11,
            "mean_time_taken": 0.15532797033136542,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Colors",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <set>\n\nconst int MAX_N = 2e5 + 5;\n\nstd::vector<int> adj[MAX_N];\nstd::vector<int> color(MAX_N);\nstd::vector<int> result(MAX_N);\nstd::vector<std::set<int>> subtree_colors(MAX_N);\n\nvoid dfs(int node, int parent) {\n    subtree_colors[node].insert(color[node]);\n    \n    for (int child : adj[node]) {\n        if (child != parent) {\n            dfs(child, node);\n            \n            if (subtree_colors[child].size() > subtree_colors[node].size()) {\n                std::swap(subtree_colors[child], subtree_colors[node]);\n            }\n            \n            for (int c : subtree_colors[child]) {\n                subtree_colors[node].insert(c);\n            }\n        }\n    }\n    \n    result[node] = subtree_colors[node].size();\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    \n    for (int i = 1; i <= n; i++) {\n        std::cin >> color[i];\n    }\n    \n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        std::cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    \n    dfs(1, 0);\n    \n    for (int i = 1; i <= n; i++) {\n        std::cout << result[i] << \" \";\n    }\n    std::cout << std::endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 11,
            "total_test_cases": 15,
            "mean_time_taken": 0.2885528564453125,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                5,
                13,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Numbers",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <unordered_set>\n\nint main() {\n    // Fast I/O\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    // Read the number of values\n    int n;\n    std::cin >> n;\n\n    // Use unordered_set to store unique values\n    std::unordered_set<int> distinct_values;\n\n    // Read n integers and insert them into the set\n    for (int i = 0; i < n; ++i) {\n        int x;\n        std::cin >> x;\n        distinct_values.insert(x);\n    }\n\n    // Print the number of distinct values\n    std::cout << distinct_values.size() << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 14,
            "total_test_cases": 15,
            "mean_time_taken": 0.1696310043334961,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Routes",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 505;\n\nstd::vector<int> graph[MAXN];\nint parent[MAXN];\nbool used[MAXN];\nstd::vector<std::vector<int>> paths;\n\nbool dfs(int v, int t) {\n    if (v == t) return true;\n    used[v] = true;\n    for (int u : graph[v]) {\n        if (!used[u] && dfs(u, t)) {\n            parent[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    int n, m;\n    std::cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        std::cin >> a >> b;\n        graph[a].push_back(b);\n    }\n\n    int max_flow = 0;\n    while (true) {\n        std::fill(used, used + n + 1, false);\n        std::fill(parent, parent + n + 1, -1);\n\n        if (!dfs(1, n)) break;\n\n        max_flow++;\n        std::vector<int> path;\n        for (int v = n; v != 1; v = parent[v]) {\n            path.push_back(v);\n            auto it = std::find(graph[parent[v]].begin(), graph[parent[v]].end(), v);\n            graph[parent[v]].erase(it);\n        }\n        path.push_back(1);\n        std::reverse(path.begin(), path.end());\n        paths.push_back(path);\n    }\n\n    std::cout << max_flow << \"\\n\";\n    for (const auto& path : paths) {\n        std::cout << path.size() << \"\\n\";\n        for (int v : path) {\n            std::cout << v << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 18,
            "mean_time_taken": 0.08095516098870172,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                5,
                6,
                8,
                10,
                12,
                14,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Routes II",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 505;\nconst int INF = 1e9;\n\nint n, m, k;\nvector<int> graph[MAXN];\nint capacity[MAXN][MAXN];\nint flow[MAXN][MAXN];\nint parent[MAXN];\n\nbool bfs(int s, int t) {\n    memset(parent, -1, sizeof(parent));\n    queue<int> q;\n    q.push(s);\n    parent[s] = s;\n    \n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        \n        for (int v : graph[u]) {\n            if (parent[v] == -1 && capacity[u][v] > flow[u][v]) {\n                parent[v] = u;\n                if (v == t) return true;\n                q.push(v);\n            }\n        }\n    }\n    \n    return false;\n}\n\nint edmonds_karp(int s, int t) {\n    int max_flow = 0;\n    \n    while (bfs(s, t)) {\n        int path_flow = INF;\n        for (int v = t; v != s; v = parent[v]) {\n            int u = parent[v];\n            path_flow = min(path_flow, capacity[u][v] - flow[u][v]);\n        }\n        \n        for (int v = t; v != s; v = parent[v]) {\n            int u = parent[v];\n            flow[u][v] += path_flow;\n            flow[v][u] -= path_flow;\n        }\n        \n        max_flow += path_flow;\n    }\n    \n    return max_flow;\n}\n\nvector<int> find_path(int s, int t) {\n    vector<int> path;\n    vector<bool> visited(n + 1, false);\n    \n    function<bool(int)> dfs = [&](int u) {\n        visited[u] = true;\n        path.push_back(u);\n        \n        if (u == t) return true;\n        \n        for (int v : graph[u]) {\n            if (!visited[v] && flow[u][v] > 0) {\n                flow[u][v]--;\n                if (dfs(v)) return true;\n                flow[u][v]++;\n            }\n        }\n        \n        path.pop_back();\n        return false;\n    };\n    \n    dfs(s);\n    return path;\n}\n\nint main() {\n    cin >> n >> m >> k;\n    \n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        capacity[a][b] = 1;\n    }\n    \n    int max_flow = edmonds_karp(1, n);\n    \n    if (max_flow < k) {\n        cout << -1 << endl;\n        return 0;\n    }\n    \n    int total_teleporters = 0;\n    vector<vector<int>> paths;\n    \n    for (int i = 0; i < k; i++) {\n        vector<int> path = find_path(1, n);\n        paths.push_back(path);\n        total_teleporters += path.size() - 1;\n    }\n    \n    cout << total_teleporters << endl;\n    for (const auto& path : paths) {\n        cout << path.size() << endl;\n        for (int room : path) {\n            cout << room << \" \";\n        }\n        cout << endl;\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 10,
            "mean_time_taken": 0.08128876686096191,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Substrings",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> build_suffix_array(const string& s) {\n    int n = s.length();\n    vector<int> sa(n);\n    vector<pair<char, int>> chars(n);\n    \n    for (int i = 0; i < n; i++) {\n        chars[i] = {s[i], i};\n    }\n    sort(chars.begin(), chars.end());\n    \n    for (int i = 0; i < n; i++) {\n        sa[i] = chars[i].second;\n    }\n    \n    vector<int> classes(n);\n    for (int i = 0; i < n; i++) {\n        classes[sa[i]] = i > 0 && chars[i].first == chars[i-1].first ? classes[sa[i-1]] : i;\n    }\n    \n    for (int len = 1; len < n; len *= 2) {\n        vector<pair<pair<int, int>, int>> pairs(n);\n        for (int i = 0; i < n; i++) {\n            pairs[i] = {{classes[i], classes[(i + len) % n]}, i};\n        }\n        sort(pairs.begin(), pairs.end());\n        \n        for (int i = 0; i < n; i++) {\n            sa[i] = pairs[i].second;\n        }\n        \n        classes[sa[0]] = 0;\n        for (int i = 1; i < n; i++) {\n            classes[sa[i]] = classes[sa[i-1]] + (pairs[i].first != pairs[i-1].first);\n        }\n    }\n    \n    return sa;\n}\n\nvector<int> build_lcp_array(const string& s, const vector<int>& sa) {\n    int n = s.length();\n    vector<int> rank(n);\n    for (int i = 0; i < n; i++) {\n        rank[sa[i]] = i;\n    }\n    \n    vector<int> lcp(n-1, 0);\n    int k = 0;\n    for (int i = 0; i < n - 1; i++) {\n        if (rank[i] == n - 1) {\n            k = 0;\n            continue;\n        }\n        int j = sa[rank[i] + 1];\n        while (i + k < n && j + k < n && s[i+k] == s[j+k]) {\n            k++;\n        }\n        lcp[rank[i]] = k;\n        if (k > 0) k--;\n    }\n    \n    return lcp;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    \n    vector<int> sa = build_suffix_array(s);\n    vector<int> lcp = build_lcp_array(s, sa);\n    \n    long long total = (long long)s.length() * (s.length() + 1) / 2;\n    long long lcp_sum = 0;\n    for (int x : lcp) {\n        lcp_sum += x;\n    }\n    \n    cout << total - lcp_sum << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 7,
            "mean_time_taken": 0.6587403161185128,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Values Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\n\nvector<int> tree[4 * MAXN];\nint arr[MAXN], compressed[MAXN];\nvector<pair<int, int>> queries[MAXN];\nint answer[MAXN];\n\nvoid build(int node, int start, int end) {\n    if (start == end) {\n        tree[node] = {compressed[start]};\n        return;\n    }\n    int mid = (start + end) / 2;\n    build(2 * node, start, mid);\n    build(2 * node + 1, mid + 1, end);\n    merge(tree[2 * node].begin(), tree[2 * node].end(),\n          tree[2 * node + 1].begin(), tree[2 * node + 1].end(),\n          back_inserter(tree[node]));\n    tree[node].erase(unique(tree[node].begin(), tree[node].end()), tree[node].end());\n}\n\nint query(int node, int start, int end, int l, int r, int x) {\n    if (r < start || end < l) return 0;\n    if (l <= start && end <= r) {\n        return upper_bound(tree[node].begin(), tree[node].end(), x) - tree[node].begin();\n    }\n    int mid = (start + end) / 2;\n    return query(2 * node, start, mid, l, r, x) + query(2 * node + 1, mid + 1, end, l, r, x);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> compress;\n    for (int i = 1; i <= n; i++) {\n        cin >> arr[i];\n        compress.push_back(arr[i]);\n    }\n\n    sort(compress.begin(), compress.end());\n    compress.erase(unique(compress.begin(), compress.end()), compress.end());\n\n    for (int i = 1; i <= n; i++) {\n        compressed[i] = lower_bound(compress.begin(), compress.end(), arr[i]) - compress.begin();\n    }\n\n    for (int i = 0; i < q; i++) {\n        int l, r;\n        cin >> l >> r;\n        queries[r].push_back({l, i});\n    }\n\n    build(1, 1, n);\n\n    set<int> distinct;\n    for (int r = 1; r <= n; r++) {\n        distinct.insert(arr[r]);\n        for (auto query : queries[r]) {\n            int l = query.first, idx = query.second;\n            answer[idx] = distinct.size() - query(1, 1, n, 1, l - 1, compressed[r]);\n        }\n    }\n\n    for (int i = 0; i < q; i++) {\n        cout << answer[i] << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Distributing Apples",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long modpow(long long base, long long exp, long long modulus) {\n    long long result = 1;\n    base %= modulus;\n    while (exp > 0) {\n        if (exp & 1) result = (result * base) % modulus;\n        base = (base * base) % modulus;\n        exp >>= 1;\n    }\n    return result;\n}\n\nlong long modinv(long long a, long long m) {\n    return modpow(a, m - 2, m);\n}\n\nlong long nCr(long long n, long long r, long long m) {\n    if (r > n) return 0;\n    long long numerator = 1, denominator = 1;\n    for (long long i = 0; i < r; i++) {\n        numerator = (numerator * (n - i)) % m;\n        denominator = (denominator * (i + 1)) % m;\n    }\n    return (numerator * modinv(denominator, m)) % m;\n}\n\nint main() {\n    long long n, m;\n    cin >> n >> m;\n    cout << nCr(n + m - 1, m, MOD) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.08506723550649789,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Divisor Analysis",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long add(long long a, long long b) {\n    return (a + b) % MOD;\n}\n\nlong long mul(long long a, long long b) {\n    return (a * b) % MOD;\n}\n\nlong long pow_mod(long long base, long long exp) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp & 1) result = mul(result, base);\n        base = mul(base, base);\n        exp >>= 1;\n    }\n    return result;\n}\n\nlong long inv_mod(long long a) {\n    return pow_mod(a, MOD - 2);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    long long num_div = 1, sum_div = 1, prod_div = 1;\n    long long total_exp = 0;\n    \n    for (int i = 0; i < n; i++) {\n        long long x, k;\n        cin >> x >> k;\n        \n        num_div = mul(num_div, k + 1);\n        \n        long long sum_term = mul(pow_mod(x, k + 1) - 1, inv_mod(x - 1));\n        sum_div = mul(sum_div, sum_term);\n        \n        long long prod_term = pow_mod(x, (k * (k + 1) / 2) % (MOD - 1));\n        prod_div = mul(prod_div, prod_term);\n        \n        total_exp = add(total_exp, mul(k, num_div));\n    }\n    \n    prod_div = pow_mod(prod_div, inv_mod(2));\n    \n    cout << num_div << \" \" << sum_div << \" \" << prod_div << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 7,
            "mean_time_taken": 0.10550550052097865,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Download Speed",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\n\nint bfs(vector<vector<int>>& graph, vector<vector<int>>& capacity, vector<int>& parent, int source, int sink) {\n    fill(parent.begin(), parent.end(), -1);\n    parent[source] = -2;\n    queue<pair<int, int>> q;\n    q.push({source, INF});\n\n    while (!q.empty()) {\n        int cur = q.front().first;\n        int flow = q.front().second;\n        q.pop();\n\n        for (int next : graph[cur]) {\n            if (parent[next] == -1 && capacity[cur][next]) {\n                parent[next] = cur;\n                int new_flow = min(flow, capacity[cur][next]);\n                if (next == sink)\n                    return new_flow;\n                q.push({next, new_flow});\n            }\n        }\n    }\n\n    return 0;\n}\n\nint maxFlow(vector<vector<int>>& graph, vector<vector<int>>& capacity, int source, int sink) {\n    int n = graph.size();\n    vector<int> parent(n);\n    int flow = 0;\n    int new_flow;\n\n    while (new_flow = bfs(graph, capacity, parent, source, sink)) {\n        flow += new_flow;\n        int cur = sink;\n        while (cur != source) {\n            int prev = parent[cur];\n            capacity[prev][cur] -= new_flow;\n            capacity[cur][prev] += new_flow;\n            cur = prev;\n        }\n    }\n\n    return flow;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> graph(n + 1);\n    vector<vector<int>> capacity(n + 1, vector<int>(n + 1, 0));\n\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n        capacity[a][b] += c;\n    }\n\n    int max_speed = maxFlow(graph, capacity, 1, n);\n    cout << max_speed << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 16,
            "total_test_cases": 21,
            "mean_time_taken": 0.1323073250906808,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                7,
                10,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Dynamic Connectivity",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nclass DSU {\n    vector<int> parent, rank;\npublic:\n    DSU(int n) : parent(n), rank(n, 0) {\n        for (int i = 0; i < n; i++) parent[i] = i;\n    }\n    \n    int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    \n    void unite(int x, int y) {\n        x = find(x), y = find(y);\n        if (x == y) return;\n        if (rank[x] < rank[y]) swap(x, y);\n        parent[y] = x;\n        if (rank[x] == rank[y]) rank[x]++;\n    }\n};\n\nint countComponents(const DSU& dsu, int n) {\n    set<int> components;\n    for (int i = 0; i < n; i++) {\n        components.insert(dsu.find(i));\n    }\n    return components.size();\n}\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n    \n    vector<pair<int, int>> initialEdges;\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--; // Convert to 0-based indexing\n        initialEdges.emplace_back(a, b);\n    }\n    \n    vector<tuple<int, int, int>> events;\n    for (int i = 0; i < k; i++) {\n        int t, a, b;\n        cin >> t >> a >> b;\n        a--; b--; // Convert to 0-based indexing\n        events.emplace_back(t, a, b);\n    }\n    \n    DSU dsu(n);\n    for (auto [a, b] : initialEdges) {\n        dsu.unite(a, b);\n    }\n    \n    vector<int> results = {countComponents(dsu, n)};\n    \n    for (auto [t, a, b] : events) {\n        if (t == 1) {\n            dsu.unite(a, b);\n        } else {\n            // Rebuild DSU without the removed edge\n            DSU newDsu(n);\n            for (auto [x, y] : initialEdges) {\n                if ((x != a || y != b) && (x != b || y != a)) {\n                    newDsu.unite(x, y);\n                }\n            }\n            for (auto [type, x, y] : events) {\n                if (type == 1) {\n                    if ((x != a || y != b) && (x != b || y != a)) {\n                        newDsu.unite(x, y);\n                    } else {\n                        break;\n                    }\n                } else if (x == a && y == b) {\n                    break;\n                }\n            }\n            dsu = move(newDsu);\n        }\n        results.push_back(countComponents(dsu, n));\n    }\n    \n    for (int result : results) {\n        cout << result << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Dynamic Range Minimum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\nclass SegmentTree {\nprivate:\n    vector<int> tree;\n    int n;\n\n    void build(vector<int>& arr, int v, int tl, int tr) {\n        if (tl == tr) {\n            tree[v] = arr[tl];\n        } else {\n            int tm = (tl + tr) / 2;\n            build(arr, v*2, tl, tm);\n            build(arr, v*2+1, tm+1, tr);\n            tree[v] = min(tree[v*2], tree[v*2+1]);\n        }\n    }\n\n    void update(int v, int tl, int tr, int pos, int new_val) {\n        if (tl == tr) {\n            tree[v] = new_val;\n        } else {\n            int tm = (tl + tr) / 2;\n            if (pos <= tm)\n                update(v*2, tl, tm, pos, new_val);\n            else\n                update(v*2+1, tm+1, tr, pos, new_val);\n            tree[v] = min(tree[v*2], tree[v*2+1]);\n        }\n    }\n\n    int query(int v, int tl, int tr, int l, int r) {\n        if (l > r) \n            return INT_MAX;\n        if (l == tl && r == tr) \n            return tree[v];\n        int tm = (tl + tr) / 2;\n        return min(query(v*2, tl, tm, l, min(r, tm)),\n                   query(v*2+1, tm+1, tr, max(l, tm+1), r));\n    }\n\npublic:\n    SegmentTree(vector<int>& arr) {\n        n = arr.size();\n        tree.resize(4*n);\n        build(arr, 1, 0, n-1);\n    }\n\n    void update(int pos, int new_val) {\n        update(1, 0, n-1, pos-1, new_val);\n    }\n\n    int query(int l, int r) {\n        return query(1, 0, n-1, l-1, r-1);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    SegmentTree st(arr);\n\n    while (q--) {\n        int type;\n        cin >> type;\n\n        if (type == 1) {\n            int k, u;\n            cin >> k >> u;\n            st.update(k, u);\n        } else {\n            int a, b;\n            cin >> a >> b;\n            cout << st.query(a, b) << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 2,
            "mean_time_taken": 0.14299392700195312,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 28,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Dynamic Range Sum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nclass SegmentTree {\nprivate:\n    vector<ll> tree;\n    int n;\n\n    void build(vector<int>& arr, int v, int tl, int tr) {\n        if (tl == tr) {\n            tree[v] = arr[tl];\n        } else {\n            int tm = (tl + tr) / 2;\n            build(arr, v*2, tl, tm);\n            build(arr, v*2+1, tm+1, tr);\n            tree[v] = tree[v*2] + tree[v*2+1];\n        }\n    }\n\n    void update(int v, int tl, int tr, int pos, int new_val) {\n        if (tl == tr) {\n            tree[v] = new_val;\n        } else {\n            int tm = (tl + tr) / 2;\n            if (pos <= tm)\n                update(v*2, tl, tm, pos, new_val);\n            else\n                update(v*2+1, tm+1, tr, pos, new_val);\n            tree[v] = tree[v*2] + tree[v*2+1];\n        }\n    }\n\n    ll sum(int v, int tl, int tr, int l, int r) {\n        if (l > r) \n            return 0;\n        if (l == tl && r == tr) \n            return tree[v];\n        int tm = (tl + tr) / 2;\n        return sum(v*2, tl, tm, l, min(r, tm))\n             + sum(v*2+1, tm+1, tr, max(l, tm+1), r);\n    }\n\npublic:\n    SegmentTree(vector<int>& arr) {\n        n = arr.size();\n        tree.resize(4 * n);\n        build(arr, 1, 0, n - 1);\n    }\n\n    void update(int pos, int new_val) {\n        update(1, 0, n - 1, pos - 1, new_val);\n    }\n\n    ll sum(int l, int r) {\n        return sum(1, 0, n - 1, l - 1, r - 1);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    SegmentTree st(arr);\n\n    while (q--) {\n        int type;\n        cin >> type;\n\n        if (type == 1) {\n            int k, u;\n            cin >> k >> u;\n            st.update(k, u);\n        } else {\n            int a, b;\n            cin >> a >> b;\n            cout << st.sum(a, b) << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 2,
            "mean_time_taken": 0.13237690925598145,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 29,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Edit Distance",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint editDistance(const string &s1, const string &s2) {\n    int n = s1.length();\n    int m = s2.length();\n    \n    // Create a DP table\n    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\n    \n    // Base cases\n    for (int i = 0; i <= n; i++) {\n        dp[i][0] = i;  // Transforming s1[0..i] to empty string\n    }\n    for (int j = 0; j <= m; j++) {\n        dp[0][j] = j;  // Transforming empty string to s2[0..j]\n    }\n    \n    // Fill the DP table\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            if (s1[i-1] == s2[j-1]) {\n                dp[i][j] = dp[i-1][j-1];  // No operation needed\n            } else {\n                dp[i][j] = 1 + min({dp[i-1][j],    // Delete\n                                    dp[i][j-1],    // Insert\n                                    dp[i-1][j-1]}); // Replace\n            }\n        }\n    }\n    \n    return dp[n][m];\n}\n\nint main() {\n    string s1, s2;\n    cin >> s1 >> s2;\n    \n    cout << editDistance(s1, s2) << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 17,
            "total_test_cases": 17,
            "mean_time_taken": 0.29125337039723115,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 30,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Elevator Rides",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n    \n    vector<int> weights(n);\n    for (int i = 0; i < n; i++) {\n        cin >> weights[i];\n    }\n    \n    vector<pair<int, int>> dp(1 << n, {n + 1, 0});\n    dp[0] = {1, 0};\n    \n    for (int mask = 1; mask < (1 << n); mask++) {\n        for (int i = 0; i < n; i++) {\n            if (mask & (1 << i)) {\n                auto prev = dp[mask ^ (1 << i)];\n                if (prev.second + weights[i] <= x) {\n                    prev.second += weights[i];\n                } else {\n                    prev.first++;\n                    prev.second = weights[i];\n                }\n                dp[mask] = min(dp[mask], prev);\n            }\n        }\n    }\n    \n    cout << dp[(1 << n) - 1].first << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 39,
            "total_test_cases": 39,
            "mean_time_taken": 0.2164468459593944,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 31,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Empty String",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countWays(const string& s) {\n    int n = s.length();\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n\n    // Base cases\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = 1;  // Single character\n        if (i > 0) dp[i][i-1] = 1;  // Empty substring\n    }\n\n    // Fill the dp table\n    for (int len = 2; len <= n; len++) {\n        for (int i = 0; i + len - 1 < n; i++) {\n            int j = i + len - 1;\n            \n            // Always add the ways without matching i and j\n            dp[i][j] = (dp[i+1][j] + dp[i][j-1]) % MOD;\n\n            // If characters at i and j match, add the ways of matching them\n            if (s[i] == s[j]) {\n                dp[i][j] = (dp[i][j] + dp[i+1][j-1]) % MOD;\n            }\n        }\n    }\n\n    return dp[0][n-1];\n}\n\nint main() {\n    string s;\n    cin >> s;\n    cout << countWays(s) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.08598148822784424,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 31,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Eulerian Subgraphs",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int MAX_N = 20; // Since 2^20 > 10^5\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<pair<int, int>> edges(m);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--; // 0-based indexing\n        edges[i] = {a, b};\n    }\n\n    vector<long long> dp(1 << n, 0);\n    dp[0] = 1; // Empty subgraph is Eulerian\n\n    for (auto [u, v] : edges) {\n        for (int mask = (1 << n) - 1; mask >= 0; mask--) {\n            int new_mask = mask ^ (1 << u) ^ (1 << v);\n            dp[new_mask] = (dp[new_mask] + dp[mask]) % MOD;\n        }\n    }\n\n    cout << dp[0] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 3,
            "mean_time_taken": 0.12388372421264648,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 31,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Even Outdegree Edges",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <set>\n#include <utility>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> adj(n + 1);\n    vector<int> degree(n + 1, 0);\n    vector<pair<int, int>> edges;\n\n    // Read edges and build adjacency list\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n        degree[a]++;\n        degree[b]++;\n        edges.push_back({a, b});\n    }\n\n    // Check if all nodes have even degree\n    for (int i = 1; i <= n; i++) {\n        if (degree[i] % 2 != 0) {\n            cout << \"IMPOSSIBLE\" << endl;\n            return 0;\n        }\n    }\n\n    // Assign directions\n    set<pair<int, int>> processed;\n    vector<pair<int, int>> result;\n\n    for (auto &edge : edges) {\n        int a = edge.first, b = edge.second;\n        if (processed.count({a, b}) || processed.count({b, a})) continue;\n\n        result.push_back({a, b});\n        processed.insert({a, b});\n    }\n\n    // Print result\n    for (auto &edge : result) {\n        cout << edge.first << \" \" << edge.second << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 8,
            "mean_time_taken": 0.1437920331954956,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 31,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Exponentiation",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long modpow(long long a, long long b, long long m) {\n    a %= m;\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = res * a % m;\n        a = a * a % m;\n        b >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n;\n\n    while (n--) {\n        long long a, b;\n        cin >> a >> b;\n        cout << modpow(a, b, MOD) << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 3,
            "mean_time_taken": 0.12315670649210612,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Exponentiation II",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long modPow(long long base, long long exp, int modulus) {\n    long long result = 1;\n    base %= modulus;\n    while (exp > 0) {\n        if (exp & 1)\n            result = (result * base) % modulus;\n        base = (base * base) % modulus;\n        exp >>= 1;\n    }\n    return result;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n;\n\n    while (n--) {\n        long long a, b, c;\n        cin >> a >> b >> c;\n\n        if (a == 0 && b == 0 && c == 0) {\n            cout << 1 << \"\\n\";\n            continue;\n        }\n\n        long long exp = modPow(b, c, MOD - 1);\n        long long result = modPow(a, exp, MOD);\n\n        cout << result << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 13,
            "mean_time_taken": 0.10295693690960224,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Factory Machines",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool can_produce(vector<int>& machines, long long time, long long target) {\n    long long total = 0;\n    for (int machine : machines) {\n        total += time / machine;\n        if (total >= target) return true;\n    }\n    return false;\n}\n\nint main() {\n    int n;\n    long long t;\n    cin >> n >> t;\n\n    vector<int> machines(n);\n    for (int i = 0; i < n; i++) {\n        cin >> machines[i];\n    }\n\n    long long left = 1, right = 1e18;\n    while (left < right) {\n        long long mid = left + (right - left) / 2;\n        if (can_produce(machines, mid, t)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    cout << left << endl;\n    return 0;\n}\n",
            "passed_test_cases": 18,
            "total_test_cases": 18,
            "mean_time_taken": 0.09585387176937527,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 33,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Ferris Wheel",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n    \n    vector<int> weights(n);\n    for (int i = 0; i < n; i++) {\n        cin >> weights[i];\n    }\n    \n    sort(weights.begin(), weights.end());\n    \n    int gondolas = 0;\n    int left = 0, right = n - 1;\n    \n    while (left <= right) {\n        if (left == right) {\n            gondolas++;\n            break;\n        }\n        if (weights[left] + weights[right] <= x) {\n            gondolas++;\n            left++;\n            right--;\n        } else {\n            gondolas++;\n            right--;\n        }\n    }\n    \n    cout << gondolas << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.12270388236412635,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 34,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Fibonacci Numbers",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst long long MOD = 1e9 + 7;\n\n// Structure to represent a 2x2 matrix\nstruct Matrix {\n    vector<vector<long long>> mat;\n    Matrix() : mat(2, vector<long long>(2, 0)) {}\n};\n\n// Function to multiply two matrices\nMatrix multiply(const Matrix &a, const Matrix &b) {\n    Matrix res;\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            for (int k = 0; k < 2; k++) {\n                res.mat[i][j] = (res.mat[i][j] + a.mat[i][k] * b.mat[k][j]) % MOD;\n            }\n        }\n    }\n    return res;\n}\n\n// Function to perform matrix exponentiation\nMatrix power(Matrix base, long long exp) {\n    Matrix res;\n    res.mat[0][0] = res.mat[1][1] = 1;\n    \n    while (exp > 0) {\n        if (exp & 1) {\n            res = multiply(res, base);\n        }\n        base = multiply(base, base);\n        exp >>= 1;\n    }\n    \n    return res;\n}\n\n// Function to calculate nth Fibonacci number\nlong long fibonacci(long long n) {\n    if (n <= 1) return n;\n    \n    Matrix base;\n    base.mat[0][0] = base.mat[0][1] = base.mat[1][0] = 1;\n    base.mat[1][1] = 0;\n    \n    Matrix result = power(base, n - 1);\n    return result.mat[0][0];\n}\n\nint main() {\n    long long n;\n    cin >> n;\n    cout << fibonacci(n) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.08279345432917277,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Filling Trominos",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nchar nextLetter(char c) {\n    return (c == 'Z') ? 'A' : c + 1;\n}\n\nbool fillGrid(vector<vector<char>>& grid, int n, int m) {\n    if (n * m % 3 != 0) return false;\n    \n    char letter = 'A';\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] != '.') continue;\n            \n            // Try to place L-tromino in 4 orientations\n            if (i+1 < n && j+1 < m && grid[i][j+1] == '.' && grid[i+1][j] == '.') {\n                grid[i][j] = grid[i][j+1] = grid[i+1][j] = letter;\n            } else if (i+1 < n && j-1 >= 0 && grid[i][j-1] == '.' && grid[i+1][j] == '.') {\n                grid[i][j] = grid[i][j-1] = grid[i+1][j] = letter;\n            } else if (i-1 >= 0 && j-1 >= 0 && grid[i-1][j] == '.' && grid[i][j-1] == '.') {\n                grid[i][j] = grid[i-1][j] = grid[i][j-1] = letter;\n            } else if (i-1 >= 0 && j+1 < m && grid[i-1][j] == '.' && grid[i][j+1] == '.') {\n                grid[i][j] = grid[i-1][j] = grid[i][j+1] = letter;\n            } else {\n                return false;  // Cannot place L-tromino\n            }\n            \n            letter = nextLetter(letter);\n        }\n    }\n    return true;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        \n        vector<vector<char>> grid(n, vector<char>(m, '.'));\n        \n        if (fillGrid(grid, n, m)) {\n            cout << \"YES\\n\";\n            for (const auto& row : grid) {\n                for (char c : row) {\n                    cout << c;\n                }\n                cout << \"\\n\";\n            }\n        } else {\n            cout << \"NO\\n\";\n        }\n    }\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.09005653858184814,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding Borders",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nvector<int> compute_failure_function(const string& s) {\n    int n = s.length();\n    vector<int> f(n, 0);\n    for (int i = 1, k = 0; i < n; ++i) {\n        while (k > 0 && s[i] != s[k]) {\n            k = f[k-1];\n        }\n        if (s[i] == s[k]) {\n            ++k;\n        }\n        f[i] = k;\n    }\n    return f;\n}\n\nint main() {\n    string s;\n    cin >> s;\n\n    vector<int> failure = compute_failure_function(s);\n    set<int> border_lengths;\n\n    int n = s.length();\n    int border_length = failure[n-1];\n\n    while (border_length > 0) {\n        border_lengths.insert(border_length);\n        border_length = failure[border_length-1];\n    }\n\n    for (int length : border_lengths) {\n        cout << length << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.1598737673325972,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 36,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Finding Patterns",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    std::string s;\n    std::cin >> s;\n\n    int k;\n    std::cin >> k;\n\n    std::string pattern;\n    for (int i = 0; i < k; ++i) {\n        std::cin >> pattern;\n        if (s.find(pattern) != std::string::npos) {\n            std::cout << \"YES\\n\";\n        } else {\n            std::cout << \"NO\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 15,
            "total_test_cases": 17,
            "mean_time_taken": 0.3152102582594928,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                8,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 36,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding Periods",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> compute_failure_function(const string& s) {\n    int n = s.length();\n    vector<int> fail(n, 0);\n    for (int i = 1, j = 0; i < n; i++) {\n        while (j > 0 && s[i] != s[j]) j = fail[j-1];\n        if (s[i] == s[j]) j++;\n        fail[i] = j;\n    }\n    return fail;\n}\n\nvector<int> find_periods(const string& s) {\n    int n = s.length();\n    vector<int> fail = compute_failure_function(s);\n    vector<int> periods;\n    \n    for (int i = 1; i <= n; i++) {\n        if (n % i == 0) {\n            bool is_period = true;\n            for (int j = i; j < n; j++) {\n                if (s[j] != s[j % i]) {\n                    is_period = false;\n                    break;\n                }\n            }\n            if (is_period) periods.push_back(i);\n        }\n    }\n    \n    return periods;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    string s;\n    cin >> s;\n    \n    vector<int> periods = find_periods(s);\n    \n    for (int period : periods) {\n        cout << period << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 14,
            "mean_time_taken": 0.12281911713736397,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                8,
                9,
                10,
                11,
                12,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 36,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding a Centroid",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\n\nvector<int> adj[MAX_N];\nint subtree_size[MAX_N];\nint max_subtree[MAX_N];\nint n;\n\nint dfs(int node, int parent) {\n    subtree_size[node] = 1;\n    max_subtree[node] = 0;\n    \n    for (int child : adj[node]) {\n        if (child != parent) {\n            subtree_size[node] += dfs(child, node);\n            max_subtree[node] = max(max_subtree[node], subtree_size[child]);\n        }\n    }\n    \n    max_subtree[node] = max(max_subtree[node], n - subtree_size[node]);\n    \n    return subtree_size[node];\n}\n\nint find_centroid() {\n    dfs(1, 0);\n    int centroid = 1;\n    for (int i = 2; i <= n; i++) {\n        if (max_subtree[i] < max_subtree[centroid]) {\n            centroid = i;\n        }\n    }\n    return centroid;\n}\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    \n    cout << find_centroid() << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 16,
            "mean_time_taken": 0.13672234117984772,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                5,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 36,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Fixed-Length Paths I",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nvector<int> adj[MAX_N];\nlong long result = 0;\n\nvector<int> dfs(int node, int parent, int k) {\n    vector<int> count(k + 1, 0);\n    count[0] = 1;\n\n    for (int child : adj[node]) {\n        if (child != parent) {\n            vector<int> child_count = dfs(child, node, k);\n            for (int i = 0; i < k; i++) {\n                result += (long long)count[i] * child_count[k - i - 1];\n            }\n            for (int i = 0; i < k; i++) {\n                count[i + 1] += child_count[i];\n            }\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    dfs(1, 0, k);\n\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 9,
            "total_test_cases": 20,
            "mean_time_taken": 0.44312487840652465,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n"
            ],
            "failed_test_cases": [
                3,
                4,
                7,
                8,
                9,
                12,
                13,
                16,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 36,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Fixed-Length Paths II",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nvector<int> adj[MAX_N];\nlong long ans = 0;\nint k1, k2;\n\nvector<int> dfs(int node, int parent) {\n    vector<int> cnt(k2 + 1, 0);\n    for (int child : adj[node]) {\n        if (child == parent) continue;\n        vector<int> child_cnt = dfs(child, node);\n        for (int i = k2 - 1; i >= 0; i--) {\n            ans += (long long)cnt[k2 - i - 1] * child_cnt[i];\n            if (i >= k1 - 1) ans += child_cnt[i];\n        }\n        for (int i = 0; i < k2; i++) {\n            cnt[i + 1] += child_cnt[i];\n        }\n    }\n    cnt[0]++;\n    return cnt;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n >> k1 >> k2;\n\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    dfs(1, 0);\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 23,
            "mean_time_taken": 0.413951645726743,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                7,
                8,
                9,
                10,
                11,
                14,
                15,
                16,
                17,
                19,
                20,
                21,
                22,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 36,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Flight Discount",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nconst int MAX_N = 100005;\nconst long long INF = 1e18;\n\nvector<pair<int, int>> graph[MAX_N];\nlong long dist1[MAX_N], dist2[MAX_N];\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        graph[a].push_back({b, c});\n    }\n\n    for (int i = 1; i <= n; i++) {\n        dist1[i] = dist2[i] = INF;\n    }\n\n    priority_queue<pair<long long, pair<int, bool>>, \n                   vector<pair<long long, pair<int, bool>>>, \n                   greater<pair<long long, pair<int, bool>>>> pq;\n\n    pq.push({0, {1, false}});\n    dist1[1] = 0;\n\n    while (!pq.empty()) {\n        long long d = pq.top().first;\n        int u = pq.top().second.first;\n        bool used = pq.top().second.second;\n        pq.pop();\n\n        if (used && d > dist2[u]) continue;\n        if (!used && d > dist1[u]) continue;\n\n        for (auto edge : graph[u]) {\n            int v = edge.first;\n            int cost = edge.second;\n\n            if (!used) {\n                // Don't use coupon\n                if (dist1[v] > d + cost) {\n                    dist1[v] = d + cost;\n                    pq.push({dist1[v], {v, false}});\n                }\n                // Use coupon\n                if (dist2[v] > d + cost / 2) {\n                    dist2[v] = d + cost / 2;\n                    pq.push({dist2[v], {v, true}});\n                }\n            } else {\n                // Coupon already used\n                if (dist2[v] > d + cost) {\n                    dist2[v] = d + cost;\n                    pq.push({dist2[v], {v, true}});\n                }\n            }\n        }\n    }\n\n    cout << min(dist1[n], dist2[n]) << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 24,
            "total_test_cases": 24,
            "mean_time_taken": 0.15530990560849509,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 37,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Flight Route Requests",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass DSU {\n    vector<int> parent, rank;\npublic:\n    DSU(int n) : parent(n), rank(n, 0) {\n        for (int i = 0; i < n; i++) parent[i] = i;\n    }\n    \n    int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    \n    bool unite(int x, int y) {\n        x = find(x), y = find(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        parent[y] = x;\n        if (rank[x] == rank[y]) rank[x]++;\n        return true;\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    DSU dsu(n);\n    int connections = 0;\n    \n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--; // Convert to 0-based indexing\n        \n        if (dsu.unite(a, b)) {\n            connections++;\n        }\n    }\n    \n    cout << connections << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 17,
            "mean_time_taken": 0.09259427295011632,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                9,
                11,
                12,
                15,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 37,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Flight Routes",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct State {\n    int node;\n    ll dist;\n    State(int n, ll d) : node(n), dist(d) {}\n};\n\nstruct CompareState {\n    bool operator()(const State& s1, const State& s2) {\n        return s1.dist > s2.dist;\n    }\n};\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<vector<pair<int, int>>> graph(n + 1);\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        graph[a].push_back({b, c});\n    }\n\n    vector<vector<ll>> distances(n + 1, vector<ll>(k, 1e18));\n    priority_queue<State, vector<State>, CompareState> pq;\n\n    pq.push(State(1, 0));\n    distances[1][0] = 0;\n\n    vector<ll> result;\n\n    while (!pq.empty() && result.size() < k) {\n        State current = pq.top();\n        pq.pop();\n\n        if (current.node == n) {\n            result.push_back(current.dist);\n            continue;\n        }\n\n        for (auto& edge : graph[current.node]) {\n            int next_node = edge.first;\n            ll next_dist = current.dist + edge.second;\n\n            if (distances[next_node].back() > next_dist) {\n                distances[next_node].pop_back();\n                distances[next_node].push_back(next_dist);\n                sort(distances[next_node].begin(), distances[next_node].end());\n                pq.push(State(next_node, next_dist));\n            }\n        }\n    }\n\n    for (ll price : result) {\n        cout << price << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 16,
            "total_test_cases": 17,
            "mean_time_taken": 0.3746623852673699,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 37,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Flight Routes Check",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nconst int MAX_N = 100005;\n\nvector<int> graph[MAX_N], rev_graph[MAX_N];\nbool visited[MAX_N];\nstack<int> finish_order;\nint n, m;\n\nvoid dfs1(int v) {\n    visited[v] = true;\n    for (int u : graph[v]) {\n        if (!visited[u]) {\n            dfs1(u);\n        }\n    }\n    finish_order.push(v);\n}\n\nvoid dfs2(int v) {\n    visited[v] = true;\n    for (int u : rev_graph[v]) {\n        if (!visited[u]) {\n            dfs2(u);\n        }\n    }\n}\n\nint main() {\n    cin >> n >> m;\n    \n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        rev_graph[b].push_back(a);\n    }\n\n    // First DFS\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            dfs1(i);\n        }\n    }\n\n    // Reset visited array\n    fill(visited + 1, visited + n + 1, false);\n\n    // Second DFS\n    int start = finish_order.top();\n    dfs2(start);\n\n    // Check if all nodes were visited\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            cout << \"NO\" << endl;\n            cout << start << \" \" << i << endl;\n            return 0;\n        }\n    }\n\n    cout << \"YES\" << endl;\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 20,
            "mean_time_taken": 0.12616589069366455,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 37,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Food Division",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<long long> current(n), desired(n), diff(n);\n    \n    for (int i = 0; i < n; i++) cin >> current[i];\n    for (int i = 0; i < n; i++) cin >> desired[i];\n\n    // Calculate difference\n    for (int i = 0; i < n; i++) {\n        diff[i] = current[i] - desired[i];\n    }\n\n    long long cumulative_sum = 0;\n    long long max_abs_sum = 0;\n\n    // Find maximum absolute cumulative sum\n    for (int i = 0; i < n; i++) {\n        cumulative_sum += diff[i];\n        max_abs_sum = max(max_abs_sum, abs(cumulative_sum));\n    }\n\n    cout << max_abs_sum << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 5,
            "mean_time_taken": 0.10682735443115235,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 37,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Forbidden Cities",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N = 100005;\nbool can_reach[MAX_N][MAX_N][MAX_N];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m, q;\n    cin >> n >> m >> q;\n\n    // Initialize all direct connections\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            can_reach[i][j][0] = (i == j);\n        }\n    }\n\n    // Read roads\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        can_reach[a][b][0] = can_reach[b][a][0] = true;\n    }\n\n    // Floyd-Warshall algorithm\n    for (int k = 1; k <= n; k++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                can_reach[i][j][k] = can_reach[i][j][k-1] || \n                                     (can_reach[i][k][k-1] && can_reach[k][j][k-1]);\n            }\n        }\n    }\n\n    // Process queries\n    for (int i = 0; i < q; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        cout << (can_reach[a][b][c-1] ? \"YES\" : \"NO\") << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 37,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Forest Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n\n    // Create and fill the prefix sum array\n    vector<vector<int>> prefix(n+1, vector<int>(n+1, 0));\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            char c;\n            cin >> c;\n            prefix[i][j] = prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1] + (c == '*');\n        }\n    }\n\n    // Process queries\n    while (q--) {\n        int y1, x1, y2, x2;\n        cin >> y1 >> x1 >> y2 >> x2;\n        int trees = prefix[y2][x2] - prefix[y1-1][x2] - prefix[y2][x1-1] + prefix[y1-1][x1-1];\n        cout << trees << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 3,
            "mean_time_taken": 0.11412676175435384,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 38,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Forest Queries II",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass BIT2D {\n    vector<vector<int>> bit;\n    int n;\n\npublic:\n    BIT2D(int size) : n(size + 1) {\n        bit.resize(n, vector<int>(n, 0));\n    }\n\n    void update(int y, int x, int val) {\n        for (int i = y; i < n; i += i & -i)\n            for (int j = x; j < n; j += j & -j)\n                bit[i][j] += val;\n    }\n\n    int query(int y, int x) {\n        int sum = 0;\n        for (int i = y; i > 0; i -= i & -i)\n            for (int j = x; j > 0; j -= j & -j)\n                sum += bit[i][j];\n        return sum;\n    }\n\n    int rangeQuery(int y1, int x1, int y2, int x2) {\n        return query(y2, x2) - query(y1-1, x2) - query(y2, x1-1) + query(y1-1, x1-1);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n\n    BIT2D forest(n);\n    vector<vector<bool>> hasTree(n+1, vector<bool>(n+1, false));\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            char c;\n            cin >> c;\n            if (c == '*') {\n                forest.update(i, j, 1);\n                hasTree[i][j] = true;\n            }\n        }\n    }\n\n    while (q--) {\n        int type;\n        cin >> type;\n\n        if (type == 1) {\n            int y, x;\n            cin >> y >> x;\n            if (hasTree[y][x]) {\n                forest.update(y, x, -1);\n                hasTree[y][x] = false;\n            } else {\n                forest.update(y, x, 1);\n                hasTree[y][x] = true;\n            }\n        } else {\n            int y1, x1, y2, x2;\n            cin >> y1 >> x1 >> y2 >> x2;\n            cout << forest.rangeQuery(y1, x1, y2, x2) << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 5,
            "mean_time_taken": 0.24386463165283204,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 39,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Functional Graph Distribution",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<vector<long long>> dp(n + 1, vector<long long>(n + 1, 0));\n\n    // Base cases\n    for (int i = 1; i <= n; i++) {\n        dp[i][i] = 1;\n    }\n    dp[1][1] = 1;\n\n    // Fill the dp table\n    for (int i = 2; i <= n; i++) {\n        for (int j = 1; j <= i; j++) {\n            dp[i][j] = (dp[i-1][j] * (i-1) % MOD + dp[i-1][j-1]) % MOD;\n        }\n    }\n\n    // Sum up and print the results\n    for (int k = 1; k <= n; k++) {\n        long long sum = 0;\n        for (int i = k; i <= n; i++) {\n            sum = (sum + dp[n][i]) % MOD;\n        }\n        cout << sum << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.14045283198356628,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 39,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Game Routes",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nvector<vector<int>> graph;\nvector<bool> visited;\nvector<long long> dp;\nstack<int> topo_order;\n\nvoid dfs(int node) {\n    visited[node] = true;\n    for (int neighbor : graph[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor);\n        }\n    }\n    topo_order.push(node);\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    graph.resize(n + 1);\n    visited.resize(n + 1, false);\n    dp.resize(n + 1, 0);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n    }\n\n    // Topological sort\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            dfs(i);\n        }\n    }\n\n    // Dynamic programming\n    dp[1] = 1;\n    while (!topo_order.empty()) {\n        int node = topo_order.top();\n        topo_order.pop();\n        for (int neighbor : graph[node]) {\n            dp[neighbor] = (dp[neighbor] + dp[node]) % MOD;\n        }\n    }\n\n    cout << dp[n] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 15,
            "total_test_cases": 15,
            "mean_time_taken": 0.12360711097717285,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Giant Pizza",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <string>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\n\nvector<int> graph[MAX_N], rev_graph[MAX_N];\nbool visited[MAX_N];\nint scc[MAX_N], scc_count;\nstack<int> st;\nstring result;\n\nvoid dfs1(int v) {\n    visited[v] = true;\n    for (int u : graph[v]) {\n        if (!visited[u]) dfs1(u);\n    }\n    st.push(v);\n}\n\nvoid dfs2(int v) {\n    scc[v] = scc_count;\n    for (int u : rev_graph[v]) {\n        if (scc[u] == -1) dfs2(u);\n    }\n}\n\nvoid add_edge(int a, int b) {\n    graph[a].push_back(b);\n    rev_graph[b].push_back(a);\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < n; i++) {\n        char c1, c2;\n        int x, y;\n        cin >> c1 >> x >> c2 >> y;\n        x--; y--;  // 0-based indexing\n        \n        add_edge(2*x + (c1 == '-'), 2*y + (c2 == '+'));\n        add_edge(2*y + (c2 == '-'), 2*x + (c1 == '+'));\n    }\n\n    for (int i = 0; i < 2*m; i++) {\n        if (!visited[i]) dfs1(i);\n    }\n\n    fill(scc, scc + 2*m, -1);\n    while (!st.empty()) {\n        int v = st.top();\n        st.pop();\n        if (scc[v] == -1) {\n            dfs2(v);\n            scc_count++;\n        }\n    }\n\n    result = string(m, '?');\n    for (int i = 0; i < m; i++) {\n        if (scc[2*i] == scc[2*i + 1]) {\n            cout << \"IMPOSSIBLE\" << endl;\n            return 0;\n        }\n        result[i] = (scc[2*i] > scc[2*i + 1]) ? '+' : '-';\n    }\n\n    cout << result << endl;\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 22,
            "mean_time_taken": 0.13202333450317383,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                22
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Graph Girth",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nconst int INF = INT_MAX;\n\nint bfs(int start, const std::vector<std::vector<int>>& graph) {\n    int n = graph.size();\n    std::vector<int> distance(n, INF);\n    std::vector<int> parent(n, -1);\n    std::queue<int> q;\n\n    distance[start] = 0;\n    q.push(start);\n\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n\n        for (int u : graph[v]) {\n            if (distance[u] == INF) {\n                distance[u] = distance[v] + 1;\n                parent[u] = v;\n                q.push(u);\n            } else if (parent[v] != u && parent[u] != v) {\n                return distance[v] + distance[u] + 1;\n            }\n        }\n    }\n\n    return INF;\n}\n\nint findGirth(const std::vector<std::vector<int>>& graph) {\n    int n = graph.size();\n    int girth = INF;\n\n    for (int i = 0; i < n; ++i) {\n        girth = std::min(girth, bfs(i, graph));\n    }\n\n    return girth == INF ? -1 : girth;\n}\n\nint main() {\n    int n, m;\n    std::cin >> n >> m;\n\n    std::vector<std::vector<int>> graph(n);\n\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        std::cin >> a >> b;\n        --a; --b; // Convert to 0-based indexing\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n\n    int result = findGirth(graph);\n    std::cout << result << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 17,
            "total_test_cases": 20,
            "mean_time_taken": 0.14300400018692017,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                10,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Graph Paths I",
            "category": "Mathematics",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int MAXN = 100;\n\nstruct Matrix {\n    long long mat[MAXN][MAXN];\n    int n;\n\n    Matrix(int _n) : n(_n) {\n        memset(mat, 0, sizeof(mat));\n    }\n\n    Matrix operator*(const Matrix& other) const {\n        Matrix result(n);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int k = 0; k < n; k++) {\n                    result.mat[i][j] = (result.mat[i][j] + mat[i][k] * other.mat[k][j]) % MOD;\n                }\n            }\n        }\n        return result;\n    }\n};\n\nMatrix matrix_power(Matrix base, long long exp) {\n    Matrix result(base.n);\n    for (int i = 0; i < base.n; i++) {\n        result.mat[i][i] = 1;\n    }\n\n    while (exp > 0) {\n        if (exp & 1) {\n            result = result * base;\n        }\n        base = base * base;\n        exp >>= 1;\n    }\n\n    return result;\n}\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    Matrix adj(n);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--; // Convert to 0-based indexing\n        adj.mat[a][b]++;\n    }\n\n    Matrix result = matrix_power(adj, k);\n    cout << result.mat[0][n-1] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.14935476439339773,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 41,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Graph Paths II",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <climits>\n\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1e18;\n\nstruct Matrix {\n    vector<vector<ll>> mat;\n    int n;\n\n    Matrix(int _n) : n(_n) {\n        mat.assign(n, vector<ll>(n, INF));\n    }\n\n    Matrix operator*(const Matrix& other) const {\n        Matrix result(n);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int k = 0; k < n; k++) {\n                    result.mat[i][j] = min(result.mat[i][j], mat[i][k] + other.mat[k][j]);\n                }\n            }\n        }\n        return result;\n    }\n};\n\nMatrix matrix_power(Matrix base, ll exp) {\n    Matrix result(base.n);\n    for (int i = 0; i < base.n; i++) result.mat[i][i] = 0;\n\n    while (exp > 0) {\n        if (exp & 1) result = result * base;\n        base = base * base;\n        exp >>= 1;\n    }\n    return result;\n}\n\nint main() {\n    int n, m;\n    ll k;\n    cin >> n >> m >> k;\n\n    Matrix graph(n);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        ll c;\n        cin >> a >> b >> c;\n        a--; b--; // Convert to 0-based indexing\n        graph.mat[a][b] = min(graph.mat[a][b], c);\n    }\n\n    Matrix result = matrix_power(graph, k);\n\n    ll ans = result.mat[0][n-1];\n    if (ans >= INF) ans = -1;\n    cout << ans << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 14,
            "total_test_cases": 15,
            "mean_time_taken": 0.2403109073638916,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 41,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Gray Code",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<string> generateGrayCode(int n) {\n    if (n == 1) {\n        return {\"0\", \"1\"};\n    }\n    \n    vector<string> prevCode = generateGrayCode(n - 1);\n    vector<string> result;\n    \n    // Prepend '0' to each code from the previous solution\n    for (const string& code : prevCode) {\n        result.push_back(\"0\" + code);\n    }\n    \n    // Prepend '1' to each code from the previous solution in reverse order\n    for (int i = prevCode.size() - 1; i >= 0; i--) {\n        result.push_back(\"1\" + prevCode[i]);\n    }\n    \n    return result;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<string> grayCode = generateGrayCode(n);\n    \n    for (const string& code : grayCode) {\n        cout << code << endl;\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 16,
            "total_test_cases": 16,
            "mean_time_taken": 0.08991557359695435,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Grid Completion",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int MAXN = 505;\n\nint n;\nchar grid[MAXN][MAXN];\nbool row_a[MAXN], row_b[MAXN], col_a[MAXN], col_b[MAXN];\nvector<int> graph[MAXN];\nint match[MAXN];\nbool vis[MAXN];\n\nbool dfs(int u) {\n    vis[u] = true;\n    for (int v : graph[u]) {\n        if (match[v] == -1 || (!vis[match[v]] && dfs(match[v]))) {\n            match[v] = u;\n            return true;\n        }\n    }\n    return false;\n}\n\nint hungarian() {\n    memset(match, -1, sizeof(match));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        if (!row_a[i]) {\n            memset(vis, 0, sizeof(vis));\n            if (dfs(i)) result++;\n        }\n    }\n    return result;\n}\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> grid[i][j];\n            if (grid[i][j] == 'A') {\n                row_a[i] = col_a[j] = true;\n            } else if (grid[i][j] == 'B') {\n                row_b[i] = col_b[j] = true;\n            }\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (!row_a[i]) {\n            for (int j = 0; j < n; j++) {\n                if (!col_b[j] && grid[i][j] == '.') {\n                    graph[i].push_back(j);\n                }\n            }\n        }\n    }\n\n    int matched = hungarian();\n    long long ways = 1;\n    for (int i = 1; i <= matched; i++) {\n        ways = (ways * i) % MOD;\n    }\n\n    cout << ways << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 6,
            "mean_time_taken": 0.09321506818135579,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Path Construction",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring solve(int n, int m, int y1, int x1, int y2, int x2) {\n    y1--; x1--; y2--; x2--;  // Convert to 0-indexed\n\n    if (n == 1) {\n        return (x1 == 0 && x2 == m-1) ? string(m-1, 'R') : \"NO\";\n    }\n    if (m == 1) {\n        return (y1 == 0 && y2 == n-1) ? string(n-1, 'D') : \"NO\";\n    }\n    if (n == 2 && m == 2) {\n        return (y1 != y2 && x1 != x2) ? \"RD\" : \"NO\";\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    string path;\n    int y = y1, x = x1;\n    visited[y][x] = true;\n\n    auto move = [&](char dir) {\n        path += dir;\n        if (dir == 'U') y--;\n        if (dir == 'D') y++;\n        if (dir == 'L') x--;\n        if (dir == 'R') x++;\n        visited[y][x] = true;\n    };\n\n    // Fill all but last two rows\n    for (int i = 0; i < n-2; i++) {\n        if (i % 2 == 0) {\n            while (x < m-1) move('R');\n            if (i < n-3) move('D');\n        } else {\n            while (x > 0) move('L');\n            move('D');\n        }\n    }\n\n    // Fill last two rows\n    if ((n-y1) % 2 == 1) {\n        while (y < n-1) move('D');\n        while (x > 0) move('L');\n        move('D');\n        while (x < m-1) move('R');\n    } else {\n        while (x > 0) move('L');\n        move('D');\n        while (x < m-1) move('R');\n        move('D');\n        while (x > 0) move('L');\n    }\n\n    // Reach the target\n    while (y < y2) move('D');\n    while (y > y2) move('U');\n    while (x < x2) move('R');\n    while (x > x2) move('L');\n\n    return path;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m, y1, x1, y2, x2;\n        cin >> n >> m >> y1 >> x1 >> y2 >> x2;\n        string result = solve(n, m, y1, x1, y2, x2);\n        cout << (result == \"NO\" ? \"NO\" : \"YES\") << endl;\n        if (result != \"NO\") cout << result << endl;\n    }\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 20,
            "mean_time_taken": 0.12949241399765016,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Paths",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<bool>> grid(n+1, vector<bool>(n+1, false));\n    for (int i = 0; i < m; i++) {\n        int y, x;\n        cin >> y >> x;\n        grid[y][x] = true;  // Mark trap positions\n    }\n\n    vector<int> dp(n+1, 0);\n    dp[1] = 1;  // One way to reach the start\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i == 1 && j == 1) continue;  // Skip the start position\n            if (grid[i][j]) {\n                dp[j] = 0;  // No ways to reach a trap\n            } else {\n                dp[j] = (dp[j] + dp[j-1]) % MOD;\n            }\n        }\n    }\n\n    cout << dp[n] << endl;\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 20,
            "mean_time_taken": 0.143762469291687,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                12,
                14,
                16,
                17,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Paths",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 7;\nvector<vector<bool>> visited(N, vector<bool>(N, false));\nstring path;\nint count = 0;\n\nbool isValid(int x, int y) {\n    return x >= 0 && x < N && y >= 0 && y < N && !visited[x][y];\n}\n\nvoid dfs(int x, int y, int idx) {\n    if (x == N-1 && y == 0) {\n        if (idx == 48) count++;\n        return;\n    }\n    \n    if (idx == 48) return;\n    \n    visited[x][y] = true;\n    \n    if (path[idx] == '?' || path[idx] == 'D') {\n        if (isValid(x+1, y)) dfs(x+1, y, idx+1);\n    }\n    if (path[idx] == '?' || path[idx] == 'U') {\n        if (isValid(x-1, y)) dfs(x-1, y, idx+1);\n    }\n    if (path[idx] == '?' || path[idx] == 'L') {\n        if (isValid(x, y-1)) dfs(x, y-1, idx+1);\n    }\n    if (path[idx] == '?' || path[idx] == 'R') {\n        if (isValid(x, y+1)) dfs(x, y+1, idx+1);\n    }\n    \n    visited[x][y] = false;\n}\n\nint main() {\n    cin >> path;\n    \n    dfs(0, 0, 0);\n    \n    cout << count << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 20,
            "mean_time_taken": 0.9612658619880676,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Paths",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countPaths(int n, vector<string>& grid) {\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n    \n    // Base case\n    if (grid[0][0] == '*') return 0;\n    dp[0][0] = 1;\n    \n    // Fill first row\n    for (int j = 1; j < n; j++) {\n        if (grid[0][j] != '*') dp[0][j] = dp[0][j-1];\n    }\n    \n    // Fill first column\n    for (int i = 1; i < n; i++) {\n        if (grid[i][0] != '*') dp[i][0] = dp[i-1][0];\n    }\n    \n    // Fill the rest of the dp table\n    for (int i = 1; i < n; i++) {\n        for (int j = 1; j < n; j++) {\n            if (grid[i][j] != '*') {\n                dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD;\n            }\n        }\n    }\n    \n    return dp[n-1][n-1];\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<string> grid(n);\n    for (int i = 0; i < n; i++) {\n        cin >> grid[i];\n    }\n    \n    cout << countPaths(n, grid) << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 15,
            "total_test_cases": 20,
            "mean_time_taken": 0.10081247091293336,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                7,
                10,
                16,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Puzzle I",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> a(n), b(n);\n    int sum_a = 0, sum_b = 0;\n\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        sum_a += a[i];\n    }\n\n    for (int i = 0; i < n; i++) {\n        cin >> b[i];\n        sum_b += b[i];\n    }\n\n    if (sum_a != sum_b) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    vector<vector<char>> grid(n, vector<char>(n, '.'));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (a[i] > 0 && b[j] > 0) {\n                grid[i][j] = 'X';\n                a[i]--;\n                b[j]--;\n            }\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (a[i] != 0 || b[i] != 0) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << grid[i][j];\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 12,
            "mean_time_taken": 0.08378336826960246,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                6,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Puzzle II",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\nconst int MAXN = 55;\n\nint n, source, sink;\nint grid[MAXN][MAXN], a[MAXN], b[MAXN];\nvector<vector<int>> capacity, flow;\nvector<int> parent;\n\nint bfs(int s, int t, int min_edge) {\n    fill(parent.begin(), parent.end(), -1);\n    parent[s] = -2;\n    queue<pair<int, int>> q;\n    q.push({s, INF});\n\n    while (!q.empty()) {\n        int cur = q.front().first;\n        int flow = q.front().second;\n        q.pop();\n\n        for (int next = 0; next < sink + 1; next++) {\n            if (parent[next] == -1 && capacity[cur][next] - ::flow[cur][next] >= min_edge) {\n                parent[next] = cur;\n                int new_flow = min(flow, capacity[cur][next] - ::flow[cur][next]);\n                if (next == t)\n                    return new_flow;\n                q.push({next, new_flow});\n            }\n        }\n    }\n\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int result = 0;\n    for (int scaling = 512; scaling > 0; scaling /= 2) {\n        while (true) {\n            int flow = bfs(s, t, scaling);\n            if (flow == 0)\n                break;\n            result += flow;\n            int cur = t;\n            while (cur != s) {\n                int prev = parent[cur];\n                ::flow[prev][cur] += flow;\n                ::flow[cur][prev] -= flow;\n                cur = prev;\n            }\n        }\n    }\n    return result;\n}\n\nint main() {\n    cin >> n;\n    source = 0;\n    sink = 2 * n + 1;\n\n    for (int i = 1; i <= n; i++)\n        cin >> a[i];\n    for (int j = 1; j <= n; j++)\n        cin >> b[j];\n\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++)\n            cin >> grid[i][j];\n\n    capacity.assign(sink + 1, vector<int>(sink + 1, 0));\n    flow.assign(sink + 1, vector<int>(sink + 1, 0));\n    parent.assign(sink + 1, -1);\n\n    int total_sum = 0;\n    for (int i = 1; i <= n; i++) {\n        capacity[source][i] = a[i];\n        total_sum += a[i];\n        for (int j = 1; j <= n; j++) {\n            capacity[i][n + j] = grid[i][j];\n        }\n    }\n\n    for (int j = 1; j <= n; j++) {\n        capacity[n + j][sink] = b[j];\n    }\n\n    int max_coins = max_flow(source, sink);\n\n    if (max_coins != total_sum) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    cout << max_coins << endl;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (flow[i][n + j] > 0)\n                cout << 'X';\n            else\n                cout << '.';\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 8,
            "mean_time_taken": 0.0837632417678833,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grundy's Game",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N = 1000000;\n\nvector<bool> precompute_winners() {\n    vector<bool> dp(MAX_N + 1, false);\n    for (int i = 3; i <= MAX_N; ++i) {\n        for (int j = 1; j < i - j; ++j) {\n            if (!dp[j] && !dp[i - j]) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    vector<bool> winners = precompute_winners();\n\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n;\n        cin >> n;\n        cout << (winners[n] ? \"first\" : \"second\") << '\\n';\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 1.0366895198822021,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Hamiltonian Flights",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int MAXN = 20;\n\nvector<int> graph[MAXN];\nlong long dp[1 << MAXN][MAXN];\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--; // 0-based indexing\n        graph[a].push_back(b);\n    }\n\n    dp[1][0] = 1; // Base case: one way to start at city 1\n\n    for (int mask = 1; mask < (1 << n); mask++) {\n        for (int i = 0; i < n; i++) {\n            if (mask & (1 << i)) { // if city i is visited in this mask\n                for (int j : graph[i]) {\n                    if (!(mask & (1 << j))) { // if city j is not visited\n                        dp[mask | (1 << j)][j] += dp[mask][i];\n                        dp[mask | (1 << j)][j] %= MOD;\n                    }\n                }\n            }\n        }\n    }\n\n    cout << dp[(1 << n) - 1][n - 1] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 20,
            "mean_time_taken": 0.563382887840271,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                5,
                6,
                8,
                9,
                12,
                14,
                16,
                18,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Hamming Distance",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint hammingDistance(const string& a, const string& b) {\n    int distance = 0;\n    for (int i = 0; i < a.length(); i++) {\n        if (a[i] != b[i]) distance++;\n    }\n    return distance;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<string> strings(n);\n    for (int i = 0; i < n; i++) {\n        cin >> strings[i];\n    }\n\n    int minDistance = k + 1;  // Initialize to a value larger than possible\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int distance = hammingDistance(strings[i], strings[j]);\n            minDistance = min(minDistance, distance);\n            if (minDistance == 1) break;  // Early exit if we find distance 1\n        }\n        if (minDistance == 1) break;  // Early exit if we find distance 1\n    }\n\n    cout << minDistance << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 15,
            "mean_time_taken": 0.522330904006958,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                5,
                7,
                8,
                12,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "High Score",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nconst long long INF = 1e18;\n\nstruct Edge {\n    int to;\n    long long weight;\n};\n\nvector<vector<Edge>> graph;\nvector<bool> reachable_from_cycle;\n\nvoid dfs(int v) {\n    reachable_from_cycle[v] = true;\n    for (auto& e : graph[v]) {\n        if (!reachable_from_cycle[e.to]) {\n            dfs(e.to);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    graph.resize(n + 1);\n    vector<long long> dist(n + 1, -INF);\n    vector<bool> in_queue(n + 1, false);\n    vector<int> count(n + 1, 0);\n    queue<int> q;\n\n    for (int i = 0; i < m; i++) {\n        int a, b, x;\n        cin >> a >> b >> x;\n        graph[a].push_back({b, x});\n    }\n\n    dist[1] = 0;\n    q.push(1);\n    in_queue[1] = true;\n\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        in_queue[v] = false;\n\n        for (auto& e : graph[v]) {\n            if (dist[v] + e.weight > dist[e.to]) {\n                dist[e.to] = dist[v] + e.weight;\n                if (!in_queue[e.to]) {\n                    q.push(e.to);\n                    in_queue[e.to] = true;\n                    count[e.to]++;\n                    if (count[e.to] > n) {\n                        reachable_from_cycle.assign(n + 1, false);\n                        dfs(e.to);\n                        if (reachable_from_cycle[n]) {\n                            cout << -1 << endl;\n                            return 0;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    if (dist[n] == -INF) {\n        cout << \"No path from 1 to n\" << endl;\n    } else {\n        cout << dist[n] << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 34,
            "total_test_cases": 43,
            "mean_time_taken": 0.30253554499426555,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                6,
                10,
                13,
                14,
                15,
                25,
                34,
                36,
                42
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Hotel Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nclass SegmentTree {\n    vector<int> tree;\n    int n;\n\npublic:\n    SegmentTree(const vector<int>& arr) {\n        n = arr.size();\n        tree.resize(4 * n);\n        build(arr, 1, 0, n - 1);\n    }\n\n    void build(const vector<int>& arr, int v, int tl, int tr) {\n        if (tl == tr) {\n            tree[v] = arr[tl];\n        } else {\n            int tm = (tl + tr) / 2;\n            build(arr, v*2, tl, tm);\n            build(arr, v*2+1, tm+1, tr);\n            tree[v] = max(tree[v*2], tree[v*2+1]);\n        }\n    }\n\n    int query(int rooms, int v, int tl, int tr) {\n        if (tree[v] < rooms) return 0;\n        if (tl == tr) return tl + 1;\n        int tm = (tl + tr) / 2;\n        if (tree[v*2] >= rooms)\n            return query(rooms, v*2, tl, tm);\n        else\n            return query(rooms, v*2+1, tm+1, tr);\n    }\n\n    void update(int pos, int new_val, int v, int tl, int tr) {\n        if (tl == tr) {\n            tree[v] = new_val;\n        } else {\n            int tm = (tl + tr) / 2;\n            if (pos <= tm)\n                update(pos, new_val, v*2, tl, tm);\n            else\n                update(pos, new_val, v*2+1, tm+1, tr);\n            tree[v] = max(tree[v*2], tree[v*2+1]);\n        }\n    }\n\n    int find_hotel(int rooms) {\n        return query(rooms, 1, 0, n - 1);\n    }\n\n    void decrease_rooms(int hotel, int rooms) {\n        int new_val = tree[hotel] - rooms;\n        update(hotel - 1, new_val, 1, 0, n - 1);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> hotels(n);\n    for (int i = 0; i < n; i++) {\n        cin >> hotels[i];\n    }\n\n    SegmentTree st(hotels);\n\n    for (int i = 0; i < m; i++) {\n        int rooms;\n        cin >> rooms;\n        int hotel = st.find_hotel(rooms);\n        cout << hotel << \" \";\n        if (hotel > 0) {\n            st.decrease_rooms(hotel, rooms);\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 11,
            "mean_time_taken": 0.11123973673040216,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                7,
                8,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Houses and Schools",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 3005;\nconst long long INF = 1e18;\n\nint n, k;\nlong long c[MAXN], prefix_sum[MAXN], prefix_distance[MAXN];\nlong long dp[MAXN][MAXN];\n\nlong long get_distance(int l, int r) {\n    long long mid = (l + r) / 2;\n    long long left_sum = prefix_sum[mid] - prefix_sum[l-1];\n    long long right_sum = prefix_sum[r] - prefix_sum[mid];\n    long long left_dist = prefix_distance[mid] - prefix_distance[l-1];\n    long long right_dist = prefix_distance[r] - prefix_distance[mid];\n    return (mid * left_sum - left_dist) + (right_dist - mid * right_sum);\n}\n\nint main() {\n    cin >> n >> k;\n    \n    for (int i = 1; i <= n; i++) {\n        cin >> c[i];\n        prefix_sum[i] = prefix_sum[i-1] + c[i];\n        prefix_distance[i] = prefix_distance[i-1] + i * c[i];\n    }\n    \n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= k; j++) {\n            dp[i][j] = INF;\n        }\n    }\n    \n    dp[0][0] = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= k; j++) {\n            for (int prev = 0; prev < i; prev++) {\n                dp[i][j] = min(dp[i][j], dp[prev][j-1] + get_distance(prev+1, i));\n            }\n        }\n    }\n    \n    cout << dp[n][k] << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 6,
            "mean_time_taken": 0.6062678098678589,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Increasing Array",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    long long moves = 0;\n    int max_so_far = arr[0];\n\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < max_so_far) {\n            moves += max_so_far - arr[i];\n        } else {\n            max_so_far = arr[i];\n        }\n    }\n\n    cout << moves << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 7,
            "mean_time_taken": 0.09680448259626116,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Increasing Array II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<long long> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    long long current_max = arr[0];\n    long long total_moves = 0;\n\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < current_max) {\n            total_moves += current_max - arr[i];\n        } else {\n            current_max = arr[i];\n        }\n    }\n\n    cout << total_moves << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 7,
            "mean_time_taken": 0.10336678368704659,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Increasing Array Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nclass SegmentTree {\n    vector<ll> tree;\n    int n;\n\npublic:\n    SegmentTree(int size) {\n        n = size;\n        tree.resize(4 * n, 0);\n    }\n\n    void update(int node, int start, int end, int idx, ll val) {\n        if (start == end) {\n            tree[node] = val;\n            return;\n        }\n        int mid = (start + end) / 2;\n        if (idx <= mid)\n            update(2 * node, start, mid, idx, val);\n        else\n            update(2 * node + 1, mid + 1, end, idx, val);\n        tree[node] = tree[2 * node] + tree[2 * node + 1];\n    }\n\n    ll query(int node, int start, int end, int l, int r) {\n        if (r < start || end < l) return 0;\n        if (l <= start && end <= r) return tree[node];\n        int mid = (start + end) / 2;\n        return query(2 * node, start, mid, l, r) + query(2 * node + 1, mid + 1, end, l, r);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n\n    vector<ll> arr(n + 1);\n    for (int i = 1; i <= n; i++) {\n        cin >> arr[i];\n    }\n\n    SegmentTree st(n + 1);\n    ll max_so_far = 0;\n    for (int i = 1; i <= n; i++) {\n        if (arr[i] < max_so_far) {\n            st.update(1, 1, n, i, max_so_far - arr[i]);\n        }\n        max_so_far = max(max_so_far, arr[i]);\n    }\n\n    while (q--) {\n        int a, b;\n        cin >> a >> b;\n        cout << st.query(1, 1, n, a, b) << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 8,
            "mean_time_taken": 0.17025351524353027,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Increasing Subsequence",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    \n    vector<int> lis;\n    \n    for (int i = 0; i < n; i++) {\n        auto it = lower_bound(lis.begin(), lis.end(), arr[i]);\n        if (it == lis.end()) {\n            lis.push_back(arr[i]);\n        } else {\n            *it = arr[i];\n        }\n    }\n    \n    cout << lis.size() << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 17,
            "total_test_cases": 17,
            "mean_time_taken": 0.10175453915315516,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 44,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Increasing Subsequence II",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nclass FenwickTree {\n    vector<int> bit;\n    int n;\n\npublic:\n    FenwickTree(int n) {\n        this->n = n + 1;\n        bit.assign(this->n, 0);\n    }\n\n    void update(int idx, int val) {\n        for (++idx; idx < n; idx += idx & -idx)\n            bit[idx] = (bit[idx] + val) % MOD;\n    }\n\n    int query(int idx) {\n        int res = 0;\n        for (++idx; idx > 0; idx -= idx & -idx)\n            res = (res + bit[idx]) % MOD;\n        return res;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    set<int> unique_values;\n\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        unique_values.insert(a[i]);\n    }\n\n    map<int, int> compress;\n    int idx = 0;\n    for (int x : unique_values) {\n        compress[x] = idx++;\n    }\n\n    FenwickTree ft(unique_values.size());\n\n    long long result = 0;\n    for (int i = 0; i < n; i++) {\n        int pos = compress[a[i]];\n        int count = (ft.query(pos - 1) + 1) % MOD;\n        ft.update(pos, count);\n        result = (result + count) % MOD;\n    }\n\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.15774741172790527,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 45,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Intersection Points",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n};\n\nstruct Segment {\n    Point start, end;\n    bool isVertical;\n};\n\nbool compareVertical(const Segment& a, const Segment& b) {\n    return a.start.x < b.start.x;\n}\n\nbool intersects(const Segment& horizontal, const Segment& vertical) {\n    return horizontal.start.x <= vertical.start.x && horizontal.end.x >= vertical.start.x &&\n           vertical.start.y <= horizontal.start.y && vertical.end.y >= horizontal.start.y;\n}\n\nint countIntersections(vector<Segment>& horizontals, vector<Segment>& verticals) {\n    sort(verticals.begin(), verticals.end(), compareVertical);\n    \n    int intersectionCount = 0;\n    for (const auto& h : horizontals) {\n        auto it = lower_bound(verticals.begin(), verticals.end(), h,\n            [](const Segment& v, const Segment& h) {\n                return v.start.x < h.start.x;\n            });\n        \n        while (it != verticals.end() && it->start.x <= h.end.x) {\n            if (intersects(h, *it)) {\n                intersectionCount++;\n            }\n            ++it;\n        }\n    }\n    \n    return intersectionCount;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n;\n\n    vector<Segment> horizontals, verticals;\n    for (int i = 0; i < n; ++i) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        \n        if (y1 == y2) { // Horizontal\n            horizontals.push_back({{min(x1, x2), y1}, {max(x1, x2), y2}, false});\n        } else { // Vertical\n            verticals.push_back({{x1, min(y1, y2)}, {x2, max(y1, y2)}, true});\n        }\n    }\n\n    cout << countIntersections(horizontals, verticals) << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 5,
            "mean_time_taken": 0.46719183921813967,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 45,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Inverse Inversions",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> perm(n);\n    for (int i = 0; i < n; i++) {\n        perm[i] = i + 1;\n    }\n\n    int pos = n - 1;\n    while (k > 0) {\n        int i = min(k, pos);\n        int val = perm[pos];\n        for (int j = pos; j > pos - i; j--) {\n            perm[j] = perm[j-1];\n        }\n        perm[pos-i] = val;\n        k -= i;\n        pos--;\n    }\n\n    for (int i = 0; i < n; i++) {\n        cout << perm[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 10,
            "mean_time_taken": 0.27707221508026125,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                8,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 45,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Inversion Probability",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\ndouble inversion_probability(int ri, int rj) {\n    double prob = 0.0;\n    int m = min(ri, rj);\n    for (int k = 1; k <= m; ++k) {\n        prob += static_cast<double>(ri - k + 1) / (ri * rj);\n    }\n    return prob;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<int> r(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> r[i];\n    }\n    \n    double expected_inversions = 0.0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            expected_inversions += inversion_probability(r[i], r[j]);\n        }\n    }\n    \n    cout << fixed << setprecision(6) << round(expected_inversions * 1e6) / 1e6 << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 20,
            "mean_time_taken": 0.08134645223617554,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 45,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Investigation",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nstruct Edge {\n    int to;\n    long long cost;\n};\n\nstruct State {\n    int node;\n    long long dist;\n    bool operator>(const State& other) const {\n        return dist > other.dist;\n    }\n};\n\nvector<long long> dijkstra(int n, vector<vector<Edge>>& graph) {\n    vector<long long> dist(n + 1, LLONG_MAX);\n    vector<int> count(n + 1, 0);\n    vector<int> min_flights(n + 1, INT_MAX);\n    vector<int> max_flights(n + 1, 0);\n    priority_queue<State, vector<State>, greater<State>> pq;\n\n    dist[1] = 0;\n    count[1] = 1;\n    min_flights[1] = max_flights[1] = 0;\n    pq.push({1, 0});\n\n    while (!pq.empty()) {\n        State current = pq.top();\n        pq.pop();\n\n        if (current.dist > dist[current.node]) continue;\n\n        for (const Edge& edge : graph[current.node]) {\n            long long new_dist = current.dist + edge.cost;\n            int new_flights = min_flights[current.node] + 1;\n\n            if (new_dist < dist[edge.to]) {\n                dist[edge.to] = new_dist;\n                count[edge.to] = count[current.node];\n                min_flights[edge.to] = new_flights;\n                max_flights[edge.to] = max_flights[current.node] + 1;\n                pq.push({edge.to, new_dist});\n            } else if (new_dist == dist[edge.to]) {\n                count[edge.to] = (count[edge.to] + count[current.node]) % MOD;\n                min_flights[edge.to] = min(min_flights[edge.to], new_flights);\n                max_flights[edge.to] = max(max_flights[edge.to], max_flights[current.node] + 1);\n            }\n        }\n    }\n\n    return {dist[n], count[n], min_flights[n], max_flights[n]};\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<Edge>> graph(n + 1);\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        graph[a].push_back({b, c});\n    }\n\n    vector<long long> result = dijkstra(n, graph);\n\n    cout << result[0] << \" \" << result[1] << \" \" << result[2] << \" \" << result[3] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.1301969051361084,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 46,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Josephus Problem I",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nvector<int> josephus(int n) {\n    queue<int> q;\n    vector<int> result;\n\n    // Populate the queue\n    for (int i = 1; i <= n; i++) {\n        q.push(i);\n    }\n\n    // Simulate the process\n    while (!q.empty()) {\n        // Skip this child\n        q.push(q.front());\n        q.pop();\n\n        // Remove this child if queue is not empty\n        if (!q.empty()) {\n            result.push_back(q.front());\n            q.pop();\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> order = josephus(n);\n\n    // Print the result\n    for (int child : order) {\n        cout << child << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.08671848590557392,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 47,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Josephus Problem II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\nvector<int> josephus(int n, int k) {\n    set<int> circle;\n    for (int i = 1; i <= n; ++i) {\n        circle.insert(i);\n    }\n\n    vector<int> result;\n    auto it = circle.begin();\n    while (!circle.empty()) {\n        int steps = k % circle.size();\n        for (int i = 0; i < steps; ++i) {\n            ++it;\n            if (it == circle.end()) {\n                it = circle.begin();\n            }\n        }\n        result.push_back(*it);\n        it = circle.erase(it);\n        if (it == circle.end()) {\n            it = circle.begin();\n        }\n    }\n    return result;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> order = josephus(n, k);\n    for (int child : order) {\n        cout << child << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 17,
            "mean_time_taken": 0.3312179060543285,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                7,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 47,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Josephus Queries",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nlong long josephus(long long n, long long k) {\n    if (n == 1) return 1;\n    if (k == 1) return 2;\n    if (k <= (n + 1) / 2) {\n        if (2 * k > n) return (2 * k) % n;\n        else return 2 * k;\n    }\n    long long new_n = n / 2;\n    long long new_k = k - (n + 1) / 2;\n    long long res = josephus(new_n, new_k);\n    if (n % 2 == 0) return 2 * res - 1;\n    else return 2 * res + 1;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int q;\n    cin >> q;\n\n    while (q--) {\n        long long n, k;\n        cin >> n >> k;\n        cout << josephus(n, k) << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 2,
            "mean_time_taken": 0.10000145435333252,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 48,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Knight's Tour",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 8;\nvector<vector<int>> board(N, vector<int>(N, 0));\nint dx[] = {2, 1, -1, -2, -2, -1, 1, 2};\nint dy[] = {1, 2, 2, 1, -1, -2, -2, -1};\n\nbool is_valid(int x, int y) {\n    return x >= 0 && x < N && y >= 0 && y < N && board[x][y] == 0;\n}\n\nbool knight_tour(int x, int y, int move) {\n    if (move == N * N) return true;\n\n    for (int i = 0; i < 8; i++) {\n        int next_x = x + dx[i];\n        int next_y = y + dy[i];\n\n        if (is_valid(next_x, next_y)) {\n            board[next_x][next_y] = move + 1;\n            if (knight_tour(next_x, next_y, move + 1)) return true;\n            board[next_x][next_y] = 0;  // backtrack\n        }\n    }\n\n    return false;\n}\n\nvoid print_board() {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cout << board[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    int start_x, start_y;\n    cin >> start_x >> start_y;\n\n    start_x--;  // Convert to 0-based indexing\n    start_y--;\n\n    board[start_x][start_y] = 1;\n    if (knight_tour(start_x, start_y, 1)) {\n        print_board();\n    } else {\n        cout << \"No solution exists\" << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 23,
            "mean_time_taken": 0.9539989803148352,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 48,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Knuth Division",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<long long> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    \n    vector<long long> prefix_sum(n + 1, 0);\n    for (int i = 0; i < n; i++) {\n        prefix_sum[i + 1] = prefix_sum[i] + arr[i];\n    }\n    \n    vector<vector<long long>> dp(n, vector<long long>(n, 0));\n    \n    for (int len = 2; len <= n; len++) {\n        for (int i = 0; i + len - 1 < n; i++) {\n            int j = i + len - 1;\n            dp[i][j] = LLONG_MAX;\n            for (int k = i; k < j; k++) {\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + prefix_sum[j+1] - prefix_sum[i]);\n            }\n        }\n    }\n    \n    cout << dp[0][n-1] << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 3,
            "mean_time_taken": 0.5020469029744467,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 48,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Labyrinth",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\nusing namespace std;\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\nconst char dir[] = {'U', 'D', 'L', 'R'};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<string> maze(n);\n    vector<vector<int>> visited(n, vector<int>(m, -1));\n    queue<pair<int, int>> q;\n    int sx, sy, ex, ey;\n    \n    for (int i = 0; i < n; i++) {\n        cin >> maze[i];\n        for (int j = 0; j < m; j++) {\n            if (maze[i][j] == 'A') {\n                sx = i; sy = j;\n            } else if (maze[i][j] == 'B') {\n                ex = i; ey = j;\n            }\n        }\n    }\n    \n    q.push({sx, sy});\n    visited[sx][sy] = 4;  // Special value for start\n    \n    while (!q.empty()) {\n        int x = q.front().first, y = q.front().second;\n        q.pop();\n        \n        if (x == ex && y == ey) break;\n        \n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i], ny = y + dy[i];\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && maze[nx][ny] != '#' && visited[nx][ny] == -1) {\n                visited[nx][ny] = i;\n                q.push({nx, ny});\n            }\n        }\n    }\n    \n    if (visited[ex][ey] == -1) {\n        cout << \"NO\" << endl;\n    } else {\n        cout << \"YES\" << endl;\n        string path;\n        int x = ex, y = ey;\n        while (x != sx || y != sy) {\n            int d = visited[x][y];\n            path += dir[d];\n            x -= dx[d];\n            y -= dy[d];\n        }\n        reverse(path.begin(), path.end());\n        cout << path.length() << endl << path << endl;\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 48,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Letter Pair Move Game",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_solvable(const string& s) {\n    int a_count = 0, b_count = 0;\n    for (char c : s) {\n        if (c == 'A') a_count++;\n        else if (c == 'B') b_count++;\n        else if (c == '.' && a_count > 0 && b_count > 0) return false;\n    }\n    return true;\n}\n\npair<int, int> find_empty_spaces(const string& s) {\n    int first = s.find('.');\n    int second = s.find('.', first + 1);\n    return {first, second};\n}\n\npair<int, int> find_swap_positions(const string& s) {\n    int leftmost_b = s.find('B');\n    int rightmost_a = s.rfind('A');\n    return {leftmost_b, rightmost_a};\n}\n\nvoid perform_swap(string& s, int b_pos, int a_pos, int empty1, int empty2) {\n    s[empty1] = 'B';\n    s[empty2] = 'A';\n    s[b_pos] = '.';\n    s[a_pos] = '.';\n}\n\nint main() {\n    int n;\n    string s;\n    cin >> n >> s;\n\n    if (!is_solvable(s)) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    vector<string> moves;\n    while (true) {\n        auto [b_pos, a_pos] = find_swap_positions(s);\n        if (b_pos > a_pos) break;\n\n        auto [empty1, empty2] = find_empty_spaces(s);\n        perform_swap(s, b_pos, a_pos, empty1, empty2);\n        moves.push_back(s);\n    }\n\n    cout << moves.size() << endl;\n    for (const auto& move : moves) {\n        cout << move << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 24,
            "mean_time_taken": 0.18557717402776083,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                17,
                18,
                19,
                20,
                21,
                22,
                24
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 48,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Line Segment Intersection",
            "category": "Geometry",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct Point {\n    long long x, y;\n    Point(long long x = 0, long long y = 0) : x(x), y(y) {}\n};\n\n// Returns 0 if collinear, positive if clockwise, negative if counterclockwise\nlong long orientation(Point p, Point q, Point r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\nbool onSegment(Point p, Point q, Point r) {\n    return q.x <= max(p.x, r.x) && q.x >= min(p.x, r.x) &&\n           q.y <= max(p.y, r.y) && q.y >= min(p.y, r.y);\n}\n\nbool doIntersect(Point p1, Point q1, Point p2, Point q2) {\n    long long o1 = orientation(p1, q1, p2);\n    long long o2 = orientation(p1, q1, q2);\n    long long o3 = orientation(p2, q2, p1);\n    long long o4 = orientation(p2, q2, q1);\n\n    if (o1 != o2 && o3 != o4)\n        return true;\n\n    if (o1 == 0 && onSegment(p1, p2, q1)) return true;\n    if (o2 == 0 && onSegment(p1, q2, q1)) return true;\n    if (o3 == 0 && onSegment(p2, p1, q2)) return true;\n    if (o4 == 0 && onSegment(p2, q1, q2)) return true;\n\n    return false;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n\n    while (t--) {\n        long long x1, y1, x2, y2, x3, y3, x4, y4;\n        cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4;\n\n        Point p1(x1, y1), q1(x2, y2), p2(x3, y3), q2(x4, y4);\n\n        if (doIntersect(p1, q1, p2, q2))\n            cout << \"YES\\n\";\n        else\n            cout << \"NO\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 6,
            "mean_time_taken": 0.10638809204101562,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 48,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "List Removals",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass FenwickTree {\nprivate:\n    vector<int> bit;\n    int n;\n\npublic:\n    FenwickTree(int size) : n(size + 1) {\n        bit.assign(n, 0);\n    }\n\n    void update(int idx, int val) {\n        for (++idx; idx < n; idx += idx & -idx)\n            bit[idx] += val;\n    }\n\n    int sum(int idx) {\n        int ret = 0;\n        for (++idx; idx > 0; idx -= idx & -idx)\n            ret += bit[idx];\n        return ret;\n    }\n\n    int find_kth(int k) {\n        int low = 0, high = n - 1;\n        while (low < high) {\n            int mid = (low + high) / 2;\n            if (sum(mid) < k)\n                low = mid + 1;\n            else\n                high = mid;\n        }\n        return low;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    FenwickTree ft(n);\n    for (int i = 0; i < n; i++) {\n        ft.update(i, 1);\n    }\n\n    for (int i = 0; i < n; i++) {\n        int p;\n        cin >> p;\n        int idx = ft.find_kth(p);\n        cout << arr[idx] << \" \";\n        ft.update(idx, -1);\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 9,
            "total_test_cases": 9,
            "mean_time_taken": 0.12484383583068848,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 49,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "List of Sums",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<long long> reconstruct_A(int n, vector<long long>& B) {\n    if (n == 3) {\n        long long a = (B[0] + B[1] - B[2]) / 2;\n        long long b = B[0] - a;\n        long long c = B[1] - a;\n        return {a, b, c};\n    }\n\n    long long min_B = *min_element(B.begin(), B.end());\n    long long max_B = *max_element(B.begin(), B.end());\n    long long sum_B = 0;\n    for (long long x : B) sum_B += x;\n\n    long long smallest_A = (min_B + max_B - sum_B / (n - 1)) / (n - 2);\n\n    vector<long long> A(n);\n    A[0] = smallest_A;\n\n    int idx = 1;\n    for (long long x : B) {\n        if (x - smallest_A > 0 && idx < n) {\n            A[idx++] = x - smallest_A;\n        }\n    }\n\n    return A;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<long long> B(n * (n - 1) / 2);\n    for (int i = 0; i < n * (n - 1) / 2; i++) {\n        cin >> B[i];\n    }\n\n    vector<long long> A = reconstruct_A(n, B);\n\n    for (long long x : A) {\n        cout << x << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 10,
            "mean_time_taken": 0.0834775686264038,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 49,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Longest Flight Route",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\n\nvector<int> graph[MAXN];\nvector<int> inDegree(MAXN, 0);\nvector<int> dp(MAXN, -1);\nvector<int> parent(MAXN, -1);\n\nint n, m;\n\nvoid topologicalSort(vector<int>& order) {\n    queue<int> q;\n    for (int i = 1; i <= n; i++) {\n        if (inDegree[i] == 0) {\n            q.push(i);\n        }\n    }\n\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        order.push_back(v);\n\n        for (int u : graph[v]) {\n            inDegree[u]--;\n            if (inDegree[u] == 0) {\n                q.push(u);\n            }\n        }\n    }\n}\n\nint main() {\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        inDegree[b]++;\n    }\n\n    vector<int> order;\n    topologicalSort(order);\n\n    dp[1] = 1;\n    for (int v : order) {\n        if (dp[v] != -1) {\n            for (int u : graph[v]) {\n                if (dp[u] < dp[v] + 1) {\n                    dp[u] = dp[v] + 1;\n                    parent[u] = v;\n                }\n            }\n        }\n    }\n\n    if (dp[n] == -1) {\n        cout << \"IMPOSSIBLE\" << endl;\n    } else {\n        cout << dp[n] << endl;\n        \n        stack<int> path;\n        int current = n;\n        while (current != -1) {\n            path.push(current);\n            current = parent[current];\n        }\n\n        while (!path.empty()) {\n            cout << path.top() << \" \";\n            path.pop();\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 20,
            "total_test_cases": 24,
            "mean_time_taken": 0.12374648451805115,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                6,
                15,
                18,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 49,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Longest Palindrome",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstring longestPalindrome(const string& s) {\n    string T = \"#\";\n    for (char c : s) {\n        T += c;\n        T += \"#\";\n    }\n    \n    int n = T.length();\n    vector<int> P(n, 0);\n    int C = 0, R = 0;\n    \n    for (int i = 1; i < n - 1; i++) {\n        int mirror = 2 * C - i;\n        \n        if (i < R) {\n            P[i] = min(R - i, P[mirror]);\n        }\n        \n        while (i + (1 + P[i]) < n && i - (1 + P[i]) >= 0 && T[i + (1 + P[i])] == T[i - (1 + P[i])]) {\n            P[i]++;\n        }\n        \n        if (i + P[i] > R) {\n            C = i;\n            R = i + P[i];\n        }\n    }\n    \n    int maxLen = 0, centerIndex = 0;\n    for (int i = 0; i < n; i++) {\n        if (P[i] > maxLen) {\n            maxLen = P[i];\n            centerIndex = i;\n        }\n    }\n    \n    int start = (centerIndex - maxLen) / 2;\n    return s.substr(start, maxLen);\n}\n\nint main() {\n    string s;\n    cin >> s;\n    \n    string result = longestPalindrome(s);\n    cout << result << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 19,
            "total_test_cases": 19,
            "mean_time_taken": 0.10995990351626747,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 50,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Mail Delivery",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <unordered_set>\n\nusing namespace std;\n\nconst int MAX_N = 100005;\n\nvector<int> graph[MAX_N];\nvector<bool> visited(MAX_N, false);\nvector<int> circuit;\nunordered_set<int> used_edges[MAX_N];\n\nvoid dfs(int v) {\n    visited[v] = true;\n    for (int u : graph[v]) {\n        if (!visited[u]) {\n            dfs(u);\n        }\n    }\n}\n\nbool is_connected(int n) {\n    dfs(1);\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i] && !graph[i].empty()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid find_euler_circuit(int start) {\n    stack<int> st;\n    st.push(start);\n    \n    while (!st.empty()) {\n        int v = st.top();\n        \n        if (graph[v].empty()) {\n            circuit.push_back(v);\n            st.pop();\n        } else {\n            int u = graph[v].back();\n            graph[v].pop_back();\n            \n            if (used_edges[v].find(u) == used_edges[v].end()) {\n                st.push(u);\n                used_edges[v].insert(u);\n                used_edges[u].insert(v);\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    \n    // Check if all vertices have even degree\n    for (int i = 1; i <= n; i++) {\n        if (graph[i].size() % 2 != 0) {\n            cout << \"IMPOSSIBLE\" << endl;\n            return 0;\n        }\n    }\n    \n    // Check if the graph is connected\n    if (!is_connected(n)) {\n        cout << \"IMPOSSIBLE\" << endl;\n        return 0;\n    }\n    \n    // Find Euler circuit\n    find_euler_circuit(1);\n    \n    // Check if all edges were used\n    if (circuit.size() != m + 1) {\n        cout << \"IMPOSSIBLE\" << endl;\n        return 0;\n    }\n    \n    // Print the circuit\n    for (int v : circuit) {\n        cout << v << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 16,
            "mean_time_taken": 0.17886105179786682,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                4,
                5,
                7,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 50,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Maximum Building I",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nint largestRectangleArea(vector<int>& heights) {\n    stack<int> s;\n    int maxArea = 0;\n    heights.push_back(0);\n    int n = heights.size();\n\n    for (int i = 0; i < n; i++) {\n        while (!s.empty() && heights[s.top()] > heights[i]) {\n            int height = heights[s.top()];\n            s.pop();\n            int width = s.empty() ? i : i - s.top() - 1;\n            maxArea = max(maxArea, height * width);\n        }\n        s.push(i);\n    }\n\n    return maxArea;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<char>> forest(n, vector<char>(m));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> forest[i][j];\n        }\n    }\n\n    vector<int> histogram(m, 0);\n    int maxArea = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (forest[i][j] == '.') {\n                histogram[j]++;\n            } else {\n                histogram[j] = 0;\n            }\n        }\n        maxArea = max(maxArea, largestRectangleArea(histogram));\n    }\n\n    cout << maxArea << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.14180519183476767,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 51,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Maximum Building II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<char>> forest(n, vector<char>(m));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> forest[i][j];\n        }\n    }\n\n    vector<vector<int>> dp(n, vector<int>(m, 0));\n    vector<vector<int>> result(n, vector<int>(m, 0));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (forest[i][j] == '.') {\n                if (i == 0 || j == 0) {\n                    dp[i][j] = 1;\n                } else {\n                    dp[i][j] = 1 + min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]});\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int k = 1; k <= dp[i][j]; k++) {\n                result[i][j-k+1]++;\n            }\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cout << result[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 13,
            "mean_time_taken": 0.36234443004314715,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 51,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Maximum Subarray Sum",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    long long current_sum = 0;\n    long long max_sum = LLONG_MIN;\n\n    for (int i = 0; i < n; i++) {\n        current_sum = max((long long)arr[i], current_sum + arr[i]);\n        max_sum = max(max_sum, current_sum);\n    }\n\n    cout << max_sum << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 15,
            "total_test_cases": 15,
            "mean_time_taken": 0.09214922587076822,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 52,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Maximum Subarray Sum II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, a, b;\n    cin >> n >> a >> b;\n\n    vector<long long> prefixSum(n + 1, 0);\n    for (int i = 1; i <= n; i++) {\n        int x;\n        cin >> x;\n        prefixSum[i] = prefixSum[i-1] + x;\n    }\n\n    multiset<long long> window;\n    long long maxSum = LLONG_MIN;\n\n    for (int i = a; i <= n; i++) {\n        if (i > b) {\n            window.erase(window.find(prefixSum[i - b - 1]));\n        }\n        window.insert(prefixSum[i - a]);\n        maxSum = max(maxSum, prefixSum[i] - *window.begin());\n    }\n\n    cout << maxSum << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 52,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Maximum Xor Subarray",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int BITS = 30;\n\nstruct TrieNode {\n    TrieNode* children[2];\n    TrieNode() {\n        children[0] = children[1] = nullptr;\n    }\n};\n\nvoid insert(TrieNode* root, int num) {\n    TrieNode* node = root;\n    for (int i = BITS - 1; i >= 0; i--) {\n        int bit = (num >> i) & 1;\n        if (!node->children[bit]) {\n            node->children[bit] = new TrieNode();\n        }\n        node = node->children[bit];\n    }\n}\n\nint findMaxXor(TrieNode* root, int num) {\n    TrieNode* node = root;\n    int maxXor = 0;\n    for (int i = BITS - 1; i >= 0; i--) {\n        int bit = (num >> i) & 1;\n        if (node->children[1 - bit]) {\n            maxXor |= (1 << i);\n            node = node->children[1 - bit];\n        } else if (node->children[bit]) {\n            node = node->children[bit];\n        } else {\n            break;\n        }\n    }\n    return maxXor;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    \n    TrieNode* root = new TrieNode();\n    int prefixXor = 0;\n    int maxXorSum = 0;\n    \n    insert(root, 0);  // Insert 0 for empty subarray\n    \n    for (int num : arr) {\n        prefixXor ^= num;\n        maxXorSum = max(maxXorSum, findMaxXor(root, prefixXor));\n        insert(root, prefixXor);\n    }\n    \n    cout << maxXorSum << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.1210331916809082,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 53,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Meet in the Middle",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nvector<ll> generate_subset_sums(vector<ll>& arr) {\n    int n = arr.size();\n    vector<ll> sums;\n    for (int mask = 0; mask < (1 << n); mask++) {\n        ll sum = 0;\n        for (int i = 0; i < n; i++) {\n            if (mask & (1 << i)) {\n                sum += arr[i];\n            }\n        }\n        sums.push_back(sum);\n    }\n    return sums;\n}\n\nint main() {\n    int n;\n    ll x;\n    cin >> n >> x;\n    \n    vector<ll> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    \n    int mid = n / 2;\n    vector<ll> left(arr.begin(), arr.begin() + mid);\n    vector<ll> right(arr.begin() + mid, arr.end());\n    \n    vector<ll> left_sums = generate_subset_sums(left);\n    vector<ll> right_sums = generate_subset_sums(right);\n    \n    sort(right_sums.begin(), right_sums.end());\n    \n    ll count = 0;\n    for (ll sum : left_sums) {\n        ll complement = x - sum;\n        auto low = lower_bound(right_sums.begin(), right_sums.end(), complement);\n        auto high = upper_bound(right_sums.begin(), right_sums.end(), complement);\n        count += high - low;\n    }\n    \n    cout << count << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 38,
            "total_test_cases": 40,
            "mean_time_taken": 0.6695249915122986,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                14,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 53,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Message Route",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> bfs(const vector<vector<int>>& graph, int start, int end) {\n    int n = graph.size();\n    vector<bool> visited(n, false);\n    vector<int> parent(n, -1);\n    queue<int> q;\n\n    q.push(start);\n    visited[start] = true;\n\n    while (!q.empty()) {\n        int current = q.front();\n        q.pop();\n\n        if (current == end) {\n            vector<int> path;\n            while (current != -1) {\n                path.push_back(current);\n                current = parent[current];\n            }\n            reverse(path.begin(), path.end());\n            return path;\n        }\n\n        for (int neighbor : graph[current]) {\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                parent[neighbor] = current;\n                q.push(neighbor);\n            }\n        }\n    }\n\n    return {};  // Empty path if end is not reachable\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> graph(n + 1);  // 1-indexed\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);  // Undirected graph\n    }\n\n    vector<int> path = bfs(graph, 1, n);\n\n    if (path.empty()) {\n        cout << \"IMPOSSIBLE\" << endl;\n    } else {\n        cout << path.size() << endl;\n        for (int node : path) {\n            cout << node << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.1349122921625773,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 54,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Minimal Rotation",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstring minimalRotation(const string& s) {\n    int n = s.length();\n    string doubled = s + s;\n    vector<int> f(2 * n, -1);\n    int k = 0;\n    \n    for (int j = 1; j < 2 * n; j++) {\n        int i = f[j - k - 1];\n        while (i != -1 && doubled[j] != doubled[k + i + 1]) {\n            if (doubled[j] < doubled[k + i + 1]) {\n                k = j - i - 1;\n            }\n            i = f[i];\n        }\n        if (i == -1 && doubled[j] != doubled[k + i + 1]) {\n            if (doubled[j] < doubled[k + i + 1]) {\n                k = j;\n            }\n            f[j - k] = -1;\n        } else {\n            f[j - k] = i + 1;\n        }\n    }\n    \n    return s.substr(k % n) + s.substr(0, k % n);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    string s;\n    cin >> s;\n    \n    cout << minimalRotation(s) << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 20,
            "total_test_cases": 20,
            "mean_time_taken": 0.09350311756134033,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 55,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Minimizing Coins",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n    \n    vector<int> coins(n);\n    for (int i = 0; i < n; i++) {\n        cin >> coins[i];\n    }\n    \n    vector<int> dp(x + 1, x + 1);\n    dp[0] = 0;\n    \n    for (int i = 1; i <= x; i++) {\n        for (int j = 0; j < n; j++) {\n            if (coins[j] <= i) {\n                dp[i] = min(dp[i], dp[i - coins[j]] + 1);\n            }\n        }\n    }\n    \n    cout << (dp[x] > x ? -1 : dp[x]) << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 16,
            "total_test_cases": 16,
            "mean_time_taken": 0.24151739478111267,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 56,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Minimum Euclidean Distance",
            "category": "Geometry",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nbool cmpX(const pll &a, const pll &b) {\n    return a.first < b.first;\n}\n\nbool cmpY(const pll &a, const pll &b) {\n    return a.second < b.second;\n}\n\nll dist(const pll &a, const pll &b) {\n    return (a.first - b.first) * (a.first - b.first) + \n           (a.second - b.second) * (a.second - b.second);\n}\n\nll stripClosest(vector<pll> &strip, ll d) {\n    sort(strip.begin(), strip.end(), cmpY);\n    ll min_dist = d;\n    for (size_t i = 0; i < strip.size(); ++i) {\n        for (size_t j = i + 1; j < strip.size() && (strip[j].second - strip[i].second) * (strip[j].second - strip[i].second) < min_dist; ++j) {\n            min_dist = min(min_dist, dist(strip[i], strip[j]));\n        }\n    }\n    return min_dist;\n}\n\nll closestUtil(vector<pll> &points, int start, int end) {\n    if (end - start <= 3) {\n        ll min_dist = LLONG_MAX;\n        for (int i = start; i < end; ++i) {\n            for (int j = i + 1; j < end; ++j) {\n                min_dist = min(min_dist, dist(points[i], points[j]));\n            }\n        }\n        return min_dist;\n    }\n\n    int mid = (start + end) / 2;\n    ll left_min = closestUtil(points, start, mid);\n    ll right_min = closestUtil(points, mid, end);\n    ll d = min(left_min, right_min);\n\n    vector<pll> strip;\n    for (int i = start; i < end; ++i) {\n        if (abs(points[i].first - points[mid].first) * abs(points[i].first - points[mid].first) < d) {\n            strip.push_back(points[i]);\n        }\n    }\n\n    return min(d, stripClosest(strip, d));\n}\n\nll closest(vector<pll> &points) {\n    sort(points.begin(), points.end(), cmpX);\n    return closestUtil(points, 0, points.size());\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<pll> points(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> points[i].first >> points[i].second;\n    }\n\n    cout << closest(points) << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 27,
            "total_test_cases": 27,
            "mean_time_taken": 0.18878200319078234,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 57,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Missing Coin Sum",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<long long> coins(n);\n    for (int i = 0; i < n; i++) {\n        cin >> coins[i];\n    }\n    \n    sort(coins.begin(), coins.end());\n    \n    long long smallest_sum = 1;\n    \n    for (int i = 0; i < n && coins[i] <= smallest_sum; i++) {\n        smallest_sum += coins[i];\n    }\n    \n    cout << smallest_sum << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 9,
            "total_test_cases": 9,
            "mean_time_taken": 0.10923700862460667,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 58,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Missing Coin Sum Queries",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n\n    vector<long long> coins(n);\n    for (int i = 0; i < n; i++) {\n        cin >> coins[i];\n    }\n\n    // Sort the coins\n    sort(coins.begin(), coins.end());\n\n    // Calculate prefix sums and smallest unproduceable sum\n    vector<long long> prefix_sum(n + 1, 0);\n    vector<long long> smallest_unproduceable(n + 1, 1);\n\n    for (int i = 0; i < n; i++) {\n        prefix_sum[i + 1] = prefix_sum[i] + coins[i];\n        if (coins[i] > smallest_unproduceable[i]) {\n            smallest_unproduceable[i + 1] = smallest_unproduceable[i];\n        } else {\n            smallest_unproduceable[i + 1] = prefix_sum[i + 1] + 1;\n        }\n    }\n\n    // Process queries\n    while (q--) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--; // Convert to 0-based indexing\n\n        long long result;\n        if (a == 0) {\n            result = smallest_unproduceable[b + 1];\n        } else {\n            result = min(smallest_unproduceable[a], smallest_unproduceable[b + 1] - prefix_sum[a]);\n        }\n\n        cout << result << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 8,
            "mean_time_taken": 0.1270107924938202,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 58,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Missing Number",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    long long n;\n    cin >> n;\n\n    // Calculate expected sum\n    long long expected_sum = n * (n + 1) / 2;\n\n    // Read n-1 numbers and calculate their sum\n    long long actual_sum = 0;\n    for (int i = 0; i < n - 1; i++) {\n        long long num;\n        cin >> num;\n        actual_sum += num;\n    }\n\n    // Calculate and print the missing number\n    cout << expected_sum - actual_sum << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.09144326618739537,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 59,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Money Sums",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> coins(n);\n    int max_sum = 0;\n    for (int i = 0; i < n; i++) {\n        cin >> coins[i];\n        max_sum += coins[i];\n    }\n\n    vector<bool> dp(max_sum + 1, false);\n    dp[0] = true;\n\n    for (int coin : coins) {\n        for (int j = max_sum; j >= coin; j--) {\n            if (dp[j - coin]) {\n                dp[j] = true;\n            }\n        }\n    }\n\n    vector<int> achievable_sums;\n    for (int i = 1; i <= max_sum; i++) {\n        if (dp[i]) {\n            achievable_sums.push_back(i);\n        }\n    }\n\n    cout << achievable_sums.size() << endl;\n    for (int sum : achievable_sums) {\n        cout << sum << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.14050903687110314,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 60,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Monotone Subsequences",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid solve_case(int n, int k) {\n    if (k > n || (k == 1 && n > 1)) {\n        cout << \"IMPOSSIBLE\\n\";\n        return;\n    }\n    \n    if (k == n) {\n        for (int i = 1; i <= n; i++) {\n            cout << i << \" \";\n        }\n        cout << \"\\n\";\n        return;\n    }\n    \n    int block_size = n / (k-1);\n    vector<int> result;\n    int current = 1;\n    \n    for (int i = 0; i < k-1; i++) {\n        for (int j = 0; j < block_size; j++) {\n            result.push_back(current++);\n        }\n    }\n    \n    int remaining = n - result.size();\n    int insert_pos = block_size;\n    \n    for (int i = n; i >= current; i--) {\n        result.insert(result.begin() + insert_pos, i);\n        insert_pos += block_size + 1;\n        if (insert_pos > result.size()) {\n            insert_pos = block_size;\n        }\n    }\n    \n    for (int num : result) {\n        cout << num << \" \";\n    }\n    cout << \"\\n\";\n}\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        solve_case(n, k);\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.09520316123962402,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 60,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Monster Game I",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n    \n    vector<long long> s(n), f(n);\n    for (int i = 0; i < n; i++) cin >> s[i];\n    for (int i = 0; i < n; i++) cin >> f[i];\n\n    vector<long long> dp(n + 1, 0);\n    long long current_skill = x;\n\n    for (int i = n - 1; i >= 0; i--) {\n        long long kill_time = s[i] * current_skill + dp[i + 1];\n        long long skip_time = (i == n - 1) ? 1e18 : dp[i + 1];  // Can't skip the last monster\n\n        if (kill_time < skip_time) {\n            dp[i] = kill_time;\n            current_skill = f[i];\n        } else {\n            dp[i] = skip_time;\n        }\n    }\n\n    cout << dp[0] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 5,
            "mean_time_taken": 0.12452530860900879,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 60,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Monster Game II",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> s(n+1), f(n+1);\n    for (int i = 1; i <= n; i++) cin >> s[i];\n    for (int i = 1; i <= n; i++) cin >> f[i];\n\n    vector<vector<long long>> dp(n+1, vector<long long>(1000001, LLONG_MAX));\n    dp[0][x] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= 1000000; j++) {\n            if (dp[i-1][j] == LLONG_MAX) continue;\n\n            if (i < n) {\n                // Option 1: Kill the monster\n                dp[i][f[i]] = min(dp[i][f[i]], dp[i-1][j] + (long long)s[i] * j);\n                // Option 2: Skip the monster\n                dp[i][j] = min(dp[i][j], dp[i-1][j]);\n            } else {\n                // Last level: Must kill the monster\n                dp[i][f[i]] = min(dp[i][f[i]], dp[i-1][j] + (long long)s[i] * j);\n            }\n        }\n    }\n\n    long long answer = LLONG_MAX;\n    for (int j = 1; j <= 1000000; j++) {\n        answer = min(answer, dp[n][j]);\n    }\n\n    cout << answer << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.3805660605430603,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 60,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Monsters",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\nusing namespace std;\n\nconst int MAX_N = 1000;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst string dir = \"URDL\";\n\nint n, m;\nvector<string> grid;\nvector<vector<pair<int, int>>> parent(MAX_N, vector<pair<int, int>>(MAX_N, {-1, -1}));\nvector<vector<bool>> vis(MAX_N, vector<bool>(MAX_N, false));\nqueue<pair<int, int>> q, monsters;\n\nbool is_valid(int x, int y) {\n    return x >= 0 && x < n && y >= 0 && y < m && grid[x][y] != '#';\n}\n\nbool is_boundary(int x, int y) {\n    return x == 0 || x == n - 1 || y == 0 || y == m - 1;\n}\n\nvoid move_monsters() {\n    int size = monsters.size();\n    while (size--) {\n        auto [x, y] = monsters.front();\n        monsters.pop();\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i], ny = y + dy[i];\n            if (is_valid(nx, ny) && grid[nx][ny] == '.') {\n                grid[nx][ny] = 'M';\n                monsters.push({nx, ny});\n            }\n        }\n    }\n}\n\nstring bfs(int sx, int sy) {\n    q.push({sx, sy});\n    vis[sx][sy] = true;\n\n    while (!q.empty()) {\n        move_monsters();\n        int size = q.size();\n        while (size--) {\n            auto [x, y] = q.front();\n            q.pop();\n\n            if (is_boundary(x, y)) {\n                string path;\n                while (x != sx || y != sy) {\n                    int px = parent[x][y].first, py = parent[x][y].second;\n                    for (int i = 0; i < 4; i++) {\n                        if (x - px == dx[i] && y - py == dy[i]) {\n                            path += dir[i];\n                            break;\n                        }\n                    }\n                    x = px, y = py;\n                }\n                reverse(path.begin(), path.end());\n                return path;\n            }\n\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i], ny = y + dy[i];\n                if (is_valid(nx, ny) && !vis[nx][ny] && grid[nx][ny] == '.') {\n                    vis[nx][ny] = true;\n                    parent[nx][ny] = {x, y};\n                    q.push({nx, ny});\n                }\n            }\n        }\n    }\n    return \"\";\n}\n\nint main() {\n    cin >> n >> m;\n    grid.resize(n);\n\n    int sx, sy;\n    for (int i = 0; i < n; i++) {\n        cin >> grid[i];\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 'A') {\n                sx = i, sy = j;\n                grid[i][j] = '.';\n            } else if (grid[i][j] == 'M') {\n                monsters.push({i, j});\n            }\n        }\n    }\n\n    string path = bfs(sx, sy);\n\n    if (path.empty()) {\n        cout << \"NO\\n\";\n    } else {\n        cout << \"YES\\n\" << path.length() << \"\\n\" << path << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 60,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Movie Festival",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<int, int>> movies(n);\n    for (int i = 0; i < n; i++) {\n        int start, end;\n        cin >> start >> end;\n        movies[i] = {end, start};  // Store as {end, start} for easier sorting\n    }\n\n    // Sort movies based on end times\n    sort(movies.begin(), movies.end());\n\n    int count = 0;\n    int last_end = 0;\n\n    for (const auto& movie : movies) {\n        if (movie.second >= last_end) {  // If start time is after or equal to last end time\n            count++;\n            last_end = movie.first;  // Update last end time\n        }\n    }\n\n    cout << count << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.12615388089960272,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 61,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Movie Festival II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<pair<int, int>> movies(n);\n    for (int i = 0; i < n; i++) {\n        cin >> movies[i].second >> movies[i].first;  // Read end time first, then start time\n    }\n\n    // Sort movies by end time\n    sort(movies.begin(), movies.end());\n\n    multiset<int> end_times;\n    int count = 0;\n\n    for (const auto& movie : movies) {\n        int start = movie.second;\n        int end = movie.first;\n\n        // Remove all end times <= current start time\n        while (!end_times.empty() && *end_times.begin() <= start) {\n            end_times.erase(end_times.begin());\n        }\n\n        if (end_times.size() < k) {\n            // We have a free member\n            end_times.insert(end);\n            count++;\n        } else if (!end_times.empty() && *end_times.begin() <= start) {\n            // Replace the earliest ending movie\n            end_times.erase(end_times.begin());\n            end_times.insert(end);\n            count++;\n        }\n    }\n\n    cout << count << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 13,
            "mean_time_taken": 0.14042212412907526,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                5,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 61,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Movie Festival Queries",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200005;\nconst int MAXT = 1000001;\n\nint n, q;\nvector<pair<int, int>> movies;\nvector<int> timePoints;\nint bit[MAXT];\n\nvoid update(int idx, int val) {\n    while (idx < MAXT) {\n        bit[idx] = max(bit[idx], val);\n        idx += idx & -idx;\n    }\n}\n\nint query(int idx) {\n    int res = 0;\n    while (idx > 0) {\n        res = max(res, bit[idx]);\n        idx -= idx & -idx;\n    }\n    return res;\n}\n\nint getCompressedTime(int time) {\n    return lower_bound(timePoints.begin(), timePoints.end(), time) - timePoints.begin() + 1;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n >> q;\n    movies.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> movies[i].second >> movies[i].first;  // Store as (end, start)\n        timePoints.push_back(movies[i].second);\n        timePoints.push_back(movies[i].first);\n    }\n\n    // Compress time points\n    sort(timePoints.begin(), timePoints.end());\n    timePoints.erase(unique(timePoints.begin(), timePoints.end()), timePoints.end());\n\n    // Sort movies by end time\n    sort(movies.begin(), movies.end());\n\n    // Build BIT\n    int maxMovies = 0;\n    for (auto& movie : movies) {\n        int endTime = getCompressedTime(movie.first);\n        int startTime = getCompressedTime(movie.second);\n        int canWatch = query(startTime - 1) + 1;\n        update(endTime, canWatch);\n        maxMovies = max(maxMovies, canWatch);\n    }\n\n    // Process queries\n    while (q--) {\n        int a, b;\n        cin >> a >> b;\n        a = getCompressedTime(a);\n        b = getCompressedTime(b);\n        cout << query(b) - query(a - 1) << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 5,
            "mean_time_taken": 0.2982804298400879,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 61,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Moving Robots",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <iomanip>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 8;\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\ndouble solve(int k) {\n    vector<vector<vector<double>>> dp(k + 1, vector<vector<double>>(N, vector<double>(N, 0.0)));\n\n    // Initialize: each square has 1 robot\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            dp[0][i][j] = 1.0;\n        }\n    }\n\n    // Dynamic programming\n    for (int step = 1; step <= k; step++) {\n        for (int x = 0; x < N; x++) {\n            for (int y = 0; y < N; y++) {\n                int valid_moves = 0;\n                for (int dir = 0; dir < 4; dir++) {\n                    int nx = x + dx[dir];\n                    int ny = y + dy[dir];\n                    if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                        valid_moves++;\n                    }\n                }\n                for (int dir = 0; dir < 4; dir++) {\n                    int px = x - dx[dir];\n                    int py = y - dy[dir];\n                    if (px >= 0 && px < N && py >= 0 && py < N) {\n                        int prev_valid_moves = 0;\n                        for (int pdir = 0; pdir < 4; pdir++) {\n                            int ppx = px + dx[pdir];\n                            int ppy = py + dy[pdir];\n                            if (ppx >= 0 && ppx < N && ppy >= 0 && ppy < N) {\n                                prev_valid_moves++;\n                            }\n                        }\n                        dp[step][x][y] += dp[step-1][px][py] / prev_valid_moves;\n                    }\n                }\n            }\n        }\n    }\n\n    // Calculate expected number of occupied squares\n    double occupied = 0.0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            occupied += dp[k][i][j];\n        }\n    }\n\n    // Return expected number of empty squares\n    return 64.0 - occupied;\n}\n\nint main() {\n    int k;\n    cin >> k;\n    cout << fixed << setprecision(6) << solve(k) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 16,
            "mean_time_taken": 0.08232086896896362,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 61,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Multiplication Table",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll countLessEqual(ll n, ll x) {\n    ll count = 0;\n    for (ll i = 1; i <= n; ++i) {\n        count += min(x / i, n);\n    }\n    return count;\n}\n\nint main() {\n    ll n;\n    cin >> n;\n\n    ll low = 1, high = n * n;\n    ll target = (n * n + 1) / 2;\n\n    while (low < high) {\n        ll mid = low + (high - low) / 2;\n        if (countLessEqual(n, mid) < target) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n\n    cout << low << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 8,
            "mean_time_taken": 0.10846006870269775,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 62,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Nearest Smaller Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nvector<int> nearestSmallerValues(const vector<int>& arr) {\n    int n = arr.size();\n    vector<int> result(n);\n    stack<int> s;\n\n    for (int i = 0; i < n; i++) {\n        while (!s.empty() && arr[s.top()] >= arr[i]) {\n            s.pop();\n        }\n\n        if (s.empty()) {\n            result[i] = 0;\n        } else {\n            result[i] = s.top() + 1;\n        }\n\n        s.push(i);\n    }\n\n    return result;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    vector<int> result = nearestSmallerValues(arr);\n\n    for (int i = 0; i < n; i++) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.10739348484919621,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 63,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Necessary Cities",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 100005;\n\nvector<int> adj[MAX_N];\nbool visited[MAX_N];\nint disc[MAX_N], low[MAX_N], parent[MAX_N];\nbool is_cutvertex[MAX_N];\nint timer;\n\nvoid dfs(int u) {\n    int children = 0;\n    visited[u] = true;\n    disc[u] = low[u] = ++timer;\n\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            children++;\n            parent[v] = u;\n            dfs(v);\n            low[u] = min(low[u], low[v]);\n            if (parent[u] == -1 && children > 1)\n                is_cutvertex[u] = true;\n            if (parent[u] != -1 && low[v] >= disc[u])\n                is_cutvertex[u] = true;\n        } else if (v != parent[u]) {\n            low[u] = min(low[u], disc[v]);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    fill(parent, parent + n + 1, -1);\n    dfs(1);\n\n    vector<int> necessary_cities;\n    for (int i = 1; i <= n; i++) {\n        if (is_cutvertex[i]) {\n            necessary_cities.push_back(i);\n        }\n    }\n\n    cout << necessary_cities.size() << endl;\n    for (int city : necessary_cities) {\n        cout << city << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 8,
            "mean_time_taken": 0.10675567388534546,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 63,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Necessary Roads",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 100005;\n\nvector<int> adj[MAXN];\nint disc[MAXN], low[MAXN], parent[MAXN];\nbool visited[MAXN];\nint timer;\nvector<pair<int, int>> bridges;\n\nvoid dfs(int u) {\n    visited[u] = true;\n    disc[u] = low[u] = ++timer;\n    \n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            parent[v] = u;\n            dfs(v);\n            low[u] = min(low[u], low[v]);\n            if (low[v] > disc[u]) {\n                bridges.push_back({min(u, v), max(u, v)});\n            }\n        } else if (v != parent[u]) {\n            low[u] = min(low[u], disc[v]);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            dfs(i);\n        }\n    }\n    \n    sort(bridges.begin(), bridges.end());\n    \n    cout << bridges.size() << \"\\n\";\n    for (auto bridge : bridges) {\n        cout << bridge.first << \" \" << bridge.second << \"\\n\";\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 5,
            "mean_time_taken": 0.12837181091308594,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 63,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Nested Ranges Check",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<pair<int, int>, int>> ranges(n);\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        ranges[i] = {{x, -y}, i};  // Negative y for descending order of end points\n    }\n\n    sort(ranges.begin(), ranges.end());\n\n    vector<int> contains(n, 0), contained(n, 0);\n    int max_end = 0;\n\n    // First pass: check if a range is contained by any other\n    for (int i = 0; i < n; i++) {\n        if (-ranges[i].first.second <= max_end) {\n            contained[ranges[i].second] = 1;\n        }\n        max_end = max(max_end, -ranges[i].first.second);\n    }\n\n    // Second pass: check if a range contains any other\n    int min_end = 1e9 + 1;\n    for (int i = n - 1; i >= 0; i--) {\n        if (-ranges[i].first.second > min_end) {\n            contains[ranges[i].second] = 1;\n        }\n        min_end = min(min_end, -ranges[i].first.second);\n    }\n\n    // Output results\n    for (int i = 0; i < n; i++) {\n        cout << contains[i] << \" \";\n    }\n    cout << \"\\n\";\n    for (int i = 0; i < n; i++) {\n        cout << contained[i] << \" \";\n    }\n    cout << \"\\n\";\n\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 12,
            "mean_time_taken": 0.16761640707651773,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 63,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Nested Ranges Count",
            "category": "Sorting and Searching",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nstruct Range {\n    int start, end, index;\n};\n\nstruct FenwickTree {\n    vector<int> bit;\n    int n;\n\n    FenwickTree(int n) {\n        this->n = n + 1;\n        bit.assign(n + 1, 0);\n    }\n\n    void update(int idx, int val) {\n        for (++idx; idx < n; idx += idx & -idx)\n            bit[idx] += val;\n    }\n\n    int query(int idx) {\n        int res = 0;\n        for (++idx; idx > 0; idx -= idx & -idx)\n            res += bit[idx];\n        return res;\n    }\n};\n\nbool cmp1(const Range &a, const Range &b) {\n    if (a.start == b.start) return a.end > b.end;\n    return a.start < b.start;\n}\n\nbool cmp2(const Range &a, const Range &b) {\n    if (a.end == b.end) return a.start > b.start;\n    return a.end < b.end;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n;\n\n    vector<Range> ranges(n);\n    vector<int> ends;\n\n    for (int i = 0; i < n; i++) {\n        cin >> ranges[i].start >> ranges[i].end;\n        ranges[i].index = i;\n        ends.push_back(ranges[i].end);\n    }\n\n    // Coordinate compression\n    sort(ends.begin(), ends.end());\n    ends.erase(unique(ends.begin(), ends.end()), ends.end());\n\n    for (auto &r : ranges) {\n        r.end = lower_bound(ends.begin(), ends.end(), r.end) - ends.begin();\n    }\n\n    vector<int> contains(n), contained(n);\n\n    // Count ranges each range contains\n    sort(ranges.begin(), ranges.end(), cmp1);\n    FenwickTree ft(ends.size());\n\n    for (const auto &r : ranges) {\n        contains[r.index] = ft.query(ends.size() - 1) - ft.query(r.end);\n        ft.update(r.end, 1);\n    }\n\n    // Count ranges that contain each range\n    sort(ranges.begin(), ranges.end(), cmp2);\n    ft = FenwickTree(ends.size());\n\n    for (const auto &r : ranges) {\n        contained[r.index] = ft.query(r.end);\n        ft.update(r.end, 1);\n    }\n\n    // Output results\n    for (int x : contains) cout << x << \" \";\n    cout << \"\\n\";\n    for (int x : contained) cout << x << \" \";\n    cout << \"\\n\";\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.22195927302042642,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 63,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Network Breakdown",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass DSU {\n    vector<int> parent, rank;\n    int components;\n\npublic:\n    DSU(int n) : parent(n), rank(n, 0), components(n) {\n        for (int i = 0; i < n; i++) parent[i] = i;\n    }\n\n    int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    bool unite(int x, int y) {\n        int px = find(x), py = find(y);\n        if (px == py) return false;\n        if (rank[px] < rank[py]) swap(px, py);\n        parent[py] = px;\n        if (rank[px] == rank[py]) rank[px]++;\n        components--;\n        return true;\n    }\n\n    int getComponents() { return components; }\n};\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<pair<int, int>> connections(m);\n    vector<pair<int, int>> breakdowns(k);\n\n    for (int i = 0; i < m; i++) {\n        cin >> connections[i].first >> connections[i].second;\n        connections[i].first--; connections[i].second--;\n    }\n\n    for (int i = 0; i < k; i++) {\n        cin >> breakdowns[i].first >> breakdowns[i].second;\n        breakdowns[i].first--; breakdowns[i].second--;\n    }\n\n    DSU dsu(n);\n    vector<bool> broken(m, false);\n\n    // Mark connections that will break\n    for (auto &breakdown : breakdowns) {\n        auto it = find(connections.begin(), connections.end(), breakdown);\n        if (it != connections.end()) {\n            broken[it - connections.begin()] = true;\n        }\n    }\n\n    // Connect all unbroken connections\n    for (int i = 0; i < m; i++) {\n        if (!broken[i]) {\n            dsu.unite(connections[i].first, connections[i].second);\n        }\n    }\n\n    vector<int> results;\n    // Process breakdowns in reverse order\n    for (auto it = breakdowns.rbegin(); it != breakdowns.rend(); it++) {\n        results.push_back(dsu.getComponents());\n        dsu.unite(it->first, it->second);\n    }\n\n    // Print results in correct order\n    for (auto it = results.rbegin(); it != results.rend(); it++) {\n        cout << *it << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 13,
            "mean_time_taken": 0.4555773918445294,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                5,
                6,
                8,
                10,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 63,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Network Renovation",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<vector<int>> adj(n+1);\n    vector<int> degree(n+1, 0);\n    \n    // Read the existing connections\n    for (int i = 0; i < n-1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n        degree[a]++;\n        degree[b]++;\n    }\n    \n    // Find leaf nodes\n    vector<int> leaves;\n    for (int i = 1; i <= n; i++) {\n        if (degree[i] == 1) {\n            leaves.push_back(i);\n        }\n    }\n    \n    // Calculate the number of new connections\n    int k = leaves.size() - 1;\n    \n    // Output the result\n    cout << k << endl;\n    \n    // Connect the leaf nodes in a cycle\n    for (int i = 0; i < k; i++) {\n        cout << leaves[i] << \" \" << leaves[i+1] << endl;\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 21,
            "mean_time_taken": 0.09834552946544829,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 63,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "New Flight Routes",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nconst int MAX_N = 1e5 + 5;\n\nvector<int> graph[MAX_N], rev_graph[MAX_N];\nbool visited[MAX_N];\nstack<int> finish_order;\nvector<int> scc_leaders;\n\nvoid dfs1(int v) {\n    visited[v] = true;\n    for (int u : graph[v]) {\n        if (!visited[u]) {\n            dfs1(u);\n        }\n    }\n    finish_order.push(v);\n}\n\nvoid dfs2(int v) {\n    visited[v] = true;\n    for (int u : rev_graph[v]) {\n        if (!visited[u]) {\n            dfs2(u);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        rev_graph[b].push_back(a);\n    }\n\n    // First DFS\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            dfs1(i);\n        }\n    }\n\n    // Reset visited array\n    fill(visited + 1, visited + n + 1, false);\n\n    // Second DFS\n    while (!finish_order.empty()) {\n        int v = finish_order.top();\n        finish_order.pop();\n        if (!visited[v]) {\n            dfs2(v);\n            scc_leaders.push_back(v);\n        }\n    }\n\n    int new_flights = scc_leaders.size() - 1;\n    cout << new_flights << endl;\n\n    // Connect SCCs\n    for (int i = 0; i < new_flights; i++) {\n        cout << scc_leaders[i + 1] << \" \" << scc_leaders[i] << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 26,
            "mean_time_taken": 0.12912769501025861,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                26
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 63,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "New Roads Queries",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass DSU {\n    vector<int> parent, rank;\npublic:\n    DSU(int n) : parent(n), rank(n, 0) {\n        for (int i = 0; i < n; i++) parent[i] = i;\n    }\n    \n    int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    \n    void unite(int x, int y) {\n        x = find(x), y = find(y);\n        if (x == y) return;\n        if (rank[x] < rank[y]) swap(x, y);\n        parent[y] = x;\n        if (rank[x] == rank[y]) rank[x]++;\n    }\n    \n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m, q;\n    cin >> n >> m >> q;\n\n    vector<pair<int, int>> roads(m);\n    for (int i = 0; i < m; i++) {\n        cin >> roads[i].first >> roads[i].second;\n        roads[i].first--; roads[i].second--;  // 0-based indexing\n    }\n\n    vector<pair<int, int>> queries(q);\n    vector<int> answers(q, -1);\n    for (int i = 0; i < q; i++) {\n        cin >> queries[i].first >> queries[i].second;\n        queries[i].first--; queries[i].second--;  // 0-based indexing\n    }\n\n    for (int day = 0; day < m; day++) {\n        DSU dsu(n);\n        for (int i = 0; i <= day; i++) {\n            dsu.unite(roads[i].first, roads[i].second);\n        }\n        \n        for (int i = 0; i < q; i++) {\n            if (answers[i] == -1 && dsu.same(queries[i].first, queries[i].second)) {\n                answers[i] = day + 1;\n            }\n        }\n    }\n\n    for (int ans : answers) {\n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 7,
            "mean_time_taken": 0.9023386410304478,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 63,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Nim Game I",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n;\n        cin >> n;\n\n        int nim_sum = 0;\n        for (int i = 0; i < n; i++) {\n            int x;\n            cin >> x;\n            nim_sum ^= x;\n        }\n\n        if (nim_sum != 0) {\n            cout << \"first\\n\";\n        } else {\n            cout << \"second\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 4,
            "mean_time_taken": 0.09314858913421631,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 64,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Nim Game II",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstring solve_nim_game(const vector<int>& heaps) {\n    int nim_sum = 0;\n    for (int heap : heaps) {\n        nim_sum ^= (heap % 4);\n    }\n    return (nim_sum != 0) ? \"first\" : \"second\";\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n;\n        cin >> n;\n\n        vector<int> heaps(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> heaps[i];\n        }\n\n        cout << solve_nim_game(heaps) << '\\n';\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 4,
            "mean_time_taken": 0.09829205274581909,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 65,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Number Grid",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    long long y, x;\n    cin >> y >> x;\n\n    long long result;\n    if (y == 1) {\n        result = x - 1;\n    } else if (x == 1) {\n        result = y - 1;\n    } else {\n        result = max(y, x) - 1;\n    }\n\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 20,
            "mean_time_taken": 0.08098064661026001,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                12,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 65,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Number Spiral",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <cstdint>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int64_t y, x;\n        cin >> y >> x;\n\n        int64_t result;\n\n        if (y >= x) {\n            if (y % 2 == 0) {\n                result = y * y - (y - x);\n            } else {\n                result = (y - 1) * (y - 1) + x;\n            }\n        } else {\n            if (x % 2 == 0) {\n                result = (x - 1) * (x - 1) + y;\n            } else {\n                result = x * x - (x - y);\n            }\n        }\n\n        cout << result << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.10406672954559326,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 65,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "One Bit Positions",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.length();\n    \n    vector<int> result(n - 1, 0);\n    \n    for (int k = 1; k < n; k++) {\n        int ones_count = 0;\n        for (int i = 0; i < k; i++) {\n            if (s[i] == '1') ones_count++;\n        }\n        \n        for (int i = k; i < n; i++) {\n            if (s[i] == '1') ones_count++;\n            if (s[i-k] == '1') ones_count--;\n            \n            if (s[i] == '1' && s[i-k] == '1') {\n                result[k-1]++;\n            }\n        }\n    }\n    \n    for (int i = 0; i < n - 1; i++) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 5,
            "mean_time_taken": 0.8525939464569092,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 65,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Palindrome Queries",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nconst int MOD = 1e9 + 7;\n\nint n, m;\nstring s;\nvector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\nlong long prefix[MAX_N], suffix[MAX_N];\n\nvoid update(int pos, char c) {\n    int old_prime = primes[s[pos] - 'a'];\n    int new_prime = primes[c - 'a'];\n    s[pos] = c;\n\n    for (int i = pos; i <= n; i++) {\n        prefix[i] = (prefix[i] * new_prime) % MOD;\n        prefix[i] = (prefix[i] * modInverse(old_prime, MOD)) % MOD;\n    }\n\n    for (int i = pos; i >= 1; i--) {\n        suffix[i] = (suffix[i] * new_prime) % MOD;\n        suffix[i] = (suffix[i] * modInverse(old_prime, MOD)) % MOD;\n    }\n}\n\nbool isPalindrome(int l, int r) {\n    long long prefix_product = prefix[r];\n    if (l > 1) prefix_product = (prefix_product * modInverse(prefix[l-1], MOD)) % MOD;\n\n    long long suffix_product = suffix[l];\n    if (r < n) suffix_product = (suffix_product * modInverse(suffix[r+1], MOD)) % MOD;\n\n    return prefix_product == suffix_product;\n}\n\nlong long modPow(long long base, long long exp, long long modulus) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp & 1) result = (result * base) % modulus;\n        base = (base * base) % modulus;\n        exp >>= 1;\n    }\n    return result;\n}\n\nlong long modInverse(long long a, long long m) {\n    return modPow(a, m - 2, m);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n >> m >> s;\n    s = \" \" + s;  // 1-indexing\n\n    prefix[0] = suffix[n+1] = 1;\n    for (int i = 1; i <= n; i++) {\n        prefix[i] = (prefix[i-1] * primes[s[i] - 'a']) % MOD;\n    }\n    for (int i = n; i >= 1; i--) {\n        suffix[i] = (suffix[i+1] * primes[s[i] - 'a']) % MOD;\n    }\n\n    while (m--) {\n        int type;\n        cin >> type;\n        if (type == 1) {\n            int k;\n            char x;\n            cin >> k >> x;\n            update(k, x);\n        } else {\n            int a, b;\n            cin >> a >> b;\n            cout << (isPalindrome(a, b) ? \"YES\" : \"NO\") << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 65,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Palindrome Reorder",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    string s;\n    cin >> s;\n    \n    vector<int> freq(26, 0);\n    for (char c : s) {\n        freq[c - 'A']++;\n    }\n    \n    int odd_count = 0;\n    char odd_char = 'A';\n    for (int i = 0; i < 26; i++) {\n        if (freq[i] % 2 != 0) {\n            odd_count++;\n            odd_char = 'A' + i;\n        }\n    }\n    \n    if (odd_count > 1) {\n        cout << \"NO SOLUTION\" << endl;\n        return 0;\n    }\n    \n    string result = \"\";\n    for (int i = 0; i < 26; i++) {\n        if (freq[i] % 2 == 0) {\n            for (int j = 0; j < freq[i] / 2; j++) {\n                result += (char)('A' + i);\n            }\n        }\n    }\n    \n    string reverse_result = result;\n    reverse(reverse_result.begin(), reverse_result.end());\n    \n    if (odd_count == 1) {\n        for (int i = 0; i < freq[odd_char - 'A']; i++) {\n            result += odd_char;\n        }\n    }\n    \n    result += reverse_result;\n    \n    cout << result << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 16,
            "total_test_cases": 17,
            "mean_time_taken": 0.09359089066000546,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 65,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Parcel Delivery",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1e9;\n\nstruct Edge {\n    int to, cap, cost, flow;\n    Edge(int t, int ca, int co) : to(t), cap(ca), cost(co), flow(0) {}\n};\n\nvector<vector<Edge>> graph;\nvector<int> dist, potential, parent, parent_edge;\n\nvoid add_edge(int from, int to, int cap, int cost) {\n    graph[from].emplace_back(to, cap, cost);\n    graph[to].emplace_back(from, 0, -cost);\n}\n\nbool dijkstra(int s, int t, int n) {\n    dist.assign(n, INF);\n    parent.assign(n, -1);\n    parent_edge.assign(n, -1);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    dist[s] = 0;\n    pq.push({0, s});\n\n    while (!pq.empty()) {\n        int d = pq.top().first;\n        int v = pq.top().second;\n        pq.pop();\n\n        if (d > dist[v]) continue;\n\n        for (int i = 0; i < graph[v].size(); i++) {\n            Edge& e = graph[v][i];\n            int new_dist = dist[v] + e.cost + potential[v] - potential[e.to];\n            if (e.cap > e.flow && new_dist < dist[e.to]) {\n                dist[e.to] = new_dist;\n                parent[e.to] = v;\n                parent_edge[e.to] = i;\n                pq.push({new_dist, e.to});\n            }\n        }\n    }\n\n    return dist[t] != INF;\n}\n\nint min_cost_flow(int s, int t, int k, int n) {\n    int cost = 0;\n    potential.assign(n, 0);\n\n    // Bellman-Ford for initial potential\n    for (int i = 0; i < n; i++)\n        for (int v = 0; v < n; v++)\n            for (Edge& e : graph[v])\n                if (e.cap > 0)\n                    potential[e.to] = min(potential[e.to], potential[v] + e.cost);\n\n    while (k > 0) {\n        if (!dijkstra(s, t, n)) return -1;\n\n        for (int i = 0; i < n; i++)\n            if (dist[i] != INF)\n                potential[i] += dist[i];\n\n        int flow = k;\n        for (int v = t; v != s; v = parent[v]) {\n            Edge& e = graph[parent[v]][parent_edge[v]];\n            flow = min(flow, e.cap - e.flow);\n        }\n\n        k -= flow;\n        cost += flow * (dist[t] - potential[s] + potential[t]);\n\n        for (int v = t; v != s; v = parent[v]) {\n            Edge& e = graph[parent[v]][parent_edge[v]];\n            e.flow += flow;\n            graph[v][graph[parent[v]][parent_edge[v]].to].flow -= flow;\n        }\n    }\n\n    return cost;\n}\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    graph.resize(n);\n\n    for (int i = 0; i < m; i++) {\n        int a, b, r, c;\n        cin >> a >> b >> r >> c;\n        a--; b--;  // 0-based indexing\n        add_edge(a, b, r, c);\n    }\n\n    int result = min_cost_flow(0, n-1, k, n);\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 13,
            "mean_time_taken": 0.17590772188626802,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "free(): invalid pointer\n",
                "Failed",
                "Failed",
                "free(): invalid next size (fast)\n",
                "free(): invalid next size (normal)\n",
                "Failed",
                "free(): invalid next size (normal)\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 65,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Path Queries",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\n\nvector<int> adj[MAX_N];\nint start[MAX_N], finish[MAX_N], timer;\nlong long bit[MAX_N];\nint n, q;\n\nvoid update(int idx, long long val) {\n    while (idx <= n) {\n        bit[idx] += val;\n        idx += idx & -idx;\n    }\n}\n\nlong long query(int idx) {\n    long long sum = 0;\n    while (idx > 0) {\n        sum += bit[idx];\n        idx -= idx & -idx;\n    }\n    return sum;\n}\n\nvoid dfs(int v, int p) {\n    start[v] = ++timer;\n    for (int u : adj[v]) {\n        if (u != p) {\n            dfs(u, v);\n        }\n    }\n    finish[v] = timer;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n >> q;\n    vector<int> values(n + 1);\n    for (int i = 1; i <= n; i++) {\n        cin >> values[i];\n    }\n\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    dfs(1, 0);\n\n    for (int i = 1; i <= n; i++) {\n        update(start[i], values[i]);\n        update(finish[i] + 1, -values[i]);\n    }\n\n    while (q--) {\n        int type;\n        cin >> type;\n        if (type == 1) {\n            int s, x;\n            cin >> s >> x;\n            long long diff = x - values[s];\n            values[s] = x;\n            update(start[s], diff);\n            update(finish[s] + 1, -diff);\n        } else {\n            int s;\n            cin >> s;\n            cout << query(start[s]) << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 9,
            "total_test_cases": 10,
            "mean_time_taken": 0.15213427543640137,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 65,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Path Queries II",
            "category": "Tree Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 65,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Pattern Positions",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> computeLPS(string pattern) {\n    int m = pattern.length();\n    vector<int> lps(m, 0);\n    int len = 0;\n    int i = 1;\n\n    while (i < m) {\n        if (pattern[i] == pattern[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        } else {\n            if (len != 0) {\n                len = lps[len - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    return lps;\n}\n\nint KMP(string text, string pattern) {\n    int n = text.length();\n    int m = pattern.length();\n    vector<int> lps = computeLPS(pattern);\n\n    int i = 0, j = 0;\n    while (i < n) {\n        if (pattern[j] == text[i]) {\n            i++;\n            j++;\n        }\n\n        if (j == m) {\n            return i - j + 1;  // 1-indexed position\n        } else if (i < n && pattern[j] != text[i]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    string text;\n    cin >> text;\n\n    int k;\n    cin >> k;\n\n    for (int i = 0; i < k; i++) {\n        string pattern;\n        cin >> pattern;\n        cout << KMP(text, pattern) << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 10,
            "mean_time_taken": 0.4998399972915649,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                5,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 65,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Permutation Inversions",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\n    dp[1][0] = 1;\n\n    for (int i = 2; i <= n; i++) {\n        for (int j = 0; j <= k; j++) {\n            for (int pos = 1; pos <= i; pos++) {\n                int prev_inv = j - (i - pos);\n                if (prev_inv >= 0) {\n                    dp[i][j] = (dp[i][j] + dp[i-1][prev_inv]) % MOD;\n                }\n            }\n        }\n    }\n\n    cout << dp[n][k] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 16,
            "mean_time_taken": 0.2668208032846451,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                7,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 65,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Permutations",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    if (n == 1) {\n        cout << 1 << endl;\n    } else if (n < 4) {\n        cout << \"NO SOLUTION\" << endl;\n    } else {\n        // Print even numbers\n        for (int i = 2; i <= n; i += 2) {\n            cout << i << \" \";\n        }\n        // Print odd numbers\n        for (int i = 1; i <= n; i += 2) {\n            cout << i << (i == n || i == n-1 ? \"\" : \" \");\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 21,
            "total_test_cases": 21,
            "mean_time_taken": 0.09856244495936803,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 66,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Permutations II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countBeautifulPermutations(int n) {\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n    \n    // Base case\n    dp[1][1] = 1;\n    \n    for (int i = 2; i <= n; i++) {\n        for (int j = 1; j <= i; j++) {\n            for (int k = 1; k < i; k++) {\n                if (abs(k - j) != 1) {\n                    dp[i][j] = (dp[i][j] + dp[i-1][k]) % MOD;\n                }\n            }\n        }\n    }\n    \n    int result = 0;\n    for (int j = 1; j <= n; j++) {\n        result = (result + dp[n][j]) % MOD;\n    }\n    \n    return result;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    cout << countBeautifulPermutations(n) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 23,
            "mean_time_taken": 0.36625440224357275,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 66,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Pizzeria Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nclass SegmentTree {\n    vector<ll> tree;\n    int n;\n\npublic:\n    SegmentTree(int size) {\n        n = size;\n        tree.resize(4 * n, 1e18);\n    }\n\n    void update(int node, int start, int end, int idx, ll val) {\n        if (start == end) {\n            tree[node] = val;\n            return;\n        }\n        int mid = (start + end) / 2;\n        if (idx <= mid)\n            update(2 * node, start, mid, idx, val);\n        else\n            update(2 * node + 1, mid + 1, end, idx, val);\n        tree[node] = min(tree[2 * node], tree[2 * node + 1]);\n    }\n\n    ll query(int node, int start, int end, int l, int r) {\n        if (r < start || end < l)\n            return 1e18;\n        if (l <= start && end <= r)\n            return tree[node];\n        int mid = (start + end) / 2;\n        return min(query(2 * node, start, mid, l, r),\n                   query(2 * node + 1, mid + 1, end, l, r));\n    }\n\n    void update(int idx, ll val) {\n        update(1, 0, n - 1, idx, val);\n    }\n\n    ll query(int l, int r) {\n        return query(1, 0, n - 1, l, r);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n\n    SegmentTree left_tree(n), right_tree(n);\n\n    for (int i = 0; i < n; i++) {\n        ll p;\n        cin >> p;\n        left_tree.update(i, p - i);\n        right_tree.update(i, p + i);\n    }\n\n    while (q--) {\n        int type, k;\n        cin >> type >> k;\n        k--;\n\n        if (type == 1) {\n            ll x;\n            cin >> x;\n            left_tree.update(k, x - k);\n            right_tree.update(k, x + k);\n        } else {\n            ll left_min = left_tree.query(0, k) + k;\n            ll right_min = right_tree.query(k, n - 1) - k;\n            cout << min(left_min, right_min) << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 4,
            "mean_time_taken": 0.19787651300430298,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 67,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Planets Cycles",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\n\nvector<int> teleporter(MAX_N);\nvector<int> result(MAX_N, -1);\nvector<bool> visited(MAX_N, false);\nvector<int> current_path;\n\nvoid dfs(int planet) {\n    visited[planet] = true;\n    current_path.push_back(planet);\n    \n    int next = teleporter[planet];\n    if (result[next] != -1) {\n        // We've reached a planet that's already been processed\n        for (int i = 0; i < current_path.size(); i++) {\n            result[current_path[i]] = result[next] + current_path.size() - i;\n        }\n    } else if (visited[next]) {\n        // We've found a cycle\n        int cycle_start = 0;\n        while (current_path[cycle_start] != next) cycle_start++;\n        \n        int cycle_length = current_path.size() - cycle_start;\n        for (int i = cycle_start; i < current_path.size(); i++) {\n            result[current_path[i]] = cycle_length;\n        }\n        for (int i = 0; i < cycle_start; i++) {\n            result[current_path[i]] = cycle_length + cycle_start - i;\n        }\n    } else {\n        // Continue DFS\n        dfs(next);\n    }\n    \n    current_path.pop_back();\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    for (int i = 1; i <= n; i++) {\n        cin >> teleporter[i];\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        if (result[i] == -1) {\n            dfs(i);\n        }\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 11,
            "total_test_cases": 14,
            "mean_time_taken": 0.1152207681110927,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                8,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 67,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Planets Queries I",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nconst int MAXLOG = 30; // log2(10^9) \u2248 29.9, so 30 is enough\n\nint n, q;\nint t[MAXN];\nint jump[MAXN][MAXLOG];\n\nvoid precompute() {\n    for (int i = 1; i <= n; i++) {\n        jump[i][0] = t[i];\n    }\n    for (int j = 1; j < MAXLOG; j++) {\n        for (int i = 1; i <= n; i++) {\n            jump[i][j] = jump[jump[i][j-1]][j-1];\n        }\n    }\n}\n\nint query(int x, long long k) {\n    for (int j = MAXLOG - 1; j >= 0; j--) {\n        if (k >= (1LL << j)) {\n            x = jump[x][j];\n            k -= (1LL << j);\n        }\n    }\n    return x;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n >> q;\n    for (int i = 1; i <= n; i++) {\n        cin >> t[i];\n    }\n\n    precompute();\n\n    while (q--) {\n        int x;\n        long long k;\n        cin >> x >> k;\n        cout << query(x, k) << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.12603312272291917,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 68,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Planets Queries II",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n\nconst int MAXN = 2e5 + 5;\n\nstd::vector<int> teleporter(MAXN);\nstd::vector<int> cycle_id(MAXN, -1);\nstd::vector<int> position(MAXN, -1);\nstd::vector<int> dist_to_cycle(MAXN, -1);\n\nvoid dfs(int node, std::vector<int>& path, std::vector<bool>& visited, std::vector<bool>& in_stack) {\n    visited[node] = true;\n    in_stack[node] = true;\n    path.push_back(node);\n\n    int next = teleporter[node];\n    if (!visited[next]) {\n        dfs(next, path, visited, in_stack);\n    } else if (in_stack[next]) {\n        int cycle_start = next;\n        int cycle_id = next;\n        int pos = 0;\n        for (int i = path.size() - 1; i >= 0; i--) {\n            int curr = path[i];\n            cycle_id[curr] = cycle_id;\n            position[curr] = pos++;\n            if (curr == cycle_start) break;\n        }\n    }\n\n    if (cycle_id[node] == -1) {\n        dist_to_cycle[node] = dist_to_cycle[next] + 1;\n        cycle_id[node] = cycle_id[next];\n    }\n\n    path.pop_back();\n    in_stack[node] = false;\n}\n\nvoid preprocess(int n) {\n    std::vector<bool> visited(n + 1, false);\n    std::vector<bool> in_stack(n + 1, false);\n    std::vector<int> path;\n\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            dfs(i, path, visited, in_stack);\n        }\n    }\n}\n\nint query(int start, int end) {\n    if (cycle_id[start] != cycle_id[end]) return -1;\n\n    if (position[start] != -1 && position[end] != -1) {\n        int dist = (position[end] - position[start] + position.size()) % position.size();\n        return dist;\n    }\n\n    if (position[start] == -1 && position[end] != -1) {\n        return dist_to_cycle[start] + position[end];\n    }\n\n    if (position[start] == -1 && position[end] == -1) {\n        if (dist_to_cycle[start] >= dist_to_cycle[end]) {\n            return dist_to_cycle[start] - dist_to_cycle[end];\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    int n, q;\n    std::cin >> n >> q;\n\n    for (int i = 1; i <= n; i++) {\n        std::cin >> teleporter[i];\n    }\n\n    preprocess(n);\n\n    while (q--) {\n        int a, b;\n        std::cin >> a >> b;\n        std::cout << query(a, b) << std::endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 68,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Planets and Kingdoms",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nclass Graph {\n    int V;\n    vector<vector<int>> adj;\n    vector<vector<int>> transpose;\n\npublic:\n    Graph(int v) : V(v), adj(v), transpose(v) {}\n\n    void addEdge(int v, int w) {\n        adj[v].push_back(w);\n        transpose[w].push_back(v);\n    }\n\n    void dfs1(int v, vector<bool>& visited, stack<int>& Stack) {\n        visited[v] = true;\n        for (int i : adj[v]) {\n            if (!visited[i]) {\n                dfs1(i, visited, Stack);\n            }\n        }\n        Stack.push(v);\n    }\n\n    void dfs2(int v, vector<bool>& visited, vector<int>& component) {\n        visited[v] = true;\n        component.push_back(v);\n        for (int i : transpose[v]) {\n            if (!visited[i]) {\n                dfs2(i, visited, component);\n            }\n        }\n    }\n\n    vector<vector<int>> kosaraju() {\n        stack<int> Stack;\n        vector<bool> visited(V, false);\n\n        for (int i = 0; i < V; i++) {\n            if (!visited[i]) {\n                dfs1(i, visited, Stack);\n            }\n        }\n\n        fill(visited.begin(), visited.end(), false);\n        vector<vector<int>> SCCs;\n\n        while (!Stack.empty()) {\n            int v = Stack.top();\n            Stack.pop();\n\n            if (!visited[v]) {\n                vector<int> component;\n                dfs2(v, visited, component);\n                SCCs.push_back(component);\n            }\n        }\n\n        return SCCs;\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    Graph g(n);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        g.addEdge(a - 1, b - 1);  // 0-based indexing\n    }\n\n    vector<vector<int>> SCCs = g.kosaraju();\n    \n    cout << SCCs.size() << endl;\n\n    vector<int> kingdom(n);\n    for (int i = 0; i < SCCs.size(); i++) {\n        for (int planet : SCCs[i]) {\n            kingdom[planet] = i + 1;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        cout << kingdom[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.16124656200408935,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 69,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Playlist",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> songs(n);\n    for (int i = 0; i < n; i++) {\n        cin >> songs[i];\n    }\n\n    unordered_set<int> unique_songs;\n    int left = 0, right = 0;\n    int max_length = 0;\n\n    while (right < n) {\n        while (unique_songs.count(songs[right]) > 0) {\n            unique_songs.erase(songs[left]);\n            left++;\n        }\n        unique_songs.insert(songs[right]);\n        max_length = max(max_length, right - left + 1);\n        right++;\n    }\n\n    cout << max_length << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 19,
            "total_test_cases": 20,
            "mean_time_taken": 0.1744288206100464,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                1
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 69,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Point Location Test",
            "category": "Geometry",
            "solution": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n\n    while (t--) {\n        long long x1, y1, x2, y2, x3, y3;\n        cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\n        // Calculate vectors\n        long long v1x = x2 - x1;\n        long long v1y = y2 - y1;\n        long long v2x = x3 - x1;\n        long long v2y = y3 - y1;\n\n        // Calculate cross product\n        long long cross_product = v1x * v2y - v1y * v2x;\n\n        // Determine position\n        if (cross_product > 0) {\n            cout << \"LEFT\\n\";\n        } else if (cross_product < 0) {\n            cout << \"RIGHT\\n\";\n        } else {\n            cout << \"TOUCH\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 6,
            "mean_time_taken": 0.10227251052856445,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 70,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Point in Polygon",
            "category": "Geometry",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1e-9;\n\nstruct Point {\n    long long x, y;\n    Point(long long x = 0, long long y = 0) : x(x), y(y) {}\n};\n\n// Check if point q lies on line segment pr\nbool onSegment(Point p, Point r, Point q) {\n    return q.x <= max(p.x, r.x) && q.x >= min(p.x, r.x) &&\n           q.y <= max(p.y, r.y) && q.y >= min(p.y, r.y);\n}\n\n// Check orientation of ordered triplet (p, q, r)\nint orientation(Point p, Point q, Point r) {\n    long long val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    if (val == 0) return 0;  // Collinear\n    return (val > 0) ? 1 : 2; // Clockwise or Counterclockwise\n}\n\n// Check if line segment 'p1q1' and 'p2q2' intersect\nbool doIntersect(Point p1, Point q1, Point p2, Point q2) {\n    int o1 = orientation(p1, q1, p2);\n    int o2 = orientation(p1, q1, q2);\n    int o3 = orientation(p2, q2, p1);\n    int o4 = orientation(p2, q2, q1);\n\n    if (o1 != o2 && o3 != o4) return true;\n\n    if (o1 == 0 && onSegment(p1, q1, p2)) return true;\n    if (o2 == 0 && onSegment(p1, q1, q2)) return true;\n    if (o3 == 0 && onSegment(p2, q2, p1)) return true;\n    if (o4 == 0 && onSegment(p2, q2, q1)) return true;\n\n    return false;\n}\n\n// Check if point p is inside polygon\nstring isInside(vector<Point>& polygon, Point p) {\n    int n = polygon.size();\n    if (n < 3) return \"OUTSIDE\";\n\n    // Check if point is on boundary\n    for (int i = 0; i < n; i++) {\n        Point next = polygon[(i + 1) % n];\n        if (onSegment(polygon[i], next, p))\n            return \"BOUNDARY\";\n    }\n\n    // Create a point for line segment from p to infinite\n    Point extreme = {INT_MAX, p.y};\n\n    int count = 0, i = 0;\n    do {\n        int next = (i + 1) % n;\n\n        if (doIntersect(polygon[i], polygon[next], p, extreme)) {\n            if (orientation(polygon[i], p, polygon[next]) == 0)\n                return onSegment(polygon[i], polygon[next], p) ? \"BOUNDARY\" : \"OUTSIDE\";\n            count++;\n        }\n        i = next;\n    } while (i != 0);\n\n    return (count & 1) ? \"INSIDE\" : \"OUTSIDE\";\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<Point> polygon(n);\n    for (int i = 0; i < n; i++) {\n        cin >> polygon[i].x >> polygon[i].y;\n    }\n\n    for (int i = 0; i < m; i++) {\n        Point p;\n        cin >> p.x >> p.y;\n        cout << isInside(polygon, p) << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 70,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Police Chase",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nconst int MAXN = 505;\n\nint n, m;\nvector<int> graph[MAXN];\nint capacity[MAXN][MAXN];\nint parent[MAXN];\nbool visited[MAXN];\n\nbool bfs(int s, int t) {\n    fill(visited, visited + n + 1, false);\n    queue<int> q;\n    q.push(s);\n    visited[s] = true;\n    parent[s] = -1;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        for (int v : graph[u]) {\n            if (!visited[v] && capacity[u][v] > 0) {\n                q.push(v);\n                parent[v] = u;\n                visited[v] = true;\n                if (v == t) return true;\n            }\n        }\n    }\n    return false;\n}\n\nint fordFulkerson(int s, int t) {\n    int max_flow = 0;\n\n    while (bfs(s, t)) {\n        int path_flow = INT_MAX;\n        for (int v = t; v != s; v = parent[v]) {\n            int u = parent[v];\n            path_flow = min(path_flow, capacity[u][v]);\n        }\n\n        for (int v = t; v != s; v = parent[v]) {\n            int u = parent[v];\n            capacity[u][v] -= path_flow;\n            capacity[v][u] += path_flow;\n        }\n\n        max_flow += path_flow;\n    }\n\n    return max_flow;\n}\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for (int v : graph[u]) {\n        if (!visited[v] && capacity[u][v] > 0) {\n            dfs(v);\n        }\n    }\n}\n\nint main() {\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n        capacity[a][b] = capacity[b][a] = 1;\n    }\n\n    int min_cut = fordFulkerson(1, n);\n    cout << min_cut << endl;\n\n    fill(visited, visited + n + 1, false);\n    dfs(1);\n\n    for (int u = 1; u <= n; u++) {\n        if (visited[u]) {\n            for (int v : graph[u]) {\n                if (!visited[v]) {\n                    cout << u << \" \" << v << endl;\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 15,
            "total_test_cases": 15,
            "mean_time_taken": 0.08499590555826823,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 71,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Polygon Area",
            "category": "Geometry",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<long long> x(n), y(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i];\n    }\n\n    long long area = 0;\n    for (int i = 0; i < n; i++) {\n        int j = (i + 1) % n;\n        area += x[i] * y[j] - x[j] * y[i];\n    }\n\n    area = abs(area);\n\n    cout << area << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 5,
            "mean_time_taken": 0.08634872436523437,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 72,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Polygon Lattice Points",
            "category": "Geometry",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll gcd(ll a, ll b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<pair<ll, ll>> points(n);\n    for (int i = 0; i < n; i++) {\n        cin >> points[i].first >> points[i].second;\n    }\n    \n    ll area = 0;\n    ll boundary = 0;\n    \n    for (int i = 0; i < n; i++) {\n        int j = (i + 1) % n;\n        \n        // Shoelace formula\n        area += points[i].first * points[j].second - points[j].first * points[i].second;\n        \n        // Count boundary points\n        ll dx = abs(points[i].first - points[j].first);\n        ll dy = abs(points[i].second - points[j].second);\n        boundary += gcd(dx, dy);\n    }\n    \n    area = abs(area);\n    \n    // Pick's theorem: A = i + b/2 - 1\n    // Rearranging: i = A - b/2 + 1\n    ll interior = (area - boundary + 2) / 2;\n    \n    cout << interior << \" \" << boundary << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 5,
            "mean_time_taken": 0.09009761810302734,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 73,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Polynomial Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Node {\n    ll sum;\n    ll lazy_start, lazy_step;\n    Node() : sum(0), lazy_start(0), lazy_step(0) {}\n};\n\nclass SegmentTree {\nprivate:\n    vector<Node> tree;\n    int n;\n\n    void build(vector<int>& arr, int v, int tl, int tr) {\n        if (tl == tr) {\n            tree[v].sum = arr[tl];\n        } else {\n            int tm = (tl + tr) / 2;\n            build(arr, v*2, tl, tm);\n            build(arr, v*2+1, tm+1, tr);\n            tree[v].sum = tree[v*2].sum + tree[v*2+1].sum;\n        }\n    }\n\n    void push(int v, int tl, int tr) {\n        if (tree[v].lazy_start == 0 && tree[v].lazy_step == 0) return;\n\n        int tm = (tl + tr) / 2;\n        int left_count = tm - tl + 1;\n        int right_count = tr - tm;\n\n        // Update left child\n        tree[v*2].sum += (tree[v].lazy_start * left_count) + (tree[v].lazy_step * left_count * (left_count - 1) / 2);\n        tree[v*2].lazy_start += tree[v].lazy_start;\n        tree[v*2].lazy_step += tree[v].lazy_step;\n\n        // Update right child\n        ll right_start = tree[v].lazy_start + tree[v].lazy_step * left_count;\n        tree[v*2+1].sum += (right_start * right_count) + (tree[v].lazy_step * right_count * (right_count - 1) / 2);\n        tree[v*2+1].lazy_start += right_start;\n        tree[v*2+1].lazy_step += tree[v].lazy_step;\n\n        tree[v].lazy_start = tree[v].lazy_step = 0;\n    }\n\n    void update(int v, int tl, int tr, int l, int r) {\n        if (l > r) return;\n        if (l == tl && tr == r) {\n            int count = tr - tl + 1;\n            tree[v].sum += (l - tl + 1) * count + (count * (count - 1) / 2);\n            tree[v].lazy_start += l - tl + 1;\n            tree[v].lazy_step += 1;\n        } else {\n            push(v, tl, tr);\n            int tm = (tl + tr) / 2;\n            update(v*2, tl, tm, l, min(r, tm));\n            update(v*2+1, tm+1, tr, max(l, tm+1), r);\n            tree[v].sum = tree[v*2].sum + tree[v*2+1].sum;\n        }\n    }\n\n    ll query(int v, int tl, int tr, int l, int r) {\n        if (l > r) return 0;\n        if (l == tl && tr == r) {\n            return tree[v].sum;\n        }\n        push(v, tl, tr);\n        int tm = (tl + tr) / 2;\n        return query(v*2, tl, tm, l, min(r, tm)) +\n               query(v*2+1, tm+1, tr, max(l, tm+1), r);\n    }\n\npublic:\n    SegmentTree(vector<int>& arr) {\n        n = arr.size();\n        tree.resize(4 * n);\n        build(arr, 1, 0, n-1);\n    }\n\n    void update(int l, int r) {\n        update(1, 0, n-1, l, r);\n    }\n\n    ll query(int l, int r) {\n        return query(1, 0, n-1, l, r);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    SegmentTree st(arr);\n\n    while (q--) {\n        int type, a, b;\n        cin >> type >> a >> b;\n        a--; b--; // Convert to 0-based indexing\n\n        if (type == 1) {\n            st.update(a, b);\n        } else {\n            cout << st.query(a, b) << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 0.18893003463745117,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 73,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Prefix Sum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\nstruct Node {\n    long long sum, maxPrefix, minPrefix;\n    Node(long long val = 0) : sum(val), maxPrefix(max(0LL, val)), minPrefix(min(0LL, val)) {}\n};\n\nclass SegmentTree {\nprivate:\n    vector<Node> tree;\n    int n;\n\n    Node combine(const Node& left, const Node& right) {\n        Node result;\n        result.sum = left.sum + right.sum;\n        result.maxPrefix = max(left.maxPrefix, left.sum + right.maxPrefix);\n        result.minPrefix = min(left.minPrefix, left.sum + right.minPrefix);\n        return result;\n    }\n\n    void build(const vector<int>& arr, int v, int tl, int tr) {\n        if (tl == tr) {\n            tree[v] = Node(arr[tl]);\n        } else {\n            int tm = (tl + tr) / 2;\n            build(arr, v*2, tl, tm);\n            build(arr, v*2+1, tm+1, tr);\n            tree[v] = combine(tree[v*2], tree[v*2+1]);\n        }\n    }\n\n    void update(int v, int tl, int tr, int pos, int new_val) {\n        if (tl == tr) {\n            tree[v] = Node(new_val);\n        } else {\n            int tm = (tl + tr) / 2;\n            if (pos <= tm)\n                update(v*2, tl, tm, pos, new_val);\n            else\n                update(v*2+1, tm+1, tr, pos, new_val);\n            tree[v] = combine(tree[v*2], tree[v*2+1]);\n        }\n    }\n\n    Node query(int v, int tl, int tr, int l, int r) {\n        if (l > r)\n            return Node();\n        if (l == tl && r == tr)\n            return tree[v];\n        int tm = (tl + tr) / 2;\n        return combine(query(v*2, tl, tm, l, min(r, tm)),\n                       query(v*2+1, tm+1, tr, max(l, tm+1), r));\n    }\n\npublic:\n    SegmentTree(const vector<int>& arr) {\n        n = arr.size();\n        tree.resize(4 * n);\n        build(arr, 1, 0, n - 1);\n    }\n\n    void update(int pos, int new_val) {\n        update(1, 0, n - 1, pos - 1, new_val);\n    }\n\n    long long queryMaxPrefix(int l, int r) {\n        return query(1, 0, n - 1, l - 1, r - 1).maxPrefix;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    SegmentTree st(arr);\n\n    while (q--) {\n        int type;\n        cin >> type;\n\n        if (type == 1) {\n            int k, u;\n            cin >> k >> u;\n            st.update(k, u);\n        } else {\n            int a, b;\n            cin >> a >> b;\n            cout << st.queryMaxPrefix(a, b) << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 6,
            "mean_time_taken": 0.15136873722076416,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 74,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Prime Multiples",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nlong long gcd(long long a, long long b) {\n    while (b) {\n        a %= b;\n        swap(a, b);\n    }\n    return a;\n}\n\nlong long lcm(long long a, long long b) {\n    return a / gcd(a, b) * b;\n}\n\nint main() {\n    long long n;\n    int k;\n    cin >> n >> k;\n    \n    vector<long long> primes(k);\n    for (int i = 0; i < k; i++) {\n        cin >> primes[i];\n    }\n    \n    long long result = 0;\n    for (int mask = 1; mask < (1 << k); mask++) {\n        int bits = __builtin_popcount(mask);\n        long long current_lcm = 1;\n        \n        for (int i = 0; i < k; i++) {\n            if (mask & (1 << i)) {\n                if (n / current_lcm < primes[i]) {\n                    current_lcm = n + 1;\n                    break;\n                }\n                current_lcm = lcm(current_lcm, primes[i]);\n            }\n        }\n        \n        if (bits % 2 == 1) {\n            result += n / current_lcm;\n        } else {\n            result -= n / current_lcm;\n        }\n    }\n    \n    cout << result << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 5,
            "mean_time_taken": 0.15136122703552246,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 75,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Programmers and Artists",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int a, b, n;\n    cin >> a >> b >> n;\n\n    vector<pair<int, int>> applicants;\n    long long sum = 0;\n\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        applicants.push_back({y - x, max(x, y)});\n    }\n\n    sort(applicants.begin(), applicants.end());\n\n    for (int i = 0; i < b; i++) {\n        sum += applicants[i].second;\n    }\n\n    for (int i = n - 1; i >= n - a; i--) {\n        sum += applicants[i].second;\n    }\n\n    cout << sum << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 11,
            "mean_time_taken": 0.1174352385781028,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 75,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Projects",
            "category": "Dynamic Programming",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nstruct Project {\n    ll start, end, reward;\n};\n\nbool compare(const Project &a, const Project &b) {\n    return a.end < b.end;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<Project> projects(n);\n\n    for (int i = 0; i < n; i++) {\n        cin >> projects[i].start >> projects[i].end >> projects[i].reward;\n    }\n\n    // Sort projects by end time\n    sort(projects.begin(), projects.end(), compare);\n\n    vector<ll> dp(n);\n    dp[0] = projects[0].reward;\n\n    for (int i = 1; i < n; i++) {\n        ll include = projects[i].reward;\n        int j = upper_bound(projects.begin(), projects.begin() + i, Project{0, projects[i].start, 0}, compare) - projects.begin() - 1;\n        \n        if (j >= 0) {\n            include += dp[j];\n        }\n\n        dp[i] = max(dp[i-1], include);\n    }\n\n    cout << dp[n-1] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 14,
            "mean_time_taken": 0.14232110977172852,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                5,
                8,
                9,
                10,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 75,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Pr\u00fcfer Code",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> prufer(n - 2);\n    for (int i = 0; i < n - 2; i++) {\n        cin >> prufer[i];\n    }\n\n    vector<int> degree(n + 1, 1);\n    for (int node : prufer) {\n        degree[node]++;\n    }\n\n    set<int> leaves;\n    for (int i = 1; i <= n; i++) {\n        if (degree[i] == 1) {\n            leaves.insert(i);\n        }\n    }\n\n    vector<pair<int, int>> edges;\n    for (int parent : prufer) {\n        int leaf = *leaves.begin();\n        edges.push_back({leaf, parent});\n        \n        leaves.erase(leaf);\n        degree[parent]--;\n        if (degree[parent] == 1) {\n            leaves.insert(parent);\n        }\n    }\n\n    int node1 = *leaves.begin();\n    leaves.erase(node1);\n    int node2 = *leaves.begin();\n    edges.push_back({node1, node2});\n\n    for (const auto& edge : edges) {\n        cout << edge.first << \" \" << edge.second << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 11,
            "mean_time_taken": 0.1876394965431907,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 75,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Pyramid Array",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nint n, a[MAXN], left[MAXN], right[MAXN], bit[MAXN];\nvector<pair<int, int>> sorted;\n\nvoid update(int x, int val) {\n    for (; x <= n; x += x & -x)\n        bit[x] += val;\n}\n\nint query(int x) {\n    int res = 0;\n    for (; x > 0; x -= x & -x)\n        res += bit[x];\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n        sorted.push_back({a[i], i});\n    }\n\n    sort(sorted.begin(), sorted.end());\n    for (int i = 0; i < n; i++) {\n        int idx = sorted[i].second;\n        left[idx] = query(n) - query(idx);\n        update(idx, 1);\n    }\n\n    memset(bit, 0, sizeof(bit));\n    for (int i = n - 1; i >= 0; i--) {\n        int idx = sorted[i].second;\n        right[idx] = query(idx - 1);\n        update(idx, 1);\n    }\n\n    int ans = n;\n    for (int i = 1; i <= n; i++) {\n        ans = min(ans, left[i] + right[i]);\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 75,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Range Queries and Copies",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX_N = 2e5 + 5;\n\nstruct Node {\n    ll sum;\n    Node *left, *right;\n    Node(ll val = 0) : sum(val), left(nullptr), right(nullptr) {}\n};\n\nclass PersistentSegmentTree {\nprivate:\n    Node* build(int l, int r) {\n        Node* node = new Node();\n        if (l == r) return node;\n        int mid = (l + r) / 2;\n        node->left = build(l, mid);\n        node->right = build(mid + 1, r);\n        return node;\n    }\n\n    Node* update(Node* prev, int l, int r, int idx, ll val) {\n        Node* curr = new Node();\n        *curr = *prev;\n        if (l == r) {\n            curr->sum = val;\n            return curr;\n        }\n        int mid = (l + r) / 2;\n        if (idx <= mid)\n            curr->left = update(prev->left, l, mid, idx, val);\n        else\n            curr->right = update(prev->right, mid + 1, r, idx, val);\n        curr->sum = curr->left->sum + curr->right->sum;\n        return curr;\n    }\n\n    ll query(Node* node, int l, int r, int ql, int qr) {\n        if (ql > r || qr < l) return 0;\n        if (ql <= l && r <= qr) return node->sum;\n        int mid = (l + r) / 2;\n        return query(node->left, l, mid, ql, qr) + query(node->right, mid + 1, r, ql, qr);\n    }\n\npublic:\n    vector<Node*> roots;\n    int n;\n\n    PersistentSegmentTree(int size, vector<int>& arr) : n(size) {\n        Node* root = build(1, n);\n        for (int i = 1; i <= n; i++) {\n            root = update(root, 1, n, i, arr[i-1]);\n        }\n        roots.push_back(root);\n    }\n\n    void update(int version, int idx, ll val) {\n        roots.push_back(update(roots[version], 1, n, idx, val));\n    }\n\n    ll query(int version, int l, int r) {\n        return query(roots[version], 1, n, l, r);\n    }\n\n    void copy(int version) {\n        roots.push_back(roots[version]);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    PersistentSegmentTree pst(n, arr);\n\n    while (q--) {\n        int type;\n        cin >> type;\n\n        if (type == 1) {\n            int k, a, x;\n            cin >> k >> a >> x;\n            pst.update(k-1, a, x);\n        } else if (type == 2) {\n            int k, a, b;\n            cin >> k >> a >> b;\n            cout << pst.query(k-1, a, b) << \"\\n\";\n        } else {\n            int k;\n            cin >> k;\n            pst.copy(k-1);\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 7,
            "mean_time_taken": 0.20249414443969727,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 75,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Range Update Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass FenwickTree {\nprivate:\n    vector<long long> tree;\n    int n;\n\n    int LSB(int i) {\n        return i & (-i);\n    }\n\npublic:\n    FenwickTree(int size) : n(size + 1) {\n        tree.resize(n, 0);\n    }\n\n    void update(int i, long long delta) {\n        while (i < n) {\n            tree[i] += delta;\n            i += LSB(i);\n        }\n    }\n\n    long long query(int i) {\n        long long sum = 0;\n        while (i > 0) {\n            sum += tree[i];\n            i -= LSB(i);\n        }\n        return sum;\n    }\n\n    void rangeUpdate(int l, int r, long long value) {\n        update(l, value);\n        update(r + 1, -value);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n\n    vector<long long> arr(n + 1);\n    FenwickTree ft(n);\n\n    for (int i = 1; i <= n; i++) {\n        cin >> arr[i];\n        ft.rangeUpdate(i, i, arr[i]);\n    }\n\n    while (q--) {\n        int type;\n        cin >> type;\n\n        if (type == 1) {\n            int a, b, u;\n            cin >> a >> b >> u;\n            ft.rangeUpdate(a, b, u);\n        } else {\n            int k;\n            cin >> k;\n            cout << ft.query(k) << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 3,
            "mean_time_taken": 0.139998197555542,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 76,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Range Updates and Sums",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\n\nstruct Node {\n    long long sum, lazy;\n    bool set;\n    long long set_val;\n    Node() : sum(0), lazy(0), set(false), set_val(0) {}\n};\n\nint n, q;\nvector<int> arr(MAX_N);\nNode tree[4 * MAX_N];\n\nvoid build(int node, int start, int end) {\n    if (start == end) {\n        tree[node].sum = arr[start];\n        return;\n    }\n    int mid = (start + end) / 2;\n    build(2 * node, start, mid);\n    build(2 * node + 1, mid + 1, end);\n    tree[node].sum = tree[2 * node].sum + tree[2 * node + 1].sum;\n}\n\nvoid propagate(int node, int start, int end) {\n    if (tree[node].set) {\n        tree[node].sum = (end - start + 1) * tree[node].set_val;\n        if (start != end) {\n            tree[2 * node].set = tree[2 * node + 1].set = true;\n            tree[2 * node].set_val = tree[2 * node + 1].set_val = tree[node].set_val;\n            tree[2 * node].lazy = tree[2 * node + 1].lazy = 0;\n        }\n        tree[node].set = false;\n    }\n    if (tree[node].lazy) {\n        tree[node].sum += (end - start + 1) * tree[node].lazy;\n        if (start != end) {\n            tree[2 * node].lazy += tree[node].lazy;\n            tree[2 * node + 1].lazy += tree[node].lazy;\n        }\n        tree[node].lazy = 0;\n    }\n}\n\nvoid update(int node, int start, int end, int l, int r, int val, bool is_set) {\n    propagate(node, start, end);\n    if (start > r || end < l) return;\n    if (l <= start && end <= r) {\n        if (is_set) {\n            tree[node].set = true;\n            tree[node].set_val = val;\n            tree[node].lazy = 0;\n        } else {\n            tree[node].lazy += val;\n        }\n        propagate(node, start, end);\n        return;\n    }\n    int mid = (start + end) / 2;\n    update(2 * node, start, mid, l, r, val, is_set);\n    update(2 * node + 1, mid + 1, end, l, r, val, is_set);\n    tree[node].sum = tree[2 * node].sum + tree[2 * node + 1].sum;\n}\n\nlong long query(int node, int start, int end, int l, int r) {\n    propagate(node, start, end);\n    if (start > r || end < l) return 0;\n    if (l <= start && end <= r) return tree[node].sum;\n    int mid = (start + end) / 2;\n    return query(2 * node, start, mid, l, r) + query(2 * node + 1, mid + 1, end, l, r);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n >> q;\n    for (int i = 1; i <= n; i++) {\n        cin >> arr[i];\n    }\n\n    build(1, 1, n);\n\n    while (q--) {\n        int type, a, b, x;\n        cin >> type >> a >> b;\n        if (type == 1) {\n            cin >> x;\n            update(1, 1, n, a, b, x, false);\n        } else if (type == 2) {\n            cin >> x;\n            update(1, 1, n, a, b, x, true);\n        } else {\n            cout << query(1, 1, n, a, b) << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 4,
            "mean_time_taken": 0.18880409002304077,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 77,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Range Xor Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> prefix_xor(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        int x;\n        cin >> x;\n        prefix_xor[i] = prefix_xor[i-1] ^ x;\n    }\n\n    while (q--) {\n        int a, b;\n        cin >> a >> b;\n        cout << (prefix_xor[b] ^ prefix_xor[a-1]) << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 2,
            "mean_time_taken": 0.10371065139770508,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 78,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Reachability Queries",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N = 50001;\n\nbool reachable[MAX_N][MAX_N];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m, q;\n    cin >> n >> m >> q;\n\n    // Initialize reachability matrix\n    for (int i = 1; i <= n; i++) {\n        reachable[i][i] = true;\n    }\n\n    // Read edges\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        reachable[a][b] = true;\n    }\n\n    // Floyd-Warshall algorithm\n    for (int k = 1; k <= n; k++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                reachable[i][j] |= (reachable[i][k] && reachable[k][j]);\n            }\n        }\n    }\n\n    // Answer queries\n    for (int i = 0; i < q; i++) {\n        int a, b;\n        cin >> a >> b;\n        cout << (reachable[a][b] ? \"YES\" : \"NO\") << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 78,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Reachable Nodes",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nconst int MAXN = 5e4 + 5;\n\nvector<int> adj[MAXN];\nbool visited[MAXN];\nint reachable[MAXN];\nstack<int> topo_order;\n\nvoid dfs(int node) {\n    visited[node] = true;\n    for (int next : adj[node]) {\n        if (!visited[next]) {\n            dfs(next);\n        }\n    }\n    topo_order.push(node);\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n\n    // Topological sort\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            dfs(i);\n        }\n    }\n\n    // Calculate reachable nodes\n    while (!topo_order.empty()) {\n        int node = topo_order.top();\n        topo_order.pop();\n        \n        reachable[node] = 1; // Node itself\n        for (int next : adj[node]) {\n            reachable[node] += reachable[next];\n        }\n    }\n\n    // Print results\n    for (int i = 1; i <= n; i++) {\n        cout << reachable[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.11268484592437744,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 78,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Reading Books",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<long long> books(n);\n    long long sum = 0;\n    long long max_time = 0;\n    \n    for (int i = 0; i < n; i++) {\n        cin >> books[i];\n        sum += books[i];\n        max_time = max(max_time, books[i]);\n    }\n    \n    long long result = max(sum, 2 * max_time);\n    \n    cout << result << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.0916754832634559,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 79,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Rectangle Cutting",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_SIZE = 501;\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n\n    vector<vector<int>> dp(MAX_SIZE, vector<int>(MAX_SIZE, 0));\n\n    // Initialize base cases\n    for (int i = 1; i < MAX_SIZE; i++) {\n        for (int j = 1; j < MAX_SIZE; j++) {\n            if (i == j) {\n                dp[i][j] = 0;\n            } else if (i == 1) {\n                dp[i][j] = j - 1;\n            } else if (j == 1) {\n                dp[i][j] = i - 1;\n            } else {\n                dp[i][j] = 1e9; // Initialize with a large value\n            }\n        }\n    }\n\n    // Fill the dp table\n    for (int i = 2; i <= a; i++) {\n        for (int j = 2; j <= b; j++) {\n            if (i == j) continue; // Already handled in base case\n\n            // Try horizontal cuts\n            for (int k = 1; k < i; k++) {\n                dp[i][j] = min(dp[i][j], 1 + dp[k][j] + dp[i-k][j]);\n            }\n\n            // Try vertical cuts\n            for (int k = 1; k < j; k++) {\n                dp[i][j] = min(dp[i][j], 1 + dp[i][k] + dp[i][j-k]);\n            }\n        }\n    }\n\n    cout << dp[a][b] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 23,
            "total_test_cases": 26,
            "mean_time_taken": 0.2890597948661217,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                7,
                15,
                19
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 79,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Removal Game",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<long long> a(n);\n    long long total_sum = 0;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        total_sum += a[i];\n    }\n    \n    vector<vector<long long>> dp(n, vector<long long>(n, 0));\n    \n    for (int len = 1; len <= n; len++) {\n        for (int i = 0; i + len - 1 < n; i++) {\n            int j = i + len - 1;\n            if (len == 1) {\n                dp[i][j] = a[i];\n            } else {\n                dp[i][j] = max(a[i] - dp[i+1][j], a[j] - dp[i][j-1]);\n            }\n        }\n    }\n    \n    cout << (total_sum + dp[0][n-1]) / 2 << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.21819821425846644,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 80,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Removing Digits",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\nint minSteps(int n) {\n    vector<int> dp(n + 1, INT_MAX);\n    dp[0] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int num = i;\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit != 0 && i - digit >= 0) {\n                dp[i] = min(dp[i], dp[i - digit] + 1);\n            }\n            num /= 10;\n        }\n    }\n\n    return dp[n];\n}\n\nint main() {\n    int n;\n    cin >> n;\n    cout << minSteps(n) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.09583474908556257,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 81,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Removing Digits II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    long long n;\n    cin >> n;\n\n    vector<int> dp(n + 1, n + 1);\n    dp[0] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int num = i;\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit != 0 && i >= digit) {\n                dp[i] = min(dp[i], dp[i - digit] + 1);\n            }\n            num /= 10;\n        }\n    }\n\n    cout << dp[n] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 9,
            "mean_time_taken": 0.2122143374549018,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                5,
                7,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 81,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Repeating Substring",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nvector<int> sort_cyclic_shifts(string const& s) {\n    int n = s.length();\n    const int alphabet = 256;\n    vector<int> p(n), c(n), cnt(max(alphabet, n), 0);\n    for (int i = 0; i < n; i++)\n        cnt[s[i]]++;\n    for (int i = 1; i < alphabet; i++)\n        cnt[i] += cnt[i-1];\n    for (int i = 0; i < n; i++)\n        p[--cnt[s[i]]] = i;\n    c[p[0]] = 0;\n    int classes = 1;\n    for (int i = 1; i < n; i++) {\n        if (s[p[i]] != s[p[i-1]])\n            classes++;\n        c[p[i]] = classes - 1;\n    }\n    vector<int> pn(n), cn(n);\n    for (int h = 0; (1 << h) < n; ++h) {\n        for (int i = 0; i < n; i++) {\n            pn[i] = p[i] - (1 << h);\n            if (pn[i] < 0)\n                pn[i] += n;\n        }\n        fill(cnt.begin(), cnt.begin() + classes, 0);\n        for (int i = 0; i < n; i++)\n            cnt[c[pn[i]]]++;\n        for (int i = 1; i < classes; i++)\n            cnt[i] += cnt[i-1];\n        for (int i = n-1; i >= 0; i--)\n            p[--cnt[c[pn[i]]]] = pn[i];\n        cn[p[0]] = 0;\n        classes = 1;\n        for (int i = 1; i < n; i++) {\n            pair<int, int> cur = {c[p[i]], c[(p[i] + (1 << h)) % n]};\n            pair<int, int> prev = {c[p[i-1]], c[(p[i-1] + (1 << h)) % n]};\n            if (cur != prev)\n                ++classes;\n            cn[p[i]] = classes - 1;\n        }\n        c.swap(cn);\n    }\n    return p;\n}\n\nvector<int> lcp_construction(string const& s, vector<int> const& p) {\n    int n = s.length();\n    vector<int> rank(n, 0);\n    for (int i = 0; i < n; i++)\n        rank[p[i]] = i;\n    int k = 0;\n    vector<int> lcp(n-1, 0);\n    for (int i = 0; i < n; i++) {\n        if (rank[i] == n - 1) {\n            k = 0;\n            continue;\n        }\n        int j = p[rank[i] + 1];\n        while (i + k < n && j + k < n && s[i+k] == s[j+k])\n            k++;\n        lcp[rank[i]] = k;\n        if (k)\n            k--;\n    }\n    return lcp;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    s += \"$\";\n    vector<int> p = sort_cyclic_shifts(s);\n    vector<int> lcp = lcp_construction(s, p);\n    \n    int max_lcp = 0;\n    int max_lcp_index = 0;\n    for (int i = 0; i < lcp.size(); i++) {\n        if (lcp[i] > max_lcp) {\n            max_lcp = lcp[i];\n            max_lcp_index = i;\n        }\n    }\n    \n    if (max_lcp == 0) {\n        cout << -1 << endl;\n    } else {\n        cout << s.substr(p[max_lcp_index], max_lcp) << endl;\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 8,
            "mean_time_taken": 0.13879230618476868,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 82,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Repetitions",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint longestRepetition(const string& dna) {\n    int max_length = 0;\n    int current_length = 0;\n    char previous_char = '\\0';\n\n    for (char c : dna) {\n        if (c == previous_char) {\n            current_length++;\n        } else {\n            max_length = max(max_length, current_length);\n            current_length = 1;\n            previous_char = c;\n        }\n    }\n\n    // Check one last time in case the longest repetition was at the end\n    max_length = max(max_length, current_length);\n\n    return max_length;\n}\n\nint main() {\n    string dna;\n    cin >> dna;\n\n    int result = longestRepetition(dna);\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.09330612421035767,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 83,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Required Substring",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countStrings(int n, const string& pattern) {\n    int m = pattern.length();\n    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\n    \n    // Base case\n    dp[0][0] = 1;\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= m; j++) {\n            // Case 1: Add a character that doesn't extend the match\n            if (j > 0) {\n                dp[i][j] = (26LL * dp[i-1][j] - dp[i-1][j-1] + MOD) % MOD;\n            } else {\n                dp[i][j] = (26LL * dp[i-1][j]) % MOD;\n            }\n            \n            // Case 2: Add a character that extends the match\n            if (j < m && i > 1) {\n                dp[i][j+1] = (dp[i][j+1] + dp[i-1][j]) % MOD;\n            }\n        }\n    }\n    \n    return dp[n][m];\n}\n\nint main() {\n    int n;\n    string pattern;\n    cin >> n >> pattern;\n    \n    cout << countStrings(n, pattern) << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 19,
            "mean_time_taken": 0.08523353777433697,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 83,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Restaurant Customers",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> arrival(n);\n    vector<int> departure(n);\n\n    for (int i = 0; i < n; i++) {\n        cin >> arrival[i] >> departure[i];\n    }\n\n    sort(arrival.begin(), arrival.end());\n    sort(departure.begin(), departure.end());\n\n    int current_customers = 0;\n    int max_customers = 0;\n    int arrival_index = 0;\n    int departure_index = 0;\n\n    while (arrival_index < n && departure_index < n) {\n        if (arrival[arrival_index] < departure[departure_index]) {\n            current_customers++;\n            max_customers = max(max_customers, current_customers);\n            arrival_index++;\n        } else {\n            current_customers--;\n            departure_index++;\n        }\n    }\n\n    cout << max_customers << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.1348857879638672,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 84,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Reversal Sorting",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    \n    vector<pair<int, int>> reversals;\n    \n    for (int i = 0; i < n; i++) {\n        if (arr[i] != i + 1) {\n            int pos = find(arr.begin() + i, arr.end(), i + 1) - arr.begin();\n            reverse(arr.begin() + i, arr.begin() + pos + 1);\n            reversals.push_back({i + 1, pos + 1});\n        }\n    }\n    \n    cout << reversals.size() << endl;\n    for (const auto& reversal : reversals) {\n        cout << reversal.first << \" \" << reversal.second << endl;\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 12,
            "mean_time_taken": 0.24919472138086954,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 84,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Reversals and Sums",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct Node {\n    long long sum;\n    bool lazy;\n    Node *left, *right;\n    Node(long long val) : sum(val), lazy(false), left(nullptr), right(nullptr) {}\n};\n\nclass SegmentTree {\nprivate:\n    Node* root;\n    int n;\n\n    Node* build(vector<int>& arr, int l, int r) {\n        if (l == r) return new Node(arr[l]);\n        int mid = (l + r) / 2;\n        Node* node = new Node(0);\n        node->left = build(arr, l, mid);\n        node->right = build(arr, mid + 1, r);\n        node->sum = node->left->sum + node->right->sum;\n        return node;\n    }\n\n    void push(Node* node, int l, int r) {\n        if (node->lazy) {\n            node->sum = (long long)(r - l + 1) * (node->sum) - node->sum;\n            if (l != r) {\n                node->left->lazy = !node->left->lazy;\n                node->right->lazy = !node->right->lazy;\n            }\n            node->lazy = false;\n        }\n    }\n\n    void reverse(Node* node, int l, int r, int ql, int qr) {\n        push(node, l, r);\n        if (ql > r || qr < l) return;\n        if (ql <= l && r <= qr) {\n            node->lazy = !node->lazy;\n            push(node, l, r);\n            return;\n        }\n        int mid = (l + r) / 2;\n        reverse(node->left, l, mid, ql, qr);\n        reverse(node->right, mid + 1, r, ql, qr);\n        node->sum = node->left->sum + node->right->sum;\n    }\n\n    long long query(Node* node, int l, int r, int ql, int qr) {\n        if (ql > r || qr < l) return 0;\n        push(node, l, r);\n        if (ql <= l && r <= qr) return node->sum;\n        int mid = (l + r) / 2;\n        return query(node->left, l, mid, ql, qr) + query(node->right, mid + 1, r, ql, qr);\n    }\n\npublic:\n    SegmentTree(vector<int>& arr) : n(arr.size()) {\n        root = build(arr, 0, n - 1);\n    }\n\n    void reverse(int l, int r) {\n        reverse(root, 0, n - 1, l, r);\n    }\n\n    long long query(int l, int r) {\n        return query(root, 0, n - 1, l, r);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    SegmentTree st(arr);\n\n    while (m--) {\n        int t, a, b;\n        cin >> t >> a >> b;\n        a--; b--; // Convert to 0-based indexing\n\n        if (t == 1) {\n            st.reverse(a, b);\n        } else {\n            cout << st.query(a, b) << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.13344049453735352,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 84,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Road Construction",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass DSU {\n    vector<int> parent, rank, size;\n    int components, largest;\n\npublic:\n    DSU(int n) : parent(n+1), rank(n+1, 0), size(n+1, 1), components(n), largest(1) {\n        for (int i = 1; i <= n; i++) parent[i] = i;\n    }\n\n    int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x != y) {\n            components--;\n            if (rank[x] < rank[y]) swap(x, y);\n            parent[y] = x;\n            size[x] += size[y];\n            largest = max(largest, size[x]);\n            if (rank[x] == rank[y]) rank[x]++;\n        }\n    }\n\n    pair<int, int> get_state() {\n        return {components, largest};\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n    cin >> n >> m;\n\n    DSU dsu(n);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        dsu.unite(a, b);\n        auto [components, largest] = dsu.get_state();\n        cout << components << \" \" << largest << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 8,
            "mean_time_taken": 0.09642517566680908,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 85,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Road Reparation",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Edge {\n    int a, b, cost;\n};\n\nclass DSU {\n    vector<int> parent, rank;\npublic:\n    DSU(int n) : parent(n), rank(n, 0) {\n        for (int i = 0; i < n; i++) parent[i] = i;\n    }\n    \n    int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    \n    void unite(int x, int y) {\n        x = find(x), y = find(y);\n        if (x == y) return;\n        if (rank[x] < rank[y]) swap(x, y);\n        parent[y] = x;\n        if (rank[x] == rank[y]) rank[x]++;\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<Edge> edges(m);\n    for (int i = 0; i < m; i++) {\n        cin >> edges[i].a >> edges[i].b >> edges[i].cost;\n        edges[i].a--; edges[i].b--;  // 0-based indexing\n    }\n    \n    sort(edges.begin(), edges.end(), [](const Edge& e1, const Edge& e2) {\n        return e1.cost < e2.cost;\n    });\n    \n    DSU dsu(n);\n    long long total_cost = 0;\n    int edges_used = 0;\n    \n    for (const Edge& e : edges) {\n        if (dsu.find(e.a) != dsu.find(e.b)) {\n            dsu.unite(e.a, e.b);\n            total_cost += e.cost;\n            edges_used++;\n        }\n    }\n    \n    if (edges_used == n - 1) {\n        cout << total_cost << endl;\n    } else {\n        cout << \"IMPOSSIBLE\" << endl;\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 16,
            "total_test_cases": 16,
            "mean_time_taken": 0.13772426545619965,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 86,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Robot Path",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <set>\n#include <utility>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    set<pair<int, int>> visited;\n    int x = 0, y = 0;\n    long long total_distance = 0;\n    visited.insert({x, y});\n\n    for (int i = 0; i < n; ++i) {\n        char direction;\n        int distance;\n        cin >> direction >> distance;\n\n        int dx = 0, dy = 0;\n        switch (direction) {\n            case 'U': dy = 1; break;\n            case 'D': dy = -1; break;\n            case 'L': dx = -1; break;\n            case 'R': dx = 1; break;\n        }\n\n        for (int j = 0; j < distance; ++j) {\n            x += dx;\n            y += dy;\n            total_distance++;\n\n            if (visited.count({x, y})) {\n                cout << total_distance << endl;\n                return 0;\n            }\n            visited.insert({x, y});\n        }\n    }\n\n    cout << total_distance << endl;\n    return 0;\n}\n",
            "passed_test_cases": 21,
            "total_test_cases": 35,
            "mean_time_taken": 0.3932364055088588,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                6,
                7,
                8,
                10,
                18,
                23,
                26,
                28,
                29,
                30,
                33,
                35
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 86,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Room Allocation",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<pair<int, int>, int>> customers(n);\n    for (int i = 0; i < n; i++) {\n        int arrival, departure;\n        cin >> arrival >> departure;\n        customers[i] = {{arrival, departure}, i};\n    }\n\n    // Sort customers by arrival time\n    sort(customers.begin(), customers.end());\n\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    vector<int> room_allocation(n);\n    int rooms = 0;\n\n    for (const auto& customer : customers) {\n        int arrival = customer.first.first;\n        int departure = customer.first.second;\n        int index = customer.second;\n\n        if (!pq.empty() && pq.top().first < arrival) {\n            int room = pq.top().second;\n            pq.pop();\n            pq.push({departure, room});\n            room_allocation[index] = room;\n        } else {\n            rooms++;\n            pq.push({departure, rooms});\n            room_allocation[index] = rooms;\n        }\n    }\n\n    cout << rooms << endl;\n    for (int room : room_allocation) {\n        cout << room << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 12,
            "mean_time_taken": 0.20626294612884521,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 86,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Round Trip",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 100005;\n\nvector<int> adj[MAX_N];\nvector<bool> visited(MAX_N, false);\nvector<int> parent(MAX_N, -1);\nvector<int> cycle;\n\nbool dfs(int v, int p) {\n    visited[v] = true;\n    parent[v] = p;\n\n    for (int u : adj[v]) {\n        if (u == p) continue;\n        if (visited[u]) {\n            // Found a cycle\n            int cur = v;\n            cycle.push_back(u);\n            while (cur != u) {\n                cycle.push_back(cur);\n                cur = parent[cur];\n            }\n            cycle.push_back(u);\n            return true;\n        }\n        if (dfs(u, v)) return true;\n    }\n    return false;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    bool found_cycle = false;\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            if (dfs(i, -1)) {\n                found_cycle = true;\n                break;\n            }\n        }\n    }\n\n    if (found_cycle) {\n        cout << cycle.size() << endl;\n        for (int v : cycle) {\n            cout << v << \" \";\n        }\n        cout << endl;\n    } else {\n        cout << \"IMPOSSIBLE\" << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 11,
            "total_test_cases": 26,
            "mean_time_taken": 0.12280080868647648,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                8,
                9,
                11,
                13,
                16,
                17,
                18,
                20,
                21,
                23,
                26
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 86,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Round Trip II",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nconst int MAXN = 100005;\n\nvector<int> adj[MAXN];\nint state[MAXN];\nint parent[MAXN];\nint cycle_start, cycle_end;\n\nbool dfs(int v) {\n    state[v] = 1;\n    for (int u : adj[v]) {\n        if (state[u] == 0) {\n            parent[u] = v;\n            if (dfs(u))\n                return true;\n        } else if (state[u] == 1) {\n            cycle_end = v;\n            cycle_start = u;\n            return true;\n        }\n    }\n    state[v] = 2;\n    return false;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n\n    for (int i = 1; i <= n; i++) {\n        if (state[i] == 0 && dfs(i))\n            break;\n    }\n\n    if (cycle_start == 0) {\n        cout << \"IMPOSSIBLE\" << endl;\n    } else {\n        vector<int> cycle;\n        cycle.push_back(cycle_start);\n        for (int v = cycle_end; v != cycle_start; v = parent[v])\n            cycle.push_back(v);\n        cycle.push_back(cycle_start);\n\n        cout << cycle.size() << endl;\n        for (int i = cycle.size() - 1; i >= 0; i--)\n            cout << cycle[i] << \" \";\n        cout << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 20,
            "total_test_cases": 20,
            "mean_time_taken": 0.10926872491836548,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 87,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Salary Queries",
            "category": "Range Queries",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nconst int MAX_N = 2e5 + 5;\n\nint n, q;\nvector<int> salaries(MAX_N);\nvector<int> compressed;\nvector<int> tree(MAX_N);\nvector<int> count_tree(MAX_N);\n\nvoid update(vector<int>& t, int idx, int val) {\n    while (idx < MAX_N) {\n        t[idx] += val;\n        idx += idx & -idx;\n    }\n}\n\nint query(vector<int>& t, int idx) {\n    int sum = 0;\n    while (idx > 0) {\n        sum += t[idx];\n        idx -= idx & -idx;\n    }\n    return sum;\n}\n\nint get_compressed(int x) {\n    return lower_bound(compressed.begin(), compressed.end(), x) - compressed.begin() + 1;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n >> q;\n    \n    for (int i = 1; i <= n; i++) {\n        cin >> salaries[i];\n        compressed.push_back(salaries[i]);\n    }\n\n    sort(compressed.begin(), compressed.end());\n    compressed.erase(unique(compressed.begin(), compressed.end()), compressed.end());\n\n    for (int i = 1; i <= n; i++) {\n        int idx = get_compressed(salaries[i]);\n        update(tree, idx, 1);\n        update(count_tree, i, idx);\n    }\n\n    while (q--) {\n        char type;\n        cin >> type;\n        if (type == '!') {\n            int k, x;\n            cin >> k >> x;\n            int old_idx = query(count_tree, k) - query(count_tree, k-1);\n            int new_idx = get_compressed(x);\n            update(tree, old_idx, -1);\n            update(tree, new_idx, 1);\n            update(count_tree, k, new_idx - old_idx);\n        } else {\n            int a, b;\n            cin >> a >> b;\n            int idx_a = get_compressed(a);\n            int idx_b = get_compressed(b);\n            cout << query(tree, idx_b) - query(tree, idx_a - 1) << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 13,
            "mean_time_taken": 0.1966858643751878,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 87,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "School Dance",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst int MAX_N = 505;\n\nvector<int> graph[MAX_N];\nint match[MAX_N];\nbool visited[MAX_N];\n\nbool dfs(int u) {\n    for (int v : graph[u]) {\n        if (visited[v]) continue;\n        visited[v] = true;\n        if (match[v] == -1 || dfs(match[v])) {\n            match[v] = u;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    for (int i = 0; i < k; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n    }\n\n    fill(match, match + MAX_N, -1);\n\n    int max_pairs = 0;\n    for (int i = 1; i <= n; i++) {\n        fill(visited, visited + MAX_N, false);\n        if (dfs(i)) max_pairs++;\n    }\n\n    cout << max_pairs << endl;\n\n    for (int i = 1; i <= m; i++) {\n        if (match[i] != -1) {\n            cout << match[i] << \" \" << i << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 15,
            "mean_time_taken": 0.08315656979878744,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                8,
                9,
                11,
                12,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 87,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "School Excursion",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <bitset>\n\nconst int MAX_N = 100005;\n\nclass DSU {\n    std::vector<int> parent, rank, size;\npublic:\n    DSU(int n) : parent(n), rank(n, 0), size(n, 1) {\n        for (int i = 0; i < n; i++) parent[i] = i;\n    }\n    \n    int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    \n    void unite(int x, int y) {\n        x = find(x), y = find(y);\n        if (x == y) return;\n        if (rank[x] < rank[y]) std::swap(x, y);\n        parent[y] = x;\n        size[x] += size[y];\n        if (rank[x] == rank[y]) rank[x]++;\n    }\n    \n    int get_size(int x) {\n        return size[find(x)];\n    }\n};\n\nint main() {\n    int n, m;\n    std::cin >> n >> m;\n    \n    DSU dsu(n);\n    \n    for (int i = 0; i < m; i++) {\n        int a, b;\n        std::cin >> a >> b;\n        dsu.unite(a-1, b-1);  // 0-indexed\n    }\n    \n    std::vector<int> group_sizes;\n    std::vector<bool> visited(n, false);\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            int size = dsu.get_size(i);\n            group_sizes.push_back(size);\n            visited[i] = true;\n        }\n    }\n    \n    std::bitset<MAX_N> dp;\n    dp[0] = 1;  // 0 children is always possible\n    \n    for (int size : group_sizes) {\n        dp |= (dp << size);\n    }\n    \n    // Output the result (1-indexed)\n    for (int i = 1; i <= n; i++) {\n        std::cout << dp[i];\n    }\n    std::cout << std::endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 13,
            "mean_time_taken": 0.31172970625070423,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 87,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Shortest Routes I",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> pli;\n\nconst int MAX_N = 1e5 + 5;\n\nvector<pli> graph[MAX_N];\nll dist[MAX_N];\n\nvoid dijkstra(int start, int n) {\n    for (int i = 1; i <= n; i++) {\n        dist[i] = LLONG_MAX;\n    }\n    dist[start] = 0;\n\n    priority_queue<pli, vector<pli>, greater<pli>> pq;\n    pq.push({0, start});\n\n    while (!pq.empty()) {\n        int u = pq.top().second;\n        ll d = pq.top().first;\n        pq.pop();\n\n        if (d > dist[u]) continue;\n\n        for (auto &edge : graph[u]) {\n            int v = edge.second;\n            ll w = edge.first;\n\n            if (dist[u] + w < dist[v]) {\n                dist[v] = dist[u] + w;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        graph[a].push_back({c, b});\n    }\n\n    dijkstra(1, n);\n\n    for (int i = 1; i <= n; i++) {\n        cout << dist[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 23,
            "total_test_cases": 23,
            "mean_time_taken": 0.15459900316984757,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 88,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Shortest Routes II",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst long long INF = 1e18;\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n\n    vector<vector<long long>> dist(n + 1, vector<long long>(n + 1, INF));\n\n    // Initialize diagonal elements to 0\n    for (int i = 1; i <= n; i++) {\n        dist[i][i] = 0;\n    }\n\n    // Read roads\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        long long c;\n        cin >> a >> b >> c;\n        dist[a][b] = min(dist[a][b], c);\n        dist[b][a] = min(dist[b][a], c);  // Undirected graph\n    }\n\n    // Floyd-Warshall algorithm\n    for (int k = 1; k <= n; k++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (dist[i][k] < INF && dist[k][j] < INF) {\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n    }\n\n    // Process queries\n    for (int i = 0; i < q; i++) {\n        int a, b;\n        cin >> a >> b;\n        if (dist[a][b] == INF) {\n            cout << -1 << endl;\n        } else {\n            cout << dist[a][b] << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 11,
            "total_test_cases": 15,
            "mean_time_taken": 0.617851988474528,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                7,
                13,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 88,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Shortest Subsequence",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring shortestNonSubsequence(const string& dna) {\n    int count[4] = {0}; // Count for A, C, G, T\n    \n    // Count occurrences of each character\n    for (char c : dna) {\n        switch (c) {\n            case 'A': count[0]++; break;\n            case 'C': count[1]++; break;\n            case 'G': count[2]++; break;\n            case 'T': count[3]++; break;\n        }\n    }\n    \n    // Find the character with minimum count\n    int minCount = *min_element(count, count + 4);\n    \n    // If any character is missing, return it\n    if (minCount == 0) {\n        if (count[0] == 0) return \"A\";\n        if (count[1] == 0) return \"C\";\n        if (count[2] == 0) return \"G\";\n        if (count[3] == 0) return \"T\";\n    }\n    \n    // Otherwise, repeat the least frequent character three times\n    char leastFrequent;\n    if (count[0] == minCount) leastFrequent = 'A';\n    else if (count[1] == minCount) leastFrequent = 'C';\n    else if (count[2] == minCount) leastFrequent = 'G';\n    else leastFrequent = 'T';\n    \n    return string(3, leastFrequent);\n}\n\nint main() {\n    string dna;\n    cin >> dna;\n    cout << shortestNonSubsequence(dna) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.09415233135223389,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 88,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Signal Processing",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<long long> process_signal(const vector<int>& signal, const vector<int>& mask) {\n    int n = signal.size();\n    int m = mask.size();\n    vector<long long> result(n + m - 1, 0);\n\n    for (int i = 0; i < n + m - 1; ++i) {\n        int start = max(0, i - m + 1);\n        int end = min(i + 1, n);\n        for (int j = start; j < end; ++j) {\n            result[i] += static_cast<long long>(signal[j]) * mask[i - j];\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> signal(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> signal[i];\n    }\n\n    vector<int> mask(m);\n    for (int i = 0; i < m; ++i) {\n        cin >> mask[i];\n    }\n\n    vector<long long> result = process_signal(signal, mask);\n\n    for (int i = 0; i < n + m - 1; ++i) {\n        cout << result[i] << (i < n + m - 2 ? \" \" : \"\\n\");\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.7198992172876993,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 88,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sliding Window Cost",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    multiset<int> window;\n    ll left_sum = 0, right_sum = 0;\n    \n    // Initialize the first window\n    for (int i = 0; i < k; i++) {\n        window.insert(arr[i]);\n    }\n\n    auto mid = next(window.begin(), (k - 1) / 2);\n    for (auto it = window.begin(); it != mid; ++it) {\n        left_sum += *it;\n    }\n    for (auto it = mid; it != window.end(); ++it) {\n        right_sum += *it;\n    }\n\n    // Calculate and output cost for each window\n    for (int i = 0; i <= n - k; i++) {\n        int median = *mid;\n        ll cost = right_sum - left_sum - (ll)median * (k / 2) + (ll)median * ((k + 1) / 2);\n        cout << cost << \" \";\n\n        if (i == n - k) break;\n\n        // Remove leftmost element\n        if (arr[i] <= *mid) {\n            left_sum -= arr[i];\n        } else {\n            right_sum -= arr[i];\n        }\n        window.erase(window.find(arr[i]));\n\n        // Add new element\n        window.insert(arr[i + k]);\n        if (arr[i + k] <= *mid) {\n            left_sum += arr[i + k];\n        } else {\n            right_sum += arr[i + k];\n        }\n\n        // Adjust median if necessary\n        if (arr[i] <= *mid && arr[i + k] > *mid) {\n            ++mid;\n            left_sum += *prev(mid);\n            right_sum -= *mid;\n        } else if (arr[i] > *mid && arr[i + k] <= *mid) {\n            --mid;\n            left_sum -= *mid;\n            right_sum += *next(mid);\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 34,
            "mean_time_taken": 0.1274403964771944,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                33,
                34
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 88,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sliding Window Median",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nclass MedianFinder {\nprivate:\n    multiset<int> lower, upper;\n\n    void balance() {\n        while (lower.size() > upper.size()) {\n            upper.insert(*lower.rbegin());\n            lower.erase(prev(lower.end()));\n        }\n        while (upper.size() > lower.size()) {\n            lower.insert(*upper.begin());\n            upper.erase(upper.begin());\n        }\n    }\n\npublic:\n    void add(int num) {\n        if (lower.empty() || num < *lower.rbegin()) {\n            lower.insert(num);\n        } else {\n            upper.insert(num);\n        }\n        balance();\n    }\n\n    void remove(int num) {\n        if (num <= *lower.rbegin()) {\n            lower.erase(lower.find(num));\n        } else {\n            upper.erase(upper.find(num));\n        }\n        balance();\n    }\n\n    int getMedian() {\n        return *lower.rbegin();\n    }\n};\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> nums(n);\n    for (int i = 0; i < n; i++) {\n        cin >> nums[i];\n    }\n\n    MedianFinder mf;\n    vector<int> medians;\n\n    // Process first k elements\n    for (int i = 0; i < k; i++) {\n        mf.add(nums[i]);\n    }\n    medians.push_back(mf.getMedian());\n\n    // Process remaining windows\n    for (int i = k; i < n; i++) {\n        mf.remove(nums[i - k]);\n        mf.add(nums[i]);\n        medians.push_back(mf.getMedian());\n    }\n\n    // Output medians\n    for (int median : medians) {\n        cout << median << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 40,
            "total_test_cases": 40,
            "mean_time_taken": 0.1586923658847809,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 89,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Sorting Methods",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nlong long countInversions(vector<int>& arr) {\n    long long inversions = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        for (int j = i + 1; j < arr.size(); j++) {\n            if (arr[i] > arr[j]) inversions++;\n        }\n    }\n    return inversions;\n}\n\nint countSwaps(vector<int>& arr) {\n    int swaps = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        swaps += arr[i] - (i + 1);\n    }\n    return swaps / 2;\n}\n\nint countMoves(vector<int>& arr) {\n    int moves = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] != i + 1) moves++;\n    }\n    return moves;\n}\n\nint countMovesToFront(vector<int>& arr) {\n    int moves = 0;\n    vector<int> sorted = arr;\n    sort(sorted.begin(), sorted.end());\n    int j = arr.size() - 1;\n    for (int i = arr.size() - 1; i >= 0; i--) {\n        if (arr[i] == sorted[j]) {\n            j--;\n        } else {\n            moves++;\n        }\n    }\n    return moves;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    cout << countInversions(arr) << \" \"\n         << countSwaps(arr) << \" \"\n         << countMoves(arr) << \" \"\n         << countMovesToFront(arr) << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 10,
            "mean_time_taken": 0.5610653400421143,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 89,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Special Substrings",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\nusing namespace std;\n\nlong long countSpecialSubstrings(const string& s) {\n    int n = s.length();\n    long long count = 0;\n    int left = 0;\n    vector<int> freq(26, 0);\n    set<int> uniqueFreq;\n\n    for (int right = 0; right < n; ++right) {\n        freq[s[right] - 'a']++;\n        uniqueFreq.insert(freq[s[right] - 'a']);\n\n        while (uniqueFreq.size() > 1) {\n            freq[s[left] - 'a']--;\n            if (freq[s[left] - 'a'] == 0) {\n                uniqueFreq.erase(0);\n            } else {\n                uniqueFreq.insert(freq[s[left] - 'a']);\n            }\n            if (uniqueFreq.find(freq[s[left] - 'a'] + 1) != uniqueFreq.end()) {\n                uniqueFreq.erase(freq[s[left] - 'a'] + 1);\n            }\n            left++;\n        }\n\n        count += right - left + 1;\n    }\n\n    return count;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    cout << countSpecialSubstrings(s) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 8,
            "mean_time_taken": 0.15254193544387817,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 89,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Stack Weights",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<int, int>> moves(n);\n    for (int i = 0; i < n; i++) {\n        cin >> moves[i].first >> moves[i].second;\n    }\n\n    int left_max = 0, right_max = 0;\n\n    for (const auto& move : moves) {\n        int coin = move.first;\n        int stack = move.second;\n\n        if (stack == 1) {\n            left_max = max(left_max, coin);\n        } else {\n            right_max = max(right_max, coin);\n        }\n\n        if (left_max > right_max) {\n            cout << \">\" << endl;\n        } else if (right_max > left_max) {\n            cout << \"<\" << endl;\n        } else {\n            cout << \"?\" << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 5,
            "mean_time_taken": 0.2083888053894043,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 89,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Stair Game",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid solve_test_case() {\n    int n;\n    cin >> n;\n    \n    vector<int> balls(n);\n    for (int i = 0; i < n; i++) {\n        cin >> balls[i];\n    }\n    \n    int xor_sum = 0;\n    for (int i = 1; i < n; i += 2) {\n        xor_sum ^= balls[i];\n    }\n    \n    if (xor_sum != 0) {\n        cout << \"first\" << endl;\n    } else {\n        cout << \"second\" << endl;\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        solve_test_case();\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 7,
            "mean_time_taken": 0.09674583162580218,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 90,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Static Range Minimum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\nclass SegmentTree {\nprivate:\n    vector<int> tree;\n    int n;\n\n    void build(vector<int>& arr, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = arr[start];\n            return;\n        }\n        int mid = (start + end) / 2;\n        build(arr, 2 * node, start, mid);\n        build(arr, 2 * node + 1, mid + 1, end);\n        tree[node] = min(tree[2 * node], tree[2 * node + 1]);\n    }\n\n    int query(int node, int start, int end, int l, int r) {\n        if (r < start || end < l) return INT_MAX;\n        if (l <= start && end <= r) return tree[node];\n        int mid = (start + end) / 2;\n        return min(query(2 * node, start, mid, l, r),\n                   query(2 * node + 1, mid + 1, end, l, r));\n    }\n\npublic:\n    SegmentTree(vector<int>& arr) {\n        n = arr.size();\n        tree.resize(4 * n);\n        build(arr, 1, 0, n - 1);\n    }\n\n    int rangeMinQuery(int l, int r) {\n        return query(1, 0, n - 1, l - 1, r - 1);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    SegmentTree segTree(arr);\n\n    while (q--) {\n        int a, b;\n        cin >> a >> b;\n        cout << segTree.rangeMinQuery(a, b) << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 4,
            "mean_time_taken": 0.12327975034713745,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 91,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Static Range Sum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n\n    vector<long long> prefix_sum(n + 1, 0);\n    for (int i = 1; i <= n; i++) {\n        int x;\n        cin >> x;\n        prefix_sum[i] = prefix_sum[i-1] + x;\n    }\n\n    while (q--) {\n        int a, b;\n        cin >> a >> b;\n        long long sum = prefix_sum[b] - (a > 1 ? prefix_sum[a-1] : 0);\n        cout << sum << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 2,
            "mean_time_taken": 0.10632085800170898,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 92,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Stick Divisions",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    long long x, n;\n    cin >> x >> n;\n\n    priority_queue<long long, vector<long long>, greater<long long>> pq;\n\n    // Read stick lengths and push them into the priority queue\n    for (int i = 0; i < n; i++) {\n        long long length;\n        cin >> length;\n        pq.push(length);\n    }\n\n    long long total_cost = 0;\n\n    // Combine sticks until only one remains\n    while (pq.size() > 1) {\n        long long first = pq.top();\n        pq.pop();\n        long long second = pq.top();\n        pq.pop();\n\n        long long combined = first + second;\n        total_cost += combined;\n        pq.push(combined);\n    }\n\n    cout << total_cost << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 6,
            "mean_time_taken": 0.18370795249938965,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 93,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Stick Game",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    \n    vector<int> moves(k);\n    for (int i = 0; i < k; i++) {\n        cin >> moves[i];\n    }\n    \n    vector<bool> dp(n + 1, false);\n    string result(n, 'L');\n    \n    for (int i = 1; i <= n; i++) {\n        for (int move : moves) {\n            if (i - move >= 0 && !dp[i - move]) {\n                dp[i] = true;\n                result[i - 1] = 'W';\n                break;\n            }\n        }\n    }\n    \n    cout << result << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 6,
            "mean_time_taken": 0.31404678026835126,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 93,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Stick Lengths",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<long long> sticks(n);\n    for (int i = 0; i < n; i++) {\n        cin >> sticks[i];\n    }\n    \n    sort(sticks.begin(), sticks.end());\n    \n    long long median = sticks[n / 2];\n    long long total_cost = 0;\n    \n    for (int i = 0; i < n; i++) {\n        total_cost += abs(sticks[i] - median);\n    }\n    \n    cout << total_cost << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.10176855867559259,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 94,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "String Functions",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> z_function(const string& s) {\n    int n = s.length();\n    vector<int> z(n);\n    int l = 0, r = 0;\n    for (int i = 1; i < n; i++) {\n        if (i <= r)\n            z[i] = min(r - i + 1, z[i - l]);\n        while (i + z[i] < n && s[z[i]] == s[i + z[i]])\n            z[i]++;\n        if (i + z[i] - 1 > r) {\n            l = i;\n            r = i + z[i] - 1;\n        }\n    }\n    return z;\n}\n\nvector<int> pi_function(const string& s) {\n    int n = s.length();\n    vector<int> pi(n);\n    for (int i = 1; i < n; i++) {\n        int j = pi[i - 1];\n        while (j > 0 && s[i] != s[j])\n            j = pi[j - 1];\n        if (s[i] == s[j])\n            j++;\n        pi[i] = j;\n    }\n    return pi;\n}\n\nint main() {\n    string s;\n    cin >> s;\n\n    vector<int> z = z_function(s);\n    vector<int> pi = pi_function(s);\n\n    // Print z function values\n    for (int i = 0; i < s.length(); i++) {\n        cout << z[i] << \" \";\n    }\n    cout << endl;\n\n    // Print pi function values\n    for (int i = 0; i < s.length(); i++) {\n        cout << pi[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 5,
            "mean_time_taken": 0.21351156234741211,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 95,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "String Matching",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> computeLPS(const string& pattern) {\n    int m = pattern.length();\n    vector<int> lps(m, 0);\n    int len = 0;\n    int i = 1;\n\n    while (i < m) {\n        if (pattern[i] == pattern[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        } else {\n            if (len != 0) {\n                len = lps[len - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    return lps;\n}\n\nint KMPSearch(const string& text, const string& pattern) {\n    int n = text.length();\n    int m = pattern.length();\n    vector<int> lps = computeLPS(pattern);\n\n    int i = 0, j = 0;\n    int count = 0;\n\n    while (i < n) {\n        if (pattern[j] == text[i]) {\n            i++;\n            j++;\n        }\n\n        if (j == m) {\n            count++;\n            j = lps[j - 1];\n        } else if (i < n && pattern[j] != text[i]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    string text, pattern;\n    getline(cin, text);\n    getline(cin, pattern);\n\n    int result = KMPSearch(text, pattern);\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 37,
            "total_test_cases": 37,
            "mean_time_taken": 0.08232342874681628,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 96,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "String Removals",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countStrings(string s) {\n    int n = s.length();\n    vector<int> dp(n + 1, 0);\n    vector<int> last(26, -1);  // To store the last position of each character\n\n    dp[0] = 1;  // Empty string\n\n    for (int i = 1; i <= n; i++) {\n        dp[i] = (2 * dp[i-1]) % MOD;  // Double the previous count\n\n        if (last[s[i-1] - 'a'] != -1) {\n            int j = last[s[i-1] - 'a'];\n            dp[i] = (dp[i] - dp[j] + MOD) % MOD;  // Subtract to avoid duplicates\n        }\n\n        last[s[i-1] - 'a'] = i - 1;\n    }\n\n    return dp[n];\n}\n\nint main() {\n    string s;\n    cin >> s;\n    cout << countStrings(s) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 7,
            "mean_time_taken": 0.08881524630955287,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 96,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "String Reorder",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstring reorderString(const string& s) {\n    vector<int> freq(26, 0);\n    for (char c : s) {\n        freq[c - 'A']++;\n    }\n\n    int maxFreq = *max_element(freq.begin(), freq.end());\n    if (maxFreq > (s.length() + 1) / 2) {\n        return \"-1\";\n    }\n\n    vector<pair<int, char>> chars;\n    for (int i = 0; i < 26; i++) {\n        if (freq[i] > 0) {\n            chars.emplace_back(-freq[i], 'A' + i);\n        }\n    }\n    sort(chars.begin(), chars.end());\n\n    string result(s.length(), ' ');\n    int index = 0;\n    for (const auto& [f, c] : chars) {\n        for (int i = 0; i < -f; i++) {\n            if (index >= s.length()) {\n                index = 1;\n            }\n            result[index] = c;\n            index += 2;\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    cout << reorderString(s) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 9,
            "total_test_cases": 15,
            "mean_time_taken": 0.0886706034342448,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                7,
                13,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 96,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "String Transform",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring rotateRight(string s, int k) {\n    k %= s.length();\n    reverse(s.begin(), s.end());\n    reverse(s.begin(), s.begin() + k);\n    reverse(s.begin() + k, s.end());\n    return s;\n}\n\nint main() {\n    string transformed;\n    cin >> transformed;\n\n    int n = transformed.length() - 1;  // length of original string\n    int k = transformed.find('#');     // position of #\n\n    string original = transformed.substr(0, k) + transformed.substr(k + 1);\n    original = rotateRight(original, k);\n\n    cout << original << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 6,
            "mean_time_taken": 0.10199364026387532,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 96,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Strongly Connected Edges",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 1e5 + 5;\n\nvector<int> adj[MAX_N];\nbool visited[MAX_N];\nint parent[MAX_N];\nvector<pair<int, int>> directed_edges;\n\nvoid dfs(int v) {\n    visited[v] = true;\n    for (int u : adj[v]) {\n        if (!visited[u]) {\n            parent[u] = v;\n            directed_edges.push_back({v, u});\n            dfs(u);\n        } else if (u != parent[v] && u < v) {\n            directed_edges.push_back({u, v});\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    if (m == 0 && n > 1) {\n        cout << \"IMPOSSIBLE\" << endl;\n        return 0;\n    }\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    dfs(1);\n\n    if (count(visited + 1, visited + n + 1, true) != n) {\n        cout << \"IMPOSSIBLE\" << endl;\n        return 0;\n    }\n\n    for (auto [a, b] : directed_edges) {\n        cout << a << \" \" << b << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 11,
            "mean_time_taken": 0.129218881780451,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 96,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Distinct Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nlong long countSubarrays(vector<int>& arr, int k) {\n    int n = arr.size();\n    unordered_map<int, int> freq;\n    long long count = 0;\n    int left = 0;\n\n    for (int right = 0; right < n; right++) {\n        freq[arr[right]]++;\n\n        while (freq.size() > k) {\n            freq[arr[left]]--;\n            if (freq[arr[left]] == 0) {\n                freq.erase(arr[left]);\n            }\n            left++;\n        }\n\n        count += right - left + 1;\n    }\n\n    return count;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    long long result = countSubarrays(arr, k);\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.14728913307189942,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 97,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Subarray Divisibility",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<int> freq(n, 0);\n    long long prefix_sum = 0;\n    long long count = 0;\n    \n    freq[0] = 1; // Empty subarray\n    \n    for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        prefix_sum += x;\n        \n        // Handle negative numbers\n        int remainder = (prefix_sum % n + n) % n;\n        \n        // Add number of subarrays ending at current position\n        count += freq[remainder];\n        \n        // Increment frequency of current remainder\n        freq[remainder]++;\n    }\n    \n    cout << count << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.09559330940246583,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 98,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Subarray Squares",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 3005;\nconst ll INF = 1e18;\n\nint n, k;\nll a[MAXN], sum[MAXN];\nll dp[2][MAXN];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n        sum[i] = sum[i-1] + a[i];\n    }\n\n    for (int i = 1; i <= n; i++) {\n        dp[1][i] = sum[i] * sum[i];\n    }\n\n    for (int j = 2; j <= k; j++) {\n        for (int i = j; i <= n; i++) {\n            dp[j&1][i] = INF;\n            for (int p = j-1; p < i; p++) {\n                ll cost = dp[(j-1)&1][p] + (sum[i] - sum[p]) * (sum[i] - sum[p]);\n                dp[j&1][i] = min(dp[j&1][i], cost);\n            }\n        }\n    }\n\n    cout << dp[k&1][n] << \"\\n\";\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 11,
            "mean_time_taken": 0.6177861040288751,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 98,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Sum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct Node {\n    long long sum, pref, suff, ans;\n    Node(long long val = 0) : sum(val), pref(max(0LL, val)), suff(max(0LL, val)), ans(max(0LL, val)) {}\n};\n\nclass SegmentTree {\nprivate:\n    vector<Node> tree;\n    int n;\n\n    Node combine(const Node& l, const Node& r) {\n        Node res;\n        res.sum = l.sum + r.sum;\n        res.pref = max(l.pref, l.sum + r.pref);\n        res.suff = max(r.suff, r.sum + l.suff);\n        res.ans = max({l.ans, r.ans, l.suff + r.pref});\n        return res;\n    }\n\n    void build(const vector<int>& a, int v, int tl, int tr) {\n        if (tl == tr) {\n            tree[v] = Node(a[tl]);\n            return;\n        }\n        int tm = (tl + tr) / 2;\n        build(a, v*2, tl, tm);\n        build(a, v*2+1, tm+1, tr);\n        tree[v] = combine(tree[v*2], tree[v*2+1]);\n    }\n\n    void update(int v, int tl, int tr, int pos, int new_val) {\n        if (tl == tr) {\n            tree[v] = Node(new_val);\n            return;\n        }\n        int tm = (tl + tr) / 2;\n        if (pos <= tm)\n            update(v*2, tl, tm, pos, new_val);\n        else\n            update(v*2+1, tm+1, tr, pos, new_val);\n        tree[v] = combine(tree[v*2], tree[v*2+1]);\n    }\n\npublic:\n    SegmentTree(const vector<int>& a) {\n        n = a.size();\n        tree.resize(4 * n);\n        build(a, 1, 0, n-1);\n    }\n\n    void update(int pos, int new_val) {\n        update(1, 0, n-1, pos, new_val);\n    }\n\n    long long query() {\n        return tree[1].ans;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    SegmentTree st(a);\n\n    while (m--) {\n        int k, x;\n        cin >> k >> x;\n        st.update(k-1, x);\n        cout << st.query() << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 15,
            "total_test_cases": 15,
            "mean_time_taken": 0.17349851926167806,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 99,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Subarray Sums I",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nlong long subarraySumsI(vector<int>& arr, int x) {\n    long long count = 0;\n    long long current_sum = 0;\n    unordered_map<long long, int> sum_frequency;\n    \n    sum_frequency[0] = 1;  // Initialize with 0 sum occurring once\n    \n    for (int num : arr) {\n        current_sum += num;\n        \n        if (current_sum == x) {\n            count++;\n        }\n        \n        if (sum_frequency.find(current_sum - x) != sum_frequency.end()) {\n            count += sum_frequency[current_sum - x];\n        }\n        \n        sum_frequency[current_sum]++;\n    }\n    \n    return count;\n}\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n    \n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    \n    cout << subarraySumsI(arr, x) << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 12,
            "mean_time_taken": 0.1291616161664327,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                5,
                6,
                7,
                8,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 99,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Sums II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nlong long countSubarrays(const vector<int>& arr, long long x) {\n    long long result = 0;\n    long long currentSum = 0;\n    unordered_map<long long, int> prefixSumCount;\n    prefixSumCount[0] = 1;\n\n    for (int num : arr) {\n        currentSum += num;\n        long long difference = currentSum - x;\n        \n        if (prefixSumCount.find(difference) != prefixSumCount.end()) {\n            result += prefixSumCount[difference];\n        }\n        \n        prefixSumCount[currentSum]++;\n    }\n\n    return result;\n}\n\nint main() {\n    int n;\n    long long x;\n    cin >> n >> x;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    cout << countSubarrays(arr, x) << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 27,
            "total_test_cases": 27,
            "mean_time_taken": 0.13917064666748047,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 100,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Subordinates",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\n\nvector<int> adj[MAX_N];\nint subordinates[MAX_N];\n\nint dfs(int node) {\n    int count = 0;\n    for (int child : adj[node]) {\n        count += 1 + dfs(child);\n    }\n    subordinates[node] = count;\n    return count;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    // Build the adjacency list\n    for (int i = 2; i <= n; i++) {\n        int boss;\n        cin >> boss;\n        adj[boss].push_back(i);\n    }\n\n    // Perform DFS starting from the general director (node 1)\n    dfs(1);\n\n    // Print the results\n    for (int i = 1; i <= n; i++) {\n        cout << subordinates[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 12,
            "mean_time_taken": 0.11835209528605144,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 100,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Substring Distribution",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nvector<int> countDistinctSubstrings(const string& s) {\n    int n = s.length();\n    vector<int> result(n);\n\n    for (int len = 1; len <= n; ++len) {\n        unordered_set<string> distinct;\n        for (int i = 0; i <= n - len; ++i) {\n            distinct.insert(s.substr(i, len));\n        }\n        result[len - 1] = distinct.size();\n    }\n\n    return result;\n}\n\nint main() {\n    string s;\n    cin >> s;\n\n    vector<int> counts = countDistinctSubstrings(s);\n\n    for (int count : counts) {\n        cout << count << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 9,
            "mean_time_taken": 0.8264738983578153,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 100,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Substring Order I",
            "category": "String Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 100,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Substring Order II",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\n// Custom comparator for suffixes\nstruct SuffixComparator {\n    const string& s;\n    SuffixComparator(const string& str) : s(str) {}\n    bool operator()(int i, int j) const {\n        return s.substr(i) < s.substr(j);\n    }\n};\n\nint main() {\n    string s;\n    long long k;\n    cin >> s >> k;\n    \n    int n = s.length();\n    \n    // Generate suffix array\n    vector<int> suffixes(n);\n    for (int i = 0; i < n; i++) {\n        suffixes[i] = i;\n    }\n    \n    // Sort suffixes\n    sort(suffixes.begin(), suffixes.end(), SuffixComparator(s));\n    \n    // Find kth smallest substring\n    for (int i = 0; i < n; i++) {\n        for (int len = 1; len <= n - suffixes[i]; len++) {\n            k--;\n            if (k == 0) {\n                cout << s.substr(suffixes[i], len) << endl;\n                return 0;\n            }\n        }\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 9,
            "mean_time_taken": 0.8252732223934598,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 100,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Substring Reversals",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    string s;\n    cin >> s;\n    \n    vector<int> reverse_count(n + 1, 0);\n    \n    // Process all operations\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        reverse_count[a-1]++;\n        reverse_count[b]--;\n    }\n    \n    // Calculate cumulative sum of reverse_count\n    int current_reverses = 0;\n    for (int i = 0; i < n; i++) {\n        current_reverses += reverse_count[i];\n        reverse_count[i] = current_reverses % 2;\n    }\n    \n    // Apply reversals and print the final string\n    string result = s;\n    int left = 0, right = n - 1;\n    for (int i = 0; i < n; i++) {\n        if (reverse_count[i] == 0) {\n            result[i] = s[left++];\n        } else {\n            result[i] = s[right--];\n        }\n    }\n    \n    cout << result << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.12097048759460449,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 100,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subtree Queries",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\n\nvector<int> adj[MAX_N];\nint start[MAX_N], end[MAX_N], tour[MAX_N], timer;\nlong long tree[4 * MAX_N];\nint n, q;\n\nvoid dfs(int v, int p = -1) {\n    start[v] = timer;\n    tour[timer++] = v;\n    for (int u : adj[v]) {\n        if (u != p) {\n            dfs(u, v);\n        }\n    }\n    end[v] = timer - 1;\n}\n\nvoid build(int node, int l, int r) {\n    if (l == r) {\n        tree[node] = tour[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(2 * node, l, mid);\n    build(2 * node + 1, mid + 1, r);\n    tree[node] = tree[2 * node] + tree[2 * node + 1];\n}\n\nvoid update(int node, int l, int r, int pos, int val) {\n    if (l == r) {\n        tree[node] = val;\n        return;\n    }\n    int mid = (l + r) / 2;\n    if (pos <= mid)\n        update(2 * node, l, mid, pos, val);\n    else\n        update(2 * node + 1, mid + 1, r, pos, val);\n    tree[node] = tree[2 * node] + tree[2 * node + 1];\n}\n\nlong long query(int node, int l, int r, int ql, int qr) {\n    if (ql > r || qr < l) return 0;\n    if (ql <= l && r <= qr) return tree[node];\n    int mid = (l + r) / 2;\n    return query(2 * node, l, mid, ql, qr) + query(2 * node + 1, mid + 1, r, ql, qr);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n >> q;\n    vector<int> values(n + 1);\n    for (int i = 1; i <= n; i++) {\n        cin >> values[i];\n    }\n\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    dfs(1);\n    build(1, 0, n - 1);\n\n    for (int i = 1; i <= n; i++) {\n        update(1, 0, n - 1, start[i], values[i]);\n    }\n\n    while (q--) {\n        int type;\n        cin >> type;\n        if (type == 1) {\n            int s, x;\n            cin >> s >> x;\n            update(1, 0, n - 1, start[s], x);\n        } else {\n            int s;\n            cin >> s;\n            cout << query(1, 0, n - 1, start[s], end[s]) << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 100,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Sum of Divisors",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst long long MOD = 1e9 + 7;\n\nlong long sum_of_divisors(long long n) {\n    long long result = 0;\n    long long i = 1;\n    \n    while (i <= n) {\n        long long q = n / i;\n        long long next_i = n / q + 1;\n        \n        long long count = (next_i - i) % MOD;\n        result = (result + q % MOD * ((i + next_i - 1) % MOD) % MOD * count % MOD * 500000004LL % MOD) % MOD;\n        \n        i = next_i;\n    }\n    \n    return result;\n}\n\nint main() {\n    long long n;\n    cin >> n;\n    \n    cout << sum_of_divisors(n) << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 18,
            "total_test_cases": 18,
            "mean_time_taken": 0.08789298269483778,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 101,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Sum of Four Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n    \n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    \n    vector<pair<int, pair<int, int>>> pairs;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            pairs.push_back({a[i] + a[j], {i, j}});\n        }\n    }\n    \n    sort(pairs.begin(), pairs.end());\n    \n    int left = 0, right = pairs.size() - 1;\n    while (left < right) {\n        int sum = pairs[left].first + pairs[right].first;\n        if (sum == x) {\n            int i1 = pairs[left].second.first;\n            int i2 = pairs[left].second.second;\n            int i3 = pairs[right].second.first;\n            int i4 = pairs[right].second.second;\n            \n            if (i1 != i3 && i1 != i4 && i2 != i3 && i2 != i4) {\n                cout << i1 + 1 << \" \" << i2 + 1 << \" \" << i3 + 1 << \" \" << i4 + 1 << endl;\n                return 0;\n            }\n            left++;\n        } else if (sum < x) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    \n    cout << \"IMPOSSIBLE\" << endl;\n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 28,
            "mean_time_taken": 0.16518018075398036,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                7,
                9,
                11,
                12,
                15,
                16,
                18,
                20,
                21,
                22,
                26,
                27,
                28
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 101,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sum of Three Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<pair<int, int>> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i].first;\n        arr[i].second = i + 1;  // Store original index\n    }\n\n    sort(arr.begin(), arr.end());\n\n    for (int i = 0; i < n - 2; i++) {\n        int left = i + 1;\n        int right = n - 1;\n\n        while (left < right) {\n            long long sum = (long long)arr[i].first + arr[left].first + arr[right].first;\n\n            if (sum == x) {\n                cout << arr[i].second << \" \" << arr[left].second << \" \" << arr[right].second << endl;\n                return 0;\n            } else if (sum < x) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n\n    cout << \"IMPOSSIBLE\" << endl;\n    return 0;\n}\n",
            "passed_test_cases": 27,
            "total_test_cases": 27,
            "mean_time_taken": 0.10230413189640751,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 102,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Sum of Two Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    unordered_map<int, int> complement_map;\n\n    for (int i = 0; i < n; i++) {\n        int complement = x - a[i];\n        \n        if (complement_map.find(complement) != complement_map.end()) {\n            cout << complement_map[complement] + 1 << \" \" << i + 1 << \"\\n\";\n            return 0;\n        }\n\n        complement_map[a[i]] = i;\n    }\n\n    cout << \"IMPOSSIBLE\\n\";\n\n    return 0;\n}\n",
            "passed_test_cases": 18,
            "total_test_cases": 27,
            "mean_time_taken": 0.16677833486486365,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                9,
                10,
                11,
                21,
                22,
                24,
                25
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 102,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Swap Game",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <queue>\n#include <unordered_set>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nconst string goal = \"123456789\";\nconst vector<int> adjacent = {1, -1, 3, -3};\n\nint bfs(string start) {\n    queue<pair<string, int>> q;\n    unordered_set<string> visited;\n\n    q.push({start, 0});\n    visited.insert(start);\n\n    while (!q.empty()) {\n        auto [current, moves] = q.front();\n        q.pop();\n\n        if (current == goal) return moves;\n\n        int zero = current.find('0');\n        for (int dir : adjacent) {\n            int new_pos = zero + dir;\n            if (new_pos >= 0 && new_pos < 9 && abs(zero % 3 - new_pos % 3) <= 1) {\n                string next = current;\n                swap(next[zero], next[new_pos]);\n                if (visited.find(next) == visited.end()) {\n                    q.push({next, moves + 1});\n                    visited.insert(next);\n                }\n            }\n        }\n    }\n    return -1; // Impossible to reach goal state\n}\n\nint main() {\n    string grid;\n    for (int i = 0; i < 9; i++) {\n        int x;\n        cin >> x;\n        grid += to_string(x);\n    }\n    cout << bfs(grid) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 19,
            "mean_time_taken": 0.13159867336875514,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 102,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Swap Round Sorting",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<int> a(n);\n    vector<int> pos(n + 1);\n    \n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        pos[a[i]] = i + 1;\n    }\n    \n    vector<vector<pair<int, int>>> rounds;\n    \n    while (true) {\n        vector<pair<int, int>> swaps;\n        vector<bool> used(n + 1, false);\n        \n        for (int i = 1; i <= n; i++) {\n            if (!used[i] && pos[i] != i) {\n                int j = pos[i];\n                swaps.push_back({j, i});\n                used[i] = used[a[i-1]] = true;\n                swap(a[i-1], a[j-1]);\n                pos[a[i-1]] = i;\n                pos[a[j-1]] = j;\n            }\n        }\n        \n        if (swaps.empty()) break;\n        rounds.push_back(swaps);\n    }\n    \n    cout << rounds.size() << endl;\n    \n    for (const auto& round : rounds) {\n        cout << round.size() << endl;\n        for (const auto& swap : round) {\n            cout << swap.first << \" \" << swap.second << endl;\n        }\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 15,
            "mean_time_taken": 0.14229742685953775,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                6,
                7,
                9,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 102,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Task Assignment",
            "category": "Advanced Techniques",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 102,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Tasks and Deadlines",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<pair<int, int>> tasks(n);\n    for (int i = 0; i < n; i++) {\n        cin >> tasks[i].first >> tasks[i].second;\n    }\n    \n    // Sort tasks based on duration\n    sort(tasks.begin(), tasks.end());\n    \n    long long current_time = 0;\n    long long total_reward = 0;\n    \n    for (const auto& task : tasks) {\n        current_time += task.first;\n        total_reward += task.second - current_time;\n    }\n    \n    cout << total_reward << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 6,
            "mean_time_taken": 0.14024261633555093,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 103,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Teleporters Path",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nconst int MAX_N = 100005;\n\nvector<int> graph[MAX_N];\nint in_degree[MAX_N], out_degree[MAX_N];\nvector<int> path;\n\nvoid dfs(int v) {\n    while (!graph[v].empty()) {\n        int u = graph[v].back();\n        graph[v].pop_back();\n        dfs(u);\n    }\n    path.push_back(v);\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        out_degree[a]++;\n        in_degree[b]++;\n    }\n\n    // Check Eulerian path conditions\n    bool possible = true;\n    for (int i = 2; i < n; i++) {\n        if (in_degree[i] != out_degree[i]) {\n            possible = false;\n            break;\n        }\n    }\n    if (out_degree[1] != in_degree[1] + 1 || in_degree[n] != out_degree[n] + 1) {\n        possible = false;\n    }\n\n    if (!possible) {\n        cout << \"IMPOSSIBLE\" << endl;\n        return 0;\n    }\n\n    // Find Eulerian path using Hierholzer's algorithm\n    dfs(1);\n\n    // Check if all teleporters were used\n    if (path.size() != m + 1) {\n        cout << \"IMPOSSIBLE\" << endl;\n        return 0;\n    }\n\n    // Print the path in reverse order\n    for (int i = path.size() - 1; i >= 0; i--) {\n        cout << path[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 18,
            "mean_time_taken": 0.13616677125295004,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                4,
                5,
                7,
                9,
                10,
                11,
                12,
                13,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 103,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Throwing Dice",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\n// Matrix multiplication\nvector<vector<long long>> multiply(const vector<vector<long long>>& a, const vector<vector<long long>>& b) {\n    int n = a.size();\n    vector<vector<long long>> result(n, vector<long long>(n, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int k = 0; k < n; k++) {\n                result[i][j] = (result[i][j] + a[i][k] * b[k][j]) % MOD;\n            }\n        }\n    }\n    return result;\n}\n\n// Matrix exponentiation\nvector<vector<long long>> power(vector<vector<long long>> matrix, long long exp) {\n    int n = matrix.size();\n    vector<vector<long long>> result(n, vector<long long>(n, 0));\n    for (int i = 0; i < n; i++) {\n        result[i][i] = 1;\n    }\n    while (exp > 0) {\n        if (exp & 1) {\n            result = multiply(result, matrix);\n        }\n        matrix = multiply(matrix, matrix);\n        exp >>= 1;\n    }\n    return result;\n}\n\nint main() {\n    long long n;\n    cin >> n;\n\n    if (n <= 6) {\n        int results[7] = {1, 1, 2, 4, 8, 16, 32};\n        cout << results[n] << endl;\n        return 0;\n    }\n\n    vector<vector<long long>> base = {\n        {1, 1, 1, 1, 1, 1},\n        {1, 0, 0, 0, 0, 0},\n        {0, 1, 0, 0, 0, 0},\n        {0, 0, 1, 0, 0, 0},\n        {0, 0, 0, 1, 0, 0},\n        {0, 0, 0, 0, 1, 0}\n    };\n\n    vector<vector<long long>> result = power(base, n - 6);\n\n    long long answer = 0;\n    long long initial[6] = {32, 16, 8, 4, 2, 1};\n    for (int i = 0; i < 6; i++) {\n        answer = (answer + result[0][i] * initial[i]) % MOD;\n    }\n\n    cout << answer << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 32,
            "total_test_cases": 32,
            "mean_time_taken": 0.08165375888347626,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 104,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Tower of Hanoi",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nvector<pair<int, int>> moves;\n\nvoid hanoi(int n, int source, int auxiliary, int destination) {\n    if (n == 1) {\n        moves.push_back({source, destination});\n        return;\n    }\n    \n    hanoi(n - 1, source, destination, auxiliary);\n    moves.push_back({source, destination});\n    hanoi(n - 1, auxiliary, source, destination);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    // Calculate minimum number of moves\n    int total_moves = pow(2, n) - 1;\n    \n    // Generate the sequence of moves\n    hanoi(n, 1, 2, 3);\n    \n    // Output the result\n    cout << total_moves << endl;\n    for (const auto& move : moves) {\n        cout << move.first << \" \" << move.second << endl;\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 16,
            "total_test_cases": 16,
            "mean_time_taken": 0.08711960911750793,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 105,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Towers",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <set>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    multiset<int> towers;\n\n    for (int i = 0; i < n; i++) {\n        int cube;\n        cin >> cube;\n\n        auto it = towers.upper_bound(cube);\n        if (it != towers.end()) {\n            towers.erase(it);\n        }\n        towers.insert(cube);\n    }\n\n    cout << towers.size() << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.14407227436701456,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 106,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Traffic Lights",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int x, n;\n    cin >> x >> n;\n\n    set<int> positions = {0, x};\n    multiset<int> gaps = {x};\n\n    for (int i = 0; i < n; ++i) {\n        int p;\n        cin >> p;\n\n        auto it = positions.insert(p).first;\n        auto prev = it, next = it;\n        --prev;\n        ++next;\n\n        gaps.erase(gaps.find(*next - *prev));\n        gaps.insert(p - *prev);\n        gaps.insert(*next - p);\n\n        cout << *gaps.rbegin() << \" \";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.397030770778656,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 107,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Trailing Zeros",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n\nusing namespace std;\n\nlong long trailingZeros(long long n) {\n    long long zeros = 0;\n    for (long long i = 5; n / i >= 1; i *= 5) {\n        zeros += n / i;\n    }\n    return zeros;\n}\n\nint main() {\n    long long n;\n    cin >> n;\n    cout << trailingZeros(n) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.08443711354182316,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 108,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Tree Diameter",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nvector<int> adj[MAXN];\nbool visited[MAXN];\nint farthest_node, max_dist;\n\nvoid dfs(int node, int dist) {\n    visited[node] = true;\n    if (dist > max_dist) {\n        max_dist = dist;\n        farthest_node = node;\n    }\n    for (int neighbor : adj[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, dist + 1);\n        }\n    }\n}\n\nint find_diameter() {\n    // First DFS to find one end of the diameter\n    max_dist = -1;\n    fill(visited, visited + MAXN, false);\n    dfs(1, 0);\n\n    // Second DFS from the farthest node found\n    int start = farthest_node;\n    max_dist = -1;\n    fill(visited, visited + MAXN, false);\n    dfs(start, 0);\n\n    return max_dist;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    int diameter = find_diameter();\n    cout << diameter << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 16,
            "total_test_cases": 18,
            "mean_time_taken": 0.14050567150115967,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 108,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Distances I",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\n\nvector<int> adj[MAXN];\nint dist[MAXN], maxDist[MAXN];\n\nvoid dfs1(int u, int parent) {\n    for (int v : adj[u]) {\n        if (v != parent) {\n            dist[v] = dist[u] + 1;\n            dfs1(v, u);\n        }\n    }\n}\n\nvoid dfs2(int u, int parent, int d) {\n    maxDist[u] = max(maxDist[u], d);\n    for (int v : adj[u]) {\n        if (v != parent) {\n            dfs2(v, u, d + 1);\n        }\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    // First DFS from node 1\n    dfs1(1, 0);\n\n    // Find the farthest node from node 1\n    int farthest = 1;\n    for (int i = 1; i <= n; i++) {\n        if (dist[i] > dist[farthest]) {\n            farthest = i;\n        }\n    }\n\n    // Reset distances\n    fill(dist, dist + MAXN, 0);\n\n    // Second DFS from the farthest node\n    dfs1(farthest, 0);\n\n    // Find the diameter end points\n    int diameter_end = 1;\n    for (int i = 1; i <= n; i++) {\n        if (dist[i] > dist[diameter_end]) {\n            diameter_end = i;\n        }\n    }\n\n    // Calculate max distances\n    dfs2(farthest, 0, 0);\n    dfs2(diameter_end, 0, 0);\n\n    // Print results\n    for (int i = 1; i <= n; i++) {\n        cout << maxDist[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 15,
            "mean_time_taken": 0.16425617535909018,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                5,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 108,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Distances II",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\n\nvector<int> adj[MAX_N];\nlong long subtree_size[MAX_N], dist[MAX_N];\nint n;\n\nvoid dfs1(int u, int p = -1) {\n    subtree_size[u] = 1;\n    for (int v : adj[u]) {\n        if (v == p) continue;\n        dfs1(v, u);\n        subtree_size[u] += subtree_size[v];\n        dist[u] += dist[v] + subtree_size[v];\n    }\n}\n\nvoid dfs2(int u, int p = -1) {\n    for (int v : adj[u]) {\n        if (v == p) continue;\n        dist[v] = dist[u] + n - 2 * subtree_size[v];\n        dfs2(v, u);\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    dfs1(1);\n    dfs2(1);\n\n    for (int i = 1; i <= n; i++) {\n        cout << dist[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 14,
            "mean_time_taken": 0.13354643753596715,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                5,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 108,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Isomorphism I",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <functional>\n\nusing namespace std;\n\nvector<vector<int>> tree1, tree2;\nvector<long long> signature1, signature2;\n\nlong long dfs(int node, int parent, vector<vector<int>>& tree, vector<long long>& signature) {\n    vector<long long> childSignatures;\n    for (int child : tree[node]) {\n        if (child != parent) {\n            childSignatures.push_back(dfs(child, node, tree, signature));\n        }\n    }\n    \n    sort(childSignatures.begin(), childSignatures.end());\n    \n    string s = \"\";\n    for (long long sig : childSignatures) {\n        s += to_string(sig) + \",\";\n    }\n    \n    hash<string> hasher;\n    signature[node] = hasher(s);\n    return signature[node];\n}\n\nbool areIsomorphic(int n) {\n    signature1.resize(n + 1);\n    signature2.resize(n + 1);\n    \n    long long sig1 = dfs(1, 0, tree1, signature1);\n    long long sig2 = dfs(1, 0, tree2, signature2);\n    \n    return sig1 == sig2;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n;\n        cin >> n;\n        \n        tree1.clear();\n        tree2.clear();\n        tree1.resize(n + 1);\n        tree2.resize(n + 1);\n        \n        for (int i = 0; i < n - 1; i++) {\n            int u, v;\n            cin >> u >> v;\n            tree1[u].push_back(v);\n            tree1[v].push_back(u);\n        }\n        \n        for (int i = 0; i < n - 1; i++) {\n            int u, v;\n            cin >> u >> v;\n            tree2[u].push_back(v);\n            tree2[v].push_back(u);\n        }\n        \n        cout << (areIsomorphic(n) ? \"YES\" : \"NO\") << \"\\n\";\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 14,
            "total_test_cases": 15,
            "mean_time_taken": 0.17040990193684896,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 108,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Isomorphism II",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj1, adj2;\n\nvector<int> findCenters(vector<vector<int>>& adj) {\n    int n = adj.size();\n    vector<int> degree(n);\n    queue<int> leaves;\n    \n    for (int i = 0; i < n; i++) {\n        degree[i] = adj[i].size();\n        if (degree[i] <= 1) leaves.push(i);\n    }\n    \n    int remaining = n;\n    while (remaining > 2) {\n        int leafCount = leaves.size();\n        remaining -= leafCount;\n        \n        while (leafCount--) {\n            int leaf = leaves.front();\n            leaves.pop();\n            \n            for (int neighbor : adj[leaf]) {\n                if (--degree[neighbor] == 1) {\n                    leaves.push(neighbor);\n                }\n            }\n        }\n    }\n    \n    vector<int> centers;\n    while (!leaves.empty()) {\n        centers.push_back(leaves.front());\n        leaves.pop();\n    }\n    return centers;\n}\n\nstring canonicalForm(vector<vector<int>>& adj, int node, int parent) {\n    vector<string> childForms;\n    for (int child : adj[node]) {\n        if (child != parent) {\n            childForms.push_back(canonicalForm(adj, child, node));\n        }\n    }\n    sort(childForms.begin(), childForms.end());\n    string result = \"(\" + to_string(childForms.size());\n    for (const string& form : childForms) {\n        result += form;\n    }\n    result += \")\";\n    return result;\n}\n\nbool areIsomorphic() {\n    vector<int> centers1 = findCenters(adj1);\n    vector<int> centers2 = findCenters(adj2);\n    \n    if (centers1.size() != centers2.size()) return false;\n    \n    set<string> forms1, forms2;\n    for (int center : centers1) {\n        forms1.insert(canonicalForm(adj1, center, -1));\n    }\n    for (int center : centers2) {\n        forms2.insert(canonicalForm(adj2, center, -1));\n    }\n    \n    return forms1 == forms2;\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n    \n    adj1.assign(n, vector<int>());\n    adj2.assign(n, vector<int>());\n    \n    for (int i = 0; i < n-1; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        adj1[u].push_back(v);\n        adj1[v].push_back(u);\n    }\n    \n    for (int i = 0; i < n-1; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        adj2[u].push_back(v);\n        adj2[v].push_back(u);\n    }\n    \n    cout << (areIsomorphic() ? \"YES\" : \"NO\") << \"\\n\";\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 14,
            "mean_time_taken": 0.1919342279434204,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 108,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Matching",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\n\nvector<int> adj[MAX_N];\npair<int, int> dp[MAX_N];\n\npair<int, int> dfs(int node, int parent) {\n    int with = 0, without = 0;\n    bool matched = false;\n\n    for (int child : adj[node]) {\n        if (child != parent) {\n            pair<int, int> child_result = dfs(child, node);\n            without += max(child_result.first, child_result.second);\n            \n            if (!matched && child_result.second > child_result.first) {\n                with += child_result.first + 1;\n                matched = true;\n            } else {\n                with += max(child_result.first, child_result.second);\n            }\n        }\n    }\n\n    dp[node] = {with, without};\n    return dp[node];\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    pair<int, int> result = dfs(1, 0);\n    cout << max(result.first, result.second) << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 13,
            "mean_time_taken": 0.14487816737248346,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 108,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Traversals",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> postorder;\nvector<int> preorder;\nunordered_map<int, int> inorder_map;\nint index = 0;\n\nvoid reconstruct(int start, int end) {\n    if (start > end) return;\n    \n    int root = preorder[index++];\n    int mid = inorder_map[root];\n    \n    reconstruct(start, mid - 1);  // Left subtree\n    reconstruct(mid + 1, end);    // Right subtree\n    \n    postorder.push_back(root);    // Add to postorder\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    preorder.resize(n);\n    vector<int> inorder(n);\n    \n    // Read preorder\n    for (int i = 0; i < n; i++) {\n        cin >> preorder[i];\n    }\n    \n    // Read inorder and build map\n    for (int i = 0; i < n; i++) {\n        cin >> inorder[i];\n        inorder_map[inorder[i]] = i;\n    }\n    \n    reconstruct(0, n - 1);\n    \n    // Print postorder\n    for (int i = 0; i < n; i++) {\n        cout << postorder[i] << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.1181159218152364,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 109,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Two Knights",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    for (long long k = 1; k <= n; k++) {\n        long long total = k * k;\n        long long all_ways = (total * (total - 1)) / 2;\n        long long attacking = 4 * (k - 1) * (k - 2);\n        cout << all_ways - attacking << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 3,
            "mean_time_taken": 0.08931446075439453,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 110,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Two Sets",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    long long n;\n    cin >> n;\n\n    long long sum = n * (n + 1) / 2;\n\n    if (sum % 2 != 0) {\n        cout << \"NO\" << endl;\n        return 0;\n    }\n\n    cout << \"YES\" << endl;\n\n    vector<int> set1, set2;\n    long long sum1 = 0, sum2 = 0;\n    \n    for (int i = n; i >= 1; i--) {\n        if (sum1 <= sum2) {\n            set1.push_back(i);\n            sum1 += i;\n        } else {\n            set2.push_back(i);\n            sum2 += i;\n        }\n    }\n\n    cout << set1.size() << endl;\n    for (int num : set1) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    cout << set2.size() << endl;\n    for (int num : set2) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 23,
            "total_test_cases": 23,
            "mean_time_taken": 0.08686385984006136,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 111,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Two Sets II",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n;\n    cin >> n;\n\n    long long total_sum = (long long)n * (n + 1) / 2;\n    \n    if (total_sum % 2 != 0) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    int target = total_sum / 2;\n\n    vector<vector<int>> dp(n + 1, vector<int>(target + 1, 0));\n    dp[0][0] = 1;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= target; j++) {\n            dp[i][j] = dp[i-1][j];\n            if (j >= i) {\n                dp[i][j] = (dp[i][j] + dp[i-1][j-i]) % MOD;\n            }\n        }\n    }\n\n    int result = dp[n][target];\n    result = (long long)result * ((MOD + 1) / 2) % MOD;  // Divide by 2\n\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 24,
            "total_test_cases": 24,
            "mean_time_taken": 0.1600469450155894,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 112,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Two Stacks Sorting",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> input(n);\n    for (int i = 0; i < n; i++) {\n        cin >> input[i];\n    }\n\n    stack<int> s1, s2;\n    vector<int> result;\n    int next = 1;\n\n    for (int num : input) {\n        if (num == next) {\n            result.push_back(0);  // 0 means directly to output\n            next++;\n            while (!s1.empty() && s1.top() == next) {\n                s1.pop();\n                result.push_back(1);\n                next++;\n            }\n            while (!s2.empty() && s2.top() == next) {\n                s2.pop();\n                result.push_back(2);\n                next++;\n            }\n        } else if (num > next) {\n            s1.push(num);\n            result.push_back(1);\n        } else {\n            s2.push(num);\n            result.push_back(2);\n        }\n    }\n\n    if (!s1.empty() || !s2.empty()) {\n        cout << \"IMPOSSIBLE\" << endl;\n    } else {\n        for (int r : result) {\n            if (r != 0) cout << r << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 14,
            "mean_time_taken": 0.1073319571358817,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                5,
                6,
                7,
                8,
                10,
                11,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 112,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Visiting Cities",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> pli;\n\nconst int MAX_N = 1e5 + 5;\n\nvector<pli> graph[MAX_N], rev_graph[MAX_N];\nll dist1[MAX_N], dist2[MAX_N];\nvector<bool> on_path;\n\nvoid dijkstra(int start, vector<pli> g[], ll dist[]) {\n    priority_queue<pli, vector<pli>, greater<pli>> pq;\n    fill(dist, dist + MAX_N, LLONG_MAX);\n    dist[start] = 0;\n    pq.push({0, start});\n\n    while (!pq.empty()) {\n        int v = pq.top().second;\n        ll d = pq.top().first;\n        pq.pop();\n\n        if (d > dist[v]) continue;\n\n        for (auto &e : g[v]) {\n            int to = e.second;\n            ll len = e.first;\n            if (dist[v] + len < dist[to]) {\n                dist[to] = dist[v] + len;\n                pq.push({dist[to], to});\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        graph[a].push_back({c, b});\n        rev_graph[b].push_back({c, a});\n    }\n\n    dijkstra(1, graph, dist1);\n    dijkstra(n, rev_graph, dist2);\n\n    ll min_dist = dist1[n];\n    on_path.resize(n + 1, false);\n\n    for (int i = 1; i <= n; i++) {\n        if (dist1[i] + dist2[i] == min_dist) {\n            on_path[i] = true;\n        }\n    }\n\n    int count = 0;\n    for (int i = 1; i <= n; i++) {\n        if (on_path[i]) count++;\n    }\n\n    cout << count << endl;\n    for (int i = 1; i <= n; i++) {\n        if (on_path[i]) cout << i << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 13,
            "mean_time_taken": 0.17725489689753607,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                7,
                10,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 112,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Weird Algorithm",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n\nint main() {\n    long long n;\n    std::cin >> n;\n    \n    while (n != 1) {\n        std::cout << n << \" \";\n        if (n % 2 == 0) {\n            n = n / 2;\n        } else {\n            n = n * 3 + 1;\n        }\n    }\n    \n    std::cout << 1 << std::endl;\n    \n    return 0;\n}\n",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.08449651513780866,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 113,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Word Combinations",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nstruct TrieNode {\n    unordered_map<char, TrieNode*> children;\n    bool is_end;\n    TrieNode() : is_end(false) {}\n};\n\nvoid insert(TrieNode* root, const string& word) {\n    TrieNode* node = root;\n    for (char c : word) {\n        if (!node->children[c]) {\n            node->children[c] = new TrieNode();\n        }\n        node = node->children[c];\n    }\n    node->is_end = true;\n}\n\nint countWays(const string& s, TrieNode* root) {\n    int n = s.length();\n    vector<int> dp(n + 1, 0);\n    dp[0] = 1;\n\n    for (int i = 1; i <= n; i++) {\n        TrieNode* node = root;\n        for (int j = i - 1; j >= 0; j--) {\n            if (!node->children[s[j]]) break;\n            node = node->children[s[j]];\n            if (node->is_end) {\n                dp[i] = (dp[i] + dp[j]) % MOD;\n            }\n        }\n    }\n\n    return dp[n];\n}\n\nint main() {\n    string s;\n    cin >> s;\n\n    int k;\n    cin >> k;\n\n    TrieNode* root = new TrieNode();\n    for (int i = 0; i < k; i++) {\n        string word;\n        cin >> word;\n        insert(root, word);\n    }\n\n    cout << countWays(s, root) << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 6,
            "mean_time_taken": 0.38921840985616046,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 113,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Writing Numbers",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    long long n;\n    cin >> n;\n\n    // Calculate 10^n\n    long long power_of_ten = 1;\n    for (int i = 0; i < n; ++i) {\n        if (power_of_ten > 1e18 / 10) {\n            // If 10^n would overflow, we've reached the maximum possible number\n            cout << 1e18 << endl;\n            return 0;\n        }\n        power_of_ten *= 10;\n    }\n\n    // Calculate the result: (10^n - 1) + n\n    long long result = power_of_ten - 1 + n;\n\n    // Check if the result exceeds 10^18\n    if (result > 1e18) {\n        result = 1e18;\n    }\n\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 21,
            "mean_time_taken": 0.08180336725144159,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 113,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Xor Pyramid",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n;\n\n    vector<int> bottom(n);\n    for (int i = 0; i < n; i++) {\n        cin >> bottom[i];\n    }\n\n    int result = 0;\n    for (int i = 0; i < n; i += 2) {\n        result ^= bottom[i];\n    }\n\n    cout << result << \"\\n\";\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.09070304036140442,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 113,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        }
    ],
    "total_passed_problems": 113,
    "initial_config": {
        "ignore_time_limits": false,
        "model": "claude-3-5-sonnet-20240620",
        "provider": "anthropic",
        "categories": [],
        "shots": 1
    }
}