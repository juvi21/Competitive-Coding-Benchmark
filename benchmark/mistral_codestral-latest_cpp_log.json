{
    "problems": [
        {
            "title": "Acyclic Graph Edges",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_NODES = 100005;\n\nint numNodes, numEdges;\nint discoveryTime[MAX_NODES], low[MAX_NODES], parent[MAX_NODES];\nvector<int> adjList[MAX_NODES];\nvector<pair<int, int>> edges;\n\nvoid dfs(int node) {\n    static int time = 0;\n    discoveryTime[node] = low[node] = time++;\n    for (int neighbor : adjList[node]) {\n        if (discoveryTime[neighbor] == -1) {\n            parent[neighbor] = node;\n            dfs(neighbor);\n            low[node] = min(low[node], low[neighbor]);\n        } else if (neighbor != parent[node]) {\n            low[node] = min(low[node], discoveryTime[neighbor]);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d%d\", &numNodes, &numEdges);\n    for (int i = 0; i < numEdges; i++) {\n        int node1, node2;\n        scanf(\"%d%d\", &node1, &node2);\n        adjList[node1].push_back(node2);\n        adjList[node2].push_back(node1);\n        edges.push_back(make_pair(node1, node2));\n    }\n    fill_n(discoveryTime, MAX_NODES, -1);\n    fill_n(parent, MAX_NODES, -1);\n    dfs(1);\n    for (auto edge : edges) {\n        int node1 = edge.first, node2 = edge.second;\n        if (parent[node1] == node2) {\n            printf(\"%d %d\\n\", node2, node1);\n        } else if (parent[node2] == node1) {\n            printf(\"%d %d\\n\", node1, node2);\n        } else if (discoveryTime[node1] < discoveryTime[node2]) {\n            printf(\"%d %d\\n\", node2, node1);\n        } else {\n            printf(\"%d %d\\n\", node1, node2);\n        }\n    }\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 4,
            "mean_time_taken": 0.11197352409362793,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Advertisement",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <map>\n#include <algorithm>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::map<int, int> freq;\n    int max_freq = 0, max_height = 0;\n\n    for (int i = 0; i < n; i++) {\n        int height;\n        std::cin >> height;\n        freq[height]++;\n        max_freq = std::max(max_freq, freq[height]);\n        if (max_freq == freq[height]) {\n            max_height = height;\n        }\n    }\n\n    std::cout << max_freq * max_height << std::endl;\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 11,
            "mean_time_taken": 0.16469318216497247,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Another Game",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, count = 0;\n        cin >> n;\n        for (int i = 0; i < n; i++) {\n            int x;\n            cin >> x;\n            if (x % 2 != 0) {\n                count++;\n            }\n        }\n        if (count % 2 == 0) {\n            cout << \"first\" << endl;\n        } else {\n            cout << \"second\" << endl;\n        }\n    }\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 0.11239186922709148,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Apartments",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<int> applicants(n);\n    vector<int> apartments(m);\n\n    for (int i = 0; i < n; i++) {\n        cin >> applicants[i];\n    }\n\n    for (int i = 0; i < m; i++) {\n        cin >> apartments[i];\n    }\n\n    sort(applicants.begin(), applicants.end());\n    sort(applications.begin(), applications.end());\n\n    int i = 0, j = 0, count = 0;\n\n    while (i < n && j < m) {\n        if (abs(applicants[i] - apartments[j]) <= k) {\n            count++;\n            i++;\n            j++;\n        } else if (applicants[i] < apartments[j]) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n\n    cout << count << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Apple Division",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint n;\nvector<int> weights;\n\nint appleDivision(int idx, int diff) {\n    if (idx == n) {\n        return abs(diff);\n    }\n\n    int include = appleDivision(idx + 1, diff + weights[idx]);\n    int exclude = appleDivision(idx + 1, diff);\n\n    return min(include, exclude);\n}\n\nint main() {\n    cin >> n;\n    weights.resize(n);\n\n    for (int i = 0; i < n; i++) {\n        cin >> weights[i];\n    }\n\n    cout << appleDivision(0, 0) << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 18,
            "mean_time_taken": 0.08221002419789632,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                17,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Apples and Bananas",
            "category": "Advanced Techniques",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Area of Rectangles",
            "category": "Additional Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Array Description",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <cstring>\n\nconst int MAX_N = 100005;\nconst int MAX_M = 105;\nconst int MOD = 1000000007;\n\nint n, m;\nint arr[MAX_N];\nlong long dp[MAX_N][MAX_M];\n\nint main() {\n    std::cin >> n >> m;\n    for (int i = 1; i <= n; i++) {\n        std::cin >> arr[i];\n    }\n\n    // Base case: dp[1][j] = 1 if arr[1] is either 0 or j, otherwise dp[1][j] = 0\n    for (int j = 1; j <= m; j++) {\n        dp[1][j] = (arr[1] == 0 || arr[1] == j) ? 1 : 0;\n    }\n\n    // Iterate through the array and update the dp array\n    for (int i = 2; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            // If arr[i] is known and not equal to j, dp[i][j] = 0\n            if (arr[i] != 0 && arr[i] != j) {\n                dp[i][j] = 0;\n            } else {\n                // Otherwise, dp[i][j] = sum of dp[i-1][j-1], dp[i-1][j], and dp[i-1][j+1]\n                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j] + dp[i - 1][j + 1]) % MOD;\n            }\n        }\n    }\n\n    // The answer is the sum of dp[n][j] for all j\n    long long answer = 0;\n    for (int j = 1; j <= m; j++) {\n        answer = (answer + dp[n][j]) % MOD;\n    }\n\n    std::cout << answer << std::endl;\n    return 0;\n}\n",
            "passed_test_cases": 29,
            "total_test_cases": 29,
            "mean_time_taken": 0.09707723814865639,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 1,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Array Division",
            "category": "Sorting and Searching",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 1,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Beautiful Subgrids",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<vector<int>> grid(n, vector<int>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    int result = 0;\n    for (int i = 1; i < n; i++) {\n        for (int j = 1; j < n; j++) {\n            if (grid[i][j] && grid[i - 1][j] && grid[i][j - 1] && grid[i - 1][j - 1]) {\n                result += min(i, j) - max(0, min(i - 1, j - 1));\n            }\n        }\n    }\n\n    cout << result << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.15621638298034668,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 1,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Binary Subsequences",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::string result;\n\n    // Find the largest power of 2 less than or equal to n\n    int powerOfTwo = 1;\n    while (powerOfTwo <= n) {\n        powerOfTwo *= 2;\n    }\n    powerOfTwo /= 2;\n\n    // Append zeros to the result\n    int zeros = powerOfTwo - 1;\n    for (int i = 0; i < zeros; i++) {\n        result += '0';\n    }\n\n    // Append ones to the result\n    int ones = n - zeros;\n    for (int i = 0; i < ones; i++) {\n        result += '1';\n    }\n\n    std::cout << result << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 12,
            "mean_time_taken": 0.08360439538955688,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 1,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Binomial Coefficients",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 1000005;\nconst int MOD = 1000000007;\n\n// Function to calculate (base^exponent)%MOD\nlong long power(long long base, long long exponent) {\n    long long result = 1;\n    while (exponent > 0) {\n        if (exponent % 2 == 1)\n            result = (result * base) % MOD;\n        base = (base * base) % MOD;\n        exponent /= 2;\n    }\n    return result;\n}\n\n// Function to calculate nCr\nlong long nCr(long long n, long long r, vector<long long>& factorial, vector<long long>& inverse) {\n    if (n < r)\n        return 0;\n    if (r > n - r)\n        r = n - r;\n    return (((factorial[n] * inverse[r]) % MOD) * inverse[n - r]) % MOD;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    vector<long long> factorial(MAX_N, 1);\n    vector<long long> inverse(MAX_N, 1);\n\n    // Precompute factorials and their inverses\n    for (int i = 2; i < MAX_N; i++) {\n        factorial[i] = (factorial[i - 1] * i) % MOD;\n        inverse[i] = power(factorial[i], MOD - 2);\n    }\n\n    int num_queries;\n    cin >> num_queries;\n\n    // Answer queries\n    while (num_queries--) {\n        long long n, r;\n        cin >> n >> r;\n        cout << nCr(n, r, factorial, inverse) << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.19179502400484952,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Bit Inversions",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    string s;\n    int n, m, x, max_len = 0;\n    cin >> s >> m;\n    n = s.length();\n    int left[n], right[n];\n\n    // Step 3: Initialize left array\n    left[0] = 1;\n    for (int i = 1; i < n; i++) {\n        if (s[i] == s[i-1]) {\n            left[i] = left[i-1] + 1;\n        } else {\n            left[i] = 1;\n        }\n    }\n\n    // Step 4: Initialize right array\n    right[n-1] = 1;\n    for (int i = n-2; i >= 0; i--) {\n        if (s[i] == s[i+1]) {\n            right[i] = right[i+1] + 1;\n        } else {\n            right[i] = 1;\n        }\n    }\n\n    // Step 5-7: Process changes and print results\n    for (int i = 0; i < m; i++) {\n        cin >> x;\n        x--;\n        s[x] = (s[x] == '0') ? '1' : '0';\n        if (x > 0 && s[x] == s[x-1]) {\n            left[x] = left[x-1] + 1;\n        } else {\n            left[x] = 1;\n        }\n        if (x < n-1 && s[x] == s[x+1]) {\n            right[x] = right[x+1] + 1;\n        } else {\n            right[x] = 1;\n        }\n        max_len = max(max_len, max(left[x], right[x]));\n        cout << max_len << \" \";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.15053671598434448,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bit Problem",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nconst int MAX_N = 1000005;\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> a(n);\n    std::vector<int> divisible(MAX_N, 0);\n    std::vector<int> bitwise_and(MAX_N, 0);\n    std::vector<int> non_zero_bitwise_and(MAX_N, 0);\n\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n        divisible[a[i]]++;\n        bitwise_and[a[i]]++;\n        for (int j = 1; j * a[i] < MAX_N; j++) {\n            non_zero_bitwise_and[j * a[i]]++;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        std::cout << divisible[a[i]] << \" \";\n        std::cout << bitwise_and[a[i]] << \" \";\n        std::cout << non_zero_bitwise_and[a[i]] << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.1363232135772705,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bit Strings",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    // Define a constant for the modulo value\n    const long long MOD = 1000000007;\n\n    // Read the input value of n\n    long long n;\n    cin >> n;\n\n    // Initialize a variable result to 1\n    long long result = 1;\n\n    // Initialize a variable base to 2\n    long long base = 2;\n\n    // Use a while loop to calculate (2^n) % MOD directly\n    while (n > 0) {\n        // If n is odd, multiply the base with the result and take the modulo\n        if (n % 2 == 1) {\n            result = (result * base) % MOD;\n        }\n        // Square the base and take the modulo\n        base = (base * base) % MOD;\n        // Divide n by 2\n        n /= 2;\n    }\n\n    // Print the result\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.08206806580225627,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Bit Substrings",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nint main() {\n    std::string bitString;\n    std::cin >> bitString;\n\n    int n = bitString.length();\n    std::vector<int> count(n + 1, 0);\n\n    int left = 0, right = 0;\n    for (int i = 0; i < n; i++) {\n        if (bitString[i] == '1') {\n            right++;\n            for (int j = right; j >= left + 1; j--) {\n                count[j]++;\n            }\n        } else {\n            left++;\n        }\n    }\n\n    for (int i = 0; i <= n; i++) {\n        std::cout << count[i] << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 8,
            "mean_time_taken": 0.21129581332206726,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Book Shop",
            "category": "Dynamic Programming",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Book Shop II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_BOOKS = 100;\nconst int MAX_PRICE = 100000;\n\nint dp[MAX_BOOKS + 1][MAX_PRICE + 1]; // dp[i][j] represents the maximum number of pages that can be bought with a total price of j using the first i books\nint prices[MAX_BOOKS];\nint pages[MAX_BOOKS];\nint copies[MAX_BOOKS];\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    for (int i = 1; i <= n; i++) {\n        cin >> prices[i];\n    }\n\n    for (int i = 1; i <= n; i++) {\n        cin >> pages[i];\n    }\n\n    for (int i = 1; i <= n; i++) {\n        cin >> copies[i];\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= x; j++) {\n            dp[i][j] = dp[i - 1][j]; // Initialize the maximum number of pages that can be bought with a total price of j using the first i books as the maximum number of pages that can be bought using the first i - 1 books\n\n            for (int k = 1; k <= copies[i] && k * prices[i] <= j; k++) {\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - k * prices[i]] + k * pages[i]); // Update the maximum number of pages that can be bought with a total price of j using the first i books by considering the current book\n            }\n        }\n    }\n\n    cout << dp[n][x] << endl; // Output the maximum number of pages that can be bought with a total price of x using all n books\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 10,
            "mean_time_taken": 0.5656883955001831,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bracket Sequences I",
            "category": "Mathematics",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Bracket Sequences II",
            "category": "Mathematics",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Building Roads",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 100005;\nint parent[MAX_N];\n\nint find_parent(int x) {\n    if (parent[x] == x) return x;\n    return parent[x] = find_parent(parent[x]);\n}\n\nvoid merge_components(int x, int y) {\n    int parent_x = find_parent(x);\n    int parent_y = find_parent(y);\n    parent[parent_x] = parent_y;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<pair<int, int>> roads(m);\n    for (int i = 0; i < m; i++) {\n        cin >> roads[i].first >> roads[i].second;\n    }\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n    }\n    for (auto road : roads) {\n        merge_components(road.first, road.second);\n    }\n    int num_components = 0;\n    for (int i = 1; i <= n; i++) {\n        if (parent[i] == i) num_components++;\n    }\n    cout << num_components - 1 << endl;\n    for (int i = 1; i <= n; i++) {\n        if (parent[i] != i) {\n            cout << i << \" \" << parent[i] << endl;\n            parent[i] = parent[parent[i]];\n        }\n    }\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.12179583311080933,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Building Teams",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N = 100005;\nvector<int> adj[MAX_N];\nint color[MAX_N];\n\nbool dfs(int u, int c) {\n    color[u] = c;\n    for (int v : adj[u]) {\n        if (color[v] == c) {\n            return false;\n        }\n        if (color[v] == 0 && !dfs(v, 3 - c)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    for (int i = 1; i <= n; i++) {\n        if (color[i] == 0 && !dfs(i, 1)) {\n            cout << \"IMPOSSIBLE\" << endl;\n            return 0;\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        cout << color[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.13319952487945558,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Candy Lottery",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n\nconst int MAX_N = 105;\nconst int MAX_K = 105;\n\ndouble dp[MAX_N][MAX_K];\n\nint main() {\n    int n, k;\n    std::cin >> n >> k;\n\n    dp[0][0] = 1.0;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= k; j++) {\n            for (int x = 0; x < j; x++) {\n                dp[i][j] += dp[i - 1][x] * std::pow((double)j / k, i - 1);\n            }\n            dp[i][j] += dp[i - 1][j] * (1.0 - std::pow((double)(j - 1) / k, i - 1));\n        }\n    }\n\n    double expected_max = 0.0;\n    for (int j = 1; j <= k; j++) {\n        expected_max += dp[n][j] * j;\n    }\n\n    std::cout << std::fixed << std::setprecision(6) << expected_max << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 14,
            "mean_time_taken": 0.08148482867649623,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Chess Tournament",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1e5 + 5;\n\nvector<int> graph[MAX_N];\nint matchR[MAX_N], matchL[MAX_N];\nint numVerticesLeft, numVerticesRight;\nvector<pair<int, int>> result;\n\nbool bipartiteMatch(int leftVertex) {\n    if (matchL[leftVertex] != -1) return false;\n    for (int rightVertex : graph[leftVertex]) {\n        if (matchR[rightVertex] == -1) {\n            matchL[leftVertex] = rightVertex;\n            matchR[rightVertex] = leftVertex;\n            return true;\n        }\n    }\n    for (int rightVertex : graph[leftVertex]) {\n        if (bipartiteMatch(matchR[rightVertex])) {\n            matchL[leftVertex] = rightVertex;\n            matchR[rightVertex] = leftVertex;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int numPlayers;\n    cin >> numPlayers;\n\n    vector<int> playerGames(numPlayers);\n    for (int i = 0; i < numPlayers; i++) {\n        cin >> playerGames[i];\n    }\n\n    int totalGames = 0;\n    for (int i = 0; i < numPlayers; i++) {\n        totalGames += playerGames[i];\n    }\n\n    if (totalGames % 2 != 0 || *max_element(playerGames.begin(), playerGames.end()) > numPlayers / 2) {\n        cout << \"IMPOSSIBLE\\n\";\n        return 0;\n    }\n\n    numVerticesLeft = numVerticesRight = numPlayers / 2;\n    for (int i = 0; i < numPlayers; i++) {\n        if (playerGames[i] % 2 != 0) {\n            for (int j = 0; j < numPlayers; j++) {\n                if (i != j && playerGames[j] > 0) {\n                    graph[i].push_back(j);\n                    playerGames[i]--;\n                    playerGames[j]--;\n                }\n            }\n        }\n    }\n\n    memset(matchR, -1, sizeof(matchR));\n    memset(matchL, -1, sizeof(matchL));\n    for (int i = 0; i < numPlayers; i++) {\n        if (playerGames[i] > 0) {\n            bipartiteMatch(i);\n        }\n    }\n\n    for (int i = 0; i < numPlayers; i++) {\n        if (matchL[i] != -1 && i < matchL[i]) {\n            result.push_back({i + 1, matchL[i] + 1});\n        }\n    }\n\n    cout << result.size() << \"\\n\";\n    for (auto& game : result) {\n        cout << game.first << \" \" << game.second << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 21,
            "mean_time_taken": 0.08281301316760835,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Chessboard and Queens",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\nconst int N = 8;\nvector<string> board(N);\nbitset<N> col, diag1, diag2;\nint count = 0;\n\nbool is_safe(int row, int col) {\n    return !::col[col] && !diag1[row + col] && !diag2[row - col + N - 1];\n}\n\nvoid place_queens(int row) {\n    if (row == N) {\n        count++;\n        return;\n    }\n    for (int col = 0; col < N; col++) {\n        if (board[row][col] == '.' && is_safe(row, col)) {\n            ::col[col] = diag1[row + col] = diag2[row - col + N - 1] = 1;\n            place_queens(row + 1);\n            ::col[col] = diag1[row + col] = diag2[row - col + N - 1] = 0;\n        }\n    }\n}\n\nint main() {\n    for (int i = 0; i < N; i++) {\n        cin >> board[i];\n    }\n    place_queens(0);\n    cout << count << endl;\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.08259611129760742,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 5,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Christmas Party",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main() {\n    int n;\n    cin >> n;\n\n    long long result = 1;\n    for (int i = 1; i <= n; i++) {\n        result = (result * (n - i)) % MOD;\n    }\n\n    cout << result << endl;\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 15,
            "mean_time_taken": 0.08154301643371582,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 5,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coding Company",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int MAX_N = 105;\nconst int MAX_X = 5005;\n\nint n, x;\nint a[MAX_N];\nint dp[MAX_N][MAX_N][MAX_X];\n\nint main() {\n    cin >> n >> x;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    sort(a + 1, a + n + 1);\n    dp[0][0][0] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= i; j++) {\n            for (int k = 0; k <= x; k++) {\n                dp[i][j][k] = dp[i - 1][j - 1][k - (a[i] - a[i - j + 1])];\n                if (k >= a[i] - a[i - j + 1]) {\n                    dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k]) % MOD;\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n        ans = (ans + dp[n][i][x]) % MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.10529788335164388,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 5,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Arrangement",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> row1(n), row2(n);\n    for (int i = 0; i < n; i++) {\n        cin >> row1[i];\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> row2[i];\n    }\n\n    int swaps_row1 = 0, swaps_row2 = 0;\n    for (int i = 0; i < n; i++) {\n        if (row1[i] > 1) {\n            swaps_row1 += row1[i] - 1;\n            row2[i] += row1[i] - 1;\n        }\n        if (row2[i] > 1) {\n            swaps_row2 += row2[i] - 1;\n        }\n    }\n\n    int total_swaps = swaps_row1 + swaps_row2;\n    cout << total_swaps << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 10,
            "mean_time_taken": 0.09401803016662598,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 5,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Collector",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_NODES = 1e5 + 5;\nvector<int> graph[MAX_NODES], reversed_graph[MAX_NODES], condensed_graph[MAX_NODES];\nint node_values[MAX_NODES], component_values[MAX_NODES], visited[MAX_NODES], component_index[MAX_NODES];\nstack<int> node_stack;\n\nvoid dfs1(int node) {\n    visited[node] = 1;\n    for (int neighbor : graph[node]) {\n        if (!visited[neighbor]) {\n            dfs1(neighbor);\n        }\n    }\n    node_stack.push(node);\n}\n\nvoid dfs2(int node, int component) {\n    visited[node] = 0;\n    component_index[node] = component;\n    component_values[component] = max(component_values[component], node_values[node]);\n    for (int neighbor : reversed_graph[node]) {\n        if (visited[neighbor]) {\n            dfs2(neighbor, component);\n        }\n    }\n}\n\nvoid dfs3(int node) {\n    visited[node] = 1;\n    for (int neighbor : condensed_graph[node]) {\n        if (!visited[neighbor]) {\n            dfs3(neighbor);\n        }\n        component_values[node] = max(component_values[node], component_values[neighbor]);\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int num_nodes, num_edges;\n    cin >> num_nodes >> num_edges;\n\n    for (int i = 1; i <= num_nodes; i++) {\n        cin >> node_values[i];\n    }\n\n    for (int i = 1; i <= num_edges; i++) {\n        int node1, node2;\n        cin >> node1 >> node2;\n        graph[node1].push_back(node2);\n        reversed_graph[node2].push_back(node1);\n    }\n\n    for (int i = 1; i <= num_nodes; i++) {\n        if (!visited[i]) {\n            dfs1(i);\n        }\n    }\n\n    int component_counter = 0;\n    while (!node_stack.empty()) {\n        int node = node_stack.top();\n        node_stack.pop();\n        if (visited[node]) {\n            dfs2(node, ++component_counter);\n        }\n    }\n\n    for (int i = 1; i <= num_nodes; i++) {\n        for (int neighbor : graph[i]) {\n            if (component_index[i] != component_index[neighbor]) {\n                condensed_graph[component_index[i]].push_back(component_index[neighbor]);\n            }\n        }\n    }\n\n    for (int i = 1; i <= component_counter; i++) {\n        if (!visited[i]) {\n            dfs3(i);\n        }\n    }\n\n    int max_value = 0;\n    for (int i = 1; i <= component_counter; i++) {\n        max_value = max(max_value, component_values[i]);\n    }\n\n    cout << max_value;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 14,
            "mean_time_taken": 0.11648874623434884,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 5,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Combinations I",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> coins(n);\n    for (int i = 0; i < n; i++) {\n        cin >> coins[i];\n    }\n\n    vector<int> dp(x + 1, 0);\n    dp[0] = 1;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = coins[i]; j <= x; j++) {\n            dp[j] = (dp[j] + dp[j - coins[i]]) % MOD;\n        }\n    }\n\n    cout << dp[x] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 13,
            "mean_time_taken": 0.2222906626187838,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                6,
                7,
                8,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 5,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Combinations II",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> coins(n);\n    for (int i = 0; i < n; i++) {\n        cin >> coins[i];\n    }\n\n    vector<int> dp(x + 1, 0);\n    dp[0] = 1;\n\n    for (int c : coins) {\n        for (int j = c; j <= x; j++) {\n            dp[j] = (dp[j] + dp[j - c]) % MOD;\n        }\n    }\n\n    cout << dp[x] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 15,
            "total_test_cases": 15,
            "mean_time_taken": 0.24983909924825032,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Coin Grid",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<string> grid(n);\n    vector<int> row_count(n, 0), col_count(n, 0);\n\n    for (int i = 0; i < n; i++) {\n        cin >> grid[i];\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 'o') {\n                row_count[i]++;\n                col_count[j]++;\n            }\n        }\n    }\n\n    vector<pair<int, int>> moves;\n\n    while (true) {\n        int max_row = max_element(row_count.begin(), row_count.end()) - row_count.begin();\n        int max_col = max_element(col_count.begin(), col_count.end()) - col_count.begin();\n\n        if (row_count[max_row] == 0 && col_count[max_col] == 0) {\n            break;\n        }\n\n        if (row_count[max_row] >= col_count[max_col]) {\n            moves.push_back({1, max_row + 1});\n            for (int j = 0; j < n; j++) {\n                if (grid[max_row][j] == 'o') {\n                    col_count[j]--;\n                }\n            }\n            fill(row_count.begin(), row_count.end(), 0);\n        } else {\n            moves.push_back({2, max_col + 1});\n            for (int i = 0; i < n; i++) {\n                if (grid[i][max_col] == 'o') {\n                    row_count[i]--;\n                }\n            }\n            fill(col_count.begin(), col_count.end(), 0);\n        }\n    }\n\n    cout << moves.size() << endl;\n    for (auto move : moves) {\n        cout << move.first << \" \" << move.second << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 10,
            "mean_time_taken": 0.1773531675338745,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                6,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Piles",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int numberOfTests;\n    cin >> numberOfTests;  // Read the number of tests\n\n    while (numberOfTests--) {\n        long long int firstNumber, secondNumber;\n        cin >> firstNumber >> secondNumber;  // Read the number of coins in each pile\n\n        // Check if the total number of coins is odd or if the difference between the two piles is greater than 1\n        if ((firstNumber + secondNumber) % 3 != 0 || abs(firstNumber - secondNumber) > 1) {\n            cout << \"NO\" << endl;  // If either condition is true, it's not possible to empty the piles\n        } else {\n            cout << \"YES\" << endl;  // Otherwise, it's possible to empty the piles\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 3,
            "mean_time_taken": 0.13557052612304688,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Collecting Numbers",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> arr[i];\n    }\n\n    int current_num = 1;\n    int rounds = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (arr[i] == current_num) {\n            current_num++;\n        }\n        if (current_num == n + 1) {\n            rounds++;\n            current_num = 1;\n        }\n    }\n\n    std::cout << rounds << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 4,
            "mean_time_taken": 0.10896337032318115,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Collecting Numbers II",
            "category": "Sorting and Searching",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nint n, m, a[MAX_N], parent[MAX_N], rank[MAX_N], fenwick[MAX_N];\n\nint find_parent(int x) {\n    if (parent[x] != x) parent[x] = find_parent(parent[x]);\n    return parent[x];\n}\n\nvoid union_sets(int x, int y) {\n    x = find_parent(x);\n    y = find_parent(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) swap(x, y);\n    parent[y] = x;\n    rank[x] += rank[y];\n    fenwick[x] += fenwick[y];\n}\n\nvoid update_fenwick(int x, int val) {\n    for (; x <= n; x += x & -x) fenwick[x] += val;\n}\n\nint query_fenwick(int x) {\n    int sum = 0;\n    for (; x > 0; x -= x & -x) sum += fenwick[x];\n    return sum;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n        parent[i] = i;\n        rank[i] = 1;\n        update_fenwick(i, 1);\n    }\n    int rounds = 0;\n    for (int i = 1; i <= n; i++) {\n        if (find_parent(i) == find_parent(a[i])) {\n            rounds++;\n            union_sets(i, a[i]);\n        }\n    }\n    while (m--) {\n        int x, y;\n        cin >> x >> y;\n        if (find_parent(x) == find_parent(y)) {\n            cout << rounds << \"\\n\";\n            continue;\n        }\n        int x_parent = find_parent(x);\n        int y_parent = find_parent(y);\n        int x_size = rank[x_parent];\n        int y_size = rank[y_parent];\n        int x_count = query_fenwick(x_parent);\n        int y_count = query_fenwick(y_parent);\n        if (x_parent < y_parent) {\n            if (x_count == x_size) rounds++;\n            if (y_count == y_size) rounds++;\n        } else {\n            if (y_count == y_size) rounds++;\n            if (x_count == x_size) rounds++;\n        }\n        union_sets(x, y);\n        cout << rounds << \"\\n\";\n    }\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Common Divisors",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nconst int MAX_NUM = 1000005;\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    int num_elements;\n    std::cin >> num_elements;\n\n    std::vector<int> frequency(MAX_NUM, 0);\n    int max_num = 0;\n\n    for (int i = 0; i < num_elements; ++i) {\n        int num;\n        std::cin >> num;\n        ++frequency[num];\n        max_num = std::max(max_num, num);\n    }\n\n    for (int i = max_num; i >= 1; --i) {\n        if (frequency[i] > 1) {\n            std::cout << i << '\\n';\n            return 0;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 17,
            "mean_time_taken": 0.08692072419559255,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                9,
                10,
                11,
                12,
                13,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Company Queries I",
            "category": "Tree Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Company Queries II",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nconst int MAX_LOG = 20;\n\nint n, q;\nvector<int> adj[MAX_N];\nint depth[MAX_N];\nint ancestor[MAX_N][MAX_LOG];\n\nvoid dfs(int u, int p) {\n    depth[u] = depth[p] + 1;\n    ancestor[u][0] = p;\n    for (int i = 1; i < MAX_LOG; i++) {\n        ancestor[u][i] = ancestor[ancestor[u][i - 1]][i - 1];\n    }\n    for (int v : adj[u]) {\n        if (v != p) {\n            dfs(v, u);\n        }\n    }\n}\n\nint lca(int u, int v) {\n    if (depth[u] < depth[v]) {\n        swap(u, v);\n    }\n    int diff = depth[u] - depth[v];\n    for (int i = 0; i < MAX_LOG; i++) {\n        if ((diff >> i) & 1) {\n            u = ancestor[u][i];\n        }\n    }\n    if (u == v) {\n        return u;\n    }\n    for (int i = MAX_LOG - 1; i >= 0; i--) {\n        if (ancestor[u][i] != ancestor[v][i]) {\n            u = ancestor[u][i];\n            v = ancestor[v][i];\n        }\n    }\n    return ancestor[u][0];\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n >> q;\n    for (int i = 2; i <= n; i++) {\n        int p;\n        cin >> p;\n        adj[p].push_back(i);\n        adj[i].push_back(p);\n    }\n    dfs(1, 0);\n    while (q--) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca(u, v) << endl;\n    }\n    return 0;\n}\n",
            "passed_test_cases": 11,
            "total_test_cases": 12,
            "mean_time_taken": 0.17109769582748413,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Concert Tickets",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    multiset<int> tickets;\n    for (int i = 0; i < n; i++) {\n        int price;\n        cin >> price;\n        tickets.insert(price);\n    }\n\n    for (int i = 0; i < m; i++) {\n        int maxPrice;\n        cin >> maxPrice;\n\n        auto it = tickets.upper_bound(maxPrice);\n        if (it == tickets.begin()) {\n            cout << -1 << endl;\n        } else {\n            cout << *(--it) << endl;\n            tickets.erase(it);\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.227950551293113,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Convex Hull",
            "category": "Geometry",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Point {\n    int x, y;\n};\n\n// Calculate the cross product of vectors OA and OB\nint crossProduct(Point O, Point A, Point B) {\n    return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);\n}\n\n// Calculate the squared distance between points A and B\nint squaredDistance(Point A, Point B) {\n    return (A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y);\n}\n\n// Compare two points based on their polar angle with respect to the starting point\nbool comparePoints(Point A, Point B) {\n    int cp = crossProduct({0, 0}, A, B);\n    if (cp != 0) return cp > 0;\n    return squaredDistance({0, 0}, A) < squaredDistance({0, 0}, B);\n}\n\n// Find the convex hull of a set of points using the Graham Scan algorithm\nvector<Point> convexHull(vector<Point> points) {\n    int n = points.size();\n    if (n <= 3) return points;\n\n    // Find the starting point\n    int start = 0;\n    for (int i = 1; i < n; i++) {\n        if (points[i].y < points[start].y || (points[i].y == points[start].y && points[i].x < points[start].x)) {\n            start = i;\n        }\n    }\n    swap(points[0], points[start]);\n\n    // Sort the remaining points in polar angle with respect to the starting point\n    sort(points.begin() + 1, points.end(), comparePoints);\n\n    // Initialize the stack with the starting point and the next two points\n    stack<Point> hull;\n    hull.push(points[0]);\n    hull.push(points[1]);\n    hull.push(points[2]);\n\n    // Iterate through the remaining points\n    for (int i = 3; i < n; i++) {\n        Point top = hull.top();\n        hull.pop();\n        // While the stack has more than one point and the last two points in the stack and the current point form a non-left turn, pop the last point from the stack\n        while (crossProduct(hull.top(), top, points[i]) <= 0) {\n            top = hull.top();\n            hull.pop();\n        }\n        // Push the current point to the stack\n        hull.push(top);\n        hull.push(points[i]);\n    }\n\n    // Convert the stack to a vector and return it\n    vector<Point> result;\n    while (!hull.empty()) {\n        result.push_back(hull.top());\n        hull.pop();\n    }\n    reverse(result.begin(), result.end());\n    return result;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> points(n);\n    for (int i = 0; i < n; i++) {\n        cin >> points[i].x >> points[i].y;\n    }\n    vector<Point> hull = convexHull(points);\n    cout << hull.size() << endl;\n    for (Point p : hull) {\n        cout << p.x << \" \" << p.y << endl;\n    }\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 9,
            "mean_time_taken": 0.15190137757195366,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Bishops",
            "category": "Additional Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Counting Bits",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <cmath>\n\n// Recursive function to count the number of one bits in the binary representation of a given number\nlong long countBits(long long n) {\n    // Base case: if n is less than 2, return n\n    if (n < 2) {\n        return n;\n    }\n    // Calculate the number of bits in n\n    long long bits = std::floor(std::log2(n));\n    // Calculate the number of one bits in the most significant bit of n\n    long long msb = (n - (1LL << bits));\n    // Recursively calculate the number of one bits in the remaining bits of n\n    long long remainingBits = countBits(msb);\n    // Return the sum of the number of one bits in the most significant bit and the remaining bits\n    return (1LL << (bits - 1)) * bits + msb + 1 + remainingBits;\n}\n\nint main() {\n    // Read the input value of n\n    long long n;\n    std::cin >> n;\n    // Call countBits to calculate the total number of one bits in the binary representations of integers between 1 and n\n    long long result = countBits(n);\n    // Print the result\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "passed_test_cases": 21,
            "total_test_cases": 21,
            "mean_time_taken": 0.0794564201718285,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Counting Coprime Pairs",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nconst int MAX_VALUE = 1000005;\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> count(MAX_VALUE, 0);\n    for (int i = 0; i < n; i++) {\n        int x;\n        std::cin >> x;\n        count[x]++;\n    }\n\n    long long result = 0;\n    for (int i = 1; i < MAX_VALUE; i++) {\n        if (count[i] > 0) {\n            long long pairs = count[i] * (n - count[i]);\n            for (int j = 2 * i; j < MAX_VALUE; j += i) {\n                pairs -= count[j];\n            }\n            result += pairs;\n        }\n    }\n\n    std::cout << result / 2 << std::endl;\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 8,
            "mean_time_taken": 0.10243594646453857,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Divisors",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <cmath>\n\nconst int MAX_NUMBER = 1000000;\nint divisor_count[MAX_NUMBER + 1];\n\nint main() {\n    // Initialize divisor_count array to 0\n    for (int i = 0; i <= MAX_NUMBER; i++) {\n        divisor_count[i] = 0;\n    }\n\n    // Count the number of divisors for each number from 1 to MAX_NUMBER\n    for (int i = 1; i <= MAX_NUMBER; i++) {\n        for (int j = 1; j * j <= i; j++) {\n            if (i % j == 0) {\n                if (j == i / j) {\n                    divisor_count[i]++;\n                } else {\n                    divisor_count[i] += 2;\n                }\n            }\n        }\n    }\n\n    int number_of_test_cases;\n    std::cin >> number_of_test_cases;\n\n    // For each test case, print the count of divisors for the input number\n    while (number_of_test_cases--) {\n        int input_number;\n        std::cin >> input_number;\n        std::cout << divisor_count[input_number] << std::endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 16,
            "mean_time_taken": 0.9819631576538086,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                7,
                13,
                14,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Grids",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nlong long power(long long base, long long exponent) {\n    long long result = 1;\n    while (exponent > 0) {\n        if (exponent % 2 == 1)\n            result = (result * base) % MOD;\n        base = (base * base) % MOD;\n        exponent /= 2;\n    }\n    return result;\n}\n\nlong long countGrids(long long n) {\n    long long totalGrids = power(2, n * n);\n    long long nonSymmetricGrids = (2 * (n * n / 2) * power(2, (n * n) - 1)) % MOD;\n    return (totalGrids - nonSymmetricGrids + MOD) % MOD;\n}\n\nint main() {\n    long long n;\n    cin >> n;\n    cout << countGrids(n) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 12,
            "mean_time_taken": 0.08201680580774943,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Necklaces",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n\n// Define a constant for the modulo value\nconst long long MOD = 1e9 + 7;\n\n// Function to calculate the power of a number modulo the modulo value\nlong long power(long long base, long long exponent) {\n    long long result = 1;\n    while (exponent > 0) {\n        if (exponent % 2 == 1) {\n            result = (result * base) % MOD;\n        }\n        base = (base * base) % MOD;\n        exponent /= 2;\n    }\n    return result;\n}\n\n// Function to calculate the number of different necklaces using dynamic programming\nlong long countNecklaces(int n, int m) {\n    std::vector<long long> dp(n + 1);\n    dp[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        dp[i] = m * dp[i - 1] % MOD;\n        if (i > 1) {\n            dp[i] = (dp[i] - dp[i - 2] + MOD) % MOD;\n        }\n    }\n    long long result = dp[n];\n    for (int i = 2; i <= n; i++) {\n        if (n % i == 0) {\n            result = (result + power(m, i) * dp[n / i]) % MOD;\n        }\n    }\n    return result;\n}\n\nint main() {\n    int n, m;\n    std::cin >> n >> m;\n    std::cout << countNecklaces(n, m) << std::endl;\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 10,
            "mean_time_taken": 0.08484096527099609,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                8,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Numbers",
            "category": "Dynamic Programming",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_DIGITS = 20;\nlong long dp[MAX_DIGITS][10][2];\n\nlong long solve(string num, bool is_limit) {\n    int n = num.size();\n    memset(dp, 0, sizeof(dp));\n    dp[0][0][1] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= 9; j++) {\n            for (int k = 0; k <= 1; k++) {\n                for (int d = 0; d <= 9; d++) {\n                    if (d != j) {\n                        dp[i][d][k || (d < num[i-1] - '0')] += dp[i-1][j][k];\n                    }\n                }\n            }\n        }\n    }\n    long long ans = 0;\n    for (int j = 0; j <= 9; j++) {\n        ans += dp[n][j][is_limit];\n    }\n    return ans;\n}\n\nint main() {\n    string a, b;\n    cin >> a >> b;\n    long long ans = solve(b, true) - solve(a, false);\n    cout << ans << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 16,
            "mean_time_taken": 0.07756714522838593,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Paths",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nvector<int> adj[MAX_N];\nunordered_map<int, unordered_map<int, int>> paths;\nint subtree_size[MAX_N];\nint ans[MAX_N];\n\nvoid dfs(int u, int p) {\n    subtree_size[u] = 1;\n    for (int v : adj[u]) {\n        if (v == p) continue;\n        dfs(v, u);\n        subtree_size[u] += subtree_size[v];\n        ans[u] += ans[v];\n        if (paths[u].count(v)) {\n            ans[u] += paths[u][v];\n            ans[v] -= paths[u][v];\n        }\n    }\n    ans[u] += paths[u].size();\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        paths[u][v]++;\n        paths[v][u]++;\n    }\n    dfs(1, 0);\n    for (int i = 1; i <= n; i++) {\n        cout << ans[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 13,
            "mean_time_taken": 0.3102669899280255,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Patterns",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to build the prefix function for a given pattern\nvector<int> buildPrefixFunction(const string& pattern) {\n    int n = pattern.size();\n    vector<int> prefixFunction(n, 0);\n    int j = 0;\n    for (int i = 1; i < n; i++) {\n        while (j > 0 && pattern[i] != pattern[j]) {\n            j = prefixFunction[j - 1];\n        }\n        if (pattern[i] == pattern[j]) {\n            j++;\n        }\n        prefixFunction[i] = j;\n    }\n    return prefixFunction;\n}\n\n// Function to find all occurrences of a pattern in a given string\nvector<int> findPatternOccurrences(const string& text, const string& pattern) {\n    vector<int> prefixFunction = buildPrefixFunction(pattern);\n    vector<int> occurrences;\n    int j = 0;\n    for (int i = 0; i < text.size(); i++) {\n        while (j > 0 && text[i] != pattern[j]) {\n            j = prefixFunction[j - 1];\n        }\n        if (text[i] == pattern[j]) {\n            j++;\n        }\n        if (j == pattern.size()) {\n            occurrences.push_back(i - j + 1);\n            j = prefixFunction[j - 1];\n        }\n    }\n    return occurrences;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    string text;\n    cin >> text;\n\n    int k;\n    cin >> k;\n\n    for (int i = 0; i < k; i++) {\n        string pattern;\n        cin >> pattern;\n        vector<int> occurrences = findPatternOccurrences(text, pattern);\n        cout << occurrences.size() << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 11,
            "mean_time_taken": 0.7742282910780474,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                7,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Reorders",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nconst int MOD = 1000000007;\nconst int MAX_N = 5000;\nconst int MAX_CHAR = 26;\n\nint dp[MAX_N + 1][MAX_CHAR];\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    std::string s;\n    std::cin >> s;\n    int n = s.length();\n\n    // Initialize dp[0][j] to 1 for all j\n    for (int j = 0; j < MAX_CHAR; ++j) {\n        dp[0][j] = 1;\n    }\n\n    // Calculate dp[i][j] for all i and j\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 0; j < MAX_CHAR; ++j) {\n            for (int k = 0; k < MAX_CHAR; ++k) {\n                if (k != j) {\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % MOD;\n                }\n            }\n        }\n    }\n\n    // Calculate the answer as the sum of dp[n][j] for all j\n    int answer = 0;\n    for (int j = 0; j < MAX_CHAR; ++j) {\n        answer = (answer + dp[n][j]) % MOD;\n    }\n\n    std::cout << answer << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 9,
            "mean_time_taken": 0.08961727884080675,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Rooms",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_SIZE = 1000;\nchar grid[MAX_SIZE][MAX_SIZE];\nbool visited[MAX_SIZE][MAX_SIZE];\nint n, m;\n\nvoid dfs(int x, int y) {\n    if (x < 0 || x >= n || y < 0 || y >= m || grid[x][y] == '#' || visited[x][y]) {\n        return;\n    }\n    visited[x][y] = true;\n    dfs(x + 1, y);\n    dfs(x - 1, y);\n    dfs(x, y + 1);\n    dfs(x, y - 1);\n}\n\nint main() {\n    cin >> n >> m;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n            visited[i][j] = false;\n        }\n    }\n    int roomCount = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == '.' && !visited[i][j]) {\n                roomCount++;\n                dfs(i, j);\n            }\n        }\n    }\n    cout << roomCount << endl;\n    return 0;\n}\n",
            "passed_test_cases": 16,
            "total_test_cases": 19,
            "mean_time_taken": 0.09948835874858655,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                7,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Sequences",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#define MOD 1000000007\nusing namespace std;\n\n// Function to calculate power of a number\nlong long power(long long base, long long exponent) {\n    long long result = 1;\n    while (exponent > 0) {\n        if (exponent % 2 == 1)\n            result = (result * base) % MOD;\n        base = (base * base) % MOD;\n        exponent = exponent / 2;\n    }\n    return result;\n}\n\n// Function to calculate factorial of a number\nlong long factorial(long long n) {\n    long long result = 1;\n    for (long long i = 2; i <= n; i++)\n        result = (result * i) % MOD;\n    return result;\n}\n\n// Function to calculate combination of two numbers\nlong long combination(long long n, long long r) {\n    long long num = factorial(n);\n    long long den = (factorial(r) * factorial(n - r)) % MOD;\n    return (num * power(den, MOD - 2)) % MOD;\n}\n\n// Function to calculate number of sequences\nlong long countSequences(long long n, long long k) {\n    long long result = combination(n, k) * factorial(k);\n    for (long long i = 1; i < k; i++) {\n        long long sign = (i % 2 == 0) ? 1 : -1;\n        long long term = combination(k, i) * power(k - i, n) % MOD;\n        result = (result + sign * term + MOD) % MOD;\n    }\n    return result;\n}\n\nint main() {\n    long long n, k;\n    cin >> n >> k;\n    cout << countSequences(n, k) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 10,
            "mean_time_taken": 0.2701225757598877,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Tilings",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n\nconst int MOD = 1000000007;\n\nint main() {\n    int rows, columns;\n    std::cin >> rows >> columns;\n\n    // Initialize a 2D array to store the number of ways to fill the grid\n    std::vector<std::vector<long long>> grid(rows + 1, std::vector<long long>(columns + 1));\n\n    // Set the base cases for the dynamic programming array\n    grid[0][0] = 1;\n\n    // Iterate through the grid using dynamic programming\n    for (int i = 0; i <= rows; i++) {\n        for (int j = 0; j <= columns; j++) {\n            // Calculate the number of ways to fill each cell based on the number of ways to fill the previous cells\n            if (i > 0) {\n                grid[i][j] = (grid[i][j] + grid[i - 1][j] * 2) % MOD;\n            }\n            if (j > 0) {\n                grid[i][j] = (grid[i][j] + grid[i][j - 1] * 2) % MOD;\n            }\n            if (i > 0 && j > 0) {\n                grid[i][j] = (grid[i][j] - grid[i - 1][j - 1]) % MOD;\n                if (grid[i][j] < 0) {\n                    grid[i][j] += MOD;\n                }\n            }\n        }\n    }\n\n    // Print the result modulo 10^9+7\n    std::cout << grid[rows][columns] << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.08103327751159668,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Towers",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    std::vector<long long> towers(1000001);\n    towers[1] = 2;\n    towers[2] = 8;\n\n    // Calculate the number of towers for each height using dynamic programming\n    for (int i = 3; i <= 1000000; i++) {\n        towers[i] = (towers[i - 1] * 4 + towers[i - 2]) % MOD;\n    }\n\n    int num_test_cases;\n    std::cin >> num_test_cases;\n\n    // Print the number of towers for each test case\n    while (num_test_cases--) {\n        int height;\n        std::cin >> height;\n        std::cout << towers[height] << std::endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.09343588352203369,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Course Schedule",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nconst int MAX_NODES = 100005;\n\nvector<int> graph[MAX_NODES];\nint visited[MAX_NODES];\nstack<int> order;\n\nbool dfs(int node) {\n    visited[node] = 1;\n    for (int neighbor : graph[node]) {\n        if (visited[neighbor] == 1) {\n            return false;\n        }\n        if (visited[neighbor] == 0 && !dfs(neighbor)) {\n            return false;\n        }\n    }\n    visited[node] = 2;\n    order.push(node);\n    return true;\n}\n\nint main() {\n    int num_nodes, num_edges;\n    cin >> num_nodes >> num_edges;\n    for (int i = 0; i < num_edges; i++) {\n        int node1, node2;\n        cin >> node1 >> node2;\n        graph[node1].push_back(node2);\n    }\n    for (int i = 1; i <= num_nodes; i++) {\n        if (visited[i] == 0 && !dfs(i)) {\n            cout << \"IMPOSSIBLE\" << endl;\n            return 0;\n        }\n    }\n    while (!order.empty()) {\n        cout << order.top() << \" \";\n        order.pop();\n    }\n    cout << endl;\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 16,
            "mean_time_taken": 0.12434720993041992,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                5,
                6,
                8,
                9,
                10,
                11,
                12,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Course Schedule II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nvector<int> course_schedule(int n, vector<pair<int, int>>& prerequisites) {\n    vector<vector<int>> graph(n);\n    vector<int> in_degree(n, 0);\n\n    for (auto& p : prerequisites) {\n        graph[p.second - 1].push_back(p.first - 1);\n        in_degree[p.first - 1]++;\n    }\n\n    queue<int> q;\n    for (int i = 0; i < n; i++) {\n        if (in_degree[i] == 0) {\n            q.push(i);\n        }\n    }\n\n    vector<int> result;\n    while (!q.empty()) {\n        int course = q.front();\n        q.pop();\n        result.push_back(course + 1);\n\n        for (int next_course : graph[course]) {\n            in_degree[next_course]--;\n            if (in_degree[next_course] == 0) {\n                q.push(next_course);\n            }\n        }\n    }\n\n    if (result.size() < n) {\n        return {};\n    }\n\n    return result;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<pair<int, int>> prerequisites(m);\n    for (int i = 0; i < m; i++) {\n        cin >> prerequisites[i].first >> prerequisites[i].second;\n    }\n\n    vector<int> result = course_schedule(n, prerequisites);\n\n    for (int course : result) {\n        cout << course << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 8,
            "mean_time_taken": 0.12198039889335632,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Creating Offices",
            "category": "Additional Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Creating Strings",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <set>\n#include <string>\n\nstd::set<std::string> permutations;\n\nvoid generate_permutations(std::string& str, int index) {\n    if (index == str.length()) {\n        permutations.insert(str);\n        return;\n    }\n    for (int i = index; i < str.length(); i++) {\n        std::swap(str[index], str[i]);\n        generate_permutations(str, index + 1);\n        std::swap(str[index], str[i]);\n    }\n}\n\nint main() {\n    std::string input_string;\n    std::cin >> input_string;\n    generate_permutations(input_string, 0);\n    std::cout << permutations.size() << std::endl;\n    for (const auto& permutation : permutations) {\n        std::cout << permutation << std::endl;\n    }\n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 6,
            "mean_time_taken": 0.09400264422098796,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Creating Strings II",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAX_CHAR = 26;\nconst int MOD = 1000000007;\n\n// Function to calculate power with modulo\nlong long power(long long base, long long exponent) {\n    long long result = 1;\n    while (exponent > 0) {\n        if (exponent % 2 == 1)\n            result = (result * base) % MOD;\n        base = (base * base) % MOD;\n        exponent = exponent / 2;\n    }\n    return result;\n}\n\n// Function to calculate factorial with modulo\nlong long factorial(long long n) {\n    long long result = 1;\n    for (long long i = 2; i <= n; i++)\n        result = (result * i) % MOD;\n    return result;\n}\n\n// Function to calculate number of unique strings\nlong long countStrings(string s) {\n    long long n = s.length();\n    vector<long long> count(MAX_CHAR, 0);\n\n    // Count frequency of each character\n    for (long long i = 0; i < n; i++)\n        count[s[i] - 'a']++;\n\n    long long result = factorial(n);\n\n    // Divide by factorial of count of each character\n    for (long long i = 0; i < MAX_CHAR; i++)\n        if (count[i] > 0)\n            result = (result * power(factorial(count[i]), MOD - 2)) % MOD;\n\n    return result;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    cout << countStrings(s) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.08889959255854289,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Critical Cities",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_NODES = 100005;\nvector<int> graph[MAX_NODES];\nint discovery[MAX_NODES], low[MAX_NODES], visited[MAX_NODES];\nstack<int> nodeStack;\nint numNodes, numEdges, currentNode, adjacentNode, counter;\n\nvoid tarjan(int node) {\n    discovery[node] = low[node] = ++counter;\n    nodeStack.push(node);\n    visited[node] = 1;\n    for (int i = 0; i < graph[node].size(); i++) {\n        int nextNode = graph[node][i];\n        if (!discovery[nextNode]) {\n            tarjan(nextNode);\n            low[node] = min(low[node], low[nextNode]);\n        } else if (visited[nextNode]) {\n            low[node] = min(low[node], discovery[nextNode]);\n        }\n    }\n    if (low[node] == discovery[node]) {\n        while (nodeStack.top() != node) {\n            visited[nodeStack.top()] = 0;\n            nodeStack.pop();\n        }\n        visited[nodeStack.top()] = 0;\n        nodeStack.pop();\n    }\n}\n\nint main() {\n    scanf(\"%d%d\", &numNodes, &numEdges);\n    for (int i = 0; i < numEdges; i++) {\n        scanf(\"%d%d\", &currentNode, &adjacentNode);\n        graph[currentNode].push_back(adjacentNode);\n    }\n    tarjan(1);\n    counter = 0;\n    for (int i = 1; i <= numNodes; i++) {\n        if (visited[i]) counter++;\n    }\n    printf(\"%d\\n\", counter);\n    for (int i = 1; i <= numNodes; i++) {\n        if (visited[i]) printf(\"%d \", i);\n    }\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 14,
            "mean_time_taken": 0.10116331917898995,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Cut and Paste",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <deque>\n#include <string>\n\nint main() {\n    int n, m;\n    std::cin >> n >> m;\n\n    std::string s;\n    std::cin >> s;\n\n    std::deque<char> d(s.begin(), s.end());\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        std::cin >> a >> b;\n\n        // Cut the substring from position a to position b\n        std::deque<char> substring(d.begin() + a - 1, d.begin() + b);\n        d.erase(d.begin() + a - 1, d.begin() + b);\n\n        // Paste the substring to the end of the string\n        d.insert(d.end(), substring.begin(), substring.end());\n    }\n\n    // Concatenate all the characters in the deque to obtain the final string\n    std::string result(d.begin(), d.end());\n    std::cout << result << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 7,
            "mean_time_taken": 0.6164484024047852,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Cycle Finding",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_NODES = 2505;\nconst long long INF = 1e18;\n\nint numNodes, numEdges;\nint startNode, endNode, weight;\nlong long distance[MAX_NODES];\nvector<int> edges[MAX_NODES];\nvector<int> weights[MAX_NODES];\nvector<int> path;\n\nvoid bellmanFord(int source) {\n    for (int i = 1; i <= numNodes; i++) distance[i] = INF;\n    distance[source] = 0;\n    int lastUpdatedNode = -1;\n\n    for (int i = 1; i <= numNodes; i++) {\n        for (int u = 1; u <= numNodes; u++) {\n            for (int j = 0; j < edges[u].size(); j++) {\n                int v = edges[u][j];\n                int w = weights[u][j];\n                if (distance[u] + w < distance[v]) {\n                    distance[v] = distance[u] + w;\n                    if (i == numNodes) lastUpdatedNode = v;\n                }\n            }\n        }\n    }\n\n    if (lastUpdatedNode == -1) {\n        cout << \"NO\";\n        return;\n    }\n\n    for (int i = 1; i <= numNodes; i++) lastUpdatedNode = edges[lastUpdatedNode][0];\n    int currentNode = lastUpdatedNode;\n\n    while (true) {\n        path.push_back(currentNode);\n        if (currentNode == lastUpdatedNode && path.size() > 1) break;\n        currentNode = edges[currentNode][0];\n    }\n\n    reverse(path.begin(), path.end());\n    cout << \"YES\\n\";\n    for (int i = 0; i < path.size(); i++) cout << path[i] << \" \";\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> numNodes >> numEdges;\n    for (int i = 1; i <= numEdges; i++) {\n        cin >> startNode >> endNode >> weight;\n        edges[startNode].push_back(endNode);\n        weights[startNode].push_back(weight);\n    }\n\n    bellmanFord(1);\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Cyclic Array",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    int count = 0;\n    int sum = 0;\n    int start = 0;\n\n    for (int end = 0; end < 2 * n; end++) {\n        sum += arr[end % n];\n\n        while (sum > k) {\n            sum -= arr[start % n];\n            start++;\n        }\n\n        if (end - start + 1 == n) {\n            count++;\n            break;\n        }\n\n        if (end >= n - 1) {\n            count++;\n            sum = 0;\n            start = end + 1;\n        }\n    }\n\n    cout << count << endl;\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 21,
            "mean_time_taken": 0.08600812866574242,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                9,
                10,
                12,
                13,
                14,
                15,
                17,
                18,
                19
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "De Bruijn Sequence",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_SIZE = 1000000;\nint sequence[MAX_SIZE];\nint sequenceLength;\n\nvoid depthFirstSearch(int currentPosition, int previousNode, int firstNode) {\n    if (currentPosition == sequenceLength) {\n        for (int i = 0; i < sequenceLength - firstNode; i++) {\n            cout << sequence[i];\n        }\n        cout << endl;\n    } else {\n        int currentNode = (previousNode << 1) | (currentPosition & 1);\n        if (currentNode < sequenceLength) {\n            sequence[currentPosition] = currentNode & 1;\n            depthFirstSearch(currentPosition + 1, currentNode, firstNode);\n        } else {\n            sequence[currentPosition] = sequence[currentPosition - firstNode];\n            depthFirstSearch(currentPosition + 1, previousNode, currentPosition - firstNode + 1);\n        }\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    sequenceLength = 1 << n;\n    fill_n(sequence, MAX_SIZE, 0);\n    depthFirstSearch(0, 0, 0);\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.08291358947753906,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Dice Combinations",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countWays(int n) {\n    vector<int> dp(n + 1, 0);\n    dp[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= 6 && j <= i; j++) {\n            dp[i] = (dp[i] + dp[i - j]) % MOD;\n        }\n    }\n    return dp[n];\n}\n\nint main() {\n    int n;\n    cin >> n;\n    cout << countWays(n) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 20,
            "total_test_cases": 20,
            "mean_time_taken": 0.08627791404724121,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Dice Probability",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n\nconst int MAX_N = 101;\nconst int MAX_SUM = 601;\nconst int TOTAL_OUTCOMES = 6;\n\ndouble dp[MAX_N][MAX_N][MAX_SUM];\n\nint main() {\n    int n, a, b;\n    std::cin >> n >> a >> b;\n\n    // Initialize base cases\n    dp[0][0][0] = 1.0;\n\n    // Calculate probabilities using dynamic programming\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= i; ++j) {\n            for (int k = 1; k <= TOTAL_OUTCOMES * i; ++k) {\n                for (int l = 1; l <= TOTAL_OUTCOMES; ++l) {\n                    if (k - l >= 0) {\n                        dp[i][j][k] += dp[i - 1][j - 1][k - l];\n                    }\n                }\n                dp[i][j][k] /= TOTAL_OUTCOMES;\n            }\n        }\n    }\n\n    // Calculate final probability\n    double finalProbability = 0.0;\n    for (int i = a; i <= b; ++i) {\n        finalProbability += dp[n][n][i];\n    }\n\n    // Print final probability rounded to six decimal places\n    std::cout << std::fixed << std::setprecision(6) << finalProbability << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 17,
            "total_test_cases": 17,
            "mean_time_taken": 0.08823251724243164,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Digit Queries",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int q;\n    cin >> q;\n\n    while (q--) {\n        long long k;\n        cin >> k;\n\n        long long digits = 1, start = 1;\n        while (k > digits * 9 * start) {\n            k -= digits * 9 * start;\n            digits++;\n            start *= 10;\n        }\n\n        long long num = start + (k - 1) / digits;\n        int digit_index = (k - 1) % digits;\n\n        while (digit_index--) {\n            num /= 10;\n        }\n\n        cout << num % 10 << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.08674132823944092,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distance Queries",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nconst int MAX_LOG = 20;\n\nvector<int> adj[MAX_N];\nint depth[MAX_N];\nint ancestor[MAX_N][MAX_LOG];\n\nvoid dfs(int u, int p) {\n    for (int v : adj[u]) {\n        if (v == p) continue;\n        depth[v] = depth[u] + 1;\n        ancestor[v][0] = u;\n        for (int i = 1; i < MAX_LOG; i++) {\n            ancestor[v][i] = ancestor[ancestor[v][i - 1]][i - 1];\n        }\n        dfs(v, u);\n    }\n}\n\nint lca(int u, int v) {\n    if (depth[u] < depth[v]) swap(u, v);\n    int k = depth[u] - depth[v];\n    for (int i = 0; i < MAX_LOG; i++) {\n        if (k & (1 << i)) {\n            u = ancestor[u][i];\n        }\n    }\n    if (u == v) return u;\n    for (int i = MAX_LOG - 1; i >= 0; i--) {\n        if (ancestor[u][i] != ancestor[v][i]) {\n            u = ancestor[u][i];\n            v = ancestor[v][i];\n        }\n    }\n    return ancestor[u][0];\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    depth[1] = 0;\n    dfs(1, 0);\n    while (q--) {\n        int u, v;\n        cin >> u >> v;\n        int l = lca(u, v);\n        cout << depth[u] + depth[v] - 2 * depth[l] << \"\\n\";\n    }\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 11,
            "mean_time_taken": 0.1535877747969194,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Colors",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\n\nvector<int> adj[MAX_N];\nint color[MAX_N];\nint subtree_size[MAX_N];\n\nvoid dfs(int node, int parent) {\n    set<int> colors;\n    for (int child : adj[node]) {\n        if (child != parent) {\n            dfs(child, node);\n            for (int c : colors) {\n                subtree_size[c]--;\n            }\n            for (int c : subtree_size) {\n                if (c > 0) {\n                    colors.insert(c);\n                }\n            }\n        }\n    }\n    subtree_size[color[node]]++;\n    colors.insert(color[node]);\n    subtree_size[node] = colors.size();\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> color[i];\n    }\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(1, 0);\n    for (int i = 1; i <= n; i++) {\n        cout << subtree_size[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.19635898272196453,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Numbers",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <set>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::set<int> s;\n    for (int i = 0; i < n; i++) {\n        int x;\n        std::cin >> x;\n        s.insert(x);\n    }\n\n    std::cout << s.size() << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 15,
            "total_test_cases": 15,
            "mean_time_taken": 0.13993266423543294,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Distinct Routes",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_NODES = 505;\n\nvector<int> graph[MAX_NODES];\nset<vector<int>> paths;\nvector<int> currentPath;\nbool visited[MAX_NODES];\n\nvoid dfs(int node, int endNode) {\n    visited[node] = true;\n    currentPath.push_back(node);\n\n    if (node == endNode) {\n        paths.insert(currentPath);\n    } else {\n        for (int neighbor : graph[node]) {\n            if (!visited[neighbor]) {\n                dfs(neighbor, endNode);\n            }\n        }\n    }\n\n    visited[node] = false;\n    currentPath.pop_back();\n}\n\nint main() {\n    int numNodes, numEdges;\n    cin >> numNodes >> numEdges;\n\n    for (int i = 0; i < numEdges; i++) {\n        int node1, node2;\n        cin >> node1 >> node2;\n        graph[node1].push_back(node2);\n    }\n\n    dfs(1, numNodes);\n\n    cout << paths.size() << endl;\n\n    for (const auto& path : paths) {\n        for (int node : path) {\n            cout << node << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 18,
            "mean_time_taken": 0.29321979151831734,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                12,
                13,
                14,
                15,
                16,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Routes II",
            "category": "Advanced Techniques",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Distinct Substrings",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <unordered_map>\n#include <string>\n\nusing namespace std;\n\nstruct TrieNode {\n    unordered_map<char, TrieNode*> children;\n};\n\nint countDistinctSubstrings(string s) {\n    TrieNode* root = new TrieNode();\n    int count = 0;\n\n    for (int i = 0; i < s.length(); i++) {\n        TrieNode* node = root;\n        for (int j = i; j < s.length(); j++) {\n            if (node->children.find(s[j]) == node->children.end()) {\n                node->children[s[j]] = new TrieNode();\n                count++;\n            }\n            node = node->children[s[j]];\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    cout << countDistinctSubstrings(s) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 7,
            "mean_time_taken": 0.883481536592756,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'St9bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Values Queries",
            "category": "Range Queries",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Define constants and global variables\nconst int MAX_N = 200005;\nconst int MAX_M = 18;\nint arraySize, numberOfQueries;\nint inputArray[MAX_N];\nint lastOccurrence[MAX_N];\nint segmentTree[MAX_N * 4];\nint ancestor[MAX_N][MAX_M];\n\n// Function to calculate the greatest common divisor (GCD)\nint gcd(int a, int b) {\n    return b ? gcd(b, a % b) : a;\n}\n\n// Function to calculate the lowest common ancestor (LCA)\nint lca(int u, int v) {\n    if (u == v) return u;\n    for (int i = MAX_M - 1; i >= 0; i--) {\n        if (ancestor[u][i] != ancestor[v][i]) {\n            u = ancestor[u][i];\n            v = ancestor[v][i];\n        }\n    }\n    return ancestor[u][0];\n}\n\n// Function to update the segment tree\nvoid update(int node, int start, int end, int index, int value) {\n    if (start == end) {\n        segmentTree[node] = value;\n        return;\n    }\n    int mid = (start + end) / 2;\n    if (index <= mid)\n        update(node * 2, start, mid, index, value);\n    else\n        update(node * 2 + 1, mid + 1, end, index, value);\n    segmentTree[node] = gcd(segmentTree[node * 2], segmentTree[node * 2 + 1]);\n}\n\n// Function to query the segment tree\nint query(int node, int start, int end, int left, int right) {\n    if (start > right || end < left) return 0;\n    if (start >= left && end <= right) return segmentTree[node];\n    int mid = (start + end) / 2;\n    return gcd(query(node * 2, start, mid, left, right), query(node * 2 + 1, mid + 1, end, left, right));\n}\n\n// Function to calculate the depth of a node in the segment tree\nint depth(int node) {\n    return 31 - __builtin_clz(node);\n}\n\n// Function to process the input and output the results\nint main() {\n    scanf(\"%d%d\", &arraySize, &numberOfQueries);\n    for (int i = 1; i <= arraySize; i++) {\n        scanf(\"%d\", &inputArray[i]);\n        ancestor[i][0] = lastOccurrence[inputArray[i]];\n        lastOccurrence[inputArray[i]] = i;\n        for (int j = 1; j < MAX_M; j++) {\n            ancestor[i][j] = ancestor[ancestor[i][j - 1]][j - 1];\n        }\n    }\n    for (int i = 1; i <= arraySize; i++) {\n        update(1, 1, arraySize, i, inputArray[i]);\n    }\n    while (numberOfQueries--) {\n        int left, right;\n        scanf(\"%d%d\", &left, &right);\n        int ancestorNode = lca(left, right);\n        int answer = gcd(query(1, 1, arraySize, left, ancestorNode), query(1, 1, arraySize, right, ancestorNode));\n        int leftAncestor = ancestorNode;\n        int rightAncestor = ancestorNode;\n        for (int i = MAX_M - 1; i >= 0; i--) {\n            if (ancestor[leftAncestor][i] > ancestorNode && depth(leftAncestor - ancestor[leftAncestor][i]) >= depth(left - ancestorNode)) {\n                leftAncestor = ancestor[leftAncestor][i];\n                answer = gcd(answer, query(1, 1, arraySize, leftAncestor + 1, left));\n            }\n            if (ancestor[rightAncestor][i] > ancestorNode && depth(rightAncestor - ancestor[rightAncestor][i]) >= depth(right - ancestorNode)) {\n                rightAncestor = ancestor[rightAncestor][i];\n                answer = gcd(answer, query(1, 1, arraySize, rightAncestor + 1, right));\n            }\n        }\n        printf(\"%d\\n\", (right - left + 1) - (lower_bound(inputArray + left, inputArray + right + 1, answer) - (inputArray + left)));\n    }\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 14,
            "mean_time_taken": 0.14311623573303223,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distributing Apples",
            "category": "Mathematics",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Divisor Analysis",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\n// Function to calculate (base^exponent) % MOD\nlong long power(long long base, long long exponent) {\n    long long result = 1;\n    while (exponent > 0) {\n        if (exponent % 2 == 1)\n            result = (result * base) % MOD;\n        base = (base * base) % MOD;\n        exponent /= 2;\n    }\n    return result;\n}\n\n// Function to calculate the number of divisors, sum of divisors, and product of divisors\nvoid divisorAnalysis(vector<pair<int, int>>& primeFactors) {\n    long long numDivisors = 1, sumDivisors = 1, productDivisors = 1;\n    for (auto& factor : primeFactors) {\n        int prime = factor.first, exponent = factor.second;\n        numDivisors = (numDivisors * (exponent + 1)) % MOD;\n        sumDivisors = (sumDivisors * (power(prime, exponent + 1) - 1 + MOD) * power(prime - 1, MOD - 2)) % MOD;\n        productDivisors = (productDivisors * power(prime, exponent * (exponent + 1) / 2)) % MOD;\n    }\n    cout << numDivisors << \" \" << sumDivisors << \" \" << productDivisors << endl;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<pair<int, int>> primeFactors(n);\n    for (int i = 0; i < n; i++) {\n        cin >> primeFactors[i].first >> primeFactors[i].second;\n    }\n    divisorAnalysis(primeFactors);\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 7,
            "mean_time_taken": 0.09819511004856654,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Download Speed",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_NODES = 505;\nconst long long INF = 1e18;\n\nint numNodes, numEdges;\nlong long capacity[MAX_NODES][MAX_NODES];\nlong long flow[MAX_NODES][MAX_NODES];\nlong long distance[MAX_NODES];\nbool visited[MAX_NODES];\n\n// Function to find the shortest path from the source to the sink using the Bellman-Ford algorithm\nvoid bellmanFord(int source) {\n  for (int i = 1; i <= numNodes; i++) {\n    distance[i] = INF;\n  }\n  distance[source] = 0;\n  for (int i = 1; i <= numNodes - 1; i++) {\n    for (int j = 1; j <= numNodes; j++) {\n      for (int k = 1; k <= numNodes; k++) {\n        if (distance[j] < INF && capacity[j][k] > 0) {\n          distance[k] = min(distance[k], distance[j] + flow[j][k] - flow[k][j]);\n        }\n      }\n    }\n  }\n}\n\n// Function to find the maximum flow in the network using the Ford-Fulkerson algorithm\nlong long fordFulkerson(int source, int sink) {\n  long long totalFlow = 0;\n  while (true) {\n    bellmanFord(source);\n    if (distance[sink] >= 0) {\n      break;\n    }\n    memset(visited, 0, sizeof(visited));\n    queue<int> nodeQueue;\n    nodeQueue.push(source);\n    visited[source] = true;\n    while (!nodeQueue.empty()) {\n      int currentNode = nodeQueue.front();\n      nodeQueue.pop();\n      for (int nextNode = 1; nextNode <= numNodes; nextNode++) {\n        if (!visited[nextNode] && capacity[currentNode][nextNode] > 0 && distance[currentNode] + flow[currentNode][nextNode] - flow[nextNode][currentNode] == distance[nextNode]) {\n          visited[nextNode] = true;\n          nodeQueue.push(nextNode);\n        }\n      }\n    }\n    if (!visited[sink]) {\n      break;\n    }\n    long long minFlow = INF;\n    int currentNode = sink;\n    while (currentNode != source) {\n      int previousNode = -1;\n      for (int i = 1; i <= numNodes; i++) {\n        if (capacity[i][currentNode] > 0 && distance[i] + flow[i][currentNode] - flow[currentNode][i] == distance[currentNode] - 1) {\n          previousNode = i;\n          break;\n        }\n      }\n      minFlow = min(minFlow, capacity[previousNode][currentNode]);\n      currentNode = previousNode;\n    }\n    currentNode = sink;\n    while (currentNode != source) {\n      int previousNode = -1;\n      for (int i = 1; i <= numNodes; i++) {\n        if (capacity[i][currentNode] > 0 && distance[i] + flow[i][currentNode] - flow[currentNode][i] == distance[currentNode] - 1) {\n          previousNode = i;\n          break;\n        }\n      }\n      flow[previousNode][currentNode] += minFlow;\n      flow[currentNode][previousNode] -= minFlow;\n      currentNode = previousNode;\n    }\n    totalFlow += minFlow;\n  }\n  return totalFlow;\n}\n\nint main() {\n  scanf(\"%d%d\", &numNodes, &numEdges);\n  for (int i = 1; i <= numEdges; i++) {\n    int node1, node2, edgeCapacity;\n    scanf(\"%d%d%d\", &node1, &node2, &edgeCapacity);\n    capacity[node1][node2] = edgeCapacity;\n  }\n  printf(\"%lld\\n\", fordFulkerson(1, numNodes));\n  return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Dynamic Connectivity",
            "category": "Advanced Techniques",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Dynamic Range Minimum Queries",
            "category": "Range Queries",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Define the segment tree data structure\nstruct SegmentTree {\n    int size;\n    vector<int> tree;\n\n    // Initialize the segment tree with the input array\n    void init(int n) {\n        size = 1;\n        while (size < n) size <<= 1;\n        tree.assign(2 * size, INT_MAX);\n    }\n\n    // Update the value at the specified position in the segment tree\n    void update(int pos, int val) {\n        pos += size;\n        tree[pos] = val;\n        while (pos > 1) {\n            pos >>= 1;\n            tree[pos] = min(tree[2 * pos], tree[2 * pos + 1]);\n        }\n    }\n\n    // Find the minimum value in the specified range using the segment tree\n    int query(int l, int r) {\n        l += size;\n        r += size;\n        int res = INT_MAX;\n        while (l <= r) {\n            if (l & 1) res = min(res, tree[l++]);\n            if (!(r & 1)) res = min(res, tree[r--]);\n            l >>= 1;\n            r >>= 1;\n        }\n        return res;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n\n    SegmentTree st;\n    st.init(n);\n\n    // Initialize the segment tree with the input array\n    for (int i = 0; i < n; i++) {\n        int val;\n        cin >> val;\n        st.update(i, val);\n    }\n\n    // Process each query\n    for (int i = 0; i < q; i++) {\n        int type, a, b;\n        cin >> type >> a >> b;\n        a--;\n        if (type == 1) {\n            // Update the value at the specified position\n            st.update(a, b);\n        } else {\n            // Find the minimum value in the specified range\n            b--;\n            cout << st.query(a, b) << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 2,
            "mean_time_taken": 0.14783167839050293,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Dynamic Range Sum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Define a structure for the segment tree node\nstruct SegmentTreeNode {\n    long long sum;\n    long long flag;\n};\n\n// Build the segment tree from the input array\nvoid buildSegmentTree(vector<SegmentTreeNode>& tree, const vector<long long>& arr, int node, int start, int end) {\n    if (start == end) {\n        tree[node].sum = arr[start];\n    } else {\n        int mid = (start + end) / 2;\n        buildSegmentTree(tree, arr, 2 * node, start, mid);\n        buildSegmentTree(tree, arr, 2 * node + 1, mid + 1, end);\n        tree[node].sum = tree[2 * node].sum + tree[2 * node + 1].sum;\n    }\n}\n\n// Update the value at a specific position in the array and propagate the update to the corresponding segment tree nodes\nvoid updateSegmentTree(vector<SegmentTreeNode>& tree, int node, int start, int end, int idx, long long val) {\n    if (start == end) {\n        tree[node].sum = val;\n        tree[node].flag = 0;\n    } else {\n        int mid = (start + end) / 2;\n        if (idx <= mid) {\n            updateSegmentTree(tree, 2 * node, start, mid, idx, val);\n        } else {\n            updateSegmentTree(tree, 2 * node + 1, mid + 1, end, idx, val);\n        }\n        tree[node].sum = tree[2 * node].sum + tree[2 * node + 1].sum;\n    }\n}\n\n// Query the sum of values in a given range using the segment tree\nlong long querySegmentTree(vector<SegmentTreeNode>& tree, int node, int start, int end, int l, int r) {\n    if (r < start || end < l) {\n        return 0;\n    }\n    if (l <= start && end <= r) {\n        return tree[node].sum;\n    }\n    int mid = (start + end) / 2;\n    return querySegmentTree(tree, 2 * node, start, mid, l, r) + querySegmentTree(tree, 2 * node + 1, mid + 1, end, l, r);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n\n    vector<long long> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    vector<SegmentTreeNode> tree(4 * n);\n    buildSegmentTree(tree, arr, 1, 0, n - 1);\n\n    for (int i = 0; i < q; i++) {\n        int type, a, b;\n        cin >> type >> a >> b;\n\n        if (type == 1) {\n            updateSegmentTree(tree, 1, 0, n - 1, a - 1, b);\n        } else {\n            cout << querySegmentTree(tree, 1, 0, n - 1, a - 1, b - 1) << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 2,
            "mean_time_taken": 0.14953649044036865,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Edit Distance",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nint editDistance(const std::string& word1, const std::string& word2) {\n    int n = word1.length();\n    int m = word2.length();\n\n    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(m + 1));\n\n    for (int i = 0; i <= n; i++) {\n        dp[i][0] = i;\n    }\n    for (int j = 0; j <= m; j++) {\n        dp[0][j] = j;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            if (word1[i - 1] == word2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = std::min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]}) + 1;\n            }\n        }\n    }\n\n    return dp[n][m];\n}\n\nint main() {\n    std::string word1, word2;\n    std::cin >> word1 >> word2;\n    std::cout << editDistance(word1, word2) << std::endl;\n    return 0;\n}\n",
            "passed_test_cases": 17,
            "total_test_cases": 17,
            "mean_time_taken": 0.2828824940849753,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Elevator Rides",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> weights(n);\n    for (int i = 0; i < n; i++) {\n        cin >> weights[i];\n    }\n\n    vector<int> dp(1 << n, n + 1);\n    dp[0] = 0;\n\n    for (int mask = 0; mask < (1 << n); mask++) {\n        int totalWeight = 0;\n        for (int i = 0; i < n; i++) {\n            if (mask & (1 << i)) {\n                totalWeight += weights[i];\n            }\n        }\n\n        if (totalWeight > x) {\n            continue;\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (!(mask & (1 << i))) {\n                dp[mask | (1 << i)] = min(dp[mask | (1 << i)], dp[mask] + 1);\n            }\n        }\n    }\n\n    cout << dp[(1 << n) - 1] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 39,
            "mean_time_taken": 0.139985170119848,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                35,
                36,
                37,
                38,
                39
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Empty String",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#define MOD 1000000007\n\nusing namespace std;\n\nchar inputString[505];\nlong long dp[505][505];\n\nint main() {\n    scanf(\"%s\", inputString);\n    int stringLength = strlen(inputString);\n\n    // Iterate through the input string from right to left\n    for (int i = stringLength - 1; i >= 0; i--) {\n        dp[i][i] = 1; // Set dp[i][i] to 1 for single characters\n\n        // Iterate through substrings of length 2 to n\n        for (int len = 2; len <= stringLength - i; len++) {\n            dp[i][i + len - 1] = (dp[i + 1][i + len - 1] + dp[i][i + len - 2]) % MOD; // Set dp[i][i+len-1] to the sum of dp[i+1][i+len-1] and dp[i][i+len-2]\n\n            // If the first and last characters of the substring are equal\n            if (inputString[i] == inputString[i + len - 1]) {\n                // Iterate through all possible positions to split the substring\n                for (int k = i + 1; k < i + len - 1; k++) {\n                    // Add the number of ways to remove the characters from the two non-empty substrings\n                    dp[i][i + len - 1] = (dp[i][i + len - 1] + dp[i + 1][k] * dp[k + 1][i + len - 1]) % MOD;\n                }\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", dp[0][stringLength - 1]); // Print the result\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.09308530886967976,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Eulerian Subgraphs",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1e5 + 5;\nconst int MOD = 1e9 + 7;\n\nint parent[MAX_N], rank[MAX_N], degree[MAX_N];\n\nint find_parent(int node) {\n    if (parent[node] == node) return node;\n    return parent[node] = find_parent(parent[node]);\n}\n\nvoid union_sets(int node1, int node2) {\n    int parent1 = find_parent(node1);\n    int parent2 = find_parent(node2);\n    if (parent1 == parent2) return;\n    if (rank[parent1] < rank[parent2]) swap(parent1, parent2);\n    parent[parent2] = parent1;\n    if (rank[parent1] == rank[parent2]) rank[parent1]++;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n        rank[i] = 1;\n    }\n    for (int i = 0; i < m; i++) {\n        int node1, node2;\n        cin >> node1 >> node2;\n        degree[node1]++;\n        degree[node2]++;\n        union_sets(node1, node2);\n    }\n    for (int i = 1; i <= n; i++) {\n        if (degree[i] % 2 != 0) {\n            cout << 0 << endl;\n            return 0;\n        }\n    }\n    int answer = 1;\n    for (int i = 1; i <= n; i++) {\n        if (parent[i] == i) {\n            int size = rank[i];\n            int subgraphs = (1 << size) - 1;\n            answer = (1ll * answer * subgraphs) % MOD;\n        }\n    }\n    cout << answer << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Even Outdegree Edges",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> adj(n + 1);\n    vector<int> degree(n + 1, 0);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n        degree[a]++;\n        degree[b]++;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        if (degree[i] % 2 != 0) {\n            cout << \"IMPOSSIBLE\" << endl;\n            return 0;\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        sort(adj[i].begin(), adj[i].end());\n        for (int j = 0; j < adj[i].size(); j += 2) {\n            cout << i << \" \" << adj[i][j] << endl;\n            cout << adj[i][j + 1] << \" \" << i << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 8,
            "mean_time_taken": 0.136479914188385,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Exponentiation",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\n// Function to calculate (base^exponent)%modulus\nlong long modularExponentiation(long long base, long long exponent, long long modulus) {\n    long long result = 1;\n    while (exponent > 0) {\n        if (exponent % 2 == 1)\n            result = (result * base) % modulus;\n        base = (base * base) % modulus;\n        exponent = exponent / 2;\n    }\n    return result;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        long long a, b;\n        cin >> a >> b;\n        cout << modularExponentiation(a, b, 1000000007) << endl;\n    }\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 3,
            "mean_time_taken": 0.20722262064615884,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Exponentiation II",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nlong long power(long long base, long long exp) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1)\n            result = (result * base) % MOD;\n        base = (base * base) % MOD;\n        exp = exp / 2;\n    }\n    return result;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    while (n--) {\n        long long a, b, c;\n        cin >> a >> b >> c;\n        long long bc = power(b, c);\n        long long result = power(a, bc);\n        cout << result << endl;\n    }\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 13,
            "mean_time_taken": 0.1369910606971154,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Factory Machines",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    long long n, t;\n    cin >> n >> t;\n\n    vector<long long> machines(n);\n    for (long long i = 0; i < n; i++) {\n        cin >> machines[i];\n    }\n\n    long long left = 0, right = *max_element(machines.begin(), machines.end()) * t;\n    while (left < right) {\n        long long mid = left + (right - left) / 2;\n        long long products = 0;\n\n        for (long long i = 0; i < n; i++) {\n            products += mid / machines[i];\n        }\n\n        if (products >= t) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    cout << left << endl;\n    return 0;\n}\n",
            "passed_test_cases": 17,
            "total_test_cases": 18,
            "mean_time_taken": 0.0901305145687527,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Ferris Wheel",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nint main() {\n    int n, x;\n    std::cin >> n >> x;\n\n    std::vector<int> weights(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> weights[i];\n    }\n\n    std::sort(weights.begin(), weights.end());\n\n    int left = 0, right = n - 1, gondolas = 0;\n    while (left <= right) {\n        if (weights[left] + weights[right] <= x) {\n            left++;\n            right--;\n        } else {\n            right--;\n        }\n        gondolas++;\n    }\n\n    std::cout << gondolas << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.11882814994225135,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Fibonacci Numbers",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <cstdint>\n\n// Define a constant for the modulo value\nconstexpr uint64_t MODULO = 1000000007;\n\n// Define a structure for matrices\nstruct Matrix {\n    uint64_t data[2][2];\n\n    // Overload the multiplication operator for matrices\n    Matrix operator*(const Matrix& other) const {\n        Matrix result = {0};\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++) {\n                for (int k = 0; k < 2; k++) {\n                    result.data[i][j] = (result.data[i][j] + data[i][k] * other.data[k][j]) % MODULO;\n                }\n            }\n        }\n        return result;\n    }\n\n    // Overload the exponentiation operator for matrices\n    Matrix operator^(uint64_t power) const {\n        Matrix base = *this;\n        Matrix result = {{1, 0}, {0, 1}};\n        while (power > 0) {\n            if (power & 1) {\n                result = result * base;\n            }\n            base = base * base;\n            power >>= 1;\n        }\n        return result;\n    }\n};\n\n// Define a function to calculate the nth Fibonacci number using matrix exponentiation\nuint64_t fibonacci(uint64_t n) {\n    Matrix fib = {{1, 1}, {1, 0}};\n    return (fib ^ n).data[0][1];\n}\n\nint main() {\n    uint64_t n;\n    std::cin >> n;\n    std::cout << fibonacci(n) << std::endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Filling Trominos",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_SIZE = 105;\nchar grid[MAX_SIZE][MAX_SIZE];\nint test_case, row, col, x, y, current_char = 'A';\n\nvoid fill_grid(int x1, int y1, int x2, int y2, int x3, int y3) {\n    if (x1 == x2 && y1 == y2) return;\n\n    int mid_x = (x1 + x2) / 2;\n    int mid_y = (y1 + y2) / 2;\n\n    if (x3 <= mid_x && y3 <= mid_y) {\n        fill_grid(mid_x + 1, mid_y, x2, y2, x3, y3);\n        fill_grid(mid_x, mid_y + 1, x2, y2, mid_x, mid_y);\n        fill_grid(mid_x + 1, mid_y + 1, x2, y2, mid_x + 1, mid_y);\n    } else if (x3 <= mid_x && y3 > mid_y) {\n        fill_grid(mid_x, y1, mid_x, mid_y, x3, y3);\n        fill_grid(mid_x + 1, y1, x2, mid_y, x3, y3);\n        fill_grid(mid_x + 1, mid_y + 1, x2, y2, mid_x + 1, mid_y);\n    } else if (x3 > mid_x && y3 <= mid_y) {\n        fill_grid(x1, mid_y, mid_x, mid_y, x3, y3);\n        fill_grid(x1, mid_y + 1, mid_x, y2, x3, y3);\n        fill_grid(mid_x + 1, mid_y + 1, x2, y2, mid_x + 1, mid_y);\n    } else {\n        fill_grid(x1, mid_y, mid_x, mid_y, mid_x, mid_y);\n        fill_grid(x1, mid_y + 1, mid_x, y2, mid_x, mid_y + 1);\n        fill_grid(mid_x + 1, mid_y + 1, x2, y2, x3, y3);\n    }\n\n    grid[mid_x][mid_y] = grid[mid_x + 1][mid_y] = grid[mid_x][mid_y + 1] = current_char++;\n}\n\nint main() {\n    cin >> test_case;\n\n    while (test_case--) {\n        cin >> row >> col;\n\n        if (row % 2 == 1 && col % 2 == 1) {\n            cout << \"NO\" << endl;\n            continue;\n        }\n\n        cout << \"YES\" << endl;\n        current_char = 'A';\n\n        if (row % 2 == 1) {\n            x = 1;\n            y = (row + 1) / 2;\n        } else if (col % 2 == 1) {\n            x = (col + 1) / 2;\n            y = 1;\n        } else {\n            x = y = 0;\n        }\n\n        fill_grid(1, 1, row, col, x, y);\n\n        for (int i = 1; i <= row; i++) {\n            for (int j = 1; j <= col; j++) {\n                cout << grid[i][j];\n            }\n            cout << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.11494535207748413,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding Borders",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\n// Z-algorithm to find all occurrences of a string in itself\nstd::vector<int> z_function(const std::string& s) {\n    int n = s.length();\n    std::vector<int> z(n, 0);\n    int left = 0, right = 0;\n    for (int i = 1; i < n; i++) {\n        if (i <= right)\n            z[i] = std::min(right - i + 1, z[i - left]);\n        while (i + z[i] < n && s[z[i]] == s[i + z[i]])\n            z[i]++;\n        if (i + z[i] - 1 > right) {\n            left = i;\n            right = i + z[i] - 1;\n        }\n    }\n    return z;\n}\n\n// Find all border lengths of a given string\nstd::vector<int> find_borders(const std::string& s) {\n    int n = s.length();\n    std::vector<int> z = z_function(s);\n    std::vector<int> borders;\n    for (int i = 1; i < n; i++) {\n        if (z[i] == n - i)\n            borders.push_back(n - i);\n    }\n    std::sort(borders.begin(), borders.end());\n    return borders;\n}\n\nint main() {\n    std::string s;\n    std::cin >> s;\n    std::vector<int> borders = find_borders(s);\n    for (int border : borders) {\n        std::cout << border << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}\n",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.1168771657076749,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Finding Patterns",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Function to create the partial match table for a pattern\nvector<int> computePrefixFunction(const string& pattern) {\n    int n = pattern.size();\n    vector<int> pi(n, 0);\n    int k = 0;\n    for (int i = 1; i < n; i++) {\n        while (k > 0 && pattern[k] != pattern[i]) {\n            k = pi[k - 1];\n        }\n        if (pattern[k] == pattern[i]) {\n            k++;\n        }\n        pi[i] = k;\n    }\n    return pi;\n}\n\n// Function to search for a pattern in a string using the KMP algorithm\nbool kmpSearch(const string& text, const string& pattern) {\n    int n = text.size();\n    int m = pattern.size();\n    vector<int> pi = computePrefixFunction(pattern);\n    int q = 0;\n    for (int i = 0; i < n; i++) {\n        while (q > 0 && pattern[q] != text[i]) {\n            q = pi[q - 1];\n        }\n        if (pattern[q] == text[i]) {\n            q++;\n        }\n        if (q == m) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    string text;\n    cin >> text;\n    int k;\n    cin >> k;\n    for (int i = 0; i < k; i++) {\n        string pattern;\n        cin >> pattern;\n        if (kmpSearch(text, pattern)) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 17,
            "mean_time_taken": 0.44705696666941924,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                8,
                12,
                14,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding Periods",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<int> z_function(const std::string& s) {\n    int n = s.length();\n    std::vector<int> z(n);\n    for (int i = 1, l = 0, r = 0; i < n; ++i) {\n        if (i <= r)\n            z[i] = std::min(r - i + 1, z[i - l]);\n        while (i + z[i] < n && s[z[i]] == s[i + z[i]])\n            ++z[i];\n        if (i + z[i] - 1 > r)\n            l = i, r = i + z[i] - 1;\n    }\n    return z;\n}\n\nint main() {\n    std::string s;\n    std::cin >> s;\n    int n = s.length();\n    std::vector<int> z = z_function(s);\n    std::vector<int> periods;\n    for (int i = 1; i < n; ++i) {\n        if (i + z[i] == n)\n            periods.push_back(i);\n    }\n    periods.push_back(n);\n    for (int i = 0; i < periods.size(); ++i)\n        std::cout << periods[i] << \" \";\n    return 0;\n}\n",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.10495577539716448,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Finding a Centroid",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nvector<int> adj[MAX_N];\nint subtree_size[MAX_N];\nint n, centroid;\n\nvoid dfs(int u, int p) {\n    subtree_size[u] = 1;\n    for (int v : adj[u]) {\n        if (v != p) {\n            dfs(v, u);\n            subtree_size[u] += subtree_size[v];\n            if (subtree_size[v] * 2 >= n) {\n                centroid = v;\n                return;\n            }\n        }\n    }\n    if (n - subtree_size[u] * 2 >= n) {\n        centroid = u;\n    }\n}\n\nint main() {\n    cin >> n;\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(1, 0);\n    cout << centroid << endl;\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 16,
            "mean_time_taken": 0.1320182830095291,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                9,
                10,
                11,
                12,
                13,
                14,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Fixed-Length Paths I",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 200005;\nvector<int> adj[MAX_N];\nint subtree_size[MAX_N];\nint n, k;\n\n// Calculate the size of the subtree rooted at node u\nint dfs(int u, int p) {\n    subtree_size[u] = 1;\n    for (int v : adj[u]) {\n        if (v != p) {\n            subtree_size[u] += dfs(v, u);\n        }\n    }\n    return subtree_size[u];\n}\n\n// Calculate the number of paths that end at node u and have length k\nint count_paths(int u, int p) {\n    int paths = 0;\n    for (int v : adj[u]) {\n        if (v != p) {\n            // If the path ends at node v and has length k-1, then adding an edge to node u makes it a path of length k\n            if (k - 1 == subtree_size[n] - subtree_size[v]) {\n                paths++;\n            }\n            // Recursively calculate the number of paths that end at node v and have length k\n            paths += count_paths(v, u);\n        }\n    }\n    return paths;\n}\n\nint main() {\n    cin >> n >> k;\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(1, 0);\n    if (k == 0) {\n        cout << n << endl;\n    } else {\n        cout << count_paths(1, 0) << endl;\n    }\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 20,
            "mean_time_taken": 0.19837030172348022,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Fixed-Length Paths II",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\n\nvector<int> adj[MAX_N];\nint dp1[MAX_N], dp2[MAX_N];\nint n, k1, k2;\n\nvoid dfs(int u, int p) {\n    dp1[u] = 1;\n    dp2[u] = 0;\n    for (int v : adj[u]) {\n        if (v == p) continue;\n        dfs(v, u);\n        vector<int> temp1(k1 + 1, 0), temp2(k2 + 1, 0);\n        for (int i = 1; i <= k1; i++) {\n            temp1[i] = dp1[u] * dp1[v];\n            if (i > 1) temp1[i] += dp2[u] * dp1[v];\n        }\n        for (int i = 1; i <= k2; i++) {\n            temp2[i] = dp2[u] * dp1[v];\n            if (i > 1) temp2[i] += dp2[u] * dp2[v];\n            if (i > 1) temp2[i] += dp1[u] * dp1[v];\n        }\n        dp1[u] = accumulate(temp1.begin(), temp1.end(), 0LL);\n        dp2[u] = accumulate(temp2.begin(), temp2.end(), 0LL);\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> n >> k1 >> k2;\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(1, 0);\n    cout << dp2[1] << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Flight Discount",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100005;\nconst long long INF = 1e18;\n\nint n, m;\nvector<pair<int, int>> adj[MAX_N];\nlong long dist1[MAX_N], dist2[MAX_N];\n\nvoid dijkstra() {\n    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\n    pq.push({0, 1});\n    dist1[1] = 0;\n    dist2[1] = 0;\n\n    while (!pq.empty()) {\n        long long d = pq.top().first;\n        int u = pq.top().second;\n        pq.pop();\n\n        if (d > dist1[u]) continue;\n\n        for (auto &v : adj[u]) {\n            if (dist1[v.first] > dist1[u] + v.second) {\n                dist1[v.first] = dist1[u] + v.second;\n                pq.push({dist1[v.first], v.first});\n            }\n            if (dist2[v.first] > min(dist1[u] + v.second / 2, dist2[u] + v.second)) {\n                dist2[v.first] = min(dist1[u] + v.second / 2, dist2[u] + v.second);\n                pq.push({dist2[v.first], v.first});\n            }\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        adj[a].push_back({b, c});\n    }\n\n    fill(dist1, dist1 + MAX_N, INF);\n    fill(dist2, dist2 + MAX_N, INF);\n\n    dijkstra();\n\n    cout << min(dist1[n], dist2[n]) << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 23,
            "total_test_cases": 24,
            "mean_time_taken": 0.16422940293947855,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Flight Route Requests",
            "category": "Additional Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Flight Routes",
            "category": "Graph Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Flight Routes Check",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\nconst int MAX_NODES = 100005;\n\nvector<int> graph[MAX_NODES];\nbool visited[MAX_NODES];\nint numNodes, numEdges;\n\nvoid depthFirstSearch(int node) {\n    visited[node] = true;\n    for (int neighbor : graph[node]) {\n        if (!visited[neighbor]) {\n            depthFirstSearch(neighbor);\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    cin >> numNodes >> numEdges;\n\n    for (int i = 0; i < numEdges; i++) {\n        int node1, node2;\n        cin >> node1 >> node2;\n        graph[node1].push_back(node2);\n    }\n\n    for (int i = 1; i <= numNodes; i++) {\n        fill(visited, visited + MAX_NODES, false);\n        depthFirstSearch(i);\n\n        for (int j = 1; j <= numNodes; j++) {\n            if (!visited[j]) {\n                cout << \"NO\" << endl;\n                cout << i << \" \" << j << endl;\n                return 0;\n            }\n        }\n    }\n\n    cout << \"YES\" << endl;\n    return 0;\n}\n",
            "passed_test_cases": 14,
            "total_test_cases": 20,
            "mean_time_taken": 0.37059000730514524,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                6,
                8,
                14,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Food Division",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> a(n), b(n), diff(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    for (int i = 0; i < n; i++) {\n        std::cin >> b[i];\n        diff[i] = b[i] - a[i];\n    }\n\n    int total_diff = 0;\n    for (int i = 0; i < n; i++) {\n        total_diff += diff[i];\n    }\n\n    if (total_diff != 0) {\n        std::cout << -1 << std::endl;\n        return 0;\n    }\n\n    std::vector<int> prefix_sum(n);\n    prefix_sum[0] = diff[0];\n    for (int i = 1; i < n; i++) {\n        prefix_sum[i] = prefix_sum[i - 1] + diff[i];\n    }\n\n    int min_steps = std::abs(prefix_sum[0]);\n    for (int i = 1; i < n; i++) {\n        min_steps = std::min(min_steps, std::abs(prefix_sum[i]));\n    }\n\n    std::cout << min_steps << std::endl;\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 5,
            "mean_time_taken": 0.10518698692321778,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Forbidden Cities",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_NODES = 100005;\n\nvector<int> graph[MAX_NODES];\nbool visited[MAX_NODES];\n\nbool dfs(int a, int b, int c) {\n    visited[a] = true;\n    if (a == b) return true;\n    for (int neighbor : graph[a]) {\n        if (neighbor == c || visited[neighbor]) continue;\n        if (dfs(neighbor, b, c)) return true;\n    }\n    return false;\n}\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    for (int i = 0; i < q; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        fill(visited, visited + MAX_NODES, false);\n        if (dfs(a, b, c)) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 14,
            "mean_time_taken": 0.49021806035723003,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                5,
                6,
                8,
                10,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Forest Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<vector<int>> prefixSum(n + 1, vector<int>(n + 1, 0));\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            char c;\n            cin >> c;\n            if (c == '*') {\n                prefixSum[i][j] = prefixSum[i - 1][j] + prefixSum[i][j - 1] - prefixSum[i - 1][j - 1] + 1;\n            } else {\n                prefixSum[i][j] = prefixSum[i - 1][j] + prefixSum[i][j - 1] - prefixSum[i - 1][j - 1];\n            }\n        }\n    }\n\n    for (int i = 0; i < q; i++) {\n        int y1, x1, y2, x2;\n        cin >> y1 >> x1 >> y2 >> x2;\n        int treesInside = prefixSum[y2][x2] - prefixSum[y1 - 1][x2] - prefixSum[y2][x1 - 1] + prefixSum[y1 - 1][x1 - 1];\n        cout << treesInside << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 3,
            "mean_time_taken": 0.21319286028544107,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Forest Queries II",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<vector<char>> grid(n, vector<char>(n));\n    vector<vector<int>> prefixSum(n + 1, vector<int>(n + 1));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> grid[i][j];\n            prefixSum[i + 1][j + 1] = prefixSum[i + 1][j] + prefixSum[i][j + 1] - prefixSum[i][j] + (grid[i][j] == '*');\n        }\n    }\n\n    for (int i = 0; i < q; i++) {\n        int queryType;\n        cin >> queryType;\n\n        if (queryType == 1) {\n            int y, x;\n            cin >> y >> x;\n            y--, x--;\n\n            int currentValue = (grid[y][x] == '*');\n            int newValue = (currentValue == 1) ? 0 : 1;\n\n            grid[y][x] = (newValue == 1) ? '*' : '.';\n            prefixSum[y + 1][x + 1] += newValue - currentValue;\n\n            for (int j = x + 2; j <= n; j++) {\n                prefixSum[y + 1][j] += newValue - currentValue;\n            }\n\n            for (int j = y + 2; j <= n; j++) {\n                prefixSum[j][x + 1] += newValue - currentValue;\n            }\n        } else {\n            int y1, x1, y2, x2;\n            cin >> y1 >> x1 >> y2 >> x2;\n            y1--, x1--, y2--, x2--;\n\n            int result = prefixSum[y2 + 1][x2 + 1] - prefixSum[y1][x2 + 1] - prefixSum[y2 + 1][x1] + prefixSum[y1][x1];\n            cout << result << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 5,
            "mean_time_taken": 0.422520112991333,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Functional Graph Distribution",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <cstdint>\n\nconstexpr int MAX_N = 5005;\nconstexpr int MOD = 1000000007;\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    // Initialize a 2D vector to store the number of graphs for each k\n    std::vector<std::vector<int64_t>> dp(MAX_N, std::vector<int64_t>(MAX_N));\n    dp[0][0] = 1;\n\n    // Calculate the number of graphs for each k using dynamic programming\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= i; ++j) {\n            dp[i][j] = dp[i - 1][j - 1] + (dp[i - 1][j] * (i - j)) % MOD;\n            dp[i][j] %= MOD;\n        }\n    }\n\n    // Calculate the total number of graphs for each k\n    for (int i = 1; i <= n; ++i) {\n        int64_t sum = 0;\n        for (int j = 1; j <= i; ++j) {\n            sum += dp[i][j];\n            sum %= MOD;\n        }\n        std::cout << sum << std::endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.19721540808677673,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Game Routes",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100005;\nconst int MOD = 1000000007;\n\nvector<int> graph[MAX_N];\nint dp[MAX_N];\nint in_degree[MAX_N];\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        in_degree[b]++;\n    }\n\n    queue<int> q;\n    q.push(1);\n    dp[1] = 1;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        for (int v : graph[u]) {\n            dp[v] = (dp[v] + dp[u]) % MOD;\n            in_degree[v]--;\n\n            if (in_degree[v] == 0) {\n                q.push(v);\n            }\n        }\n    }\n\n    cout << dp[n] << endl;\n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 15,
            "mean_time_taken": 0.11008502642313639,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                5,
                6,
                8,
                9,
                10,
                11,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Giant Pizza",
            "category": "Graph Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Graph Girth",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_NODES = 2505;\nvector<int> graph[MAX_NODES];\nint distance[MAX_NODES];\n\nint bfs(int start) {\n    queue<int> q;\n    q.push(start);\n    distance[start] = 0;\n    int min_cycle_length = INT_MAX;\n\n    while (!q.empty()) {\n        int current = q.front();\n        q.pop();\n\n        for (int neighbor : graph[current]) {\n            if (distance[neighbor] == -1) {\n                distance[neighbor] = distance[current] + 1;\n                q.push(neighbor);\n            } else if (distance[neighbor] >= distance[current]) {\n                min_cycle_length = min(min_cycle_length, distance[current] + distance[neighbor] + 1);\n            }\n        }\n    }\n\n    return min_cycle_length;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n\n    int min_cycle_length = INT_MAX;\n    for (int i = 1; i <= n; i++) {\n        memset(distance, -1, sizeof distance);\n        min_cycle_length = min(min_cycle_length, bfs(i));\n    }\n\n    if (min_cycle_length == INT_MAX) {\n        cout << -1 << endl;\n    } else {\n        cout << min_cycle_length << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Graph Paths I",
            "category": "Mathematics",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Graph Paths II",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 105;\nconst long long INF = 1e18;\n\nint n, m, k;\nlong long dp[MAX_N][MAX_N][MAX_N];\nvector<tuple<int, int, int>> edges;\n\nint main() {\n    cin >> n >> m >> k;\n\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        edges.push_back(make_tuple(a, b, c));\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= k; j++) {\n            for (int l = 0; l <= k; l++) {\n                dp[i][j][l] = INF;\n            }\n        }\n    }\n\n    dp[1][0][0] = 0;\n\n    for (int i = 0; i < k; i++) {\n        for (auto &edge : edges) {\n            int a, b, c;\n            tie(a, b, c) = edge;\n            for (int j = 0; j <= i; j++) {\n                dp[b][j + 1][i + 1] = min(dp[b][j + 1][i + 1], dp[a][j][i] + c);\n            }\n        }\n    }\n\n    long long ans = INF;\n    for (int i = 0; i <= k; i++) {\n        ans = min(ans, dp[n][k][i]);\n    }\n\n    if (ans == INF) {\n        cout << -1 << endl;\n    } else {\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 15,
            "mean_time_taken": 0.10580655733744303,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                9,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Gray Code",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <bitset>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    // Generate Gray code for length n\n    for (int i = 0; i < (1 << n); i++) {\n        // Convert binary number to Gray code\n        int gray = i ^ (i >> 1);\n\n        // Print Gray code as a binary string\n        std::bitset<16> gray_bits(gray);\n        std::cout << gray_bits.to_string().substr(16 - n) << std::endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 16,
            "total_test_cases": 16,
            "mean_time_taken": 0.08485184609889984,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Grid Completion",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <cstring>\n\nconst int MAX_SIZE = 505;\nconst int MOD = 1e9 + 7;\n\nint n;\nchar grid[MAX_SIZE][MAX_SIZE];\nint dp[MAX_SIZE][MAX_SIZE];\n\nint main() {\n    std::cin >> n;\n    for (int i = 0; i < n; i++) {\n        std::cin >> grid[i];\n    }\n\n    dp[0][0] = 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == '.') {\n                dp[i][j] = (1LL * dp[i - 1][j] * dp[i][j - 1]) % MOD;\n            } else if (grid[i][j] == 'A') {\n                dp[i][j] = dp[i][j - 1];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    std::cout << dp[n - 1][n - 1] << std::endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.09123424688975017,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Path Construction",
            "category": "Additional Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Grid Paths",
            "category": "Introductory Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Grid Paths",
            "category": "Introductory Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Grid Paths",
            "category": "Introductory Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Grid Puzzle I",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> row(n), col(n);\n    for (int i = 0; i < n; i++) {\n        cin >> row[i];\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> col[i];\n    }\n\n    vector<vector<char>> grid(n, vector<char>(n, '.'));\n\n    // Fill the grid based on the row and column constraints\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < row[i]; j++) {\n            int k = 0;\n            while (col[k] == 0 || grid[i][k] == 'X') {\n                k++;\n            }\n            grid[i][k] = 'X';\n            col[k]--;\n        }\n    }\n\n    // Check if the grid is filled correctly\n    for (int i = 0; i < n; i++) {\n        if (col[i] != 0) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    // Print the grid\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << grid[i][j];\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 12,
            "mean_time_taken": 0.10948451360066731,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "malloc(): corrupted top size\n",
                "malloc(): corrupted top size\n",
                "free(): invalid next size (fast)\n",
                "free(): invalid next size (fast)\n",
                "malloc(): corrupted top size\n",
                "Failed",
                "malloc(): corrupted top size\n",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                6,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Puzzle II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_SIZE = 55;\n\nint gridSize;\nint rowSums[MAX_SIZE], colSums[MAX_SIZE];\nint grid[MAX_SIZE][MAX_SIZE];\nbool rowVisited[MAX_SIZE][MAX_SIZE], colVisited[MAX_SIZE][MAX_SIZE];\npair<int, int> rowPairs[MAX_SIZE], colPairs[MAX_SIZE];\n\nint main() {\n    scanf(\"%d\", &gridSize);\n\n    for (int i = 0; i < gridSize; i++) {\n        scanf(\"%d\", &rowSums[i]);\n        rowPairs[i] = make_pair(rowSums[i], i);\n    }\n\n    for (int i = 0; i < gridSize; i++) {\n        scanf(\"%d\", &colSums[i]);\n        colPairs[i] = make_pair(colSums[i], i);\n    }\n\n    for (int i = 0; i < gridSize; i++) {\n        for (int j = 0; j < gridSize; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n\n    sort(rowPairs, rowPairs + gridSize);\n    sort(colPairs, colPairs + gridSize);\n\n    for (int i = 0; i < gridSize; i++) {\n        int rowIndex = rowPairs[i].second;\n        for (int j = 0; j < gridSize; j++) {\n            if (rowSums[rowIndex] == 0) break;\n            int colIndex = -1, maxValue = -1;\n            for (int k = 0; k < gridSize; k++) {\n                if (colSums[k] == 0 || rowVisited[rowIndex][k] || colVisited[k][rowIndex]) continue;\n                if (grid[rowIndex][k] > maxValue) {\n                    maxValue = grid[rowIndex][k];\n                    colIndex = k;\n                }\n            }\n            if (colIndex == -1) {\n                puts(\"-1\");\n                return 0;\n            }\n            rowVisited[rowIndex][colIndex] = true;\n            colVisited[colIndex][rowIndex] = true;\n            rowSums[rowIndex]--;\n            colSums[colIndex]--;\n        }\n    }\n\n    int totalSum = 0;\n    for (int i = 0; i < gridSize; i++) {\n        for (int j = 0; j < gridSize; j++) {\n            if (rowVisited[i][j]) totalSum += grid[i][j];\n        }\n    }\n\n    printf(\"%d\\n\", totalSum);\n    for (int i = 0; i < gridSize; i++) {\n        for (int j = 0; j < gridSize; j++) {\n            putchar(rowVisited[i][j] ? 'X' : '.');\n        }\n        puts(\"\");\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 8,
            "mean_time_taken": 0.08336421847343445,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grundy's Game",
            "category": "Mathematics",
            "solution": "#include <iostream>\n\nint main() {\n    int t;\n    std::cin >> t;\n\n    while (t--) {\n        int n;\n        std::cin >> n;\n\n        if (n % 2 == 0) {\n            std::cout << \"second\\n\";\n        } else {\n            std::cout << \"first\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 3,
            "mean_time_taken": 0.12348024050394694,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Hamiltonian Flights",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> graph(n, vector<int>(n, 0));\n    vector<vector<int>> dp(n, vector<int>(1 << n, 0));\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a - 1][b - 1] = 1;\n    }\n\n    dp[0][1] = 1;\n\n    for (int mask = 1; mask < (1 << n); mask++) {\n        for (int u = 0; u < n; u++) {\n            if (!(mask & (1 << u))) continue;\n            for (int v = 0; v < n; v++) {\n                if (!(mask & (1 << v)) && graph[u][v]) {\n                    dp[v][mask | (1 << v)] = (dp[v][mask | (1 << v)] + dp[u][mask]) % MOD;\n                }\n            }\n        }\n    }\n\n    cout << dp[n - 1][(1 << n) - 1] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 20,
            "mean_time_taken": 0.5496401190757751,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                4,
                5,
                6,
                8,
                9,
                12,
                14,
                16,
                17,
                18,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Hamming Distance",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nint main() {\n    int n, k;\n    std::cin >> n >> k;\n\n    std::vector<std::string> bit_strings(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> bit_strings[i];\n    }\n\n    int min_distance = k;\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int distance = 0;\n            for (int l = 0; l < k; l++) {\n                if (bit_strings[i][l] != bit_strings[j][l]) {\n                    distance++;\n                }\n            }\n            min_distance = std::min(min_distance, distance);\n        }\n    }\n\n    std::cout << min_distance << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 15,
            "mean_time_taken": 0.6617859840393067,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                5,
                6,
                7,
                8,
                9,
                12,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "High Score",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_NODES = 2505;\nconst long long INF = 1e18;\n\nint numNodes, numEdges;\nlong long distances[MAX_NODES];\nvector<pair<int, int>> edges[MAX_NODES];\n\nvoid bellmanFord(int source) {\n    fill(distances, distances + MAX_NODES, -INF);\n    distances[source] = 0;\n\n    for (int i = 1; i < numNodes; i++) {\n        for (int u = 1; u <= numNodes; u++) {\n            for (auto &edge : edges[u]) {\n                int v = edge.first;\n                int w = edge.second;\n                distances[v] = max(distances[v], distances[u] + w);\n            }\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> numNodes >> numEdges;\n\n    for (int i = 0; i < numEdges; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        edges[u].push_back({v, w});\n    }\n\n    bellmanFord(1);\n\n    if (distances[numNodes] == INF) {\n        cout << -1 << endl;\n    } else {\n        cout << distances[numNodes] << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 19,
            "total_test_cases": 43,
            "mean_time_taken": 0.09419721780821334,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                9,
                11,
                12,
                15,
                16,
                17,
                18,
                21,
                22,
                24,
                27,
                29,
                30,
                31,
                32,
                33,
                38,
                39,
                41
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Hotel Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Segment tree data structure for range maximum queries and point updates\nstruct SegmentTree {\n    int n;\n    vector<int> t;\n\n    SegmentTree(int _n) : n(_n) {\n        t.assign(4 * n, 0);\n    }\n\n    // Update the number of free rooms in a hotel\n    void update(int p, int value) {\n        for (t[p += n] = value; p > 1; p >>= 1)\n            t[p >> 1] = max(t[p], t[p ^ 1]);\n    }\n\n    // Query the first hotel with enough free rooms\n    int query(int l, int r) {\n        int res = 0;\n        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) res = max(res, t[l++]);\n            if (r & 1) res = max(res, t[--r]);\n        }\n        return res;\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    // Build the segment tree\n    SegmentTree st(n);\n    for (int i = 0; i < n; i++) {\n        int rooms;\n        cin >> rooms;\n        st.update(i, rooms);\n    }\n\n    // Assign hotels to groups\n    for (int i = 0; i < m; i++) {\n        int rooms;\n        cin >> rooms;\n\n        // Find the first hotel with enough free rooms\n        int hotel = lower_bound(st.t.begin() + st.n, st.t.begin() + 2 * st.n, rooms) - st.t.begin() - st.n;\n\n        // If such a hotel exists, update its number of free rooms and print the hotel's index\n        if (hotel < n && st.query(hotel, hotel + 1) >= rooms) {\n            st.update(hotel, st.query(hotel, hotel + 1) - rooms);\n            cout << hotel + 1 << \" \";\n        } else {\n            cout << 0 << \" \";\n        }\n    }\n\n    cout << endl;\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 11,
            "mean_time_taken": 0.17261717536232687,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Houses and Schools",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 3005;\nlong long prefix_sum[MAX_N];\n\nlong long calculate_children(int left, int right, int mid) {\n    int mid_index = lower_bound(prefix_sum + left, prefix_sum + right + 1, mid) - prefix_sum;\n    return (mid_index - left) * (mid - prefix_sum[mid_index - 1]) + calculate_children(mid_index, right, mid);\n}\n\nbool is_possible(int left, int right, int k, long long mid) {\n    long long children = calculate_children(left, right, (left + right) / 2);\n    if (children < mid) return false;\n    if (k == 1) return true;\n    return is_possible(left, (left + right) / 2 - 1, k - 1, mid) || is_possible((left + right) / 2 + 1, right, k - 1, mid);\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) {\n        cin >> prefix_sum[i];\n        prefix_sum[i] += prefix_sum[i - 1];\n    }\n    long long left = 0, right = prefix_sum[n];\n    while (left < right) {\n        long long mid = (left + right) / 2;\n        if (is_possible(1, n, k, mid))\n            right = mid;\n        else\n            left = mid + 1;\n    }\n    cout << left << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.14617606004079184,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Increasing Array",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> arr[i];\n    }\n\n    int moves = 0;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < arr[i - 1]) {\n            moves += arr[i - 1] - arr[i];\n            arr[i] = arr[i - 1];\n        }\n    }\n\n    std::cout << moves << std::endl;\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 7,
            "mean_time_taken": 0.09487393924168178,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Increasing Array II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    priority_queue<int> maxHeap;\n    long long totalMoves = 0;\n\n    for (int i = 0; i < n; i++) {\n        int num;\n        cin >> num;\n\n        maxHeap.push(num);\n\n        if (maxHeap.top() > num) {\n            totalMoves += maxHeap.top() - num;\n            maxHeap.pop();\n            maxHeap.push(num);\n        }\n    }\n\n    cout << totalMoves << endl;\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 7,
            "mean_time_taken": 0.13054912430899485,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Increasing Array Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    // Read the size of the array and the number of queries\n    long long int arraySize, numberOfQueries;\n    cin >> arraySize >> numberOfQueries;\n\n    // Read the array elements\n    vector<long long int> array(arraySize);\n    for (long long int i = 0; i < arraySize; i++) {\n        cin >> array[i];\n    }\n\n    // Calculate the prefix sum of the array\n    vector<long long int> prefixSum(arraySize);\n    prefixSum[0] = 0;\n    for (long long int i = 1; i < arraySize; i++) {\n        if (array[i] <= array[i - 1]) {\n            prefixSum[i] = prefixSum[i - 1] + (array[i - 1] - array[i]);\n            array[i] = array[i - 1];\n        } else {\n            prefixSum[i] = prefixSum[i - 1];\n        }\n    }\n\n    // Process the queries\n    for (long long int i = 0; i < numberOfQueries; i++) {\n        long long int leftIndex, rightIndex;\n        cin >> leftIndex >> rightIndex;\n        leftIndex--;\n        rightIndex--;\n\n        // Calculate the minimum number of operations required to make the subarray increasing\n        if (leftIndex == 0) {\n            cout << prefixSum[rightIndex] << \"\\n\";\n        } else {\n            cout << prefixSum[rightIndex] - prefixSum[leftIndex - 1] << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 8,
            "mean_time_taken": 0.11017653346061707,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Increasing Subsequence",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int tail[n];\n    int length = 0;\n\n    for (int i = 0; i < n; i++) {\n        int num;\n        cin >> num;\n\n        // If num is greater than the last element of tail, append it to tail\n        if (length == 0 || num > tail[length - 1]) {\n            tail[length++] = num;\n        }\n        // Otherwise, use binary search to find the position of num in tail and replace the element at that position\n        else {\n            int pos = lower_bound(tail, tail + length, num) - tail;\n            tail[pos] = num;\n        }\n    }\n\n    // Print the length of the longest increasing subsequence\n    cout << length << endl;\n    return 0;\n}\n",
            "passed_test_cases": 17,
            "total_test_cases": 17,
            "mean_time_taken": 0.09348762736600988,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Increasing Subsequence II",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nconst int MOD = 1e9 + 7;\n\nint n;\nint arr[MAX_N];\nlong long dp[MAX_N];\nint seg_tree[4 * MAX_N];\n\nvoid update(int node, int start, int end, int idx, int val) {\n    if (start == end) {\n        seg_tree[node] = val;\n        return;\n    }\n    int mid = (start + end) / 2;\n    if (idx <= mid)\n        update(2 * node, start, mid, idx, val);\n    else\n        update(2 * node + 1, mid + 1, end, idx, val);\n    seg_tree[node] = max(seg_tree[2 * node], seg_tree[2 * node + 1]);\n}\n\nint query(int node, int start, int end, int l, int r) {\n    if (start > r || end < l)\n        return 0;\n    if (start >= l && end <= r)\n        return seg_tree[node];\n    int mid = (start + end) / 2;\n    return max(query(2 * node, start, mid, l, r), query(2 * node + 1, mid + 1, end, l, r));\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> arr[i];\n    }\n\n    for (int i = 1; i <= n; i++) {\n        dp[i] = query(1, 1, n, 1, arr[i] - 1) + 1;\n        update(1, 1, n, arr[i], dp[i]);\n    }\n\n    long long result = 0;\n    for (int i = 1; i <= n; i++) {\n        result = (result + dp[i]) % MOD;\n    }\n\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 10,
            "mean_time_taken": 0.09035763740539551,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Intersection Points",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    // Create maps to store line segments based on their x and y coordinates\n    map<int, vector<pair<int, int>>> x_coordinates;\n    map<int, vector<pair<int, int>>> y_coordinates;\n\n    // Read line segments and store them in the corresponding maps\n    for (int i = 0; i < n; i++) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n\n        if (x1 == x2) {\n            // Vertical line segment\n            y_coordinates[x1].push_back({min(y1, y2), max(y1, y2)});\n        } else {\n            // Horizontal line segment\n            x_coordinates[y1].push_back({min(x1, x2), max(x1, x2)});\n        }\n    }\n\n    int intersection_points = 0;\n\n    // Iterate through horizontal line segments and count intersections with vertical line segments\n    for (auto& it : x_coordinates) {\n        for (auto& segment : it.second) {\n            auto range = y_coordinates.equal_range(segment.first);\n            for (auto it2 = range.first; it2 != range.second; it2++) {\n                if (it2->second.front().first < segment.second && segment.first < it2->second.front().second) {\n                    intersection_points++;\n                }\n            }\n        }\n    }\n\n    // Iterate through vertical line segments and count intersections with horizontal line segments\n    for (auto& it : y_coordinates) {\n        for (auto& segment : it.second) {\n            auto range = x_coordinates.equal_range(segment.first);\n            for (auto it2 = range.first; it2 != range.second; it2++) {\n                if (it2->second.front().first < segment.second && segment.first < it2->second.front().second) {\n                    intersection_points++;\n                }\n            }\n        }\n    }\n\n    // Print the total number of intersection points\n    cout << intersection_points << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 5,
            "mean_time_taken": 0.14520797729492188,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Inverse Inversions",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> result(n);\n    for (int i = n; i >= 1; i--) {\n        result[n - i] = i;\n        if (k > 0) {\n            swap(result[n - i], result[n - i + k % i]);\n            k -= k % i;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 10,
            "mean_time_taken": 0.09667072296142579,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Inversion Probability",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <iomanip>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> r(n);\n    for (int i = 0; i < n; i++) {\n        cin >> r[i];\n    }\n\n    double expected_inversions = 0.0;\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            for (int k = 1; k <= r[j]; k++) {\n                expected_inversions += (1.0 - k / r[i]) * (k / (double)r[j]);\n            }\n        }\n    }\n\n    cout << fixed << setprecision(6) << expected_inversions << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 20,
            "mean_time_taken": 0.08005027770996094,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Investigation",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100005;\nconst long long MOD = 1000000007;\n\nint n, m;\nvector<pair<int, int>> adj[MAX_N];\nlong long dist[MAX_N], ways[MAX_N], min_flights[MAX_N], max_flights[MAX_N];\n\nvoid dijkstra() {\n    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\n    pq.push({0, 1});\n    dist[1] = 0;\n    ways[1] = 1;\n    min_flights[1] = 0;\n    max_flights[1] = 0;\n    while (!pq.empty()) {\n        long long d = pq.top().first;\n        int u = pq.top().second;\n        pq.pop();\n        if (d != dist[u]) continue;\n        for (auto v : adj[u]) {\n            if (dist[v.first] > dist[u] + v.second) {\n                dist[v.first] = dist[u] + v.second;\n                ways[v.first] = ways[u];\n                min_flights[v.first] = min_flights[u] + 1;\n                max_flights[v.first] = max_flights[u] + 1;\n                pq.push({dist[v.first], v.first});\n            } else if (dist[v.first] == dist[u] + v.second) {\n                ways[v.first] = (ways[v.first] + ways[u]) % MOD;\n                min_flights[v.first] = min(min_flights[v.first], min_flights[u] + 1);\n                max_flights[v.first] = max(max_flights[v.first], max_flights[u] + 1);\n            }\n        }\n    }\n}\n\nint main() {\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        adj[u].push_back({v, w});\n    }\n    fill(dist, dist + MAX_N, LLONG_MAX);\n    dijkstra();\n    cout << dist[n] << \" \" << ways[n] << \" \" << min_flights[n] << \" \" << max_flights[n] << endl;\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.15470376014709472,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Josephus Problem I",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <deque>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::deque<int> children;\n    for (int i = 1; i <= n; i++) {\n        children.push_back(i);\n    }\n\n    while (!children.empty()) {\n        std::cout << children.front() << \" \";\n        children.pop_front();\n\n        if (!children.empty()) {\n            children.push_back(children.front());\n            children.pop_front();\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 13,
            "mean_time_taken": 0.0830682240999662,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Josephus Problem II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n\nint main() {\n    int n, k;\n    std::cin >> n >> k;\n\n    std::vector<int> removal_order;\n    int current_position = 0;\n\n    while (n > 0) {\n        current_position = (current_position + k) % n;\n        removal_order.push_back(current_position + 1);\n        current_position = (current_position + 1) % n;\n        n--;\n    }\n\n    for (int i = 0; i < removal_order.size(); i++) {\n        std::cout << removal_order[i] << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 17,
            "mean_time_taken": 0.08437709247364718,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                9,
                11,
                13,
                14,
                15,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Josephus Queries",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    long long int numberOfQueries;\n    cin >> numberOfQueries;\n\n    while (numberOfQueries--) {\n        long long int totalElements, kthElement;\n        cin >> totalElements >> kthElement;\n\n        long long int result = (2 * kthElement) % totalElements;\n        if (result < totalElements)\n            cout << result << endl;\n        else\n            cout << result - totalElements << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.13450264930725098,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Knight's Tour",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int BOARD_SIZE = 8;\nint board[BOARD_SIZE][BOARD_SIZE];\nint degree[BOARD_SIZE][BOARD_SIZE];\nint moveX[8] = {2, 1, -1, -2, -2, -1, 1, 2};\nint moveY[8] = {1, 2, 2, 1, -1, -2, -2, -1};\n\nbool isValid(int x, int y) {\n    return (x >= 0 && y >= 0 && x < BOARD_SIZE && y < BOARD_SIZE);\n}\n\nbool depthFirstSearch(int x, int y, int moveNumber, int totalMoves) {\n    int nextX, nextY, temp;\n    board[x][y] = moveNumber;\n    if (moveNumber == totalMoves) return true;\n    for (int i = 0; i < 8; i++) {\n        nextX = x + moveX[i];\n        nextY = y + moveY[i];\n        if (isValid(nextX, nextY)) {\n            if (board[nextX][nextY] == 0) {\n                for (int j = 0; j < 8; j++) {\n                    temp = board[x + moveX[j]][y + moveY[j]];\n                    if (isValid(x + moveX[j], y + moveY[j])) {\n                        if (temp > 0) degree[nextX][nextY]--;\n                    }\n                }\n                if (depthFirstSearch(nextX, nextY, moveNumber + 1, totalMoves)) return true;\n                else {\n                    board[x][y] = 0;\n                    for (int j = 0; j < 8; j++) {\n                        temp = board[x + moveX[j]][y + moveY[j]];\n                        if (isValid(x + moveX[j], y + moveY[j])) {\n                            if (temp > 0) degree[nextX][nextY]++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int startX, startY;\n    cin >> startX >> startY;\n    startX--;\n    startY--;\n    fill(&degree[0][0], &degree[BOARD_SIZE - 1][BOARD_SIZE], 8);\n    degree[startX][startY] = 0;\n    board[startX][startY] = 1;\n    depthFirstSearch(startX, startY, 2, BOARD_SIZE * BOARD_SIZE);\n    for (int i = 0; i < BOARD_SIZE; i++) {\n        for (int j = 0; j < BOARD_SIZE; j++) {\n            cout << board[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 23,
            "mean_time_taken": 0.07931012692658798,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Knuth Division",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    priority_queue<long long> pq;\n    for (int i = 0; i < n; i++) {\n        long long x;\n        cin >> x;\n        pq.push(x);\n    }\n\n    long long total_cost = 0;\n    while (pq.size() > 1) {\n        long long a = pq.top();\n        pq.pop();\n        long long b = pq.top();\n        pq.pop();\n\n        total_cost += a + b;\n        pq.push(a + b);\n    }\n\n    cout << total_cost << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 0.0892190933227539,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Labyrinth",
            "category": "Graph Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Letter Pair Move Game",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_SIZE = 205;\nconst int INF = 0x3f3f3f3f;\n\nint n;\nstring start_state, end_state;\nint dist[MAX_SIZE][MAX_SIZE];\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\nbool is_valid(int x, int y) {\n    return x >= 0 && x < 2 * n && y >= 0 && y < 2 * n;\n}\n\nvoid bfs(int x, int y) {\n    queue<pair<int, int>> q;\n    q.push({x, y});\n    dist[x][y] = 0;\n\n    while (!q.empty()) {\n        int cx = q.front().first;\n        int cy = q.front().second;\n        q.pop();\n\n        for (int i = 0; i < 4; i++) {\n            int nx = cx + dx[i];\n            int ny = cy + dy[i];\n\n            if (is_valid(nx, ny) && start_state[nx] != '.' && start_state[ny] != '.' && dist[nx][ny] == INF) {\n                swap(start_state[cx], start_state[nx]);\n                swap(start_state[cy], start_state[ny]);\n                dist[nx][ny] = dist[cx][cy] + 1;\n                q.push({nx, ny});\n                swap(start_state[cx], start_state[nx]);\n                swap(start_state[cy], start_state[ny]);\n            }\n        }\n    }\n}\n\nint main() {\n    cin >> n;\n    cin >> start_state;\n\n    end_state = \"\";\n    for (int i = 0; i < n - 1; i++) {\n        end_state += \"A\";\n    }\n    for (int i = 0; i < n + 1; i++) {\n        end_state += \".\";\n    }\n    for (int i = 0; i < n - 1; i++) {\n        end_state += \"B\";\n    }\n\n    fill_n(*dist, MAX_SIZE * MAX_SIZE, INF);\n\n    for (int i = 0; i < 2 * n; i++) {\n        for (int j = i + 1; j < 2 * n; j++) {\n            if (start_state[i] != '.' && start_state[j] != '.') {\n                bfs(i, j);\n            }\n        }\n    }\n\n    if (dist[end_state.find('.')][end_state.rfind('.')] == INF) {\n        cout << \"-1\" << endl;\n    } else {\n        cout << dist[end_state.find('.')][end_state.rfind('.')] << endl;\n\n        while (dist[end_state.find('.')][end_state.rfind('.')] > 0) {\n            int x = end_state.find('.');\n            int y = end_state.rfind('.');\n\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n\n                if (is_valid(nx, ny) && start_state[nx] != '.' && start_state[ny] != '.' && dist[nx][ny] == dist[x][y] - 1) {\n                    swap(start_state[x], start_state[nx]);\n                    swap(start_state[y], start_state[ny]);\n                    cout << start_state << endl;\n                    break;\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 24,
            "mean_time_taken": 0.08229575554529826,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                16,
                17,
                18,
                20,
                21,
                22,
                24
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Line Segment Intersection",
            "category": "Geometry",
            "solution": "#include <iostream>\nusing namespace std;\n\n// Function to calculate the orientation of an ordered triple of points\nint orientation(pair<long long, long long> p, pair<long long, long long> q, pair<long long, long long> r) {\n    long long val = (q.second - p.second) * (r.first - q.first) - (q.first - p.first) * (r.second - q.second);\n    if (val == 0) return 0; // collinear\n    return (val > 0) ? 1 : 2; // clockwise or counterclockwise\n}\n\n// Function to check if two line segments intersect\nbool doIntersect(pair<long long, long long> p1, pair<long long, long long> q1, pair<long long, long long> p2, pair<long long, long long> q2) {\n    int o1 = orientation(p1, q1, p2);\n    int o2 = orientation(p1, q1, q2);\n    int o3 = orientation(p2, q2, p1);\n    int o4 = orientation(p2, q2, q1);\n\n    if (o1 != o2 && o3 != o4) return true;\n\n    if (o1 == 0 && onSegment(p1, p2, q1)) return true;\n    if (o2 == 0 && onSegment(p1, q2, q1)) return true;\n    if (o3 == 0 && onSegment(p2, p1, q2)) return true;\n    if (o4 == 0 && onSegment(p2, q1, q2)) return true;\n\n    return false;\n}\n\n// Function to check if a point lies on a line segment\nbool onSegment(pair<long long, long long> p, pair<long long, long long> q, pair<long long, long long> r) {\n    if (q.first <= max(p.first, r.first) && q.first >= min(p.first, r.first) && q.second <= max(p.second, r.second) && q.second >= min(p.second, r.second)) return true;\n    return false;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    int t;\n    cin >> t;\n\n    while (t--) {\n        pair<long long, long long> p1, q1, p2, q2;\n        cin >> p1.first >> p1.second >> q1.first >> q1.second >> p2.first >> p2.second >> q2.first >> q2.second;\n\n        if (doIntersect(p1, q1, p2, q2))\n            cout << \"YES\\n\";\n        else\n            cout << \"NO\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shot": 1
        },
        {
            "title": "List Removals",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    // Read the contents of the list from the input and store them in a vector\n    std::vector<int> list(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> list[i];\n    }\n\n    // Read the positions of the elements to be removed from the input and store them in a vector\n    std::vector<int> positions(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> positions[i];\n    }\n\n    // Iterate through the positions vector and for each position, remove the element at that position from the list vector and insert it at the beginning of the output vector\n    std::vector<int> output;\n    for (int i = 0; i < n; i++) {\n        int pos = positions[i] - 1;\n        output.insert(output.begin(), list[pos]);\n        list.erase(list.begin() + pos);\n    }\n\n    // Print the elements of the output vector\n    for (int i = 0; i < n; i++) {\n        std::cout << output[i] << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 9,
            "mean_time_taken": 0.38191141022576225,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "List of Sums",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int numberOfElements;\n    cin >> numberOfElements;\n\n    vector<int> elements(numberOfElements * (numberOfElements - 1) / 2);\n    for (int i = 0; i < numberOfElements * (numberOfElements - 1) / 2; i++) {\n        cin >> elements[i];\n    }\n\n    sort(elements.begin(), elements.end());\n\n    int smallestElement = elements[0];\n    int largestElement = elements[numberOfElements * (numberOfElements - 1) / 2 - 1];\n    int difference = (largestElement - smallestElement) / (numberOfElements - 1);\n\n    vector<int> result(numberOfElements);\n    result[0] = smallestElement - difference;\n    result[1] = largestElement - difference;\n\n    vector<bool> used(numberOfElements, false);\n    used[0] = used[1] = true;\n\n    for (int i = 2; i < numberOfElements; i++) {\n        for (int j = 0; j < numberOfElements * (numberOfElements - 1) / 2; j++) {\n            if (used[elements[j] - result[0]] || used[elements[j] - result[1]]) {\n                continue;\n            }\n            result[i] = elements[j] - result[1];\n            used[elements[j] - result[0]] = used[elements[j] - result[1]] = true;\n            break;\n        }\n    }\n\n    for (int i = 0; i < numberOfElements; i++) {\n        cout << result[i] << \" \";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.1178053617477417,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "double free or corruption (out)\n",
                "Failed",
                "Failed",
                "double free or corruption (out)\n",
                "Failed",
                "Failed",
                "Failed",
                "double free or corruption (out)\n",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Longest Flight Route",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> adj(n + 1);\n    vector<int> in_degree(n + 1, 0);\n    vector<int> dist(n + 1, -1);\n    vector<int> path;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        in_degree[b]++;\n    }\n\n    queue<int> q;\n    q.push(1);\n    dist[1] = 0;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        for (int v : adj[u]) {\n            in_degree[v]--;\n            if (in_degree[v] == 0) {\n                q.push(v);\n            }\n            if (dist[v] < dist[u] + 1) {\n                dist[v] = dist[u] + 1;\n            }\n        }\n    }\n\n    if (dist[n] == -1) {\n        cout << \"IMPOSSIBLE\" << endl;\n    } else {\n        cout << dist[n] + 1 << endl;\n        int u = n;\n        while (u != 0) {\n            path.push_back(u);\n            for (int v : adj[u]) {\n                if (dist[v] == dist[u] - 1) {\n                    u = v;\n                    break;\n                }\n            }\n        }\n        reverse(path.begin(), path.end());\n        for (int u : path) {\n            cout << u << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Longest Palindrome",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nstd::string preprocess(const std::string& s) {\n    std::string t = \"#\";\n    for (char c : s) {\n        t += c;\n        t += '#';\n    }\n    return t;\n}\n\nstd::string longest_palindrome(const std::string& s) {\n    std::string t = preprocess(s);\n    int n = t.length();\n    std::vector<int> p(n, 0);\n    int center = 0, right = 0;\n    int max_length = 0, center_index = 0;\n\n    for (int i = 1; i < n - 1; i++) {\n        int mirror = 2 * center - i;\n\n        if (right > i) {\n            p[i] = std::min(right - i, p[mirror]);\n        }\n\n        while (t[i + 1 + p[i]] == t[i - 1 - p[i]]) {\n            p[i]++;\n        }\n\n        if (i + p[i] > right) {\n            center = i;\n            right = i + p[i];\n        }\n\n        if (p[i] > max_length) {\n            max_length = p[i];\n            center_index = i;\n        }\n    }\n\n    int start = (center_index - max_length) / 2;\n    return s.substr(start, max_length);\n}\n\nint main() {\n    std::string s;\n    std::cin >> s;\n    std::cout << longest_palindrome(s) << std::endl;\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 19,
            "mean_time_taken": 0.11845658954821135,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "terminate called after throwing an instance of 'std::out_of_range'\n  what():  basic_string::substr: __pos (which is 18446744073709551613) > this->size() (which is 10)\n",
                "terminate called after throwing an instance of 'std::out_of_range'\n  what():  basic_string::substr: __pos (which is 18446744073709551614) > this->size() (which is 998499)\n",
                "terminate called after throwing an instance of 'std::out_of_range'\n  what():  basic_string::substr: __pos (which is 18446744073709551613) > this->size() (which is 1)\n",
                "terminate called after throwing an instance of 'std::out_of_range'\n  what():  basic_string::substr: __pos (which is 18446744073709551613) > this->size() (which is 26)\n",
                "terminate called after throwing an instance of 'std::out_of_range'\n  what():  basic_string::substr: __pos (which is 18446744073709551614) > this->size() (which is 1000000)\n",
                "terminate called after throwing an instance of 'std::out_of_range'\n  what():  basic_string::substr: __pos (which is 18446744073709551614) > this->size() (which is 1000000)\n"
            ],
            "failed_test_cases": [
                2,
                6,
                7,
                9,
                14,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Mail Delivery",
            "category": "Graph Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Maximum Building I",
            "category": "Additional Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Maximum Building II",
            "category": "Additional Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Maximum Subarray Sum",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> arr[i];\n    }\n\n    int max_sum = arr[0];\n    int current_sum = arr[0];\n\n    for (int i = 1; i < n; i++) {\n        current_sum = std::max(arr[i], current_sum + arr[i]);\n        max_sum = std::max(max_sum, current_sum);\n    }\n\n    std::cout << max_sum << std::endl;\n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 15,
            "mean_time_taken": 0.0923163890838623,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                6,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Maximum Subarray Sum II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <deque>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, a, b;\n    cin >> n >> a >> b;\n\n    int arr[n];\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    deque<int> small, large;\n    long long sum = 0, maxSum = LLONG_MIN;\n\n    for (int i = 0; i < n; i++) {\n        sum += arr[i];\n\n        if (i >= a) {\n            large.push_back(sum);\n            maxSum = max(maxSum, sum - (small.empty() ? 0 : small.front()));\n        }\n\n        if (i > b) {\n            sum -= arr[i - b];\n            if (!small.empty() && small.front() == sum - arr[i - b]) {\n                small.pop_front();\n            }\n        }\n\n        if (i >= b) {\n            if (!large.empty() && large.front() == sum - arr[i - a]) {\n                large.pop_front();\n            }\n            if (!small.empty() && small.back() >= sum) {\n                small.pop_back();\n            }\n        }\n\n        small.push_back(sum);\n    }\n\n    cout << maxSum << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Maximum Xor Subarray",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nint maxXorSubarray(std::vector<int>& nums) {\n    int max_xor = 0;\n    int curr_xor = 0;\n\n    for (int num : nums) {\n        curr_xor ^= num;\n        max_xor = std::max(max_xor, curr_xor);\n    }\n\n    return max_xor;\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> nums(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> nums[i];\n    }\n\n    int result = maxXorSubarray(nums);\n    std::cout << result << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 14,
            "mean_time_taken": 0.09367166246686663,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                6,
                10,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Meet in the Middle",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int numberOfElements, targetSum;\n    cin >> numberOfElements >> targetSum;\n\n    vector<int> elements(numberOfElements);\n    for (int i = 0; i < numberOfElements; i++) {\n        cin >> elements[i];\n    }\n\n    // Divide the array into two halves\n    int half = numberOfElements / 2;\n\n    // Generate all possible sums for the first half of the array\n    vector<long long> firstHalfSums;\n    for (int i = 0; i < (1 << half); i++) {\n        long long sum = 0;\n        for (int j = 0; j < half; j++) {\n            if (i & (1 << j)) {\n                sum += elements[j];\n            }\n        }\n        firstHalfSums.push_back(sum);\n    }\n\n    // Generate all possible sums for the second half of the array\n    vector<long long> secondHalfSums;\n    for (int i = 0; i < (1 << (numberOfElements - half)); i++) {\n        long long sum = 0;\n        for (int j = 0; j < (numberOfElements - half); j++) {\n            if (i & (1 << j)) {\n                sum += elements[half + j];\n            }\n        }\n        secondHalfSums.push_back(sum);\n    }\n\n    // Sort the vectors of sums\n    sort(firstHalfSums.begin(), firstHalfSums.end());\n    sort(secondHalfSums.begin(), secondHalfSums.end());\n\n    // Count the number of pairs of sums that add up to the target value\n    long long result = 0;\n    for (int i = 0; i < firstHalfSums.size(); i++) {\n        long long complement = targetSum - firstHalfSums[i];\n        result += upper_bound(secondHalfSums.begin(), secondHalfSums.end(), complement) -\n                  lower_bound(secondHalfSums.begin(), secondHalfSums.end(), complement);\n    }\n\n    // Print the result to standard output\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 23,
            "total_test_cases": 40,
            "mean_time_taken": 0.8130226731300354,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                8,
                11,
                13,
                14,
                15,
                18,
                20,
                21,
                22,
                28,
                33,
                34,
                36,
                37,
                40
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Message Route",
            "category": "Graph Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Minimal Rotation",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n\nint main() {\n    std::string s, t;\n    std::cin >> s;\n    t = s + s;\n    int n = s.length();\n    int min_index = 0;\n    for (int i = 1; i < n; i++) {\n        int j = 0;\n        while (j < n && t[i + j] == t[min_index + j]) {\n            j++;\n        }\n        if (j < n && t[i + j] < t[min_index + j]) {\n            min_index = i;\n        }\n    }\n    std::cout << t.substr(min_index, n) << std::endl;\n    return 0;\n}\n",
            "passed_test_cases": 15,
            "total_test_cases": 20,
            "mean_time_taken": 0.32115180492401124,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                11,
                12,
                15,
                19
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Minimizing Coins",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nconst int INF = 1e9;\n\nint main() {\n    int n, x;\n    std::cin >> n >> x;\n\n    std::vector<int> coins(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> coins[i];\n    }\n\n    std::vector<int> dp(x + 1, INF);\n    dp[0] = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = coins[i]; j <= x; j++) {\n            dp[j] = std::min(dp[j], dp[j - coins[i]] + 1);\n        }\n    }\n\n    if (dp[x] == INF) {\n        std::cout << -1 << std::endl;\n    } else {\n        std::cout << dp[x] << std::endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 16,
            "total_test_cases": 16,
            "mean_time_taken": 0.20449867844581604,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Minimum Euclidean Distance",
            "category": "Geometry",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nstruct Point {\n    int x, y;\n};\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<Point> points(n);\n    for (int i = 0; i < n; i++) {\n        cin >> points[i].x >> points[i].y;\n    }\n\n    sort(points.begin(), points.end(), [](const Point& a, const Point& b) {\n        return a.x < b.x;\n    });\n\n    long long min_dist_sq = LLONG_MAX;\n    for (int i = 1; i < n; i++) {\n        long long dist_sq = (long long)(points[i].x - points[i - 1].x) * (points[i].x - points[i - 1].x) +\n                            (long long)(points[i].y - points[i - 1].y) * (points[i].y - points[i - 1].y);\n        min_dist_sq = min(min_dist_sq, dist_sq);\n    }\n\n    cout << min_dist_sq << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Missing Coin Sum",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> coins(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> coins[i];\n    }\n\n    std::sort(coins.begin(), coins.end());\n\n    int sum = 1;\n    for (int i = 0; i < n; i++) {\n        if (coins[i] > sum) {\n            break;\n        }\n        sum += coins[i];\n    }\n\n    std::cout << sum << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 9,
            "mean_time_taken": 0.10711304346720378,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                5,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Missing Coin Sum Queries",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> coins(n);\n    vector<long long> prefixSum(n + 1);\n\n    for (int i = 0; i < n; i++) {\n        cin >> coins[i];\n        prefixSum[i + 1] = prefixSum[i] + coins[i];\n    }\n\n    for (int i = 0; i < q; i++) {\n        int a, b;\n        cin >> a >> b;\n\n        long long sum = prefixSum[b] - prefixSum[a - 1];\n        long long minValue = sum + 1;\n\n        vector<int> range(b - a + 1);\n        copy(coins.begin() + a - 1, coins.begin() + b, range.begin());\n        sort(range.begin(), range.end());\n\n        long long currentSum = 0;\n        for (int j = 0; j < range.size(); j++) {\n            if (currentSum + 1 < range[j]) {\n                minValue = currentSum + 1;\n                break;\n            }\n            currentSum += range[j];\n        }\n\n        cout << minValue << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 8,
            "mean_time_taken": 0.6780601739883423,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Missing Number",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int sum = n * (n + 1) / 2;\n    int givenSum = 0;\n\n    for (int i = 0; i < n - 1; i++) {\n        int num;\n        cin >> num;\n        givenSum += num;\n    }\n\n    int missingNumber = sum - givenSum;\n    cout << missingNumber << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 14,
            "mean_time_taken": 0.08791281495775495,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                8,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Money Sums",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> coins(n);\n    int maxSum = 0;\n    for (int i = 0; i < n; i++) {\n        std::cin >> coins[i];\n        maxSum += coins[i];\n    }\n\n    std::vector<bool> dp(maxSum + 1, false);\n    dp[0] = true;\n\n    for (int coin : coins) {\n        for (int i = maxSum; i >= coin; i--) {\n            if (dp[i - coin]) {\n                dp[i] = true;\n            }\n        }\n    }\n\n    int count = 0;\n    for (bool possible : dp) {\n        if (possible) {\n            count++;\n        }\n    }\n    std::cout << count << std::endl;\n\n    for (int i = 1; i <= maxSum; i++) {\n        if (dp[i]) {\n            std::cout << i << \" \";\n        }\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 13,
            "mean_time_taken": 0.1379849727337177,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Monotone Subsequences",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n\n        if (k == 1 || k == n) {\n            for (int i = 1; i <= n; i++) {\n                cout << i << \" \";\n            }\n            cout << endl;\n        } else if (k > 1 && k < n) {\n            for (int i = k; i > 1; i--) {\n                cout << i << \" \";\n            }\n            cout << 1 << \" \";\n            for (int i = k + 1; i <= n; i++) {\n                cout << i << \" \";\n            }\n            cout << endl;\n        } else {\n            cout << \"IMPOSSIBLE\" << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.08883023262023926,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Monster Game I",
            "category": "Advanced Techniques",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Monster Game II",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> s(n), f(n);\n    for (int i = 0; i < n; i++) {\n        cin >> s[i];\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> f[i];\n    }\n\n    long long total_time = 0;\n    for (int i = 0; i < n - 1; i++) {\n        long long kill_time = (long long)s[i] * x;\n        long long escape_time = (long long)s[n - 1] * f[i];\n        total_time += min(kill_time, escape_time);\n        x = f[i];\n    }\n\n    total_time += (long long)s[n - 1] * x;\n\n    cout << total_time << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.12057915329933167,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Monsters",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 1005;\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\nchar dir[] = {'U', 'L', 'D', 'R'};\nint dist[MAX][MAX];\nchar move[MAX][MAX];\nint n, m;\nchar grid[MAX][MAX];\n\nbool isValid(int x, int y) {\n    return (x >= 0 && x < n && y >= 0 && y < m && grid[x][y] != '#');\n}\n\nvoid bfs(int sx, int sy) {\n    queue<pair<int, int>> q;\n    q.push({sx, sy});\n    dist[sx][sy] = 0;\n    while (!q.empty()) {\n        int x = q.front().first;\n        int y = q.front().second;\n        q.pop();\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (isValid(nx, ny) && dist[nx][ny] == -1) {\n                dist[nx][ny] = dist[x][y] + 1;\n                move[nx][ny] = dir[i];\n                q.push({nx, ny});\n            }\n        }\n    }\n}\n\nint main() {\n    cin >> n >> m;\n    int sx, sy;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n            dist[i][j] = -1;\n            if (grid[i][j] == 'A') {\n                sx = i;\n                sy = j;\n            }\n        }\n    }\n    bfs(sx, sy);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (i == 0 || i == n - 1 || j == 0 || j == m - 1) {\n                if (dist[i][j] != -1) {\n                    cout << \"YES\" << endl;\n                    cout << dist[i][j] << endl;\n                    int x = i, y = j;\n                    while (dist[x][y] != 0) {\n                        cout << move[x][y];\n                        int d = move[x][y] - 'U';\n                        x -= dx[d];\n                        y -= dy[d];\n                    }\n                    return 0;\n                }\n            }\n        }\n    }\n    cout << \"NO\" << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Movie Festival",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<int, int>> movies(n);\n    for (int i = 0; i < n; i++) {\n        cin >> movies[i].first >> movies[i].second;\n    }\n\n    sort(movies.begin(), movies.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        return a.second < b.second;\n    });\n\n    int count = 1;\n    int end = movies[0].second;\n    for (int i = 1; i < n; i++) {\n        if (movies[i].first >= end) {\n            count++;\n            end = movies[i].second;\n        }\n    }\n\n    cout << count << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.12049380215731534,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Movie Festival II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct Movie {\n    int start, end;\n};\n\nbool compareMovies(Movie a, Movie b) {\n    return a.end < b.end;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<Movie> movies(n);\n    for (int i = 0; i < n; i++) {\n        cin >> movies[i].start >> movies[i].end;\n    }\n\n    sort(movies.begin(), movies.end(), compareMovies);\n\n    priority_queue<int, vector<int>, greater<int>> pq;\n    int count = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (pq.size() < k) {\n            pq.push(movies[i].end);\n            count++;\n        } else if (movies[i].start > pq.top()) {\n            pq.pop();\n            pq.push(movies[i].end);\n            count++;\n        }\n    }\n\n    cout << count << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 13,
            "mean_time_taken": 0.12479516176077035,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                5,
                6,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Movie Festival Queries",
            "category": "Additional Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Moving Robots",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n\nconst int MAX_TURNS = 101;\nconst int MAX_SQUARES = 65;\n\ndouble dp[MAX_TURNS][MAX_SQUARES];\n\nint main() {\n    int k;\n    std::cin >> k;\n\n    // Base case: initially, all squares are empty\n    for (int i = 0; i < MAX_SQUARES; i++) {\n        dp[0][i] = 64;\n    }\n\n    // Iterate through each turn and each square\n    for (int turn = 1; turn <= k; turn++) {\n        for (int square = 0; square < MAX_SQUARES; square++) {\n            double total = 0;\n\n            // Calculate the expected number of empty squares for each direction\n            total += std::max(0.0, dp[turn - 1][square - 1] + (square % 8 != 0 ? 1 : 0) - (square % 8 != 7 ? 1 : 0));\n            total += std::max(0.0, dp[turn - 1][square + 1] + (square % 8 != 7 ? 1 : 0) - (square % 8 != 0 ? 1 : 0));\n            total += std::max(0.0, dp[turn - 1][square - 8] + (square >= 8 ? 1 : 0) - (square >= 56 ? 1 : 0));\n            total += std::max(0.0, dp[turn - 1][square + 8] + (square < 56 ? 1 : 0) - (square >= 8 ? 1 : 0));\n\n            // Divide by 4 to get the expected number of empty squares for the current square\n            dp[turn][square] = total / 4;\n        }\n    }\n\n    // Print the expected number of empty squares after k turns for the center square\n    std::cout << std::fixed << std::setprecision(6) << dp[k][32] << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 16,
            "mean_time_taken": 0.0798635333776474,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Multiplication Table",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n\nint main() {\n    int n;\n    std::cin >> n;\n    int middle_number = (n + 1) / 2;\n    std::cout << middle_number << std::endl;\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 8,
            "mean_time_taken": 0.0832628607749939,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Nearest Smaller Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nvector<int> nearest_smaller_values(vector<int>& arr) {\n    stack<int> s;\n    vector<int> output(arr.size());\n\n    for (int i = 0; i < arr.size(); i++) {\n        while (!s.empty() && arr[s.top()] >= arr[i]) {\n            s.pop();\n        }\n\n        if (s.empty()) {\n            output[i] = 0;\n        } else {\n            output[i] = s.top() + 1;\n        }\n\n        s.push(i);\n    }\n\n    return output;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    vector<int> output = nearest_smaller_values(arr);\n    for (int i = 0; i < output.size(); i++) {\n        cout << output[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.105315061715933,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 28,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Necessary Cities",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_NODES = 100005;\nvector<int> graph[MAX_NODES];\nvector<int> reverse_graph[MAX_NODES];\nint discovery_time[MAX_NODES];\nint low_link[MAX_NODES];\nbool is_necessary[MAX_NODES];\nint timer;\nstack<int> node_stack;\nbool in_stack[MAX_NODES];\n\nvoid tarjan(int node) {\n    discovery_time[node] = low_link[node] = timer++;\n    node_stack.push(node);\n    in_stack[node] = true;\n    for (int neighbor : graph[node]) {\n        if (discovery_time[neighbor] == -1) {\n            tarjan(neighbor);\n            low_link[node] = min(low_link[node], low_link[neighbor]);\n        } else if (in_stack[neighbor]) {\n            low_link[node] = min(low_link[node], discovery_time[neighbor]);\n        }\n    }\n    if (low_link[node] == discovery_time[node]) {\n        int count = 0;\n        int u;\n        do {\n            u = node_stack.top();\n            node_stack.pop();\n            in_stack[u] = false;\n            count++;\n        } while (u != node);\n        if (count > 1) {\n            is_necessary[node] = false;\n        }\n    }\n}\n\nint main() {\n    int num_nodes, num_edges;\n    cin >> num_nodes >> num_edges;\n    for (int i = 0; i < num_edges; i++) {\n        int node1, node2;\n        cin >> node1 >> node2;\n        graph[node1].push_back(node2);\n        reverse_graph[node2].push_back(node1);\n    }\n    memset(discovery_time, -1, sizeof(discovery_time));\n    timer = 0;\n    for (int i = 1; i <= num_nodes; i++) {\n        if (discovery_time[i] == -1) {\n            tarjan(i);\n        }\n    }\n    vector<int> necessary_nodes;\n    for (int i = 1; i <= num_nodes; i++) {\n        if (is_necessary[i]) {\n            necessary_nodes.push_back(i);\n        }\n    }\n    cout << necessary_nodes.size() << endl;\n    for (int node : necessary_nodes) {\n        cout << node << \" \";\n    }\n    cout << endl;\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 8,
            "mean_time_taken": 0.10347294807434082,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 28,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Necessary Roads",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_NODES = 100005;\nvector<int> graph[MAX_NODES];\nint discovery_time[MAX_NODES];\nint low_time[MAX_NODES];\nbool visited[MAX_NODES];\nvector<pair<int, int>> bridges;\nint timer;\n\nvoid dfs(int u, int p) {\n    visited[u] = true;\n    discovery_time[u] = low_time[u] = timer++;\n    for (int v : graph[u]) {\n        if (v == p) continue;\n        if (visited[v]) {\n            low_time[u] = min(low_time[u], discovery_time[v]);\n        } else {\n            dfs(v, u);\n            low_time[u] = min(low_time[u], low_time[v]);\n            if (low_time[v] > discovery_time[u]) {\n                bridges.push_back({min(u, v), max(u, v)});\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n    timer = 0;\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            dfs(i, -1);\n        }\n    }\n    cout << bridges.size() << endl;\n    for (auto bridge : bridges) {\n        cout << bridge.first << \" \" << bridge.second << endl;\n    }\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 5,
            "mean_time_taken": 0.12397675514221192,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 28,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Nested Ranges Check",
            "category": "Sorting and Searching",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 28,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Nested Ranges Count",
            "category": "Sorting and Searching",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 28,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Network Breakdown",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_NODES = 100005;\n\nint parent[MAX_NODES];\nint rank[MAX_NODES];\nint connectedComponents;\n\nint findParent(int node) {\n    if (parent[node] == node) {\n        return node;\n    }\n    return parent[node] = findParent(parent[node]);\n}\n\nvoid unionNodes(int node1, int node2) {\n    int parent1 = findParent(node1);\n    int parent2 = findParent(node2);\n\n    if (parent1 == parent2) {\n        return;\n    }\n\n    if (rank[parent1] < rank[parent2]) {\n        parent[parent1] = parent2;\n    } else if (rank[parent1] > rank[parent2]) {\n        parent[parent2] = parent1;\n    } else {\n        parent[parent2] = parent1;\n        rank[parent1]++;\n    }\n\n    connectedComponents--;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int numNodes, numEdges, numQueries;\n    cin >> numNodes >> numEdges >> numQueries;\n\n    connectedComponents = numNodes;\n\n    for (int i = 1; i <= numNodes; i++) {\n        parent[i] = i;\n        rank[i] = 1;\n    }\n\n    for (int i = 0; i < numEdges; i++) {\n        int node1, node2;\n        cin >> node1 >> node2;\n        unionNodes(node1, node2);\n    }\n\n    for (int i = 0; i < numQueries; i++) {\n        int node1, node2;\n        cin >> node1 >> node2;\n        unionNodes(node1, node2);\n        cout << connectedComponents << \" \";\n    }\n\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 28,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Network Renovation",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 1e5 + 5;\n\nvector<int> adj[MAX_N];\nint subtree_size[MAX_N];\nbool visited[MAX_N];\nint centroid;\n\nvoid dfs(int u, int n) {\n    subtree_size[u] = 1;\n    bool is_centroid = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v, n);\n            subtree_size[u] += subtree_size[v];\n            if (subtree_size[v] > n / 2) {\n                is_centroid = false;\n            }\n        }\n    }\n    if (n - subtree_size[u] > n / 2) {\n        is_centroid = false;\n    }\n    if (is_centroid) {\n        centroid = u;\n    }\n}\n\nvoid solve(int u, int n) {\n    visited[u] = true;\n    vector<int> subtrees;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v, subtree_size[v]);\n            int c = centroid;\n            solve(c, subtree_size[v]);\n            subtrees.push_back(c);\n        }\n    }\n    if (subtrees.empty()) {\n        return;\n    }\n    cout << subtrees.size() << \"\\n\";\n    for (int i = 1; i < subtrees.size(); i++) {\n        cout << subtrees[i] << \" \" << subtrees[0] << \"\\n\";\n    }\n    swap(subtrees[0], subtrees.back());\n    for (int i = 1; i < subtrees.size(); i++) {\n        cout << subtrees[i] << \" \" << subtrees[0] << \"\\n\";\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n;\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(1, n);\n    solve(centroid, n);\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 21,
            "mean_time_taken": 0.14245993750435965,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 28,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "New Flight Routes",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nconst int MAX_NODES = 100000;\n\nint parent[MAX_NODES];\nint rank[MAX_NODES];\n\nvoid initialize() {\n    for (int i = 0; i < MAX_NODES; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n}\n\nint find_parent(int node) {\n    if (parent[node] == node) {\n        return node;\n    }\n    return parent[node] = find_parent(parent[node]);\n}\n\nvoid union_nodes(int node1, int node2) {\n    node1 = find_parent(node1);\n    node2 = find_parent(node2);\n\n    if (node1 == node2) {\n        return;\n    }\n\n    if (rank[node1] < rank[node2]) {\n        parent[node1] = node2;\n    } else if (rank[node1] > rank[node2]) {\n        parent[node2] = node1;\n    } else {\n        parent[node2] = node1;\n        rank[node1]++;\n    }\n}\n\nint main() {\n    int num_nodes, num_edges;\n    std::cin >> num_nodes >> num_edges;\n\n    initialize();\n\n    for (int i = 0; i < num_edges; i++) {\n        int node1, node2;\n        std::cin >> node1 >> node2;\n        union_nodes(node1 - 1, node2 - 1);\n    }\n\n    std::vector<std::pair<int, int>> new_edges;\n    int connected_components = 0;\n\n    for (int i = 0; i < num_nodes; i++) {\n        if (parent[i] == i) {\n            connected_components++;\n            if (new_edges.empty()) {\n                new_edges.push_back({i + 1, 1});\n            } else {\n                for (auto& edge : new_edges) {\n                    edge.second = i + 1;\n                }\n            }\n        }\n    }\n\n    std::cout << connected_components - 1 << std::endl;\n\n    for (auto& edge : new_edges) {\n        std::cout << edge.first << \" \" << edge.second << std::endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 26,
            "mean_time_taken": 0.09365270687983586,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 28,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "New Roads Queries",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Define a structure for the disjoint set data structure\nstruct DisjointSet {\n    vector<int> parent, rank, last_merge_time;\n\n    DisjointSet(int n) {\n        parent.resize(n);\n        rank.resize(n);\n        last_merge_time.resize(n);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            rank[i] = 1;\n            last_merge_time[i] = -1;\n        }\n    }\n\n    // Find the parent of a node\n    int find(int u) {\n        if (parent[u] != u) {\n            parent[u] = find(parent[u]);\n        }\n        return parent[u];\n    }\n\n    // Merge two sets\n    void merge(int u, int v, int time) {\n        u = find(u);\n        v = find(v);\n        if (u == v) return;\n        if (rank[u] < rank[v]) {\n            swap(u, v);\n        }\n        parent[v] = u;\n        rank[u] += rank[v];\n        last_merge_time[u] = time;\n    }\n\n    // Check if two nodes are connected\n    bool is_connected(int u, int v) {\n        return find(u) == find(v);\n    }\n\n    // Get the last merge time of a set\n    int get_last_merge_time(int u) {\n        return last_merge_time[find(u)];\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m, q;\n    cin >> n >> m >> q;\n\n    // Create a disjoint set data structure\n    DisjointSet ds(n);\n\n    // Process the roads\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        ds.merge(u, v, i + 1);\n    }\n\n    // Process the queries\n    for (int i = 0; i < q; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        if (!ds.is_connected(u, v)) {\n            cout << -1 << endl;\n        } else {\n            cout << ds.get_last_merge_time(u) << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 7,
            "mean_time_taken": 0.18088265827723912,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 28,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Nim Game I",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    long long int numberOfTestCases;\n    cin >> numberOfTestCases;\n\n    while (numberOfTestCases--) {\n        long long int sizeOfArray, arrayElement, xorResult = 0;\n        cin >> sizeOfArray;\n\n        for (long long int i = 0; i < sizeOfArray; i++) {\n            cin >> arrayElement;\n            xorResult ^= arrayElement;\n        }\n\n        if (xorResult != 0)\n            cout << \"first\\n\";\n        else\n            cout << \"second\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 4,
            "mean_time_taken": 0.08930867910385132,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 29,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Nim Game II",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    // Read the number of test cases\n    long long numberOfTestCases;\n    cin >> numberOfTestCases;\n\n    // Loop through each test case\n    while (numberOfTestCases--) {\n        long long sizeOfArray;\n        cin >> sizeOfArray;\n\n        // Initialize the XOR value to 0\n        long long xorValue = 0;\n\n        // Loop through each heap\n        for (long long i = 0; i < sizeOfArray; i++) {\n            long long arrayElement;\n            cin >> arrayElement;\n\n            // Calculate the remainder when the heap size is divided by 4\n            // and XOR it with the current XOR value\n            xorValue ^= (arrayElement % 4);\n        }\n\n        // If the XOR value is not equal to 0, the first player wins\n        // Otherwise, the second player wins\n        if (xorValue != 0)\n            cout << \"first\\n\";\n        else\n            cout << \"second\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 4,
            "mean_time_taken": 0.09274828433990479,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 30,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Number Grid",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <algorithm>\n\nint main() {\n    // Read the input values for the row and column indices of the square\n    long long int row, column;\n    std::cin >> row >> column;\n\n    // Calculate the sum of the minimum of the row and column indices\n    long long int result = std::min(row, column) - 1;\n\n    // Add the difference between the maximum of the row and column indices and the minimum of the row and column indices to the result\n    result += std::max(row, column) - std::min(row, column);\n\n    // Print the value at the square\n    std::cout << result;\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 20,
            "mean_time_taken": 0.07943229675292969,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                12,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 30,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Number Spiral",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int numberOfTestCases;\n    cin >> numberOfTestCases;\n\n    while (numberOfTestCases--) {\n        long long row, column, result;\n        cin >> row >> column;\n\n        // Determine the maximum value between the row and column\n        long long maxValue = max(row, column);\n\n        // Calculate the square of the maximum value\n        result = maxValue * maxValue;\n\n        // If the maximum value is odd\n        if (maxValue % 2 != 0) {\n            // If we are looking for a value in the top right of the square\n            if (row == maxValue) {\n                result -= column - 1;\n            }\n            // If we are looking for a value in the bottom left of the square\n            else {\n                result -= maxValue - 1;\n                result -= maxValue - row;\n            }\n        }\n        // If the maximum value is even\n        else {\n            // If we are looking for a value in the bottom right of the square\n            if (row == maxValue) {\n                result -= maxValue - 1;\n                result -= maxValue - column;\n            }\n            // If we are looking for a value in the top left of the square\n            else {\n                result -= column - 1;\n            }\n        }\n\n        // Print the result\n        cout << result << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 2,
            "mean_time_taken": 0.17205703258514404,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                1
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 30,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "One Bit Positions",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nint main() {\n    std::string binaryString;\n    std::cin >> binaryString;\n\n    int n = binaryString.length();\n    std::vector<int> ones;\n\n    // Step 3.1: Find the indices of all 1-bits\n    for (int i = 0; i < n; i++) {\n        if (binaryString[i] == '1') {\n            ones.push_back(i);\n        }\n    }\n\n    // Step 3.2: Count the number of pairs for each k\n    for (int k = 1; k < n; k++) {\n        int count = 0;\n        for (int i = 0; i < ones.size(); i++) {\n            if (ones[i] + k < n && binaryString[ones[i] + k] == '1') {\n                count++;\n            }\n        }\n        std::cout << count << \" \";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 5,
            "mean_time_taken": 0.843669319152832,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 30,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Palindrome Queries",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    string s;\n\n    cin >> n >> m;\n    cin >> s;\n\n    for (int i = 0; i < m; i++) {\n        int type;\n        cin >> type;\n\n        if (type == 1) {\n            int k;\n            char x;\n            cin >> k >> x;\n            s[k - 1] = x;\n        } else {\n            int a, b;\n            cin >> a >> b;\n\n            bool is_palindrome = true;\n            for (int j = 0; j < (b - a + 1) / 2; j++) {\n                if (s[a - 1 + j] != s[b - 1 - j]) {\n                    is_palindrome = false;\n                    break;\n                }\n            }\n\n            if (is_palindrome) {\n                cout << \"YES\" << endl;\n            } else {\n                cout << \"NO\" << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 14,
            "mean_time_taken": 0.5072710514068604,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                6,
                8,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 30,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Palindrome Reorder",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nint main() {\n    string input;\n    cin >> input;\n\n    map<char, int> frequency;\n    for (char c : input) {\n        frequency[c]++;\n    }\n\n    int oddCount = 0;\n    char oddChar;\n    for (auto const& entry : frequency) {\n        if (entry.second % 2 == 1) {\n            oddCount++;\n            oddChar = entry.first;\n        }\n    }\n\n    if (oddCount > 1) {\n        cout << \"NO SOLUTION\";\n        return 0;\n    }\n\n    string firstHalf = \"\";\n    string secondHalf = \"\";\n    for (auto const& entry : frequency) {\n        for (int i = 0; i < entry.second / 2; i++) {\n            firstHalf += entry.first;\n            secondHalf = entry.first + secondHalf;\n        }\n    }\n\n    string result = firstHalf;\n    if (oddCount == 1) {\n        result += oddChar;\n    }\n    result += secondHalf;\n\n    cout << result;\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 17,
            "mean_time_taken": 0.31114621723399444,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                5,
                6,
                9,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 30,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Parcel Delivery",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_NODES = 505;\nconst long long INF = 1e18;\n\nint numNodes, numEdges, maxFlow;\nlong long distance[MAX_NODES][MAX_NODES];\n\nstruct Edge {\n    int destination;\n    int capacity;\n    int cost;\n    int reverseEdgeIndex;\n};\n\nvector<Edge> graph[MAX_NODES];\n\nvoid addEdge(int source, int destination, int capacity, int cost) {\n    graph[source].push_back({destination, capacity, cost, (int)graph[destination].size()});\n    graph[destination].push_back({source, 0, -cost, (int)(graph[source].size() - 1)});\n}\n\nint minCostFlow() {\n    long long flow = 0, cost = 0;\n    while (flow < maxFlow) {\n        for (int i = 0; i < MAX_NODES; i++) {\n            fill(distance[i], distance[i] + MAX_NODES, INF);\n        }\n        distance[0][1] = 0;\n        bool updated = true;\n        while (updated) {\n            updated = false;\n            for (int node = 0; node < MAX_NODES; node++) {\n                for (int edgeIndex = 0; edgeIndex < graph[node].size(); edgeIndex++) {\n                    Edge& edge = graph[node][edgeIndex];\n                    if (edge.capacity > 0 && distance[node][edge.destination] > distance[node][node] + edge.cost) {\n                        distance[node][edge.destination] = distance[node][node] + edge.cost;\n                        updated = true;\n                    }\n                }\n            }\n        }\n        if (distance[MAX_NODES - 1][1] == INF) {\n            return -1;\n        }\n        int currentNode = MAX_NODES - 1;\n        while (currentNode != 1) {\n            for (int edgeIndex = 0; edgeIndex < graph[currentNode].size(); edgeIndex++) {\n                Edge& edge = graph[currentNode][edgeIndex];\n                if (edge.capacity > 0 && distance[currentNode][currentNode] == distance[edge.destination][currentNode] + edge.cost) {\n                    currentNode = edge.destination;\n                    break;\n                }\n            }\n        }\n        int flowToAdd = maxFlow - flow;\n        currentNode = MAX_NODES - 1;\n        while (currentNode != 1) {\n            for (int edgeIndex = 0; edgeIndex < graph[currentNode].size(); edgeIndex++) {\n                Edge& edge = graph[currentNode][edgeIndex];\n                if (edge.capacity > 0 && distance[currentNode][currentNode] == distance[edge.destination][currentNode] + edge.cost) {\n                    flowToAdd = min(flowToAdd, edge.capacity);\n                    currentNode = edge.destination;\n                    break;\n                }\n            }\n        }\n        flow += flowToAdd;\n        cost += flowToAdd * distance[MAX_NODES - 1][1];\n        currentNode = MAX_NODES - 1;\n        while (currentNode != 1) {\n            for (int edgeIndex = 0; edgeIndex < graph[currentNode].size(); edgeIndex++) {\n                Edge& edge = graph[currentNode][edgeIndex];\n                if (edge.capacity > 0 && distance[currentNode][currentNode] == distance[edge.destination][currentNode] + edge.cost) {\n                    edge.capacity -= flowToAdd;\n                    graph[edge.destination][edge.reverseEdgeIndex].capacity += flowToAdd;\n                    currentNode = edge.destination;\n                    break;\n                }\n            }\n        }\n    }\n    return cost;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> numNodes >> numEdges >> maxFlow;\n    for (int i = 0; i < numEdges; i++) {\n        int source, destination, capacity, cost;\n        cin >> source >> destination >> capacity >> cost;\n        addEdge(source, destination, capacity, cost);\n    }\n    cout << minCostFlow() << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 30,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Path Queries",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nvector<int> adj[MAX_N];\nint node_val[MAX_N], subtree_size[MAX_N], parent[MAX_N], depth[MAX_N], head[MAX_N], pos[MAX_N], arr[MAX_N];\nint n, q;\n\nvoid dfs1(int u, int p) {\n    subtree_size[u] = 1;\n    parent[u] = p;\n    depth[u] = depth[p] + 1;\n    for (auto& v : adj[u]) {\n        if (v != p) {\n            dfs1(v, u);\n            subtree_size[u] += subtree_size[v];\n        }\n    }\n}\n\nint cnt = 0;\nvoid dfs2(int u, int h) {\n    head[u] = h;\n    pos[u] = cnt++;\n    arr[pos[u]] = node_val[u];\n    int heavy_child = -1;\n    for (auto& v : adj[u]) {\n        if (v != parent[u] && (heavy_child == -1 || subtree_size[v] > subtree_size[heavy_child])) {\n            heavy_child = v;\n        }\n    }\n    if (heavy_child != -1) {\n        dfs2(heavy_child, h);\n    }\n    for (auto& v : adj[u]) {\n        if (v != parent[u] && v != heavy_child) {\n            dfs2(v, v);\n        }\n    }\n}\n\nstruct SegmentTree {\n    vector<long long> sum;\n    SegmentTree(int n) {\n        sum.resize(4 * n);\n    }\n    void update(int p, int val) {\n        p += sum.size() / 2;\n        sum[p] = val;\n        for (p /= 2; p > 0; p /= 2) {\n            sum[p] = sum[2 * p] + sum[2 * p + 1];\n        }\n    }\n    long long query(int l, int r) {\n        long long res = 0;\n        for (l += sum.size() / 2, r += sum.size() / 2; l < r; l /= 2, r /= 2) {\n            if (l & 1) {\n                res += sum[l++];\n            }\n            if (r & 1) {\n                res += sum[--r];\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> n >> q;\n    for (int i = 1; i <= n; i++) {\n        cin >> node_val[i];\n    }\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs1(1, 0);\n    dfs2(1, 1);\n    SegmentTree st(n);\n    for (int i = 0; i < n; i++) {\n        st.update(i, arr[i]);\n    }\n    while (q--) {\n        int type, s, x;\n        cin >> type >> s;\n        if (type == 1) {\n            cin >> x;\n            st.update(pos[s], x);\n            node_val[s] = x;\n        } else {\n            long long res = 0;\n            while (head[s] != 1) {\n                res += st.query(pos[head[s]], pos[s] + 1);\n                s = parent[head[s]];\n            }\n            res += st.query(0, pos[s] + 1);\n            cout << res << \"\\n\";\n        }\n    }\n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 10,
            "mean_time_taken": 0.15918071269989015,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 30,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Path Queries II",
            "category": "Tree Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 30,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Pattern Positions",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Function to preprocess the pattern and create the lps array\nvoid computeLPSArray(string pat, int M, vector<int>& lps) {\n    int len = 0;\n    lps[0] = 0;\n    int i = 1;\n    while (i < M) {\n        if (pat[i] == pat[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        } else {\n            if (len != 0) {\n                len = lps[len - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n}\n\n// Function to search for the pattern in the input string using the KMP algorithm\nint KMPSearch(string pat, string txt) {\n    int M = pat.length();\n    int N = txt.length();\n\n    vector<int> lps(M);\n    computeLPSArray(pat, M, lps);\n\n    int i = 0;\n    int j = 0;\n    while (i < N) {\n        if (pat[j] == txt[i]) {\n            j++;\n            i++;\n        }\n        if (j == M) {\n            return i - j + 1;\n            j = lps[j - 1];\n        } else if (i < N && pat[j] != txt[i]) {\n            if (j != 0)\n                j = lps[j - 1];\n            else\n                i = i + 1;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    string txt;\n    cin >> txt;\n\n    int k;\n    cin >> k;\n\n    for (int i = 0; i < k; i++) {\n        string pat;\n        cin >> pat;\n\n        int pos = KMPSearch(pat, txt);\n        cout << pos << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 10,
            "mean_time_taken": 0.5018560647964477,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                5,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 30,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Permutation Inversions",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#define MOD 1000000007\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<vector<long long>> dp(n + 1, vector<long long>(k + 1, 0));\n    dp[0][0] = 1;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= k; j++) {\n            for (int l = 0; l <= min(j, i - 1); l++) {\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - l]) % MOD;\n            }\n        }\n    }\n\n    cout << dp[n][k] << endl;\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 16,
            "mean_time_taken": 0.2647727131843567,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                7,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 30,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Permutations",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    if (n == 1) {\n        cout << \"NO SOLUTION\";\n        return 0;\n    }\n\n    int left = 1, right = n;\n    while (left <= right) {\n        cout << right << \" \" << left << \" \";\n        left++;\n        right--;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 21,
            "mean_time_taken": 0.09262432370867048,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 30,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Permutations II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countBeautifulPermutations(int n) {\n    vector<int> dp(n + 1);\n    dp[1] = 1;\n    dp[2] = 2;\n    for (int i = 3; i <= n; i++) {\n        dp[i] = (1LL * dp[i - 1] * (i - 1) + 1LL * dp[i - 2] * (i - 2)) % MOD;\n    }\n    return dp[n];\n}\n\nint main() {\n    int n;\n    cin >> n;\n    cout << countBeautifulPermutations(n) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 23,
            "mean_time_taken": 0.07959243525629459,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 30,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Pizzeria Queries",
            "category": "Range Queries",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nconst int INF = 1e9 + 7;\n\nint n, q;\nint arr[MAX_N];\n\nstruct Node {\n    int min_val;\n    Node() { min_val = INF; }\n};\n\nNode tree[4 * MAX_N];\n\nNode merge(Node a, Node b) {\n    Node c;\n    c.min_val = min(a.min_val, b.min_val);\n    return c;\n}\n\nvoid build(int node, int start, int end) {\n    if (start == end) {\n        tree[node].min_val = arr[start];\n    } else {\n        int mid = (start + end) / 2;\n        build(2 * node, start, mid);\n        build(2 * node + 1, mid + 1, end);\n        tree[node] = merge(tree[2 * node], tree[2 * node + 1]);\n    }\n}\n\nvoid update(int node, int start, int end, int idx, int val) {\n    if (start == end) {\n        arr[idx] = val;\n        tree[node].min_val = val;\n    } else {\n        int mid = (start + end) / 2;\n        if (idx <= mid)\n            update(2 * node, start, mid, idx, val);\n        else\n            update(2 * node + 1, mid + 1, end, idx, val);\n        tree[node] = merge(tree[2 * node], tree[2 * node + 1]);\n    }\n}\n\nNode query(int node, int start, int end, int l, int r) {\n    if (r < start || end < l) {\n        return Node();\n    }\n    if (l <= start && end <= r) {\n        return tree[node];\n    }\n    int mid = (start + end) / 2;\n    Node p1 = query(2 * node, start, mid, l, r);\n    Node p2 = query(2 * node + 1, mid + 1, end, l, r);\n    return merge(p1, p2);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    cin >> n >> q;\n    for (int i = 1; i <= n; i++) {\n        cin >> arr[i];\n    }\n    build(1, 1, n);\n    while (q--) {\n        int type, x;\n        cin >> type >> x;\n        if (type == 1) {\n            int y;\n            cin >> y;\n            update(1, 1, n, x, y);\n        } else {\n            int left = max(1, x - arr[x]);\n            int right = min(n, x + arr[x]);\n            Node result = query(1, 1, n, left, right);\n            cout << result.min_val + abs(x - result.min_val) << \"\\n\";\n        }\n    }\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 4,
            "mean_time_taken": 0.11284410953521729,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 30,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Planets Cycles",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nint n, t[MAX_N], visited[MAX_N], cycle_length[MAX_N];\n\nvoid dfs(int current, int length) {\n  visited[current] = true;\n  int next = t[current];\n  if (visited[next]) {\n    cycle_length[current] = length;\n  } else {\n    dfs(next, length + 1);\n    cycle_length[current] = cycle_length[next];\n  }\n}\n\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> t[i];\n  }\n  for (int i = 1; i <= n; i++) {\n    if (!visited[i]) {\n      dfs(i, 1);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    cout << cycle_length[i] << \" \";\n  }\n  cout << endl;\n  return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 14,
            "mean_time_taken": 0.1051790884562901,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                6,
                7,
                8,
                9,
                10,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 30,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Planets Queries I",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> teleporters(n);\n    for (int i = 0; i < n; i++) {\n        cin >> teleporters[i];\n        teleporters[i]--; // adjust index to be 0-based\n    }\n\n    const int MAX_LOG = 30;\n    vector<vector<int>> next_planet(MAX_LOG, vector<int>(n));\n    for (int i = 0; i < n; i++) {\n        next_planet[0][i] = teleporters[i];\n    }\n\n    for (int i = 1; i < MAX_LOG; i++) {\n        for (int j = 0; j < n; j++) {\n            next_planet[i][j] = next_planet[i - 1][next_planet[i - 1][j]];\n        }\n    }\n\n    for (int i = 0; i < q; i++) {\n        int x, k;\n        cin >> x >> k;\n        x--; // adjust index to be 0-based\n\n        int ans = x;\n        for (int j = 0; j < MAX_LOG; j++) {\n            if ((k >> j) & 1) {\n                ans = next_planet[j][ans];\n            }\n        }\n\n        cout << ans + 1 << endl; // adjust index to be 1-based\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.20452207785386306,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 31,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Planets Queries II",
            "category": "Graph Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 31,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Planets and Kingdoms",
            "category": "Graph Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 31,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Playlist",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <set>\n#include <vector>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> songs(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> songs[i];\n    }\n\n    std::set<int> unique_songs;\n    int left = 0, right = 0;\n    int max_length = 0;\n\n    while (right < n) {\n        if (unique_songs.find(songs[right]) == unique_songs.end()) {\n            unique_songs.insert(songs[right]);\n            max_length = std::max(max_length, right - left + 1);\n            right++;\n        } else {\n            unique_songs.erase(songs[left]);\n            left++;\n        }\n    }\n\n    std::cout << max_length << std::endl;\n    return 0;\n}\n",
            "passed_test_cases": 20,
            "total_test_cases": 20,
            "mean_time_taken": 0.17197246551513673,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Point Location Test",
            "category": "Geometry",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int x1, y1, x2, y2, x3, y3;\n        cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\n        int cross_product = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);\n\n        if (cross_product > 0)\n            cout << \"LEFT\" << endl;\n        else if (cross_product < 0)\n            cout << \"RIGHT\" << endl;\n        else\n            cout << \"TOUCH\" << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 6,
            "mean_time_taken": 0.16087937355041504,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Point in Polygon",
            "category": "Geometry",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Define a structure for points\nstruct Point {\n    long long x, y;\n};\n\n// Function to check if a point is on a line segment\nbool isOnSegment(Point p, Point q, Point r) {\n    if (q.x <= max(p.x, r.x) && q.x >= min(p.x, r.x) &&\n        q.y <= max(p.y, r.y) && q.y >= min(p.y, r.y))\n        return true;\n    return false;\n}\n\n// Function to check the orientation of three points\nint orientation(Point p, Point q, Point r) {\n    long long val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    if (val == 0) return 0;  // colinear\n    return (val > 0) ? 1 : 2; // clock or counterclockwise\n}\n\n// Function to check if two line segments intersect\nbool doIntersect(Point p1, Point q1, Point p2, Point q2) {\n    int o1 = orientation(p1, q1, p2);\n    int o2 = orientation(p1, q1, q2);\n    int o3 = orientation(p2, q2, p1);\n    int o4 = orientation(p2, q2, q1);\n\n    if (o1 != o2 && o3 != o4) return true;\n    if (o1 == 0 && isOnSegment(p1, p2, q1)) return true;\n    if (o2 == 0 && isOnSegment(p1, q2, q1)) return true;\n    if (o3 == 0 && isOnSegment(p2, p1, q2)) return true;\n    if (o4 == 0 && isOnSegment(p2, q1, q2)) return true;\n\n    return false;\n}\n\n// Function to check if a point is inside a polygon\nbool isInside(Point polygon[], int n, Point p) {\n    if (n < 3) return false;\n\n    Point extreme = {INT_MAX, p.y};\n    int count = 0, i = 0;\n    do {\n        int next = (i + 1) % n;\n        if (doIntersect(polygon[i], polygon[next], p, extreme)) {\n            if (orientation(polygon[i], p, polygon[next]) == 0)\n                return isOnSegment(polygon[i], p, polygon[next]);\n            count++;\n        }\n        i = next;\n    } while (i != 0);\n\n    return count & 1;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    Point polygon[n];\n    for (int i = 0; i < n; i++) {\n        cin >> polygon[i].x >> polygon[i].y;\n    }\n\n    for (int i = 0; i < m; i++) {\n        Point p;\n        cin >> p.x >> p.y;\n        if (isInside(polygon, n, p))\n            cout << \"INSIDE\\n\";\n        else\n            cout << \"OUTSIDE\\n\";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 8,
            "mean_time_taken": 0.08174866437911987,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Police Chase",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_NODES = 505;\n\nint numNodes, numEdges;\nvector<int> graph[MAX_NODES];\nvector<pair<int, int>> result;\nbool visited[MAX_NODES];\n\n// Perform BFS from the source node and return true if the target node is reachable\nbool breadthFirstSearch(int source, int target) {\n    queue<int> nodeQueue;\n    nodeQueue.push(source);\n    visited[source] = true;\n\n    while (!nodeQueue.empty()) {\n        int currentNode = nodeQueue.front();\n        nodeQueue.pop();\n\n        for (int neighbor : graph[currentNode]) {\n            if (visited[neighbor]) continue;\n\n            visited[neighbor] = true;\n            nodeQueue.push(neighbor);\n        }\n    }\n\n    return visited[target];\n}\n\n// Remove an edge from the graph and return true if the target node is still reachable\nbool removeEdge(int node1, int node2, int target) {\n    for (auto it = graph[node1].begin(); it != graph[node1].end(); ++it) {\n        if (*it == node2) {\n            graph[node1].erase(it);\n            break;\n        }\n    }\n\n    for (auto it = graph[node2].begin(); it != graph[node2].end(); ++it) {\n        if (*it == node1) {\n            graph[node2].erase(it);\n            break;\n        }\n    }\n\n    fill(visited, visited + MAX_NODES, false);\n    bool isReachable = breadthFirstSearch(1, target);\n\n    graph[node1].push_back(node2);\n    graph[node2].push_back(node1);\n\n    return isReachable;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> numNodes >> numEdges;\n\n    for (int i = 0; i < numEdges; ++i) {\n        int node1, node2;\n        cin >> node1 >> node2;\n        graph[node1].push_back(node2);\n        graph[node2].push_back(node1);\n    }\n\n    for (int i = 2; i < numNodes; ++i) {\n        if (!removeEdge(i, numNodes, numNodes)) {\n            result.push_back({i, numNodes});\n        }\n    }\n\n    cout << result.size() << '\\n';\n\n    for (auto edge : result) {\n        cout << edge.first << ' ' << edge.second << '\\n';\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.08210186958312989,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Polygon Area",
            "category": "Geometry",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct Point {\n    long long x, y;\n};\n\nlong long crossProduct(Point a, Point b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<Point> points(n);\n    for (int i = 0; i < n; i++) {\n        cin >> points[i].x >> points[i].y;\n    }\n\n    long long area = 0;\n    for (int i = 0; i < n; i++) {\n        area += crossProduct(points[i], points[(i + 1) % n]);\n    }\n\n    cout << abs(area / 2) << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 5,
            "mean_time_taken": 0.08566045761108398,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Polygon Lattice Points",
            "category": "Geometry",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nll gcd(ll a, ll b) {\n    return b ? gcd(b, a % b) : a;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    ll n, x, y, prev_x, prev_y, area = 0, boundary_points = 0;\n    cin >> n;\n    cin >> prev_x >> prev_y;\n    for (ll i = 1; i < n; i++) {\n        cin >> x >> y;\n        area += (prev_x * y - x * prev_y);\n        boundary_points += gcd(abs(x - prev_x), abs(y - prev_y));\n        prev_x = x;\n        prev_y = y;\n    }\n    area += (prev_x * y - x * prev_y);\n    boundary_points += gcd(abs(x - prev_x), abs(y - prev_y));\n    area = abs(area) / 2;\n    ll interior_points = area - boundary_points / 2 + 1;\n    cout << interior_points << \" \" << boundary_points << \"\\n\";\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 5,
            "mean_time_taken": 0.07926573753356933,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Polynomial Queries",
            "category": "Range Queries",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Prefix Sum Queries",
            "category": "Range Queries",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nint n, q;\nint arr[MAX_N];\n\nstruct Node {\n    int sum, pref, suff, ans;\n    Node() {}\n    Node(int sum, int pref, int suff, int ans) : sum(sum), pref(pref), suff(suff), ans(ans) {}\n};\n\nNode merge(Node a, Node b) {\n    Node c;\n    c.sum = a.sum + b.sum;\n    c.pref = max(a.pref, a.sum + b.pref);\n    c.suff = max(b.suff, b.sum + a.suff);\n    c.ans = max({a.ans, b.ans, a.suff + b.pref});\n    return c;\n}\n\nNode tree[4 * MAX_N];\n\nvoid build(int node, int start, int end) {\n    if (start == end) {\n        tree[node] = Node(arr[start], arr[start], arr[start], arr[start]);\n        return;\n    }\n    int mid = (start + end) / 2;\n    build(2 * node, start, mid);\n    build(2 * node + 1, mid + 1, end);\n    tree[node] = merge(tree[2 * node], tree[2 * node + 1]);\n}\n\nvoid update(int node, int start, int end, int idx, int val) {\n    if (start == end) {\n        tree[node] = Node(val, val, val, val);\n        return;\n    }\n    int mid = (start + end) / 2;\n    if (idx <= mid)\n        update(2 * node, start, mid, idx, val);\n    else\n        update(2 * node + 1, mid + 1, end, idx, val);\n    tree[node] = merge(tree[2 * node], tree[2 * node + 1]);\n}\n\nNode query(int node, int start, int end, int l, int r) {\n    if (start == l && end == r)\n        return tree[node];\n    int mid = (start + end) / 2;\n    if (r <= mid)\n        return query(2 * node, start, mid, l, r);\n    else if (l > mid)\n        return query(2 * node + 1, mid + 1, end, l, r);\n    else\n        return merge(query(2 * node, start, mid, l, mid), query(2 * node + 1, mid + 1, end, mid + 1, r));\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    cin >> n >> q;\n    for (int i = 1; i <= n; i++)\n        cin >> arr[i];\n    build(1, 1, n);\n    while (q--) {\n        int type, x, y;\n        cin >> type >> x >> y;\n        if (type == 1)\n            update(1, 1, n, x, y);\n        else\n            cout << query(1, 1, n, x, y).ans << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.1645050843556722,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Prime Multiples",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    long long n, k;\n    cin >> n >> k;\n\n    vector<long long> primes(k);\n    for (int i = 0; i < k; i++) {\n        cin >> primes[i];\n    }\n\n    long long result = 0;\n    for (int i = 1; i < (1 << k); i++) {\n        long long product = 1;\n        int count = 0;\n        for (int j = 0; j < k; j++) {\n            if (i & (1 << j)) {\n                product *= primes[j];\n                count++;\n            }\n        }\n        if (count % 2 == 1) {\n            result += n / product;\n        } else {\n            result -= n / product;\n        }\n    }\n\n    cout << result << endl;\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 5,
            "mean_time_taken": 0.11210556030273437,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Programmers and Artists",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int a, b, n;\n    cin >> a >> b >> n;\n\n    priority_queue<int, vector<int>, greater<int>> minProgrammers, minArtists;\n\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n\n        minProgrammers.push(x);\n        if (minProgrammers.size() > a) {\n            minProgrammers.pop();\n        }\n\n        minArtists.push(y);\n        if (minArtists.size() > b) {\n            minArtists.pop();\n        }\n    }\n\n    long long sum = 0;\n    while (!minProgrammers.empty()) {\n        sum += minProgrammers.top();\n        minProgrammers.pop();\n    }\n\n    while (!minArtists.empty()) {\n        sum += minArtists.top();\n        minArtists.pop();\n    }\n\n    cout << sum << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 11,
            "mean_time_taken": 0.13992255384271796,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Projects",
            "category": "Dynamic Programming",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1e9 + 1;\nlong long segment_tree[4 * MAX_N];\n\nvoid update(int node, int start, int end, int idx, long long val) {\n    if (start == end) {\n        segment_tree[node] = val;\n        return;\n    }\n    int mid = (start + end) / 2;\n    if (idx <= mid)\n        update(2 * node, start, mid, idx, val);\n    else\n        update(2 * node + 1, mid + 1, end, idx, val);\n    segment_tree[node] = max(segment_tree[2 * node], segment_tree[2 * node + 1]);\n}\n\nlong long query(int node, int start, int end, int l, int r) {\n    if (start > r || end < l)\n        return 0;\n    if (start >= l && end <= r)\n        return segment_tree[node];\n    int mid = (start + end) / 2;\n    return max(query(2 * node, start, mid, l, r), query(2 * node + 1, mid + 1, end, l, r));\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<tuple<int, int, int>> projects(n);\n    for (int i = 0; i < n; i++) {\n        int a, b, p;\n        cin >> a >> b >> p;\n        projects[i] = make_tuple(b, a, p);\n    }\n    sort(projects.begin(), projects.end());\n    long long max_reward = 0;\n    for (auto& project : projects) {\n        int b = get<0>(project), a = get<1>(project), p = get<2>(project);\n        long long prev_reward = query(1, 1, MAX_N, 1, a - 1);\n        update(1, 1, MAX_N, b, prev_reward + p);\n        max_reward = max(max_reward, prev_reward + p);\n    }\n    cout << max_reward << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Pr\u00fcfer Code",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> prueferCode(n - 2);\n    for (int i = 0; i < n - 2; i++) {\n        cin >> prueferCode[i];\n    }\n\n    vector<int> nodes(n);\n    iota(nodes.begin(), nodes.end(), 1);\n\n    vector<int> frequency(n + 1, 0);\n    for (int i = 0; i < n - 2; i++) {\n        frequency[prueferCode[i]]++;\n    }\n\n    vector<int> leaves;\n    for (int i = 1; i <= n; i++) {\n        if (frequency[i] == 0) {\n            leaves.push_back(i);\n        }\n    }\n\n    for (int i = 0; i < n - 2; i++) {\n        int smallestNode = *min_element(nodes.begin(), nodes.end(), [&](int a, int b) {\n            return frequency[a] == 0 && find(leaves.begin(), leaves.end(), a) == leaves.end();\n        });\n\n        cout << smallestNode << \" \" << prueferCode[i] << endl;\n\n        frequency[prueferCode[i]]--;\n        if (frequency[prueferCode[i]] == 0) {\n            leaves.push_back(prueferCode[i]);\n        }\n\n        nodes.erase(find(nodes.begin(), nodes.end(), smallestNode));\n    }\n\n    cout << nodes[0] << \" \" << nodes[1] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Pyramid Array",
            "category": "Additional Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Range Queries and Copies",
            "category": "Range Queries",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Define a structure to represent a segment tree node\nstruct Node {\n    long long sum;\n    Node* left;\n    Node* right;\n    Node(long long s) : sum(s), left(NULL), right(NULL) {}\n};\n\n// Build the segment tree from the input array\nNode* buildTree(vector<long long>& a, int start, int end) {\n    if (start == end) {\n        return new Node(a[start]);\n    }\n    int mid = (start + end) / 2;\n    Node* left = buildTree(a, start, mid);\n    Node* right = buildTree(a, mid + 1, end);\n    Node* node = new Node(left->sum + right->sum);\n    node->left = left;\n    node->right = right;\n    return node;\n}\n\n// Update the value of an element in the array and the segment tree\nvoid update(Node* node, int start, int end, int idx, long long val) {\n    if (start == end) {\n        node->sum = val;\n        return;\n    }\n    int mid = (start + end) / 2;\n    if (idx <= mid) {\n        update(node->left, start, mid, idx, val);\n    } else {\n        update(node->right, mid + 1, end, idx, val);\n    }\n    node->sum = node->left->sum + node->right->sum;\n}\n\n// Calculate the sum of values in a range of the array using the segment tree\nlong long query(Node* node, int start, int end, int l, int r) {\n    if (r < start || end < l) {\n        return 0;\n    }\n    if (l <= start && end <= r) {\n        return node->sum;\n    }\n    int mid = (start + end) / 2;\n    return query(node->left, start, mid, l, r) + query(node->right, mid + 1, end, l, r);\n}\n\n// Create a copy of an array and add it to the end of the list\nvoid copyArray(vector<Node*>& trees, int idx) {\n    Node* newTree = buildTree(*(trees[idx]), 0, trees[idx]->sum.size() - 1);\n    trees.push_back(newTree);\n}\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    vector<long long> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    vector<Node*> trees;\n    trees.push_back(buildTree(a, 0, n - 1));\n    for (int i = 0; i < q; i++) {\n        int type;\n        cin >> type;\n        if (type == 1) {\n            int k, a, x;\n            cin >> k >> a >> x;\n            update(trees[k - 1], 0, n - 1, a - 1, x);\n        } else if (type == 2) {\n            int k, a, b;\n            cin >> k >> a >> b;\n            cout << query(trees[k - 1], 0, n - 1, a - 1, b - 1) << endl;\n        } else {\n            int k;\n            cin >> k;\n            copyArray(trees, k - 1);\n        }\n    }\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Range Update Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Define a segment tree data structure\nstruct SegmentTree {\n    int n;\n    vector<long long> values, updates;\n\n    // Build the segment tree from the input array\n    void build(vector<long long>& arr) {\n        n = arr.size();\n        values.resize(4 * n);\n        updates.resize(4 * n);\n        build(arr, 1, 0, n - 1);\n    }\n\n    void build(vector<long long>& arr, int node, int start, int end) {\n        if (start == end) {\n            values[node] = arr[start];\n        } else {\n            int mid = (start + end) / 2;\n            build(arr, 2 * node, start, mid);\n            build(arr, 2 * node + 1, mid + 1, end);\n            values[node] = values[2 * node] + values[2 * node + 1];\n        }\n    }\n\n    // Propagate the updates from a parent node to its children nodes\n    void propagate(int node, int start, int end) {\n        if (updates[node] != 0) {\n            int mid = (start + end) / 2;\n            updates[2 * node] += updates[node];\n            updates[2 * node + 1] += updates[node];\n            values[2 * node] += updates[node] * (mid - start + 1);\n            values[2 * node + 1] += updates[node] * (end - mid);\n            updates[node] = 0;\n        }\n    }\n\n    // Update the values in a given range by a certain value\n    void update(int left, int right, long long value) {\n        update(1, 0, n - 1, left, right, value);\n    }\n\n    void update(int node, int start, int end, int left, int right, long long value) {\n        propagate(node, start, end);\n        if (left > end || right < start) {\n            return;\n        }\n        if (left <= start && end <= right) {\n            updates[node] += value;\n            values[node] += value * (end - start + 1);\n            return;\n        }\n        int mid = (start + end) / 2;\n        update(2 * node, start, mid, left, right, value);\n        update(2 * node + 1, mid + 1, end, left, right, value);\n        values[node] = values[2 * node] + values[2 * node + 1];\n    }\n\n    // Retrieve the value at a given position\n    long long query(int position) {\n        return query(1, 0, n - 1, position);\n    }\n\n    long long query(int node, int start, int end, int position) {\n        propagate(node, start, end);\n        if (start == end) {\n            return values[node];\n        }\n        int mid = (start + end) / 2;\n        if (position <= mid) {\n            return query(2 * node, start, mid, position);\n        } else {\n            return query(2 * node + 1, mid + 1, end, position);\n        }\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n\n    vector<long long> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    SegmentTree st;\n    st.build(arr);\n\n    for (int i = 0; i < q; i++) {\n        int type;\n        cin >> type;\n        if (type == 1) {\n            int left, right;\n            long long value;\n            cin >> left >> right >> value;\n            st.update(left - 1, right - 1, value);\n        } else {\n            int position;\n            cin >> position;\n            cout << st.query(position - 1) << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 3,
            "mean_time_taken": 0.13249715169270834,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Range Updates and Sums",
            "category": "Range Queries",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nint n, q;\nlong long arr[MAX_N], tree[4 * MAX_N], lazy[4 * MAX_N];\n\nvoid build(int node, int start, int end) {\n    if (start == end) {\n        tree[node] = arr[start];\n    } else {\n        int mid = (start + end) / 2;\n        build(2 * node, start, mid);\n        build(2 * node + 1, mid + 1, end);\n        tree[node] = tree[2 * node] + tree[2 * node + 1];\n    }\n}\n\nvoid update(int node, int start, int end, int l, int r, long long val, int type) {\n    if (lazy[node] != 0) {\n        tree[node] = (end - start + 1) * lazy[node];\n        if (start != end) {\n            lazy[2 * node] = lazy[node];\n            lazy[2 * node + 1] = lazy[node];\n        }\n        lazy[node] = 0;\n    }\n    if (start > r || end < l) {\n        return;\n    }\n    if (start >= l && end <= r) {\n        if (type == 1) {\n            tree[node] += (end - start + 1) * val;\n            if (start != end) {\n                lazy[2 * node] += val;\n                lazy[2 * node + 1] += val;\n            }\n        } else {\n            tree[node] = (end - start + 1) * val;\n            if (start != end) {\n                lazy[2 * node] = val;\n                lazy[2 * node + 1] = val;\n            }\n        }\n        return;\n    }\n    int mid = (start + end) / 2;\n    update(2 * node, start, mid, l, r, val, type);\n    update(2 * node + 1, mid + 1, end, l, r, val, type);\n    tree[node] = tree[2 * node] + tree[2 * node + 1];\n}\n\nlong long query(int node, int start, int end, int l, int r) {\n    if (lazy[node] != 0) {\n        tree[node] = (end - start + 1) * lazy[node];\n        if (start != end) {\n            lazy[2 * node] = lazy[node];\n            lazy[2 * node + 1] = lazy[node];\n        }\n        lazy[node] = 0;\n    }\n    if (start > r || end < l) {\n        return 0;\n    }\n    if (start >= l && end <= r) {\n        return tree[node];\n    }\n    int mid = (start + end) / 2;\n    long long p1 = query(2 * node, start, mid, l, r);\n    long long p2 = query(2 * node + 1, mid + 1, end, l, r);\n    return p1 + p2;\n}\n\nint main() {\n    cin >> n >> q;\n    for (int i = 1; i <= n; i++) {\n        cin >> arr[i];\n    }\n    build(1, 1, n);\n    while (q--) {\n        int type, l, r;\n        long long val;\n        cin >> type >> l >> r;\n        if (type == 3) {\n            cout << query(1, 1, n, l, r) << endl;\n        } else {\n            cin >> val;\n            update(1, 1, n, l, r, val, type);\n        }\n    }\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 4,
            "mean_time_taken": 0.19836139678955078,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Range Xor Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nint main() {\n    int n, q;\n    std::cin >> n >> q;\n\n    std::vector<int> arr(n);\n    std::vector<int> prefix_xor(n);\n\n    std::cin >> arr[0];\n    prefix_xor[0] = arr[0];\n\n    for (int i = 1; i < n; i++) {\n        std::cin >> arr[i];\n        prefix_xor[i] = arr[i] ^ prefix_xor[i - 1];\n    }\n\n    for (int i = 0; i < q; i++) {\n        int a, b;\n        std::cin >> a >> b;\n\n        int result = prefix_xor[b - 1];\n        if (a > 1) {\n            result ^= prefix_xor[a - 2];\n        }\n\n        std::cout << result << std::endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 2,
            "mean_time_taken": 0.17450988292694092,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 33,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Reachability Queries",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_NODES = 50005;\n\nvector<int> graph[MAX_NODES];\nbool visited[MAX_NODES];\n\nvoid dfs(int node) {\n    visited[node] = true;\n    for (int neighbor : graph[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor);\n        }\n    }\n}\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n    }\n\n    for (int i = 0; i < q; i++) {\n        int a, b;\n        cin >> a >> b;\n        fill(visited, visited + MAX_NODES, false);\n        dfs(a);\n        if (visited[b]) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 7,
            "mean_time_taken": 0.7637569563729423,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 33,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Reachable Nodes",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N = 50005;\n\nvector<int> adj[MAX_N];\nint reachable[MAX_N];\n\nvoid dfs(int node) {\n    reachable[node] = 1;\n    for (int neighbor : adj[node]) {\n        if (reachable[neighbor] == 0) {\n            dfs(neighbor);\n        }\n        reachable[node] += reachable[neighbor];\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n\n    for (int i = 1; i <= n; i++) {\n        if (reachable[i] == 0) {\n            dfs(i);\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        cout << reachable[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 4,
            "mean_time_taken": 0.11312878131866455,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 33,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Reading Books",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> books(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> books[i];\n    }\n\n    std::sort(books.begin(), books.end());\n\n    int total_time = 0;\n    int i = 0, j = n - 1;\n    while (i <= j) {\n        total_time += std::max(books[i], books[j]);\n        i++;\n        j--;\n    }\n\n    std::cout << total_time << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 13,
            "mean_time_taken": 0.09711654369647686,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 33,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Rectangle Cutting",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n\n    // Find the maximum dimension of the rectangle\n    int max_dim = max(a, b);\n\n    // The minimum number of moves required is equal to the maximum dimension minus one\n    int min_moves = max_dim - 1;\n\n    cout << min_moves << endl;\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 26,
            "mean_time_taken": 0.07898658055525559,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                22,
                23,
                24,
                25,
                26
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 33,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Removal Game",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 5005;\nlong long arr[MAX_N], dp[MAX_N][MAX_N];\n\nlong long solve(int i, int j) {\n    if (i > j) return 0;\n    if (dp[i][j] != -1) return dp[i][j];\n    return dp[i][j] = max(arr[i] - solve(i + 1, j), arr[j] - solve(i, j - 1));\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> arr[i];\n    }\n    memset(dp, -1, sizeof(dp));\n    cout << (solve(1, n) + accumulate(arr + 1, arr + n + 1, 0LL)) / 2 << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 33,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Removing Digits",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, max_digit = 0, steps = 0;\n    cin >> n;\n\n    // While the number is greater than 0\n    while (n > 0) {\n        // If the current digit is greater than max_digit, update max_digit\n        if (n % 10 > max_digit) {\n            max_digit = n % 10;\n        }\n        // Subtract max_digit from the number\n        n -= max_digit;\n        // Increment steps by 1\n        steps++;\n    }\n\n    // Print the number of steps required\n    cout << steps;\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 14,
            "mean_time_taken": 0.2182004451751709,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                10,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 33,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Removing Digits II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <algorithm>\n#include <string>\n\nint main() {\n    std::string number;\n    std::cin >> number;\n\n    int steps = 0;\n    while (number != \"0\") {\n        std::sort(number.begin(), number.end(), std::greater<char>());\n        int digit = number.back() - '0';\n        number = std::to_string(std::stoi(number) - digit);\n        steps++;\n    }\n\n    std::cout << steps << std::endl;\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 9,
            "mean_time_taken": 0.42153920067681205,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "terminate called after throwing an instance of 'std::out_of_range'\n  what():  stoi\n",
                "terminate called after throwing an instance of 'std::out_of_range'\n  what():  stoi\n",
                "Failed",
                "terminate called after throwing an instance of 'std::out_of_range'\n  what():  stoi\n",
                "terminate called after throwing an instance of 'std::out_of_range'\n  what():  stoi\n",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 33,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Repeating Substring",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct SuffixArray {\n    int n;\n    int k;\n    string text;\n    vector<int> p, c, lcp;\n\n    SuffixArray(string text) : text(text) {\n        n = text.size();\n        p.resize(n);\n        c.resize(n);\n        k = 0;\n        buildSuffixArray();\n        buildLCPArray();\n    }\n\n    void buildSuffixArray() {\n        // ... (same as before)\n    }\n\n    void countingSort(int k) {\n        // ... (same as before)\n    }\n\n    void buildLCPArray() {\n        // ... (same as before)\n    }\n\n    int findLongestRepeatingSubstring() {\n        int maxLCP = *max_element(lcp.begin(), lcp.end());\n        if (maxLCP == 0) {\n            return -1;\n        }\n        int index = distance(lcp.begin(), find(lcp.begin(), lcp.end(), maxLCP));\n        cout << text.substr(p[index], maxLCP) << endl;\n        return maxLCP;\n    }\n};\n\nint main() {\n    string text;\n    cin >> text;\n    SuffixArray sa(text);\n    sa.findLongestRepeatingSubstring();\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.13268527388572693,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 33,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Repetitions",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <string>\n\nint main() {\n    std::string dnaSequence;\n    std::cin >> dnaSequence;\n\n    char currentChar = dnaSequence[0];\n    int currentCount = 1;\n    int maxCount = 1;\n\n    for (int i = 1; i < dnaSequence.length(); i++) {\n        if (dnaSequence[i] == currentChar) {\n            currentCount++;\n        } else {\n            maxCount = std::max(maxCount, currentCount);\n            currentChar = dnaSequence[i];\n            currentCount = 1;\n        }\n    }\n\n    maxCount = std::max(maxCount, currentCount);\n\n    std::cout << maxCount << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.08946492274602254,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 34,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Required Substring",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main() {\n    int n, m;\n    string pattern;\n    vector<vector<long long>> dp(1001, vector<long long>(101));\n    vector<int> last_occurrence(26, -1);\n\n    cin >> n >> pattern;\n    m = pattern.size();\n\n    dp[0][0] = 1;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= m; j++) {\n            if (j == 0) {\n                dp[i][j] = dp[i - 1][m] * 25 % MOD;\n            } else {\n                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j] * 25) % MOD;\n                if (last_occurrence[pattern[j - 1] - 'A'] != -1) {\n                    dp[i][j] = (dp[i][j] - dp[i - 1][last_occurrence[pattern[j - 1] - 'A']] * 25 + MOD) % MOD;\n                }\n                last_occurrence[pattern[j - 1] - 'A'] = j - 1;\n            }\n        }\n    }\n\n    long long answer = 0;\n    for (int j = 0; j <= m; j++) {\n        answer = (answer + dp[n][j]) % MOD;\n    }\n\n    cout << answer << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 19,
            "mean_time_taken": 0.08075606195550215,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                16,
                17,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 34,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Restaurant Customers",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<int, int>> times(2 * n);\n    for (int i = 0; i < n; i++) {\n        cin >> times[i].first >> times[i + n].first;\n        times[i].second = 1;\n        times[i + n].second = -1;\n    }\n\n    sort(times.begin(), times.end());\n\n    int max_customers = 0, current_customers = 0;\n    for (auto time : times) {\n        current_customers += time.second;\n        max_customers = max(max_customers, current_customers);\n    }\n\n    cout << max_customers << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.17900259494781495,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Reversal Sorting",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    vector<pair<int, int>> reversals;\n    for (int i = 0; i < n; i++) {\n        int j = max_element(arr.begin() + i, arr.end()) - arr.begin();\n        if (i != j) {\n            reverse(arr.begin() + i, arr.begin() + j + 1);\n            reversals.push_back({i + 1, j + 1});\n        }\n    }\n\n    cout << reversals.size() << endl;\n    for (auto& reversal : reversals) {\n        cout << reversal.first << \" \" << reversal.second << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.399089515209198,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Reversals and Sums",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct Node {\n    long long sum;\n    bool reversed;\n    Node* left;\n    Node* right;\n    Node(long long s) : sum(s), reversed(false), left(nullptr), right(nullptr) {}\n};\n\nNode* build(vector<long long>& a, int start, int end) {\n    if (start == end) {\n        return new Node(a[start]);\n    }\n    int mid = (start + end) / 2;\n    Node* left = build(a, start, mid);\n    Node* right = build(a, mid + 1, end);\n    Node* node = new Node(left->sum + right->sum);\n    node->left = left;\n    node->right = right;\n    return node;\n}\n\nvoid push_down(Node* node, int start, int end) {\n    if (node->reversed) {\n        swap(node->left, node->right);\n        node->left->reversed = !node->left->reversed;\n        node->right->reversed = !node->right->reversed;\n        node->reversed = false;\n    }\n}\n\nlong long query(Node* node, int start, int end, int l, int r) {\n    if (l <= start && end <= r) {\n        return node->sum;\n    }\n    push_down(node, start, end);\n    int mid = (start + end) / 2;\n    long long result = 0;\n    if (l <= mid) {\n        result += query(node->left, start, mid, l, r);\n    }\n    if (r > mid) {\n        result += query(node->right, mid + 1, end, l, r);\n    }\n    return result;\n}\n\nvoid update(Node* node, int start, int end, int l, int r) {\n    if (l <= start && end <= r) {\n        node->reversed = !node->reversed;\n        return;\n    }\n    push_down(node, start, end);\n    int mid = (start + end) / 2;\n    if (l <= mid) {\n        update(node->left, start, mid, l, r);\n    }\n    if (r > mid) {\n        update(node->right, mid + 1, end, l, r);\n    }\n    node->sum = node->left->sum + node->right->sum;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<long long> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    Node* root = build(a, 0, n - 1);\n    for (int i = 0; i < m; i++) {\n        int t, l, r;\n        cin >> t >> l >> r;\n        if (t == 1) {\n            update(root, 0, n - 1, l - 1, r - 1);\n        } else {\n            cout << query(root, 0, n - 1, l - 1, r - 1) << endl;\n        }\n    }\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.16061896085739136,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Road Construction",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 1e5 + 5;\nint parent[MAX_N], rank[MAX_N], component_size[MAX_N];\nint num_components, max_component_size;\n\nvoid initialize() {\n    num_components = max_component_size = 0;\n    for (int i = 1; i < MAX_N; i++) {\n        parent[i] = i;\n        rank[i] = 1;\n        component_size[i] = 1;\n    }\n}\n\nint find_parent(int u) {\n    if (parent[u] == u) return u;\n    return parent[u] = find_parent(parent[u]);\n}\n\nvoid union_sets(int u, int v) {\n    u = find_parent(u);\n    v = find_parent(v);\n    if (u == v) return;\n    if (rank[u] < rank[v]) swap(u, v);\n    parent[v] = u;\n    rank[u] += rank[v];\n    component_size[u] += component_size[v];\n    max_component_size = max(max_component_size, component_size[u]);\n    num_components--;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    initialize();\n    num_components = n;\n    max_component_size = 1;\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        union_sets(u, v);\n        cout << num_components << \" \" << max_component_size << endl;\n    }\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Road Reparation",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Edge {\n    int u, v, weight;\n};\n\nstruct CompareEdges {\n    bool operator()(const Edge& a, const Edge& b) {\n        return a.weight > b.weight;\n    }\n};\n\nint findParent(int u, vector<int>& parent) {\n    if (parent[u] == u) {\n        return u;\n    }\n    return parent[u] = findParent(parent[u], parent);\n}\n\nvoid unionSets(int u, int v, vector<int>& parent, vector<int>& rank) {\n    u = findParent(u, parent);\n    v = findParent(v, parent);\n    if (u == v) {\n        return;\n    }\n    if (rank[u] < rank[v]) {\n        parent[u] = v;\n    } else if (rank[u] > rank[v]) {\n        parent[v] = u;\n    } else {\n        parent[v] = u;\n        rank[u]++;\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    priority_queue<Edge, vector<Edge>, CompareEdges> pq;\n    for (int i = 0; i < m; i++) {\n        int u, v, weight;\n        cin >> u >> v >> weight;\n        pq.push({u, v, weight});\n    }\n    vector<int> parent(n + 1);\n    vector<int> rank(n + 1, 1);\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n    }\n    int totalCost = 0;\n    while (!pq.empty()) {\n        Edge e = pq.top();\n        pq.pop();\n        if (findParent(e.u, parent) != findParent(e.v, parent)) {\n            unionSets(e.u, e.v, parent, rank);\n            totalCost += e.weight;\n        }\n    }\n    int connectedComponents = 0;\n    for (int i = 1; i <= n; i++) {\n        if (parent[i] == i) {\n            connectedComponents++;\n        }\n    }\n    if (connectedComponents > 1) {\n        cout << \"IMPOSSIBLE\" << endl;\n    } else {\n        cout << totalCost << endl;\n    }\n    return 0;\n}\n",
            "passed_test_cases": 9,
            "total_test_cases": 16,
            "mean_time_taken": 0.1565457135438919,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                5,
                6,
                7,
                9,
                11,
                13,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Robot Path",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <set>\n#include <utility>\n\nusing namespace std;\n\nint main() {\n    int n, x, y = 0, total_distance = 0;\n    char d;\n    set<pair<int, int>> visited;\n    visited.insert({0, 0});\n\n    cin >> n;\n\n    for (int i = 0; i < n; i++) {\n        cin >> d >> x;\n\n        if (d == 'U') {\n            y += x;\n        } else if (d == 'D') {\n            y -= x;\n        } else if (d == 'L') {\n            x = -x;\n        }\n\n        if (visited.find({x, y}) != visited.end()) {\n            break;\n        }\n\n        visited.insert({x, y});\n        total_distance += abs(x) + abs(y);\n    }\n\n    cout << total_distance << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 35,
            "mean_time_taken": 0.0944831030709403,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                33,
                34,
                35
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Room Allocation",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<int, int>> customers(n);\n    vector<pair<int, int>> events(2 * n);\n\n    for (int i = 0; i < n; i++) {\n        cin >> customers[i].first >> customers[i].second;\n        events[i * 2] = {customers[i].first, i};\n        events[i * 2 + 1] = {customers[i].second, -i - 1};\n    }\n\n    sort(events.begin(), events.end());\n\n    int max_rooms = 0;\n    int current_rooms = 0;\n\n    for (auto event : events) {\n        if (event.second >= 0) {\n            current_rooms++;\n            max_rooms = max(max_rooms, current_rooms);\n        } else {\n            current_rooms--;\n        }\n    }\n\n    vector<int> room_allocation(n);\n    vector<bool> room_occupied(max_rooms, false);\n\n    for (auto event : events) {\n        if (event.second >= 0) {\n            for (int i = 0; i < max_rooms; i++) {\n                if (!room_occupied[i]) {\n                    room_allocation[event.second] = i + 1;\n                    room_occupied[i] = true;\n                    break;\n                }\n            }\n        } else {\n            room_occupied[room_allocation[-event.second - 1] - 1] = false;\n        }\n    }\n\n    cout << max_rooms << endl;\n\n    for (int i = 0; i < n; i++) {\n        cout << room_allocation[i] << \" \";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.3508379062016805,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Round Trip",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_NODES = 100005;\n\nvector<int> graph[MAX_NODES];\nbool visited[MAX_NODES];\nint parent[MAX_NODES];\nint cycle[MAX_NODES];\nint cycle_length;\n\nvoid dfs(int node, int prev) {\n    visited[node] = true;\n    for (int neighbor : graph[node]) {\n        if (neighbor == prev) continue;\n        if (visited[neighbor]) {\n            // cycle found\n            int curr = node;\n            cycle_length = 0;\n            while (curr != neighbor) {\n                cycle[cycle_length++] = curr;\n                curr = parent[curr];\n            }\n            cycle[cycle_length++] = neighbor;\n            cycle[cycle_length++] = node;\n            return;\n        }\n        parent[neighbor] = node;\n        dfs(neighbor, node);\n        if (cycle_length > 0) return;\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n    dfs(1, 0);\n    if (cycle_length == 0) {\n        cout << \"IMPOSSIBLE\" << endl;\n    } else {\n        cout << cycle_length << endl;\n        for (int i = 0; i < cycle_length; i++) {\n            cout << cycle[i] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 26,
            "mean_time_taken": 0.10622096061706543,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                26
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Round Trip II",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_NODES = 100005;\n\nvector<int> adjacencyList[MAX_NODES];\nvector<int> visited(MAX_NODES, 0);\nvector<int> path;\nint cycleStart = -1;\n\nvoid dfs(int node) {\n    visited[node] = 1;\n    path.push_back(node);\n\n    for (int neighbor : adjacencyList[node]) {\n        if (cycleStart != -1) {\n            return;\n        }\n        if (visited[neighbor] == 1) {\n            cycleStart = neighbor;\n            return;\n        }\n        dfs(neighbor);\n    }\n\n    if (cycleStart != -1) {\n        return;\n    }\n    path.pop_back();\n    visited[node] = 2;\n}\n\nint main() {\n    int numNodes, numEdges;\n    cin >> numNodes >> numEdges;\n\n    for (int i = 0; i < numEdges; i++) {\n        int nodeA, nodeB;\n        cin >> nodeA >> nodeB;\n        adjacencyList[nodeA].push_back(nodeB);\n    }\n\n    for (int i = 1; i <= numNodes; i++) {\n        if (visited[i] == 0) {\n            dfs(i);\n        }\n        if (cycleStart != -1) {\n            break;\n        }\n    }\n\n    if (cycleStart == -1) {\n        cout << \"IMPOSSIBLE\" << endl;\n    } else {\n        int index = 0;\n        while (path[index] != cycleStart) {\n            index++;\n        }\n        cout << path.size() - index << endl;\n        for (int i = index; i < path.size(); i++) {\n            cout << path[i] << \" \";\n        }\n        cout << cycleStart << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 6,
            "total_test_cases": 20,
            "mean_time_taken": 0.19593440294265746,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                6,
                7,
                8,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                18,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Salary Queries",
            "category": "Range Queries",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Define a structure for a segment tree node\nstruct SegmentTreeNode {\n    int value;\n    SegmentTreeNode* left;\n    SegmentTreeNode* right;\n};\n\n// Function to update the value of a node in the segment tree\nvoid update(SegmentTreeNode* node, int start, int end, int index, int value) {\n    if (start == end) {\n        node->value = value;\n        return;\n    }\n    int mid = (start + end) / 2;\n    if (index <= mid) {\n        if (node->left == NULL) node->left = new SegmentTreeNode();\n        update(node->left, start, mid, index, value);\n    } else {\n        if (node->right == NULL) node->right = new SegmentTreeNode();\n        update(node->right, mid + 1, end, index, value);\n    }\n    node->value = 0;\n    if (node->left != NULL) node->value += node->left->value;\n    if (node->right != NULL) node->value += node->right->value;\n}\n\n// Function to query the sum of values in a range of the segment tree\nint query(SegmentTreeNode* node, int start, int end, int left, int right) {\n    if (node == NULL || start > right || end < left) return 0;\n    if (start >= left && end <= right) return node->value;\n    int mid = (start + end) / 2;\n    return query(node->left, start, mid, left, right) + query(node->right, mid + 1, end, left, right);\n}\n\n// Function to find the lower bound of a value in the segment tree\nint lowerBound(SegmentTreeNode* node, int start, int end, int value) {\n    if (node == NULL || start == end) return start;\n    int mid = (start + end) / 2;\n    if (node->left != NULL && node->left->value >= value)\n        return lowerBound(node->left, start, mid, value);\n    else\n        return lowerBound(node->right, mid + 1, end, value - (node->left != NULL ? node->left->value : 0));\n}\n\n// Function to find the upper bound of a value in the segment tree\nint upperBound(SegmentTreeNode* node, int start, int end, int value) {\n    if (node == NULL || start == end) return start;\n    int mid = (start + end) / 2;\n    if (node->left != NULL && node->left->value > value)\n        return upperBound(node->left, start, mid, value);\n    else\n        return upperBound(node->right, mid + 1, end, value - (node->left != NULL ? node->left->value : 0));\n}\n\n// Main function to process the input and output the results\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    int numElements, numQueries;\n    cin >> numElements >> numQueries;\n\n    vector<int> elements(numElements);\n    for (int i = 0; i < numElements; i++) {\n        cin >> elements[i];\n    }\n\n    sort(elements.begin(), elements.end());\n    elements.erase(unique(elements.begin(), elements.end()), elements.end());\n\n    SegmentTreeNode* root = new SegmentTreeNode();\n    for (int i = 0; i < numElements; i++) {\n        update(root, 0, elements.size() - 1, lowerBound(root, 0, elements.size() - 1, elements[i]), 1);\n    }\n\n    for (int i = 0; i < numQueries; i++) {\n        char operation;\n        cin >> operation;\n        if (operation == '?') {\n            int left, right;\n            cin >> left >> right;\n            cout << query(root, 0, elements.size() - 1, lowerBound(root, 0, elements.size() - 1, left), upperBound(root, 0, elements.size() - 1, right)) << '\\n';\n        } else {\n            int index, value;\n            cin >> index >> value;\n            index--;\n            update(root, 0, elements.size() - 1, lowerBound(root, 0, elements.size() - 1, elements[index]), -1);\n            elements[index] = value;\n            sort(elements.begin(), elements.end());\n            elements.erase(unique(elements.begin(), elements.end()), elements.end());\n            update(root, 0, elements.size() - 1, lowerBound(root, 0, elements.size() - 1, elements[index]), 1);\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 13,
            "mean_time_taken": 0.4654207413013165,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "School Dance",
            "category": "Graph Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shot": 1
        },
        {
            "title": "School Excursion",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_NODES = 1e5 + 5;\n\nint numNodes, numEdges;\nvector<int> graph[MAX_NODES];\nint visited[MAX_NODES];\nint componentSize[MAX_NODES];\nint componentIndex;\nint dp[MAX_NODES];\n\n// Perform depth-first search to find the size of each connected component\nvoid depthFirstSearch(int node) {\n  visited[node] = 1;\n  componentSize[componentIndex]++;\n  for (int neighbor : graph[node]) {\n    if (!visited[neighbor]) {\n      depthFirstSearch(neighbor);\n    }\n  }\n}\n\n// Calculate the number of ways to distribute children to attractions using dynamic programming\nvoid calculateDistribution() {\n  memset(dp, 0, sizeof(dp));\n  dp[0] = 1;\n  for (int i = 1; i <= numNodes; i++) {\n    if (componentSize[i] == 0) break;\n    for (int j = numNodes; j >= componentSize[i]; j--) {\n      dp[j] |= dp[j - componentSize[i]];\n    }\n  }\n}\n\nint main() {\n  // Read input\n  scanf(\"%d%d\", &numNodes, &numEdges);\n  for (int i = 1; i <= numEdges; i++) {\n    int node1, node2;\n    scanf(\"%d%d\", &node1, &node2);\n    graph[node1].push_back(node2);\n    graph[node2].push_back(node1);\n  }\n\n  // Find the size of each connected component\n  for (int i = 1; i <= numNodes; i++) {\n    if (!visited[i]) {\n      componentIndex++;\n      depthFirstSearch(i);\n    }\n  }\n\n  // Calculate the number of ways to distribute children to attractions\n  calculateDistribution();\n\n  // Print output\n  for (int i = 1; i <= numNodes; i++) {\n    printf(\"%d\", dp[i]);\n  }\n  printf(\"\\n\");\n\n  return 0;\n}\n",
            "passed_test_cases": 9,
            "total_test_cases": 13,
            "mean_time_taken": 0.39174499878516567,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                5,
                10,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Shortest Routes I",
            "category": "Graph Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Shortest Routes II",
            "category": "Graph Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Shortest Subsequence",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n\nint main() {\n    std::string dnaSequence;\n    std::cin >> dnaSequence;\n\n    // Check if the sequence contains \"AAA\"\n    if (dnaSequence.find(\"AAA\") == std::string::npos) {\n        std::cout << \"AAA\";\n        return 0;\n    }\n\n    // Check if the sequence contains \"TTT\"\n    if (dnaSequence.find(\"TTT\") == std::string::npos) {\n        std::cout << \"TTT\";\n        return 0;\n    }\n\n    // Check if the sequence contains \"CCC\"\n    if (dnaSequence.find(\"CCC\") == std::string::npos) {\n        std::cout << \"CCC\";\n        return 0;\n    }\n\n    // Check if the sequence contains \"GGG\"\n    if (dnaSequence.find(\"GGG\") == std::string::npos) {\n        std::cout << \"GGG\";\n        return 0;\n    }\n\n    // If the sequence contains all four possibilities, return an empty string\n    std::cout << \"\";\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.09060385227203369,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Signal Processing",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n\nint main() {\n    int n, m;\n    std::cin >> n >> m;\n\n    std::vector<int> signal(n), mask(m), result(n + m - 1);\n\n    for (int i = 0; i < n; i++) {\n        std::cin >> signal[i];\n    }\n\n    for (int i = 0; i < m; i++) {\n        std::cin >> mask[i];\n    }\n\n    for (int i = 0; i < n + m - 1; i++) {\n        for (int j = 0; j <= i; j++) {\n            if (j < n && i - j < m) {\n                result[i] += signal[j] * mask[i - j];\n            }\n        }\n    }\n\n    for (int i = 0; i < n + m - 1; i++) {\n        std::cout << result[i] << \" \";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.718396782875061,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sliding Window Cost",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    multiset<int> s;\n    long long sum = 0;\n    vector<long long> ans;\n\n    for (int i = 0; i < k; i++) {\n        s.insert(a[i]);\n        sum += a[i];\n    }\n\n    for (int i = k; i <= n; i++) {\n        long long median = *next(s.begin(), k / 2);\n        ans.push_back(k * median - sum);\n\n        if (i == n) {\n            break;\n        }\n\n        sum -= a[i - k];\n        s.erase(s.find(a[i - k]));\n\n        sum += a[i];\n        s.insert(a[i]);\n    }\n\n    for (int i = 0; i < ans.size(); i++) {\n        cout << ans[i] << \" \";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 17,
            "total_test_cases": 34,
            "mean_time_taken": 0.27237677574157715,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                4,
                5,
                8,
                11,
                12,
                14,
                15,
                16,
                17,
                18,
                20,
                25,
                28,
                29,
                31,
                32
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sliding Window Median",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    multiset<int> window;\n    for (int i = 0; i < k; i++) {\n        window.insert(arr[i]);\n    }\n\n    auto mid = next(window.begin(), k / 2);\n    cout << *mid << \" \";\n\n    for (int i = k; i < n; i++) {\n        window.erase(window.find(arr[i - k]));\n        window.insert(arr[i]);\n\n        if (arr[i] < *mid) {\n            mid--;\n        }\n        if (arr[i - k] <= *mid) {\n            mid++;\n        }\n\n        cout << *mid << \" \";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 15,
            "total_test_cases": 40,
            "mean_time_taken": 0.12331694960594178,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                8,
                9,
                10,
                12,
                14,
                15,
                18,
                20,
                21,
                22,
                25,
                27,
                28,
                30,
                31,
                33,
                34,
                35,
                36,
                38,
                40
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sorting Methods",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to calculate the minimum number of steps using the first method\nint method1(vector<int>& arr) {\n    int n = arr.size();\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (arr[j] < arr[i]) {\n                swap(arr[i], arr[j]);\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n// Function to calculate the minimum number of steps using the second method\nint method2(vector<int>& arr) {\n    int n = arr.size();\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        int min_idx = i;\n        for (int j = i + 1; j < n; j++) {\n            if (arr[j] < arr[min_idx]) {\n                min_idx = j;\n            }\n        }\n        swap(arr[i], arr[min_idx]);\n        count++;\n    }\n    return count - 1;\n}\n\n// Function to calculate the minimum number of steps using the third method\nint method3(vector<int>& arr) {\n    int n = arr.size();\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        int idx = find(arr.begin(), arr.end(), i + 1) - arr.begin();\n        if (idx != i) {\n            swap(arr[i], arr[idx]);\n            count++;\n        }\n    }\n    return count;\n}\n\n// Function to calculate the minimum number of steps using the fourth method\nint method4(vector<int>& arr) {\n    int n = arr.size();\n    int count = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        int idx = find(arr.begin(), arr.end(), i + 1) - arr.begin();\n        if (idx != i) {\n            rotate(arr.begin(), arr.begin() + idx, arr.begin() + idx + 1);\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    cout << method1(arr) << \" \";\n    cout << method2(arr) << \" \";\n    cout << method3(arr) << \" \";\n    cout << method4(arr) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.5618204832077026,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Special Substrings",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint countSpecialSubstrings(string s) {\n    int n = s.length();\n    vector<int> count(26, 0);\n    int res = 0, i = 0, j = 0;\n\n    while (j < n) {\n        count[s[j] - 'a']++;\n\n        while (i < j && count[s[j] - 'a'] > count[s[i] - 'a']) {\n            count[s[i] - 'a']--;\n            i++;\n        }\n\n        if (count[s[j] - 'a'] == count[s[i] - 'a']) {\n            res += count[s[j] - 'a'];\n        }\n\n        j++;\n    }\n\n    return res;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    cout << countSpecialSubstrings(s) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 8,
            "mean_time_taken": 0.08774134516716003,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Stack Weights",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <deque>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    deque<int> left, right;\n    vector<int> last_index(n + 1, -1);\n\n    for (int i = 0; i < n; i++) {\n        int c, s;\n        cin >> c >> s;\n\n        if (s == 1) {\n            left.push_front(c);\n        } else {\n            right.push_front(c);\n        }\n\n        last_index[c] = i;\n\n        if (left.empty()) {\n            cout << \"<\" << endl;\n        } else if (right.empty()) {\n            cout << \">\" << endl;\n        } else {\n            if (left.front() > right.front()) {\n                cout << \">\" << endl;\n            } else if (left.front() < right.front()) {\n                cout << \"<\" << endl;\n            } else {\n                if (last_index[left.back()] > last_index[right.back()]) {\n                    cout << \">\" << endl;\n                } else if (last_index[left.back()] < last_index[right.back()]) {\n                    cout << \"<\" << endl;\n                } else {\n                    cout << \"?\" << endl;\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 5,
            "mean_time_taken": 0.20778050422668456,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Stair Game",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        int xor_all = 0, xor_except_first = 0;\n        for (int i = 1; i <= n; i++) {\n            int p;\n            cin >> p;\n            xor_all ^= p;\n            if (i > 1) {\n                xor_except_first ^= p;\n            }\n        }\n        if (xor_all ^ xor_except_first) {\n            cout << \"first\" << endl;\n        } else {\n            cout << \"second\" << endl;\n        }\n    }\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 7,
            "mean_time_taken": 0.1025869505746024,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Static Range Minimum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n// Function to build the sparse table\nvoid buildSparseTable(vector<int>& arr, vector<vector<int>>& st) {\n    int n = arr.size();\n    int logn = log2(n) + 1;\n\n    // Initialize the first row of the sparse table with the array values\n    for (int i = 0; i < n; i++) {\n        st[i][0] = arr[i];\n    }\n\n    // Fill in the rest of the sparse table using dynamic programming\n    for (int j = 1; j < logn; j++) {\n        for (int i = 0; i <= n - (1 << j); i++) {\n            st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n        }\n    }\n}\n\n// Function to query the minimum value in the range [l, r]\nint query(vector<vector<int>>& st, int l, int r) {\n    int j = log2(r - l + 1);\n    return min(st[l][j], st[r - (1 << j) + 1][j]);\n}\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    // Build the sparse table\n    int logn = log2(n) + 1;\n    vector<vector<int>> st(n, vector<int>(logn));\n    buildSparseTable(arr, st);\n\n    // Process each query\n    for (int i = 0; i < q; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        cout << query(st, a, b) << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 4,
            "mean_time_taken": 0.1866249442100525,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 36,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Static Range Sum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nint main() {\n    int n, q;\n    std::cin >> n >> q;\n\n    std::vector<int> arr(n);\n    std::vector<long long> prefix_sum(n);\n\n    std::cin >> arr[0];\n    prefix_sum[0] = arr[0];\n\n    for (int i = 1; i < n; i++) {\n        std::cin >> arr[i];\n        prefix_sum[i] = prefix_sum[i - 1] + arr[i];\n    }\n\n    for (int i = 0; i < q; i++) {\n        int a, b;\n        std::cin >> a >> b;\n        a--; b--;\n\n        if (a == 0) {\n            std::cout << prefix_sum[b] << std::endl;\n        } else {\n            std::cout << prefix_sum[b] - prefix_sum[a - 1] << std::endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 2,
            "mean_time_taken": 0.18693006038665771,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 37,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Stick Divisions",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int x, n;\n    cin >> x >> n;\n\n    priority_queue<int> pq;\n    for (int i = 0; i < n; i++) {\n        int d;\n        cin >> d;\n        pq.push(d);\n    }\n\n    long long cost = 0;\n    while (pq.size() > 1) {\n        int a = pq.top();\n        pq.pop();\n        int b = pq.top();\n        pq.pop();\n        cost += a + b;\n        pq.push(a + b);\n    }\n\n    cout << cost << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.2211305300394694,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 37,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Stick Game",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> p(k);\n    for (int i = 0; i < k; i++) {\n        cin >> p[i];\n    }\n\n    vector<bool> dp(n + 1, false);\n    dp[0] = false;\n    dp[1] = true;\n\n    for (int i = 2; i <= n; i++) {\n        for (int j = 0; j < k; j++) {\n            if (p[j] <= i && !dp[i - p[j]]) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        cout << (dp[i] ? 'W' : 'L');\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 6,
            "mean_time_taken": 0.30166908105214435,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 37,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Stick Lengths",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> sticks(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> sticks[i];\n    }\n\n    std::sort(sticks.begin(), sticks.end());\n\n    int median = sticks[n / 2];\n\n    long long total_cost = 0;\n    for (int i = 0; i < n; i++) {\n        total_cost += std::abs(sticks[i] - median);\n    }\n\n    std::cout << total_cost << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.10023338144475763,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 38,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "String Functions",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<int> z_function(string s) {\n    int n = s.length();\n    vector<int> z(n, 0);\n    int left = 0, right = 0;\n    for (int i = 1; i < n; i++) {\n        if (i > right) {\n            left = right = i;\n            while (right < n && s[right - left] == s[right]) right++;\n            z[i] = right - left;\n            right--;\n        } else {\n            int k = i - left;\n            if (z[k] < right - i + 1) {\n                z[i] = z[k];\n            } else {\n                left = i;\n                while (right < n && s[right - left] == s[right]) right++;\n                z[i] = right - left;\n                right--;\n            }\n        }\n    }\n    return z;\n}\n\nvector<int> pi_function(string s) {\n    int n = s.length();\n    vector<int> dp(n, 0);\n    for (int i = 1; i < n; i++) {\n        int j = dp[i - 1];\n        while (j > 0 && s[j] != s[i]) j = dp[j - 1];\n        if (s[j] == s[i]) j++;\n        dp[i] = j;\n    }\n    return dp;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    vector<int> z = z_function(s);\n    vector<int> pi = pi_function(s);\n    for (int i = 0; i < z.size(); i++) {\n        cout << z[i] << \" \";\n    }\n    cout << endl;\n    for (int i = 0; i < pi.size(); i++) {\n        cout << pi[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 5,
            "mean_time_taken": 0.20338139533996583,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 39,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "String Matching",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<int> computePrefixFunction(const std::string& pattern) {\n    int m = pattern.size();\n    std::vector<int> pi(m, 0);\n    int k = 0;\n    for (int i = 1; i < m; i++) {\n        while (k > 0 && pattern[k] != pattern[i]) {\n            k = pi[k - 1];\n        }\n        if (pattern[k] == pattern[i]) {\n            k++;\n        }\n        pi[i] = k;\n    }\n    return pi;\n}\n\nint kmp(const std::string& text, const std::string& pattern) {\n    int n = text.size();\n    int m = pattern.size();\n    std::vector<int> pi = computePrefixFunction(pattern);\n    int q = 0;\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        while (q > 0 && pattern[q] != text[i]) {\n            q = pi[q - 1];\n        }\n        if (pattern[q] == text[i]) {\n            q++;\n        }\n        if (q == m) {\n            count++;\n            q = pi[q - 1];\n        }\n    }\n    return count;\n}\n\nint main() {\n    std::string text, pattern;\n    std::cin >> text >> pattern;\n    int count = kmp(text, pattern);\n    std::cout << count << std::endl;\n    return 0;\n}\n",
            "passed_test_cases": 37,
            "total_test_cases": 37,
            "mean_time_taken": 0.08562089945818926,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "String Removals",
            "category": "Additional Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shot": 1
        },
        {
            "title": "String Reorder",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstring reorder_string(string s) {\n    vector<int> freq(26, 0);\n    for (char c : s) {\n        freq[c - 'A']++;\n    }\n\n    priority_queue<pair<int, char>> pq;\n    for (int i = 0; i < 26; i++) {\n        if (freq[i] > 0) {\n            pq.push({freq[i], 'A' + i});\n        }\n    }\n\n    string result = \"\";\n    while (!pq.empty()) {\n        auto p1 = pq.top();\n        pq.pop();\n\n        if (result.empty() || p1.second != result.back()) {\n            result += p1.second;\n            if (p1.first > 1) {\n                pq.push({p1.first - 1, p1.second});\n            }\n        } else if (!pq.empty()) {\n            auto p2 = pq.top();\n            pq.pop();\n            result += p2.second;\n            if (p2.first > 1) {\n                pq.push({p2.first - 1, p2.second});\n            }\n            pq.push(p1);\n        } else {\n            return \"-1\";\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    cout << reorder_string(s) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 7,
            "total_test_cases": 15,
            "mean_time_taken": 0.17385668754577638,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8,
                13,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "String Transform",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    string input, result;\n    cin >> input;\n\n    // Iterate through the input string in reverse order\n    for (int i = input.size() - 2; i >= 0; i--) {\n        // Find the smallest character that is greater than the current character\n        int j = i + 1;\n        while (j < input.size() && input[j] <= input[i]) {\n            j++;\n        }\n        // Swap the characters\n        swap(input[i], input[j]);\n        // Append the current character to the result string\n        result += input[i];\n        // Rotate the input string to the left by one position\n        rotate(input.begin() + i + 1, input.begin() + j, input.end());\n    }\n\n    // Reverse the result string and print it as the output\n    reverse(result.begin(), result.end());\n    cout << result << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.5594447453816732,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Strongly Connected Edges",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_NODES = 100005;\n\nvector<int> graph[MAX_NODES];\nint low[MAX_NODES], disc[MAX_NODES];\nbool visited[MAX_NODES];\nstack<pair<int, int>> edges;\nint time_counter = 0;\n\nvoid dfs(int node, int parent) {\n    visited[node] = true;\n    disc[node] = low[node] = time_counter++;\n    for (int neighbor : graph[node]) {\n        if (!visited[neighbor]) {\n            edges.push({node, neighbor});\n            dfs(neighbor, node);\n            low[node] = min(low[node], low[neighbor]);\n            if (low[neighbor] >= disc[node]) {\n                while (true) {\n                    pair<int, int> edge = edges.top();\n                    edges.pop();\n                    cout << edge.first << \" \" << edge.second << \"\\n\";\n                    if (edge.first == node && edge.second == neighbor) break;\n                }\n                cout << neighbor << \" \" << node << \"\\n\";\n            }\n        } else if (neighbor != parent) {\n            low[node] = min(low[node], disc[neighbor]);\n            edges.push({node, neighbor});\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    int num_nodes, num_edges;\n    cin >> num_nodes >> num_edges;\n\n    for (int i = 0; i < num_edges; i++) {\n        int node1, node2;\n        cin >> node1 >> node2;\n        graph[node1].push_back(node2);\n        graph[node2].push_back(node1);\n    }\n\n    dfs(1, 0);\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 11,
            "mean_time_taken": 0.10765080018477007,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Distinct Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    map<int, int> freq;\n    int left = 0, right = 0;\n    long long count = 0;\n    int unique_elements = 0;\n\n    while (right < n) {\n        if (freq.find(arr[right]) == freq.end()) {\n            unique_elements++;\n        }\n        freq[arr[right]]++;\n\n        while (unique_elements > k) {\n            freq[arr[left]]--;\n            if (freq[arr[left]] == 0) {\n                unique_elements--;\n            }\n            left++;\n        }\n\n        count += (right - left + 1);\n        right++;\n    }\n\n    cout << count << endl;\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 10,
            "mean_time_taken": 0.21011290550231934,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                4,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Divisibility",
            "category": "Sorting and Searching",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Subarray Squares",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n\nconst int MAX_N = 3005;\nconst int INF = 0x3f3f3f3f;\n\nint dp[MAX_N][MAX_N];\nint sum[MAX_N];\nint n, k;\n\nint main() {\n    std::cin >> n >> k;\n\n    for (int i = 1; i <= n; i++) {\n        std::cin >> sum[i];\n        sum[i] += sum[i - 1];\n    }\n\n    std::memset(dp, 0x3f, sizeof(dp));\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= k; j++) {\n            if (i < j) {\n                dp[i][j] = INF;\n            } else if (i == j) {\n                dp[i][j] = sum[i] * sum[i];\n            } else {\n                for (int p = 1; p <= i - j + 1; p++) {\n                    dp[i][j] = std::min(dp[i][j], dp[i - p][j - 1] + (sum[i] - sum[i - p]) * (sum[i] - sum[i - p]));\n                }\n            }\n        }\n    }\n\n    std::cout << dp[n][k] << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 11,
            "mean_time_taken": 0.6259006586941805,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Sum Queries",
            "category": "Range Queries",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Define a structure for the segment tree nodes\nstruct Node {\n    long long maxSubarraySum, maxSuffixSum, maxPrefixSum, sum;\n};\n\n// Function to build the segment tree from the input array\nNode buildTree(vector<long long>& arr, int start, int end, vector<Node>& tree) {\n    if (start == end) {\n        tree[start].maxSubarraySum = tree[start].maxSuffixSum = tree[start].maxPrefixSum = tree[start].sum = arr[start];\n        return tree[start];\n    }\n    int mid = (start + end) / 2;\n    Node left = buildTree(arr, start, mid, tree);\n    Node right = buildTree(arr, mid + 1, end, tree);\n    tree[start].maxSubarraySum = max({left.maxSubarraySum, right.maxSubarraySum, left.maxSuffixSum + right.maxPrefixSum});\n    tree[start].maxSuffixSum = max(left.maxSuffixSum, left.sum + right.maxSuffixSum);\n    tree[start].maxPrefixSum = max(right.maxPrefixSum, right.sum + left.maxPrefixSum);\n    tree[start].sum = left.sum + right.sum;\n    return tree[start];\n}\n\n// Function to update an element in the segment tree\nvoid updateTree(int index, long long value, int start, int end, vector<Node>& tree) {\n    if (start == end) {\n        tree[index].maxSubarraySum = tree[index].maxSuffixSum = tree[index].maxPrefixSum = tree[index].sum = value;\n        return;\n    }\n    int mid = (start + end) / 2;\n    if (index <= mid)\n        updateTree(index, value, start, mid, tree);\n    else\n        updateTree(index, value, mid + 1, end, tree);\n    tree[start].maxSubarraySum = max({tree[start].maxSuffixSum, tree[start].maxPrefixSum, tree[start].maxSubarraySum, tree[start + 1].maxSubarraySum, tree[start].maxSuffixSum + tree[start + 1].maxPrefixSum});\n    tree[start].maxSuffixSum = max(tree[start].maxSuffixSum, tree[start].sum + tree[start + 1].maxSuffixSum);\n    tree[start].maxPrefixSum = max(tree[start + 1].maxPrefixSum, tree[start + 1].sum + tree[start].maxPrefixSum);\n    tree[start].sum = tree[start + 1].sum + tree[start].sum;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    int n, m;\n    cin >> n >> m;\n    vector<long long> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    vector<Node> tree(4 * n);\n    buildTree(arr, 0, n - 1, tree);\n    for (int i = 0; i < m; i++) {\n        int index, value;\n        cin >> index >> value;\n        updateTree(index - 1, value, 0, n - 1, tree);\n        cout << tree[0].maxSubarraySum << \"\\n\";\n    }\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.17598684628804526,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Sums I",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n\nint main() {\n    int n, x;\n    std::cin >> n >> x;\n\n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n\n    std::vector<int> prefixSum(n + 1);\n    prefixSum[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        prefixSum[i] = prefixSum[i - 1] + a[i - 1];\n    }\n\n    std::unordered_map<int, int> freq;\n    int count = 0;\n    for (int i = 0; i <= n; i++) {\n        if (freq.find(prefixSum[i] - x) != freq.end()) {\n            count += freq[prefixSum[i] - x];\n        }\n        freq[prefixSum[i]]++;\n    }\n\n    std::cout << count << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 12,
            "mean_time_taken": 0.1279979149500529,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                7,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Sums II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    int arr[n];\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    unordered_map<int, int> prefixSumMap;\n    prefixSumMap[0] = 1; // base case: empty prefix sum\n\n    int prefixSum = 0;\n    int count = 0;\n\n    for (int i = 0; i < n; i++) {\n        prefixSum += arr[i];\n\n        if (prefixSumMap.find(prefixSum - x) != prefixSumMap.end()) {\n            count += prefixSumMap[prefixSum - x];\n        }\n\n        prefixSumMap[prefixSum]++;\n    }\n\n    cout << count << endl;\n    return 0;\n}\n",
            "passed_test_cases": 24,
            "total_test_cases": 27,
            "mean_time_taken": 0.13498617984630443,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                21,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subordinates",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nconst int MAX_N = 200005;\n\nint n;\nstd::vector<int> adj[MAX_N];\nint subordinates[MAX_N];\n\nint dfs(int u) {\n    int count = 0;\n    for (int v : adj[u]) {\n        count += dfs(v);\n    }\n    subordinates[u] = count;\n    return count + 1;\n}\n\nint main() {\n    std::cin >> n;\n    for (int i = 2; i <= n; i++) {\n        int u;\n        std::cin >> u;\n        adj[u].push_back(i);\n    }\n    dfs(1);\n    for (int i = 1; i <= n; i++) {\n        std::cout << subordinates[i] << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}\n",
            "passed_test_cases": 10,
            "total_test_cases": 12,
            "mean_time_taken": 0.1177018682161967,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Substring Distribution",
            "category": "String Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Substring Order I",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstruct TrieNode {\n    TrieNode* children[26];\n    bool isEndOfWord;\n\n    TrieNode() {\n        for (int i = 0; i < 26; i++) {\n            children[i] = nullptr;\n        }\n        isEndOfWord = false;\n    }\n};\n\nclass Trie {\nprivate:\n    TrieNode* root;\n\n    void traverseTrie(TrieNode* node, string& result, int& k) {\n        if (node == nullptr || k <= 0) {\n            return;\n        }\n\n        if (node->isEndOfWord) {\n            k--;\n            if (k == 0) {\n                reverse(result.begin(), result.end());\n                cout << result << endl;\n            }\n        }\n\n        for (int i = 0; i < 26; i++) {\n            if (node->children[i] != nullptr) {\n                result.push_back('a' + i);\n                traverseTrie(node->children[i], result, k);\n                result.pop_back();\n            }\n        }\n    }\n\npublic:\n    Trie() {\n        root = new TrieNode();\n    }\n\n    void insert(string word) {\n        TrieNode* current = root;\n        for (char c : word) {\n            int index = c - 'a';\n            if (current->children[index] == nullptr) {\n                current->children[index] = new TrieNode();\n            }\n            current = current->children[index];\n        }\n        current->isEndOfWord = true;\n    }\n\n    void findKthSmallest(int k) {\n        string result = \"\";\n        traverseTrie(root, result, k);\n    }\n};\n\nint main() {\n    string s;\n    int k;\n    cin >> s >> k;\n\n    Trie trie;\n    for (int i = 0; i < s.length(); i++) {\n        string substring = \"\";\n        for (int j = i; j < s.length(); j++) {\n            substring += s[j];\n            trie.insert(substring);\n        }\n    }\n\n    trie.findKthSmallest(k);\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 9,
            "mean_time_taken": 0.8249382177988688,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Substring Order II",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to calculate the count of substrings that are smaller than or equal to the current substring\nlong long countSubstrings(string& s, int len) {\n    vector<long long> count(26, 0);\n    long long result = 0;\n    long long power = 1;\n    for (int i = 0; i < len; i++) {\n        power *= 26;\n    }\n    for (int i = 0; i < s.length(); i++) {\n        result += count[s[i] - 'a'] * power;\n        count[s[i] - 'a']++;\n        if (i >= len) {\n            count[s[i - len] - 'a']--;\n        }\n    }\n    return result;\n}\n\n// Function to find the kth smallest substring\nstring kthSmallestSubstring(string s, long long k) {\n    int left = 0, right = s.length();\n    while (left < right) {\n        int mid = (left + right) / 2;\n        long long count = countSubstrings(s, mid);\n        if (count < k) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    string result = \"\";\n    vector<long long> count(26, 0);\n    long long power = 1;\n    for (int i = 0; i < left; i++) {\n        power *= 26;\n    }\n    for (int i = 0; i < s.length(); i++) {\n        k -= count[s[i] - 'a'] * power;\n        count[s[i] - 'a']++;\n        if (i >= left) {\n            count[s[i - left] - 'a']--;\n        }\n        if (k <= 0) {\n            result += s[i];\n            if (result.length() == left) {\n                break;\n            }\n        }\n    }\n    return result;\n}\n\nint main() {\n    string s;\n    long long k;\n    cin >> s >> k;\n    cout << kthSmallestSubstring(s, k) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 9,
            "mean_time_taken": 0.0920561154683431,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Substring Reversals",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstruct SegmentTreeNode {\n    int start, end;\n    bool reversed;\n    SegmentTreeNode* left, *right;\n\n    SegmentTreeNode(int start, int end) : start(start), end(end), reversed(false), left(nullptr), right(nullptr) {}\n\n    void build(const string& s) {\n        if (start == end) {\n            // Leaf node, store the character\n            return;\n        }\n        int mid = (start + end) / 2;\n        left = new SegmentTreeNode(start, mid);\n        right = new SegmentTreeNode(mid + 1, end);\n        left->build(s);\n        right->build(s);\n    }\n\n    void update(int i, int j) {\n        if (i > end || j < start) {\n            // Out of range, do nothing\n            return;\n        }\n        if (i <= start && end <= j) {\n            // Entire interval is within range, reverse the substring\n            reversed = !reversed;\n            return;\n        }\n        // Split the interval and update the children\n        left->update(i, j);\n        right->update(i, j);\n    }\n\n    char get(int i, const string& s) {\n        if (start == end) {\n            // Leaf node, return the character\n            return s[start];\n        }\n        int mid = (start + end) / 2;\n        if (i <= mid) {\n            // Query the left child\n            char c = left->get(i, s);\n            if (reversed) {\n                // Reverse the character if necessary\n                return s[mid + mid - i];\n            }\n            return c;\n        }\n        // Query the right child\n        char c = right->get(i, s);\n        if (reversed) {\n            // Reverse the character if necessary\n            return s[start + start + mid - i];\n        }\n        return c;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n    cin >> n >> m;\n\n    string s;\n    cin >> s;\n\n    SegmentTreeNode* root = new SegmentTreeNode(0, n - 1);\n    root->build(s);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        root->update(a - 1, b - 1);\n    }\n\n    for (int i = 0; i < n; i++) {\n        cout << root->get(i, s);\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.1536850929260254,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subtree Queries",
            "category": "Tree Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Sum of Divisors",
            "category": "Mathematics",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long sum_of_divisors(long long n) {\n    long long result = 0;\n    for (long long i = 1; i * i <= n; i++) {\n        long long j = n / i;\n        result = (result + i * (j - i + 1) % MOD) % MOD;\n        result = (result + j * (i - 1) % MOD) % MOD;\n    }\n    return result;\n}\n\nint main() {\n    long long n;\n    cin >> n;\n    cout << sum_of_divisors(n) << endl;\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 18,
            "mean_time_taken": 0.07992462317148845,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sum of Four Values",
            "category": "Sorting and Searching",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Sum of Three Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            int remainingSum = x - arr[i] - arr[j];\n            if (binary_search(arr.begin(), arr.end(), remainingSum)) {\n                int k = lower_bound(arr.begin(), arr.end(), remainingSum) - arr.begin();\n                if (k != i && k != j) {\n                    cout << i + 1 << \" \" << j + 1 << \" \" << k + 1 << endl;\n                    return 0;\n                }\n            }\n        }\n    }\n\n    cout << \"IMPOSSIBLE\" << endl;\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 27,
            "mean_time_taken": 0.6817325662683558,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10,
                12,
                13,
                14,
                15,
                16,
                18,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sum of Two Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    unordered_map<int, int> nums;\n    for (int i = 0; i < n; i++) {\n        int num;\n        cin >> num;\n        if (nums.find(x - num) != nums.end()) {\n            cout << nums[x - num] + 1 << \" \" << i + 1;\n            return 0;\n        }\n        nums[num] = i;\n    }\n\n    cout << \"IMPOSSIBLE\";\n    return 0;\n}\n",
            "passed_test_cases": 18,
            "total_test_cases": 27,
            "mean_time_taken": 0.17114461792839897,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                9,
                10,
                11,
                21,
                22,
                24,
                25
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Swap Game",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <climits>\n\nusing namespace std;\n\n// Define macros for looping and utility functions\n#define REP(i, n) for(int i = 0; i < (n); i++)\n#define REP1(i, n) for(int i = 1; i <= (n); i++)\n#define FOR(i, a, b) for(int i = (a); i <= (b); i++)\n#define FORD(i, a, b) for(int i = (a); i >= (b); i--)\n#define FOREACH(it, c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); it++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define ms(a, b) memset((a), (b), sizeof(a))\n#define present(c, x) ((c).find(x) != (c).end())\n#define cpresent(c, x) (find(ALL(c), x) != (c).end())\n\n// Define data types and constants\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> ii;\ntypedef vector<ii> vii;\ntypedef vector<vii> vvii;\nconst int INF = 0x3f3f3f3f;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\n// Define the target state and the initial state\nint target[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nint initial[9];\n\n// Define the possible moves\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\n// Define a function to check if a state is valid\nbool is_valid(int x, int y) {\n    return x >= 0 && x < 3 && y >= 0 && y < 3;\n}\n\n// Define a function to calculate the Manhattan distance between two states\nint manhattan_distance(int* state) {\n    int distance = 0;\n    REP(i, 9) {\n        int value = state[i];\n        if (value == 0) continue;\n        int x = (value - 1) / 3;\n        int y = (value - 1) % 3;\n        distance += abs(x - i / 3) + abs(y - i % 3);\n    }\n    return distance;\n}\n\n// Define a function to solve the puzzle using A* search algorithm\nint solve(int* state) {\n    map<vector<int>, int> distance;\n    distance[vector<int>(state, state + 9)] = 0;\n    priority_queue<pair<int, vector<int> > > queue;\n    queue.push(make_pair(0, vector<int>(state, state + 9)));\n    while (!queue.empty()) {\n        vector<int> current = queue.top().second;\n        queue.pop();\n        if (current == vector<int>(target, target + 9)) {\n            return distance[current];\n        }\n        int zero_index;\n        REP(i, 9) {\n            if (current[i] == 0) {\n                zero_index = i;\n                break;\n            }\n        }\n        int x = zero_index / 3;\n        int y = zero_index % 3;\n        REP(i, 4) {\n            int new_x = x + dx[i];\n            int new_y = y + dy[i];\n            if (!is_valid(new_x, new_y)) continue;\n            swap(current[zero_index], current[new_x * 3 + new_y]);\n            if (!present(distance, current) || distance[current] > distance[vector<int>(state, state + 9)] + 1) {\n                distance[current] = distance[vector<int>(state, state + 9)] + 1;\n                queue.push(make_pair(-distance[current] - manhattan_distance(&current[0]), current));\n            }\n            swap(current[zero_index], current[new_x * 3 + new_y]);\n        }\n    }\n    return -1;\n}\n\n// Define the main function to read the input and print the output\nint main() {\n    REP(i, 9) {\n        scanf(\"%d\", &initial[i]);\n    }\n    printf(\"%d\\n\", solve(initial));\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 19,
            "mean_time_taken": 0.08030755896317332,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Swap Round Sorting",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to find the parent of an element in the disjoint set union data structure\nint find_parent(int x, vector<int>& parent) {\n    if (parent[x] != x) {\n        parent[x] = find_parent(parent[x], parent);\n    }\n    return parent[x];\n}\n\n// Function to merge two connected components in the disjoint set union data structure\nvoid union_sets(int x, int y, vector<int>& parent, vector<int>& rank) {\n    int x_parent = find_parent(x, parent);\n    int y_parent = find_parent(y, parent);\n    if (x_parent == y_parent) {\n        return;\n    }\n    if (rank[x_parent] < rank[y_parent]) {\n        parent[x_parent] = y_parent;\n    } else if (rank[x_parent] > rank[y_parent]) {\n        parent[y_parent] = x_parent;\n    } else {\n        parent[y_parent] = x_parent;\n        rank[x_parent]++;\n    }\n}\n\n// Function to count the number of connected components in the disjoint set union data structure\nint count_components(vector<int>& parent) {\n    int count = 0;\n    for (int i = 0; i < parent.size(); i++) {\n        if (parent[i] == i) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    vector<int> parent(n);\n    vector<int> rank(n, 1);\n    for (int i = 0; i < n; i++) {\n        parent[i] = i;\n    }\n    vector<pair<int, int>> swaps;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] != i + 1) {\n            swap(arr[i], arr[arr[i] - 1]);\n            swaps.push_back({i, arr[i] - 1});\n            union_sets(i, arr[i] - 1, parent, rank);\n        }\n    }\n    int k = count_components(parent) - 1;\n    cout << k << endl;\n    vector<vector<pair<int, int>>> rounds(k);\n    for (int i = 0; i < swaps.size(); i++) {\n        int x = swaps[i].first;\n        int y = swaps[i].second;\n        int x_parent = find_parent(x, parent);\n        int y_parent = find_parent(y, parent);\n        if (x_parent != y_parent) {\n            rounds[k - 1].push_back({x, y});\n            union_sets(x, y, parent, rank);\n        } else {\n            rounds[k - 2].push_back({x, y});\n        }\n    }\n    for (int i = 0; i < k; i++) {\n        cout << rounds[i].size() << endl;\n        for (int j = 0; j < rounds[i].size(); j++) {\n            cout << rounds[i][j].first + 1 << \" \" << rounds[i][j].second + 1 << endl;\n        }\n    }\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 15,
            "mean_time_taken": 0.14463911056518555,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Task Assignment",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 205;\nint n, cost[MAX_N][MAX_N], row_match[MAX_N], col_match[MAX_N], row_visited[MAX_N], col_visited[MAX_N];\n\nbool dfs(int u) {\n    row_visited[u] = true;\n    for (int v = 1; v <= n; v++) {\n        if (col_visited[v]) continue;\n        int t = row_match[u] + col_match[v] - cost[u][v];\n        if (t == 0) {\n            col_visited[v] = true;\n            if (col_match[v] == 0 || dfs(col_match[v])) {\n                col_match[v] = u;\n                row_match[u] = v;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++) {\n            cin >> cost[i][j];\n            row_match[i] = max(row_match[i], cost[i][j]);\n        }\n\n    for (int i = 1; i <= n; i++) {\n        int min_val = INT_MAX;\n        for (int j = 1; j <= n; j++)\n            min_val = min(min_val, cost[i][j] - row_match[i]);\n        for (int j = 1; j <= n; j++)\n            cost[i][j] -= min_val;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        memset(row_visited, 0, sizeof(row_visited));\n        memset(col_visited, 0, sizeof(col_visited));\n        while (!dfs(i));\n    }\n\n    int total_cost = 0;\n    for (int i = 1; i <= n; i++)\n        total_cost += cost[i][row_match[i]];\n\n    cout << total_cost << endl;\n    for (int i = 1; i <= n; i++)\n        cout << i << \" \" << row_match[i] << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 1.0365928808848064,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tasks and Deadlines",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int, int> Task;\n\n// Comparator function to sort tasks based on their deadlines\nbool compareTasks(Task a, Task b) {\n    return a.second < b.second;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<Task> tasks(n);\n\n    // Read the input and store the tasks in a vector\n    for (int i = 0; i < n; i++) {\n        cin >> tasks[i].first >> tasks[i].second;\n    }\n\n    // Sort the tasks based on their deadlines\n    sort(tasks.begin(), tasks.end(), compareTasks);\n\n    int maxReward = 0;\n    int currentTime = 0;\n\n    // Iterate through the sorted tasks\n    for (int i = 0; i < n; i++) {\n        // Update the current time by adding the duration of the current task\n        currentTime += tasks[i].first;\n\n        // Calculate the reward for the current task and update the maximum reward\n        maxReward = max(maxReward, tasks[i].second - currentTime);\n    }\n\n    // Print the maximum reward\n    cout << maxReward << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 6,
            "mean_time_taken": 0.13463743527730307,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Teleporters Path",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_NODES = 100005;\n\nvector<int> graph[MAX_NODES];\nint in_degree[MAX_NODES], out_degree[MAX_NODES];\nint path[MAX_NODES * 2];\nint num_nodes, num_edges;\n\nvoid dfs(int node) {\n    while (!graph[node].empty()) {\n        int next_node = graph[node].back();\n        graph[node].pop_back();\n        dfs(next_node);\n        path[++num_edges] = next_node;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> num_nodes >> num_edges;\n\n    for (int i = 1; i <= num_edges; i++) {\n        int node1, node2;\n        cin >> node1 >> node2;\n        graph[node1].push_back(node2);\n        in_degree[node2]++;\n        out_degree[node1]++;\n    }\n\n    int start_node = -1, end_node = -1;\n    for (int i = 1; i <= num_nodes; i++) {\n        if (out_degree[i] - in_degree[i] == 1) {\n            start_node = i;\n        } else if (out_degree[i] - in_degree[i] == -1) {\n            end_node = i;\n        } else if (out_degree[i] != in_degree[i]) {\n            cout << \"IMPOSSIBLE\" << endl;\n            return 0;\n        }\n    }\n\n    if (start_node == -1) {\n        start_node = 1;\n    }\n    if (end_node == -1) {\n        end_node = num_nodes;\n    }\n\n    for (int i = 1; i <= num_nodes; i++) {\n        sort(graph[i].begin(), graph[i].end());\n    }\n\n    path[++num_edges] = start_node;\n    dfs(start_node);\n\n    if (path[num_edges] != end_node) {\n        cout << \"IMPOSSIBLE\" << endl;\n        return 0;\n    }\n\n    for (int i = num_edges; i >= 1; i--) {\n        cout << path[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 3,
            "total_test_cases": 18,
            "mean_time_taken": 0.13065474563174778,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                15,
                16,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Throwing Dice",
            "category": "Mathematics",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int MAX_N = 1e6 + 5;\nconst int MAX_K = 6;\n\nlong long dp[MAX_N][MAX_K];\nlong long prefix_sum[MAX_N];\n\nlong long solve(long long n, int k) {\n    if (n < 7) {\n        return (n >= 1 && n <= 6);\n    }\n    if (dp[n][k] != -1) {\n        return dp[n][k];\n    }\n    long long& ans = dp[n][k];\n    ans = 0;\n    for (int i = 1; i <= 6; i++) {\n        ans = (ans + prefix_sum[max(0LL, n - i)] - prefix_sum[max(0LL, n - i - k + 1)] + MOD) % MOD;\n    }\n    return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    long long n;\n    cin >> n;\n    memset(dp, -1, sizeof(dp));\n    prefix_sum[0] = 1;\n    for (int i = 1; i < MAX_N; i++) {\n        prefix_sum[i] = (prefix_sum[i - 1] + solve(i, 6)) % MOD;\n    }\n    long long ans = 0;\n    for (int i = 1; i <= min(n, 6LL); i++) {\n        ans = (ans + solve(n - i, i)) % MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 32,
            "mean_time_taken": 0.16911154985427856,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tower of Hanoi",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nvoid hanoi(int n, int src, int dst, int aux) {\n    if (n == 1) {\n        cout << src << \" \" << dst << endl;\n        return;\n    }\n    hanoi(n - 1, src, aux, dst);\n    hanoi(1, src, dst, aux);\n    hanoi(n - 1, aux, dst, src);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    int k = (1 << n) - 1;\n    cout << k << endl;\n    hanoi(n, 1, 3, 2);\n    return 0;\n}\n",
            "passed_test_cases": 16,
            "total_test_cases": 16,
            "mean_time_taken": 0.08676649630069733,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 41,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Towers",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <set>\n#include <vector>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> cubes(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> cubes[i];\n    }\n\n    std::multiset<int> towers;\n    for (int i = 0; i < n; i++) {\n        auto it = towers.upper_bound(cubes[i]);\n        if (it != towers.end()) {\n            towers.erase(it);\n        }\n        towers.insert(cubes[i]);\n    }\n\n    std::cout << towers.size() << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.15000482400258383,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Traffic Lights",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nint main() {\n    int x, n;\n    std::cin >> x >> n;\n\n    std::vector<int> positions(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> positions[i];\n    }\n\n    std::sort(positions.begin(), positions.end());\n\n    int max_distance = positions[0];\n    std::cout << max_distance << \" \";\n\n    for (int i = 1; i < n; i++) {\n        int distance = (positions[i] - positions[i - 1]) / 2;\n        max_distance = std::max(max_distance, distance);\n        std::cout << max_distance << \" \";\n    }\n\n    max_distance = std::max(max_distance, x - positions[n - 1]);\n    std::cout << max_distance << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.1278997262318929,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Trailing Zeros",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n\nint main() {\n    int n, count = 0, i = 5;\n    std::cin >> n;\n\n    while (n / i > 0) {\n        count += n / i;\n        i *= 5;\n    }\n\n    std::cout << count << std::endl;\n    return 0;\n}\n",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.0802912161900447,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Tree Diameter",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_NODES = 200005;\n\nvector<int> adjacencyList[MAX_NODES];\nint maxDistance = 0;\nint farthestNode = 0;\n\n// Perform a DFS from a given node to find the farthest node and the maximum distance\nvoid depthFirstSearch(int node, int parent, int distance) {\n    if (distance > maxDistance) {\n        maxDistance = distance;\n        farthestNode = node;\n    }\n    for (int neighbor : adjacencyList[node]) {\n        if (neighbor != parent) {\n            depthFirstSearch(neighbor, node, distance + 1);\n        }\n    }\n}\n\nint main() {\n    int numNodes;\n    cin >> numNodes;\n\n    // Read the edges of the tree and add them to the adjacency list\n    for (int i = 1; i < numNodes; i++) {\n        int node1, node2;\n        cin >> node1 >> node2;\n        adjacencyList[node1].push_back(node2);\n        adjacencyList[node2].push_back(node1);\n    }\n\n    // Perform a DFS from an arbitrary starting node to find the farthest node\n    depthFirstSearch(1, 0, 0);\n\n    // Perform another DFS from the farthest node found in the previous step to find the actual diameter of the tree\n    maxDistance = 0;\n    depthFirstSearch(farthestNode, 0, 0);\n\n    // Print the diameter of the tree\n    cout << maxDistance << endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 16,
            "total_test_cases": 18,
            "mean_time_taken": 0.13485113779703775,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Distances I",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_NODES = 2e5 + 5;\nvector<int> adj[MAX_NODES];\nint height[MAX_NODES];\nint subtreeHeight[MAX_NODES];\nint maxDistance[MAX_NODES];\n\n// Perform DFS to calculate the height of each node and the height of the subtree rooted at that node\nvoid dfs1(int node, int parent) {\n    height[node] = height[parent] + 1;\n    for (int child : adj[node]) {\n        if (child != parent) {\n            dfs1(child, node);\n            subtreeHeight[node] = max(subtreeHeight[node], height[child]);\n        }\n    }\n}\n\n// Perform DFS to calculate the maximum distance from each node to another node\nvoid dfs2(int node, int parent) {\n    for (int child : adj[node]) {\n        if (child != parent) {\n            maxDistance[child] = max(maxDistance[node], subtreeHeight[node] - height[child] + 1);\n            dfs2(child, node);\n        }\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs1(1, 0);\n    dfs2(1, 0);\n    for (int i = 1; i <= n; i++) {\n        cout << maxDistance[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 15,
            "mean_time_taken": 0.15362521807352703,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Distances II",
            "category": "Tree Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Tree Isomorphism I",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_NODES = 100005;\n\nvector<int> adjacencyList1[MAX_NODES];\nvector<int> adjacencyList2[MAX_NODES];\nint degrees1[MAX_NODES];\nint degrees2[MAX_NODES];\n\nvoid depthFirstSearch1(int node, int parent) {\n    degrees1[node] = adjacencyList1[node].size();\n    for (int neighbor : adjacencyList1[node]) {\n        if (neighbor != parent) {\n            depthFirstSearch1(neighbor, node);\n        }\n    }\n}\n\nvoid depthFirstSearch2(int node, int parent) {\n    degrees2[node] = adjacencyList2[node].size();\n    for (int neighbor : adjacencyList2[node]) {\n        if (neighbor != parent) {\n            depthFirstSearch2(neighbor, node);\n        }\n    }\n}\n\nint main() {\n    int numberOfTestCases;\n    cin >> numberOfTestCases;\n\n    while (numberOfTestCases--) {\n        int numberOfNodes;\n        cin >> numberOfNodes;\n\n        for (int i = 1; i <= numberOfNodes; i++) {\n            adjacencyList1[i].clear();\n            adjacencyList2[i].clear();\n        }\n\n        for (int i = 1; i < numberOfNodes; i++) {\n            int node1, node2;\n            cin >> node1 >> node2;\n            adjacencyList1[node1].push_back(node2);\n            adjacencyList1[node2].push_back(node1);\n        }\n\n        for (int i = 1; i < numberOfNodes; i++) {\n            int node1, node2;\n            cin >> node1 >> node2;\n            adjacencyList2[node1].push_back(node2);\n            adjacencyList2[node2].push_back(node1);\n        }\n\n        depthFirstSearch1(1, 0);\n        depthFirstSearch2(1, 0);\n\n        sort(degrees1 + 1, degrees1 + numberOfNodes + 1);\n        sort(degrees2 + 1, degrees2 + numberOfNodes + 1);\n\n        bool isIsomorphic = true;\n        for (int i = 1; i <= numberOfNodes; i++) {\n            if (degrees1[i] != degrees2[i]) {\n                isIsomorphic = false;\n                break;\n            }\n        }\n\n        if (isIsomorphic) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 8,
            "total_test_cases": 15,
            "mean_time_taken": 0.155651060740153,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                10,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Isomorphism II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_NODES = 100005;\n\nvector<int> graph1[MAX_NODES];\nvector<int> graph2[MAX_NODES];\nvector<int> degree_sequence1[MAX_NODES];\nvector<int> degree_sequence2[MAX_NODES];\n\nvoid dfs(int node, int parent, vector<int> graph[], vector<int> degree_sequence[]) {\n    for (int child : graph[node]) {\n        if (child != parent) {\n            dfs(child, node, graph, degree_sequence);\n            degree_sequence[node].push_back(graph[child].size() - (child == parent ? 0 : 1));\n        }\n    }\n    sort(degree_sequence[node].begin(), degree_sequence[node].end());\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int num_test_cases;\n    cin >> num_test_cases;\n\n    while (num_test_cases--) {\n        int num_nodes;\n        cin >> num_nodes;\n\n        for (int i = 1; i <= num_nodes; i++) {\n            graph1[i].clear();\n            graph2[i].clear();\n            degree_sequence1[i].clear();\n            degree_sequence2[i].clear();\n        }\n\n        for (int i = 0; i < num_nodes - 1; i++) {\n            int u, v;\n            cin >> u >> v;\n            graph1[u].push_back(v);\n            graph1[v].push_back(u);\n        }\n\n        for (int i = 0; i < num_nodes - 1; i++) {\n            int u, v;\n            cin >> u >> v;\n            graph2[u].push_back(v);\n            graph2[v].push_back(u);\n        }\n\n        dfs(1, 0, graph1, degree_sequence1);\n        dfs(1, 0, graph2, degree_sequence2);\n\n        bool is_isomorphic = true;\n        for (int i = 1; i <= num_nodes; i++) {\n            if (degree_sequence1[i] != degree_sequence2[i]) {\n                is_isomorphic = false;\n                break;\n            }\n        }\n\n        if (is_isomorphic) {\n            cout << \"YES\\n\";\n        } else {\n            cout << \"NO\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 14,
            "mean_time_taken": 0.15685181958334787,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                7,
                8,
                9,
                11,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Matching",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nconst int MAX_NODES = 200005;\n\nstd::vector<int> adjacencyList[MAX_NODES];\nint subtreeSize[MAX_NODES];\nint oddSubtreesCount = 0;\n\n// Perform a DFS traversal of the tree, starting from the current node\nvoid depthFirstSearch(int currentNode, int parentNode) {\n    subtreeSize[currentNode] = 0;\n    for (int neighbor : adjacencyList[currentNode]) {\n        if (neighbor != parentNode) {\n            depthFirstSearch(neighbor, currentNode);\n            subtreeSize[currentNode] += subtreeSize[neighbor];\n        }\n    }\n    // If the current node has an odd number of children, increment the count of odd subtrees\n    if ((adjacencyList[currentNode].size() - (currentNode != 1 ? 1 : 0) + subtreeSize[currentNode]) % 2 == 1) {\n        oddSubtreesCount++;\n    }\n}\n\nint main() {\n    int numNodes;\n    std::cin >> numNodes;\n\n    // Create an adjacency list to represent the tree\n    for (int i = 1; i < numNodes; i++) {\n        int nodeA, nodeB;\n        std::cin >> nodeA >> nodeB;\n        adjacencyList[nodeA].push_back(nodeB);\n        adjacencyList[nodeB].push_back(nodeA);\n    }\n\n    // Perform a DFS traversal of the tree, starting from the root node\n    depthFirstSearch(1, 0);\n\n    // Calculate the maximum number of edges in a matching\n    int maxPairs = oddSubtreesCount / 2;\n\n    // Print the maximum number of edges in a matching as the output\n    std::cout << maxPairs << std::endl;\n\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 13,
            "mean_time_taken": 0.1454935990847074,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Traversals",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Define a structure for a binary tree node\nstruct Node {\n    int value;\n    Node* left;\n    Node* right;\n};\n\n// Function to construct the binary tree from preorder and inorder traversals\nNode* constructTree(vector<int>& preorder, vector<int>& inorder, int start, int end) {\n    static int preIndex = 0;\n\n    if (start > end)\n        return nullptr;\n\n    Node* node = new Node();\n    node->value = preorder[preIndex++];\n\n    if (start == end)\n        return node;\n\n    int inIndex = distance(inorder.begin(), find(inorder.begin(), inorder.end(), node->value));\n\n    node->left = constructTree(preorder, inorder, start, inIndex - 1);\n    node->right = constructTree(preorder, inorder, inIndex + 1, end);\n\n    return node;\n}\n\n// Function to perform a postorder traversal of the binary tree\nvoid postorderTraversal(Node* node) {\n    if (node == nullptr)\n        return;\n\n    postorderTraversal(node->left);\n    postorderTraversal(node->right);\n    cout << node->value << \" \";\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> preorder(n), inorder(n);\n\n    for (int i = 0; i < n; i++)\n        cin >> preorder[i];\n\n    for (int i = 0; i < n; i++)\n        cin >> inorder[i];\n\n    Node* root = constructTree(preorder, inorder, 0, n - 1);\n\n    postorderTraversal(root);\n\n    return 0;\n}\n",
            "passed_test_cases": 5,
            "total_test_cases": 12,
            "mean_time_taken": 0.6384883522987366,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                7,
                9,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Two Knights",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    long long int n, result;\n    cin >> n;\n\n    for (long long int k = 1; k <= n; k++) {\n        result = (k * k * (k * k - 1) / 2) - (8 * (k - 1) * (k - 2));\n        cout << result << endl;\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 2,
            "total_test_cases": 3,
            "mean_time_taken": 0.09165016810099284,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                1
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Two Sets",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    // Calculate the total sum of the set\n    int total_sum = (n * (n + 1)) / 2;\n\n    // Check if the total sum is odd\n    if (total_sum % 2 != 0) {\n        std::cout << \"NO\";\n        return 0;\n    }\n\n    // Calculate the target sum of each subset\n    int target_sum = total_sum / 2;\n\n    // Initialize two empty vectors to store the elements of the two subsets\n    std::vector<int> set1, set2;\n\n    // Iterate from n to 1\n    for (int i = n; i >= 1; i--) {\n        // Add the current element to the first subset if its sum is less than or equal to the target sum\n        if (target_sum >= i) {\n            set1.push_back(i);\n            target_sum -= i;\n        }\n        // Otherwise, add the current element to the second subset\n        else {\n            set2.push_back(i);\n        }\n    }\n\n    // Print \"YES\" and the two subsets\n    std::cout << \"YES\\n\";\n    std::cout << set1.size() << \"\\n\";\n    for (int i = 0; i < set1.size(); i++) {\n        std::cout << set1[i] << \" \";\n    }\n    std::cout << \"\\n\";\n    std::cout << set2.size() << \"\\n\";\n    for (int i = 0; i < set2.size(); i++) {\n        std::cout << set2[i] << \" \";\n    }\n\n    return 0;\n}\n",
            "passed_test_cases": 15,
            "total_test_cases": 23,
            "mean_time_taken": 0.08578370965045432,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                7,
                9,
                14,
                16,
                17,
                21,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Two Sets II",
            "category": "Dynamic Programming",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Two Stacks Sorting",
            "category": "Additional Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Visiting Cities",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_NODES = 100005;\nconst long long INF = 1e18;\n\nint numNodes, numEdges;\nvector<pair<int, int>> graph[MAX_NODES];\nlong long distances[MAX_NODES];\nint previousNodes[MAX_NODES];\n\nvoid dijkstra() {\n    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\n    pq.push({0, 1});\n    distances[1] = 0;\n\n    while (!pq.empty()) {\n        long long distance = pq.top().first;\n        int node = pq.top().second;\n        pq.pop();\n\n        if (distances[node] != distance) continue;\n\n        for (auto neighbor : graph[node]) {\n            if (distances[neighbor.first] > distances[node] + neighbor.second) {\n                distances[neighbor.first] = distances[node] + neighbor.second;\n                previousNodes[neighbor.first] = node;\n                pq.push({distances[neighbor.first], neighbor.first});\n            }\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> numNodes >> numEdges;\n\n    for (int i = 0; i < numEdges; i++) {\n        int node1, node2, weight;\n        cin >> node1 >> node2 >> weight;\n        graph[node1].push_back({node2, weight});\n    }\n\n    for (int i = 1; i <= numNodes; i++) {\n        distances[i] = INF;\n    }\n\n    dijkstra();\n\n    vector<int> path;\n    int currentNode = numNodes;\n\n    while (currentNode != 0) {\n        path.push_back(currentNode);\n        currentNode = previousNodes[currentNode];\n    }\n\n    reverse(path.begin(), path.end());\n\n    cout << path.size() << \"\\n\";\n\n    for (auto node : path) {\n        cout << node << \" \";\n    }\n\n    cout << \"\\n\";\n\n    return 0;\n}\n",
            "passed_test_cases": 4,
            "total_test_cases": 13,
            "mean_time_taken": 0.11678229845487155,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                5,
                6,
                7,
                8,
                10,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Weird Algorithm",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n\nint main() {\n    long long int n;\n    std::cin >> n;\n\n    while (n != 1) {\n        std::cout << n << \" \";\n        if (n % 2 == 0) {\n            n = n / 2;\n        } else {\n            n = n * 3 + 1;\n        }\n    }\n    std::cout << n;\n\n    return 0;\n}\n",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.08199140003749303,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 44,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Word Combinations",
            "category": "String Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 44,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Writing Numbers",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    long long n, totalDigits = 0, currentNumber = 0, power = 1;\n    cin >> n;\n\n    // Calculate the total number of digits\n    totalDigits = 10 * n;\n\n    // Calculate the number of digits in the last number\n    long long i = 1;\n    while (totalDigits > 0) {\n        totalDigits -= i * 9 * power;\n        power *= 10;\n        i++;\n    }\n    i--;\n\n    // Calculate the smallest number that can be written with the maximum number of digits\n    currentNumber = power / 10;\n\n    // Increment the number until we reach the last number that can be written\n    totalDigits += i * 9 * (power / 10);\n    while (totalDigits > 0) {\n        currentNumber++;\n        totalDigits--;\n    }\n\n    // Print the last number that can be written\n    cout << currentNumber << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 21,
            "mean_time_taken": 0.3975658870878674,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 44,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Xor Pyramid",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, result = 0;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        int input_number;\n        cin >> input_number;\n        result = result ^ input_number;\n    }\n    cout << result << endl;\n    return 0;\n}\n",
            "passed_test_cases": 1,
            "total_test_cases": 8,
            "mean_time_taken": 0.10830634832382202,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 44,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        }
    ],
    "total_passed_problems": 44,
    "initial_config": {
        "ignore_time_limits": false,
        "model": "codestral-latest",
        "provider": "mistral",
        "categories": [],
        "shots": 1
    }
}