{
    "problems": [
        {
            "title": "Acyclic Graph Edges",
            "category": "Additional Problems",
            "solution": "def dfs(node, graph, visited, result):\n    visited[node] = True\n    for neighbor in graph[node]:\n        if not visited[neighbor]:\n            result.append((node, neighbor))\n            dfs(neighbor, graph, visited, result)\n\ndef acyclic_graph_edges(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    visited = [False] * (n + 1)\n    result = []\n\n    for node in range(1, n + 1):\n        if not visited[node]:\n            dfs(node, graph, visited, result)\n\n    return result\n",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.11953228712081909,
            "mean_memory_used": 745992.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Advertisement",
            "category": "Additional Problems",
            "solution": "def max_advertisement_area(n, heights):\n    stack = []\n    max_area = 0\n\n    i = 0\n    while i < n:\n        if not stack or heights[stack[-1]] <= heights[i]:\n            stack.append(i)\n            i += 1\n        else:\n            top = stack.pop()\n            area = heights[top] * (i - (stack[-1] if stack else 0) - 1)\n            max_area = max(max_area, area)\n\n    while stack:\n        top = stack.pop()\n        area = heights[top] * (i - (stack[-1] if stack else 0) - 1)\n        max_area = max(max_area, area)\n\n    return max_area\n",
            "passed_test_cases": 0,
            "total_test_cases": 11,
            "mean_time_taken": 0.11972271312366832,
            "mean_memory_used": 1.0909090909090908,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Another Game",
            "category": "Mathematics",
            "solution": "def nim_sum(arr):\n    return functools.reduce(operator.xor, arr)\n\ndef game_winner(n, arr):\n    if nim_sum(arr) != 0:\n        return \"first\"\n    else:\n        return \"second\"\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.readline\n    t = int(input().strip())\n    for _ in range(t):\n        n = int(input().strip())\n        arr = list(map(int, input().strip().split()))\n        print(game_winner(n, arr))\n",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 0.15941031773885092,
            "mean_memory_used": 2.6666666666666665,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/AnotherGame_shot_1.py\", line 17, in <module>\n    print(game_winner(n, arr))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/AnotherGame_shot_1.py\", line 5, in game_winner\n    if nim_sum(arr) != 0:\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/AnotherGame_shot_1.py\", line 2, in nim_sum\n    return functools.reduce(operator.xor, arr)\nNameError: name 'functools' is not defined\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/AnotherGame_shot_1.py\", line 17, in <module>\n    print(game_winner(n, arr))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/AnotherGame_shot_1.py\", line 5, in game_winner\n    if nim_sum(arr) != 0:\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/AnotherGame_shot_1.py\", line 2, in nim_sum\n    return functools.reduce(operator.xor, arr)\nNameError: name 'functools' is not defined\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/AnotherGame_shot_1.py\", line 17, in <module>\n    print(game_winner(n, arr))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/AnotherGame_shot_1.py\", line 5, in game_winner\n    if nim_sum(arr) != 0:\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/AnotherGame_shot_1.py\", line 2, in nim_sum\n    return functools.reduce(operator.xor, arr)\nNameError: name 'functools' is not defined\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Apartments",
            "category": "Sorting and Searching",
            "solution": "# Read the input\nn, m, k = map(int, input().split())\napplicants = list(map(int, input().split()))\napartments = list(map(int, input().split()))\n\n# Sort the lists for easier searching\napplicants.sort()\napartments.sort()\n\n# Initialize a counter for the number of applicants who get an apartment\nassigned = 0\n\n# Use two pointers to iterate through the lists\ni = 0\nj = 0\nwhile i < n and j < m:\n    # If the current apartment is too small for the current applicant, move to the next apartment\n    if apartments[j] < applicants[i] - k:\n        j += 1\n    # If the current apartment is too large for the current applicant, move to the next applicant\n    elif apartments[j] > applicants[i] + k:\n        i += 1\n    # If the current apartment is suitable for the current applicant, assign it and move to the next applicant and apartment\n    else:\n        i += 1\n        j += 1\n        assigned += 1\n\n# Print the result\nprint(assigned)\n",
            "passed_test_cases": 19,
            "total_test_cases": 19,
            "mean_time_taken": 0.16713315562198036,
            "mean_memory_used": 429.4736842105263,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 1,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Apple Division",
            "category": "Introductory Problems",
            "solution": "def apple_division(n, weights):\n    total = sum(weights)\n    target = total // 2\n\n    # dp[i][j] is true if it's possible to get a sum j using the first i weights\n    dp = [[False for _ in range(target + 1)] for _ in range(n + 1)]\n\n    # Base case: with no weights, we can only get a sum of 0\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    # With no weights, we can't get a sum greater than 0\n    for j in range(1, target + 1):\n        dp[0][j] = False\n\n    # Fill the dp table\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if weights[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - weights[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    # If we can find a subset with a sum of target, then the minimum difference is the total sum minus twice the target\n    if dp[n][target]:\n        return total - 2 * target\n    else:\n        # Otherwise, the total sum is odd and we can't divide it evenly, so we return the difference between the total sum and twice the closest possible sum\n        return min(total - 2 * j for j in range(target, -1, -1) if dp[n][j])\n\n# Read the input\nn = int(input())\nweights = list(map(int, input().split()))\n\n# Print the result\nprint(apple_division(n, weights))\n",
            "passed_test_cases": 9,
            "total_test_cases": 18,
            "mean_time_taken": 0.586499465836419,
            "mean_memory_used": 0.8888888888888888,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                7,
                10,
                12,
                14,
                15,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 1,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Apples and Bananas",
            "category": "Advanced Techniques",
            "solution": "def solve():\n    k, n, m = map(int, input().split())\n    apples = sorted(list(map(int, input().split())))\n    bananas = sorted(list(map(int, input().split())))\n\n    ways = [0] * (2 * k + 1)\n\n    for apple in apples:\n        i, j = 0, m - 1\n        while i < m and j >= 0:\n            if apple + bananas[i] == apple + bananas[j]:\n                ways[apple + bananas[i]] += j - i + 1\n                break\n            elif apple + bananas[i] < apple + bananas[j]:\n                i += 1\n            else:\n                j -= 1\n\n    for w in range(2, 2 * k + 1):\n        print(ways[w], end=' ')\n    print()\n\nsolve()\n",
            "passed_test_cases": 1,
            "total_test_cases": 6,
            "mean_time_taken": 0.6342339118321737,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 1,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Area of Rectangles",
            "category": "Additional Problems",
            "solution": "class Node:\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n        self.left = None\n        self.right = None\n        self.max_val = 0\n\ndef build_tree(node, arr, i, j):\n    if i == j:\n        node.max_val = arr[i]\n        return arr[i]\n    mid = (i + j) // 2\n    node.left = Node(node.start, node.start + mid - i)\n    node.right = Node(node.start + mid - i + 1, node.end)\n    node.max_val = max(build_tree(node.left, arr, i, mid), build_tree(node.right, arr, mid + 1, j))\n    return node.max_val\n\ndef query(node, q_start, q_end):\n    if q_start > node.end or q_end < node.start:\n        return 0\n    if q_start <= node.start and q_end >= node.end:\n        return node.max_val\n    return max(query(node.left, q_start, q_end), query(node.right, q_start, q_end))\n\ndef update(node, idx, val):\n    if idx < node.start or idx > node.end:\n        return\n    node.max_val = max(node.max_val, val)\n    if node.start != node.end:\n        mid = (node.start + node.end) // 2\n        update(node.left, idx, val)\n        update(node.right, idx, val)\n\nn = int(input())\nrectangles = [list(map(int, input().split())) for _ in range(n)]\nevents = []\nfor x1, y1, x2, y2 in rectangles:\n    events.append((x1, 1, y1, y2))\n    events.append((x2, -1, y1, y2))\nevents.sort()\n\ntree = Node(0, 10**6 * 2)\nbuild_tree(tree, [0] * (10**6 * 2), 0, 10**6 * 2)\ntotal_area = 0\nprev_x = 0\n\nfor x, sign, y1, y2 in events:\n    if sign == 1:\n        update(tree, y1 + 10**6, y2 - y1 + 1)\n    else:\n        update(tree, y1 + 10**6, -(y2 - y1 + 1))\n    total_area += (x - prev_x) * query(tree, 0, 10**6 * 2)\n    prev_x = x\n\nprint(total_area)\n",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 1.0605314413706461,
            "mean_memory_used": 0.26666666666666666,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 1,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Array Description",
            "category": "Dynamic Programming",
            "solution": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\ndef solve():\n    n, m = map(int, input().split())\n    arr = list(map(int, input().split()))\n    dp = [0] * (m+1)\n    dp[arr[0]] = 1\n    if arr[0] == 0:\n        dp[1] = 1\n        dp[min(m, 2)] = 1\n    for i in range(1, n):\n        ndp = [0] * (m+1)\n        for j in range(1, m+1):\n            if arr[i] != 0 and arr[i] != j:\n                continue\n            if j-1 >= 1:\n                ndp[j] += dp[j-1]\n                ndp[j] %= MOD\n            if j+1 <= m:\n                ndp[j] += dp[j+1]\n                ndp[j] %= MOD\n        dp = ndp\n    print(sum(dp) % MOD)\n\nsolve()\n",
            "passed_test_cases": 6,
            "total_test_cases": 29,
            "mean_time_taken": 0.2712754298900736,
            "mean_memory_used": 0.6896551724137931,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                5,
                6,
                7,
                8,
                9,
                10,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                21,
                22,
                23,
                24,
                25,
                26,
                28,
                29
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 1,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Array Division",
            "category": "Sorting and Searching",
            "solution": "def array_division(n, k, arr):\n    left, right = max(arr), sum(arr)\n    while left < right:\n        mid = (left + right) // 2\n        current_sum, pieces = 0, 0\n        for num in arr:\n            if current_sum + num > mid:\n                pieces += 1\n                current_sum = num\n            else:\n                current_sum += num\n        if pieces >= k:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n# Read the input\nn, k = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Print the result\nprint(array_division(n, k, arr))\n",
            "passed_test_cases": 18,
            "total_test_cases": 18,
            "mean_time_taken": 0.2739991346995036,
            "mean_memory_used": 0.8888888888888888,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Beautiful Subgrids",
            "category": "Advanced Techniques",
            "solution": "# Read the input\nn = int(input())\ngrid = [list(map(int, input())) for _ in range(n)]\n\n# Initialize the count of beautiful subgrids\ncount = 0\n\n# Iterate over all possible subgrids\nfor h in range(2, n + 1):\n    for w in range(2, n + 1):\n        for i in range(n - h + 1):\n            for j in range(n - w + 1):\n                # Check if the subgrid is beautiful\n                if all(grid[i][j], grid[i][j + w - 1], grid[i + h - 1][j], grid[i + h - 1][j + w - 1]):\n                    count += 1\n\n# Print the count of beautiful subgrids\nprint(count)\n",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.48116129636764526,
            "mean_memory_used": 5763.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BeautifulSubgrids_shot_1.py\", line 14, in <module>\n    if all(grid[i][j], grid[i][j + w - 1], grid[i + h - 1][j], grid[i + h - 1][j + w - 1]):\nTypeError: all() takes exactly one argument (4 given)\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BeautifulSubgrids_shot_1.py\", line 14, in <module>\n    if all(grid[i][j], grid[i][j + w - 1], grid[i + h - 1][j], grid[i + h - 1][j + w - 1]):\nTypeError: all() takes exactly one argument (4 given)\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BeautifulSubgrids_shot_1.py\", line 14, in <module>\n    if all(grid[i][j], grid[i][j + w - 1], grid[i + h - 1][j], grid[i + h - 1][j + w - 1]):\nTypeError: all() takes exactly one argument (4 given)\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BeautifulSubgrids_shot_1.py\", line 14, in <module>\n    if all(grid[i][j], grid[i][j + w - 1], grid[i + h - 1][j], grid[i + h - 1][j + w - 1]):\nTypeError: all() takes exactly one argument (4 given)\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BeautifulSubgrids_shot_1.py\", line 14, in <module>\n    if all(grid[i][j], grid[i][j + w - 1], grid[i + h - 1][j], grid[i + h - 1][j + w - 1]):\nTypeError: all() takes exactly one argument (4 given)\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BeautifulSubgrids_shot_1.py\", line 14, in <module>\n    if all(grid[i][j], grid[i][j + w - 1], grid[i + h - 1][j], grid[i + h - 1][j + w - 1]):\nTypeError: all() takes exactly one argument (4 given)\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BeautifulSubgrids_shot_1.py\", line 14, in <module>\n    if all(grid[i][j], grid[i][j + w - 1], grid[i + h - 1][j], grid[i + h - 1][j + w - 1]):\nTypeError: all() takes exactly one argument (4 given)\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BeautifulSubgrids_shot_1.py\", line 14, in <module>\n    if all(grid[i][j], grid[i][j + w - 1], grid[i + h - 1][j], grid[i + h - 1][j + w - 1]):\nTypeError: all() takes exactly one argument (4 given)\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Binary Subsequences",
            "category": "Additional Problems",
            "solution": "# Read the input\nn = int(input())\n\n# Find the smallest k such that 2^k >= n\nk = 0\nwhile 2**k < n:\n    k += 1\n\n# Construct the binary string\ns = bin(n - 1)[2:]  # Convert n-1 to binary and remove the '0b' prefix\ns = '1' + '0'*(k - len(s)) + s  # Pad with zeros and add a leading '1'\n\n# Print the result\nprint(s)\n",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.1282357374827067,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Binomial Coefficients",
            "category": "Mathematics",
            "solution": "# Modulo\nMOD = 10**9 + 7\n\n# Function to calculate factorial\ndef factorial(n):\n    fact = 1\n    for i in range(2, n + 1):\n        fact = (fact * i) % MOD\n    return fact\n\n# Function to calculate modular multiplicative inverse\ndef mod_inv(n):\n    return pow(n, MOD - 2, MOD)\n\n# Function to calculate binomial coefficient\ndef binomial_coeff(n, k):\n    num = factorial(n)\n    den = (factorial(k) * factorial(n - k)) % MOD\n    den = mod_inv(den)\n    return (num * den) % MOD\n\n# Read the number of test cases\nn = int(input())\n\n# For each test case\nfor _ in range(n):\n    # Read a and b\n    a, b = map(int, input().split())\n\n    # Print the binomial coefficient\n    print(binomial_coeff(a, b))\n",
            "passed_test_cases": 6,
            "total_test_cases": 11,
            "mean_time_taken": 0.5426447608254172,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bit Inversions",
            "category": "Additional Problems",
            "solution": "def bit_inversions(bits, changes):\n    # Convert the bit string to a list of integers\n    bits = list(map(int, bits))\n    n = len(bits)\n    max_length = 0\n    current_length = 0\n    last_flip = -1\n\n    # Process each change\n    for change in changes:\n        # If the current bit is different from the previous one\n        if change - 1 > last_flip and bits[change - 1] != bits[last_flip + 1]:\n            current_length = change - last_flip - 1\n        elif change - 1 > last_flip:\n            current_length += 1\n        else:\n            current_length = 0\n\n        # Update the maximum length\n        max_length = max(max_length, current_length)\n\n        # Flip the bit\n        bits[change - 1] = 1 - bits[change - 1]\n\n        # Update the last flip position\n        last_flip = change - 1\n\n        print(max_length)\n\n# Read the input\nbits = input()\nm = int(input())\nchanges = list(map(int, input().split()))\n\n# Call the function\nbit_inversions(bits, changes)\n",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.17605706055959067,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bit Problem",
            "category": "Additional Problems",
            "solution": "# Read the input\nn = int(input())\nnums = list(map(int, input().split()))\n\n# Initialize an empty list to store the results\nresults = []\n\n# Iterate over each element in the list\nfor i in range(n):\n    x = nums[i]\n\n    # Initialize counters for each condition\n    count_div = 0\n    count_and = 0\n    count_not_zero = 0\n\n    # Iterate over the list again to count the number of elements that satisfy each condition\n    for j in range(n):\n        y = nums[j]\n        if x != 0 and y % x == 0:\n            count_div += 1\n        if x != 0 and x & y == x:\n            count_and += 1\n        if x != 0 and x & y != 0:\n            count_not_zero += 1\n\n    # Append the counts to the results list\n    results.append((count_div, count_and, count_not_zero))\n\n# Print the results\nfor result in results:\n    print(*result)\n",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.5855168104171753,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bit Strings",
            "category": "Introductory Problems",
            "solution": "# Read the input\nn = int(input())\n\n# Calculate 2^n using the built-in pow function\nresult = pow(2, n)\n\n# Print the result modulo 10^9+7\nprint(result % (10**9 + 7))\n",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.12681174278259277,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Bit Substrings",
            "category": "Additional Problems",
            "solution": "# Read the input string\ns = input()\nn = len(s)\n\n# Initialize dp array with all zeros\ndp = [[0 for _ in range(n+1)] for _ in range(n+1)]\n\n# Base case: all substrings of length 0 have 0 ones\nfor i in range(n+1):\n    dp[i][0] = 1\n\n# Fill the dp array\nfor i in range(1, n+1):\n    for j in range(1, n+1):\n        if s[i-1] == '0':\n            dp[i][j] = dp[i-1][j]\n        else:\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n            if s[i-1-j] == '1':\n                dp[i][j] -= dp[i-1-j][j]\n\n# Print the result\nfor i in range(n+1):\n    print(dp[n][i], end=\" \")\n",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.7144394218921661,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Book Shop",
            "category": "Dynamic Programming",
            "solution": "def max_pages(n, x, h, s):\n    dp = [[0 for _ in range(x+1)] for _ in range(n+1)]\n\n    for i in range(1, n+1):\n        for j in range(x+1):\n            if j < h[i-1]:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], s[i-1] + dp[i-1][j-h[i-1]])\n\n    return dp[n][x]\n\n# Test the function\nn, x = map(int, input().split())\nh = list(map(int, input().split()))\ns = list(map(int, input().split()))\n\nprint(max_pages(n, x, h, s))\n",
            "passed_test_cases": 7,
            "total_test_cases": 15,
            "mean_time_taken": 0.6529827435811361,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                7,
                9,
                11,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Book Shop II",
            "category": "Additional Problems",
            "solution": "def max_pages(n, x, h, s, k):\n    # Create a list of tuples, each containing the price, pages, copies, and the ratio of pages to price\n    books = sorted([(h[i], s[i], k[i], s[i]/h[i]) for i in range(n)], key=lambda x: -x[3])\n\n    max_pages = 0\n    total_price = 0\n\n    for book in books:\n        price, pages, copies, _ = book\n\n        # Calculate the number of copies we can buy\n        copies_to_buy = min(copies, x // price)\n\n        # Update the total price and max pages\n        total_price += copies_to_buy * price\n        max_pages += copies_to_buy * pages\n\n        # Break if we reach the maximum price\n        if total_price == x:\n            break\n\n    return max_pages\n\n# Test the function\nn, x = map(int, input().split())\nh = list(map(int, input().split()))\ns = list(map(int, input().split()))\nk = list(map(int, input().split()))\n\nprint(max_pages(n, x, h, s, k))\n",
            "passed_test_cases": 3,
            "total_test_cases": 10,
            "mean_time_taken": 0.1257535696029663,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bracket Sequences I",
            "category": "Mathematics",
            "solution": "# Read the input\nn = int(input())\n\n# Define the modulo value\nMOD = 10**9 + 7\n\n# Initialize a list to store the number of valid sequences for each length\ndp = [0] * (n + 1)\n\n# Base cases: there is one valid sequence of length 2, and no valid sequences of other even lengths less than 2\ndp[2] = 1\n\n# Calculate the number of valid sequences for each length from 4 to n\nfor i in range(4, n + 1, 2):\n    # A valid sequence of length i can be formed by concatenating a valid sequence of length j,\n    # a pair of brackets, and a valid sequence of length i - j - 2, for each even j from 0 to i - 2\n    for j in range(0, i - 2, 2):\n        dp[i] = (dp[i] + dp[j] * dp[i - j - 2]) % MOD\n\n# Print the result\nprint(dp[n])\n",
            "passed_test_cases": 5,
            "total_test_cases": 17,
            "mean_time_taken": 0.4458734287935145,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BracketSequencesI_shot_1.py\", line 11, in <module>\n    dp[2] = 1\nIndexError: list assignment index out of range\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                7,
                8,
                9,
                13,
                14,
                15,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bracket Sequences II",
            "category": "Mathematics",
            "solution": "MOD = 10**9 + 7\n\ndef num_sequences(n, prefix):\n    dp = [0] * (n+1)\n    dp[0] = 1\n    cnt = 0\n    for c in prefix:\n        if c == '(':\n            cnt += 1\n        else:\n            cnt -= 1\n            if cnt < 0:\n                return 0\n    if cnt > 0:\n        dp[len(prefix)] = 0\n    else:\n        dp[len(prefix)] = 1\n    for i in range(len(prefix)+1, n+1):\n        for j in range(len(prefix)-1, i-1):\n            dp[i] = (dp[i] + dp[j] * dp[i-j-2]) % MOD\n    return sum(dp[len(prefix):]) % MOD\n",
            "passed_test_cases": 0,
            "total_test_cases": 11,
            "mean_time_taken": 0.12736506895585495,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Building Roads",
            "category": "Graph Algorithms",
            "solution": "def find(parent, i):\n    if parent[i] != i:\n        parent[i] = find(parent, parent[i])\n    return parent[i]\n\ndef union(parent, rank, x, y):\n    rootX = find(parent, x)\n    rootY = find(parent, y)\n\n    if rank[rootX] > rank[rootY]:\n        parent[rootY] = rootX\n    elif rank[rootX] < rank[rootY]:\n        parent[rootX] = rootY\n    else:\n        parent[rootY] = rootX\n        rank[rootX] += 1\n\ndef kruskal(n, edges):\n    parent = list(range(n+1))\n    rank = [0] * (n+1)\n    result = []\n    i, e = 0, 0\n\n    edges.sort(key=lambda item: item[2])\n\n    while e < n - 1:\n        u, v, _ = edges[i]\n        i += 1\n        x = find(parent, u)\n        y = find(parent, v)\n\n        if x != y:\n            e += 1\n            union(parent, rank, x, y)\n            result.append([u, v])\n\n    return result\n\nn, m = map(int, input().split())\nedges = []\n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges.append([a, b, 0])  # the third element is a weight, which is 0 for all edges\n\n# add all possible edges that are not in the input\nfor i in range(1, n+1):\n    for j in range(i+1, n+1):\n        if [i, j, 0] not in edges and [j, i, 0] not in edges:\n            edges.append([i, j, 0])\n\nrequired_roads = kruskal(n, edges)\n\nprint(len(required_roads) - m)\nfor road in required_roads:\n    print(*road)\n",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.5821442008018494,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Building Teams",
            "category": "Graph Algorithms",
            "solution": "def dfs(node, graph, color):\n    if color[node] != 0:\n        return color[node] == 1\n\n    color[node] = 1\n    for neighbor in graph[node]:\n        if not dfs(neighbor, graph, color):\n            color[node] = 2\n            return False\n\n    return True\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    color = [0] * (n + 1)\n    for node in range(1, n + 1):\n        if not dfs(node, graph, color):\n            return \"IMPOSSIBLE\"\n\n    return \" \".join(map(str, color[1:]))\n\n# Test the function\nn, m = map(int, input().split())\nedges = [list(map(int, input().split())) for _ in range(m)]\nprint(solve(n, m, edges))\n",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.24651944637298584,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 29, in <module>\n    print(solve(n, m, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 21, in solve\n    if not dfs(node, graph, color):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 7, in dfs\n    if not dfs(neighbor, graph, color):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 7, in dfs\n    if not dfs(neighbor, graph, color):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 7, in dfs\n    if not dfs(neighbor, graph, color):\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 2, in dfs\n    if color[node] != 0:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 29, in <module>\n    print(solve(n, m, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 21, in solve\n    if not dfs(node, graph, color):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 7, in dfs\n    if not dfs(neighbor, graph, color):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 7, in dfs\n    if not dfs(neighbor, graph, color):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 7, in dfs\n    if not dfs(neighbor, graph, color):\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 2, in dfs\n    if color[node] != 0:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 29, in <module>\n    print(solve(n, m, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 21, in solve\n    if not dfs(node, graph, color):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 7, in dfs\n    if not dfs(neighbor, graph, color):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 7, in dfs\n    if not dfs(neighbor, graph, color):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 7, in dfs\n    if not dfs(neighbor, graph, color):\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 2, in dfs\n    if color[node] != 0:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 29, in <module>\n    print(solve(n, m, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 21, in solve\n    if not dfs(node, graph, color):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 7, in dfs\n    if not dfs(neighbor, graph, color):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 7, in dfs\n    if not dfs(neighbor, graph, color):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 7, in dfs\n    if not dfs(neighbor, graph, color):\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 2, in dfs\n    if color[node] != 0:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 29, in <module>\n    print(solve(n, m, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 21, in solve\n    if not dfs(node, graph, color):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 7, in dfs\n    if not dfs(neighbor, graph, color):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 7, in dfs\n    if not dfs(neighbor, graph, color):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 7, in dfs\n    if not dfs(neighbor, graph, color):\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/BuildingTeams_shot_1.py\", line 2, in dfs\n    if color[node] != 0:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Candy Lottery",
            "category": "Mathematics",
            "solution": "def expected_max_candies(n, k):\n    expected = 0\n    for i in range(1, k+1):\n        p1 = ((i-1)/k)**(n-1)\n        p2 = 1 - ((k-i)/k)**n\n        expected += i * p1 * p2\n    return round(expected, 6)\n\nn, k = map(int, input().split())\nprint(expected_max_candies(n, k))\n",
            "passed_test_cases": 0,
            "total_test_cases": 14,
            "mean_time_taken": 0.12255263328552246,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Chess Tournament",
            "category": "Additional Problems",
            "solution": "def chess_tournament():\n    n = int(input())\n    games = list(map(int, input().split()))\n    total_games = sum(games)\n\n    if total_games % 2 != 0:\n        print(\"IMPOSSIBLE\")\n        return\n\n    players = [i for i in range(1, n + 1)]\n    games.sort(reverse=True)\n    players.sort(reverse=True)\n\n    matches = []\n    while games and sum(games) > 0:\n        for i in range(len(games)):\n            if games[i] > 0:\n                for j in range(i + 1, len(games)):\n                    if games[j] > 0:\n                        matches.append((players[i], players[j]))\n                        games[i] -= 1\n                        games[j] -= 1\n                        break\n\n    print(len(matches))\n    for match in matches:\n        print(match[0], match[1])\n\nchess_tournament()\n",
            "passed_test_cases": 2,
            "total_test_cases": 21,
            "mean_time_taken": 0.9201424575987316,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                9,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Chessboard and Queens",
            "category": "Introductory Problems",
            "solution": "def is_safe(board, row, col):\n    # Check the current row and column\n    for i in range(len(board)):\n        if board[row][i] == 'Q' or board[i][col] == 'Q':\n            return False\n\n    # Check the diagonals\n    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n        if board[i][j] == 'Q':\n            return False\n\n    for i, j in zip(range(row, -1, -1), range(col, len(board), 1)):\n        if board[i][j] == 'Q':\n            return False\n\n    return True\n\ndef place_queens(board, row, count):\n    if row == len(board):\n        count[0] += 1\n        return\n\n    for col in range(len(board)):\n        if board[row][col] == '.' and is_safe(board, row, col):\n            board[row][col] = 'Q'\n            place_queens(board, row + 1, count)\n            board[row][col] = '.'  # Backtrack\n\ndef solve():\n    board = []\n    for _ in range(8):\n        row = input()\n        board.append(list(row))\n\n    count = [0]\n    place_queens(board, 0, count)\n    print(count[0])\n\nsolve()\n",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.129852819442749,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Christmas Party",
            "category": "Mathematics",
            "solution": "def christmas_party(n):\n    MOD = 10**9 + 7\n    dp = [0] * (n+1)\n    dp[1] = 0\n    dp[2] = 1\n\n    for i in range(3, n+1):\n        dp[i] = (i-1) * (dp[i-1] + dp[i-2]) % MOD\n\n    return dp[n]\n\n# Main function to read input and print output\ndef main():\n    n = int(input())\n    print(christmas_party(n))\n\nif __name__ == \"__main__\":\n    main()\n",
            "passed_test_cases": 14,
            "total_test_cases": 15,
            "mean_time_taken": 0.1450291633605957,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ChristmasParty_shot_1.py\", line 18, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ChristmasParty_shot_1.py\", line 15, in main\n    print(christmas_party(n))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ChristmasParty_shot_1.py\", line 5, in christmas_party\n    dp[2] = 1\nIndexError: list assignment index out of range\n"
            ],
            "failed_test_cases": [
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coding Company",
            "category": "Additional Problems",
            "solution": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\ndef coding_company():\n    n, x = map(int, input().split())\n    t = list(map(int, input().split()))\n    t.sort()\n\n    dp = [[0]*(x+1) for _ in range(n+1)]\n    dp[0][0] = 1\n\n    for i in range(1, n+1):\n        for j in range(x+1):\n            for k in range(i):\n                penalty = t[i-1] - t[k-1]\n                if j >= penalty:\n                    dp[i][j] = (dp[i][j] + dp[k][j-penalty]) % MOD\n\n    return dp[n][x]\n\nprint(coding_company())\n",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.15232144991556804,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CodingCompany_shot_1.py\", line 23, in <module>\n    print(coding_company())\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CodingCompany_shot_1.py\", line 19, in coding_company\n    dp[i][j] = (dp[i][j] + dp[k][j-penalty]) % MOD\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CodingCompany_shot_1.py\", line 23, in <module>\n    print(coding_company())\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CodingCompany_shot_1.py\", line 19, in coding_company\n    dp[i][j] = (dp[i][j] + dp[k][j-penalty]) % MOD\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CodingCompany_shot_1.py\", line 23, in <module>\n    print(coding_company())\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CodingCompany_shot_1.py\", line 19, in coding_company\n    dp[i][j] = (dp[i][j] + dp[k][j-penalty]) % MOD\nIndexError: list index out of range\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CodingCompany_shot_1.py\", line 23, in <module>\n    print(coding_company())\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CodingCompany_shot_1.py\", line 19, in coding_company\n    dp[i][j] = (dp[i][j] + dp[k][j-penalty]) % MOD\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CodingCompany_shot_1.py\", line 23, in <module>\n    print(coding_company())\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CodingCompany_shot_1.py\", line 19, in coding_company\n    dp[i][j] = (dp[i][j] + dp[k][j-penalty]) % MOD\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CodingCompany_shot_1.py\", line 23, in <module>\n    print(coding_company())\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CodingCompany_shot_1.py\", line 19, in coding_company\n    dp[i][j] = (dp[i][j] + dp[k][j-penalty]) % MOD\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CodingCompany_shot_1.py\", line 23, in <module>\n    print(coding_company())\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CodingCompany_shot_1.py\", line 19, in coding_company\n    dp[i][j] = (dp[i][j] + dp[k][j-penalty]) % MOD\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CodingCompany_shot_1.py\", line 23, in <module>\n    print(coding_company())\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CodingCompany_shot_1.py\", line 19, in coding_company\n    dp[i][j] = (dp[i][j] + dp[k][j-penalty]) % MOD\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CodingCompany_shot_1.py\", line 23, in <module>\n    print(coding_company())\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CodingCompany_shot_1.py\", line 19, in coding_company\n    dp[i][j] = (dp[i][j] + dp[k][j-penalty]) % MOD\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CodingCompany_shot_1.py\", line 23, in <module>\n    print(coding_company())\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CodingCompany_shot_1.py\", line 19, in coding_company\n    dp[i][j] = (dp[i][j] + dp[k][j-penalty]) % MOD\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CodingCompany_shot_1.py\", line 23, in <module>\n    print(coding_company())\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CodingCompany_shot_1.py\", line 19, in coding_company\n    dp[i][j] = (dp[i][j] + dp[k][j-penalty]) % MOD\nIndexError: list index out of range\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CodingCompany_shot_1.py\", line 23, in <module>\n    print(coding_company())\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CodingCompany_shot_1.py\", line 19, in coding_company\n    dp[i][j] = (dp[i][j] + dp[k][j-penalty]) % MOD\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CodingCompany_shot_1.py\", line 23, in <module>\n    print(coding_company())\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CodingCompany_shot_1.py\", line 19, in coding_company\n    dp[i][j] = (dp[i][j] + dp[k][j-penalty]) % MOD\nIndexError: list index out of range\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Arrangement",
            "category": "Additional Problems",
            "solution": "# Read input\nn = int(input())\nrow1 = list(map(int, input().split()))\nrow2 = list(map(int, input().split()))\n\n# Calculate extra coins in each row\nextra_row1 = sum(row1) - n\nextra_row2 = sum(row2) - n\n\n# Calculate total extra coins\ntotal_extra = extra_row1 + extra_row2\n\n# Print result\nprint(total_extra)\n",
            "passed_test_cases": 2,
            "total_test_cases": 10,
            "mean_time_taken": 0.1350867748260498,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Collector",
            "category": "Graph Algorithms",
            "solution": "import sys\nfrom collections import defaultdict\n\ndef dfs(graph, node, parent):\n    for child in graph[node]:\n        if child != parent:\n            dfs(graph, child, node)\n            max_path_through_child = dp[child][0]\n            max_coins_without_child = max(dp[child][1], max_coins_without_child)\n            dp[node][0] += max_path_through_child\n            dp[node][1] += max_coins_without_child\n\ndef coin_collector():\n    n, m = map(int, input().split())\n    k = list(map(int, input().split()))\n    graph = defaultdict(list)\n    for _ in range(m):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    dp = [[k[i - 1], 0] for i in range(n + 1)]\n    dfs(graph, 1, -1)\n    print(max(dp[1][0], dp[1][1]))\n\ncoin_collector()\n",
            "passed_test_cases": 0,
            "total_test_cases": 14,
            "mean_time_taken": 0.22440082686288015,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 25, in <module>\n    coin_collector()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 22, in coin_collector\n    dfs(graph, 1, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 7, in dfs\n    dfs(graph, child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 8, in dfs\n    max_path_through_child = dp[child][0]\nNameError: name 'dp' is not defined\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 25, in <module>\n    coin_collector()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 22, in coin_collector\n    dfs(graph, 1, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 7, in dfs\n    dfs(graph, child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 7, in dfs\n    dfs(graph, child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 7, in dfs\n    dfs(graph, child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 8, in dfs\n    max_path_through_child = dp[child][0]\nNameError: name 'dp' is not defined\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 25, in <module>\n    coin_collector()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 22, in coin_collector\n    dfs(graph, 1, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 8, in dfs\n    max_path_through_child = dp[child][0]\nNameError: name 'dp' is not defined\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 25, in <module>\n    coin_collector()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 22, in coin_collector\n    dfs(graph, 1, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 7, in dfs\n    dfs(graph, child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 7, in dfs\n    dfs(graph, child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 7, in dfs\n    dfs(graph, child, node)\n  [Previous line repeated 14 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 8, in dfs\n    max_path_through_child = dp[child][0]\nNameError: name 'dp' is not defined\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 25, in <module>\n    coin_collector()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 22, in coin_collector\n    dfs(graph, 1, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 7, in dfs\n    dfs(graph, child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 7, in dfs\n    dfs(graph, child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 7, in dfs\n    dfs(graph, child, node)\n  [Previous line repeated 4 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 8, in dfs\n    max_path_through_child = dp[child][0]\nNameError: name 'dp' is not defined\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 25, in <module>\n    coin_collector()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 22, in coin_collector\n    dfs(graph, 1, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 7, in dfs\n    dfs(graph, child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 7, in dfs\n    dfs(graph, child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 7, in dfs\n    dfs(graph, child, node)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 6, in dfs\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 25, in <module>\n    coin_collector()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 22, in coin_collector\n    dfs(graph, 1, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 7, in dfs\n    dfs(graph, child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 7, in dfs\n    dfs(graph, child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 7, in dfs\n    dfs(graph, child, node)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 6, in dfs\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 25, in <module>\n    coin_collector()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 22, in coin_collector\n    dfs(graph, 1, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 7, in dfs\n    dfs(graph, child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 7, in dfs\n    dfs(graph, child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 7, in dfs\n    dfs(graph, child, node)\n  [Previous line repeated 17 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 8, in dfs\n    max_path_through_child = dp[child][0]\nNameError: name 'dp' is not defined\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 25, in <module>\n    coin_collector()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 22, in coin_collector\n    dfs(graph, 1, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 7, in dfs\n    dfs(graph, child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 7, in dfs\n    dfs(graph, child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 7, in dfs\n    dfs(graph, child, node)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 6, in dfs\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 25, in <module>\n    coin_collector()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 22, in coin_collector\n    dfs(graph, 1, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 7, in dfs\n    dfs(graph, child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 7, in dfs\n    dfs(graph, child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 7, in dfs\n    dfs(graph, child, node)\n  [Previous line repeated 3 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 8, in dfs\n    max_path_through_child = dp[child][0]\nNameError: name 'dp' is not defined\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 25, in <module>\n    coin_collector()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 22, in coin_collector\n    dfs(graph, 1, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCollector_shot_1.py\", line 8, in dfs\n    max_path_through_child = dp[child][0]\nNameError: name 'dp' is not defined\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Combinations I",
            "category": "Dynamic Programming",
            "solution": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\nn, x = map(int, input().split())\ncoins = list(map(int, input().split()))\n\ndp = [[0]*(x+1) for _ in range(n+1)]\ndp[0][0] = 1\n\nfor i in range(1, n+1):\n    for j in range(x+1):\n        if j >= coins[i-1]:\n            dp[i][j] = (dp[i-1][j] + dp[i][j - coins[i-1]]) % MOD\n\nprint(dp[n][x])\n",
            "passed_test_cases": 3,
            "total_test_cases": 13,
            "mean_time_taken": 0.23354579852177546,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsI_shot_1.py\", line 8, in <module>\n    dp = [[0]*(x+1) for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsI_shot_1.py\", line 8, in <listcomp>\n    dp = [[0]*(x+1) for _ in range(n+1)]\nMemoryError\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsI_shot_1.py\", line 8, in <module>\n    dp = [[0]*(x+1) for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsI_shot_1.py\", line 8, in <listcomp>\n    dp = [[0]*(x+1) for _ in range(n+1)]\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsI_shot_1.py\", line 8, in <module>\n    dp = [[0]*(x+1) for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsI_shot_1.py\", line 8, in <listcomp>\n    dp = [[0]*(x+1) for _ in range(n+1)]\nMemoryError\n",
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsI_shot_1.py\", line 8, in <module>\n    dp = [[0]*(x+1) for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsI_shot_1.py\", line 8, in <listcomp>\n    dp = [[0]*(x+1) for _ in range(n+1)]\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsI_shot_1.py\", line 8, in <module>\n    dp = [[0]*(x+1) for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsI_shot_1.py\", line 8, in <listcomp>\n    dp = [[0]*(x+1) for _ in range(n+1)]\nMemoryError\n"
            ],
            "failed_test_cases": [
                1,
                2,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Combinations II",
            "category": "Dynamic Programming",
            "solution": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\ndef coin_combinations(n, x, coins):\n    dp = [[0]*(x+1) for _ in range(n+1)]\n    dp[0][0] = 1\n    for i in range(1, n+1):\n        for j in range(x+1):\n            if j >= coins[i-1]:\n                dp[i][j] = (dp[i-1][j] + dp[i][j-coins[i-1]]) % MOD\n            else:\n                dp[i][j] = dp[i-1][j]\n    return dp[n][x]\n\nn, x = map(int, input().split())\ncoins = list(map(int, input().split()))\nprint(coin_combinations(n, x, coins))\n",
            "passed_test_cases": 8,
            "total_test_cases": 15,
            "mean_time_taken": 0.25590492884318033,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsII_shot_1.py\", line 19, in <module>\n    print(coin_combinations(n, x, coins))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsII_shot_1.py\", line 7, in coin_combinations\n    dp = [[0]*(x+1) for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsII_shot_1.py\", line 7, in <listcomp>\n    dp = [[0]*(x+1) for _ in range(n+1)]\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsII_shot_1.py\", line 19, in <module>\n    print(coin_combinations(n, x, coins))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsII_shot_1.py\", line 7, in coin_combinations\n    dp = [[0]*(x+1) for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsII_shot_1.py\", line 7, in <listcomp>\n    dp = [[0]*(x+1) for _ in range(n+1)]\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsII_shot_1.py\", line 19, in <module>\n    print(coin_combinations(n, x, coins))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsII_shot_1.py\", line 7, in coin_combinations\n    dp = [[0]*(x+1) for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsII_shot_1.py\", line 7, in <listcomp>\n    dp = [[0]*(x+1) for _ in range(n+1)]\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsII_shot_1.py\", line 19, in <module>\n    print(coin_combinations(n, x, coins))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsII_shot_1.py\", line 7, in coin_combinations\n    dp = [[0]*(x+1) for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsII_shot_1.py\", line 7, in <listcomp>\n    dp = [[0]*(x+1) for _ in range(n+1)]\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsII_shot_1.py\", line 19, in <module>\n    print(coin_combinations(n, x, coins))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsII_shot_1.py\", line 7, in coin_combinations\n    dp = [[0]*(x+1) for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsII_shot_1.py\", line 7, in <listcomp>\n    dp = [[0]*(x+1) for _ in range(n+1)]\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsII_shot_1.py\", line 19, in <module>\n    print(coin_combinations(n, x, coins))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsII_shot_1.py\", line 7, in coin_combinations\n    dp = [[0]*(x+1) for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsII_shot_1.py\", line 7, in <listcomp>\n    dp = [[0]*(x+1) for _ in range(n+1)]\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsII_shot_1.py\", line 19, in <module>\n    print(coin_combinations(n, x, coins))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsII_shot_1.py\", line 7, in coin_combinations\n    dp = [[0]*(x+1) for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CoinCombinationsII_shot_1.py\", line 7, in <listcomp>\n    dp = [[0]*(x+1) for _ in range(n+1)]\nMemoryError\n"
            ],
            "failed_test_cases": [
                6,
                7,
                8,
                9,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Grid",
            "category": "Additional Problems",
            "solution": "# Read the grid size\nn = int(input())\n\n# Initialize row and column counters\nrow_has_coin = [False] * n\ncol_has_coin = [False] * n\n\n# Read the grid and update the counters\nfor i in range(n):\n    row = input()\n    for j in range(n):\n        if row[j] == 'o':\n            row_has_coin[i] = True\n            col_has_coin[j] = True\n\n# Count the number of rows and columns with coins\nnum_rows = sum(row_has_coin)\nnum_cols = sum(col_has_coin)\n\n# Print the minimum number of moves\nprint(min(num_rows, num_cols))\n\n# Print the moves\nfor i in range(n):\n    if row_has_coin[i]:\n        print(\"1\", i + 1)\n    if col_has_coin[i]:\n        print(\"2\", i + 1)\n",
            "passed_test_cases": 2,
            "total_test_cases": 10,
            "mean_time_taken": 0.12714803218841553,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Piles",
            "category": "Introductory Problems",
            "solution": "# Read the number of tests\nt = int(input())\n\nfor _ in range(t):\n    # Read the number of coins in the left pile a and the right pile b\n    a, b = map(int, input().split())\n\n    # If a is equal to b, print \"YES\"\n    if a == b:\n        print(\"YES\")\n    else:\n        # Swap a and b if a is greater than b\n        if a > b:\n            a, b = b, a\n\n        # If a is odd, print \"NO\"\n        if a % 2 != 0:\n            print(\"NO\")\n        else:\n            # Otherwise, print \"YES\"\n            print(\"YES\")\n",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 0.25902827580769855,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Collecting Numbers",
            "category": "Sorting and Searching",
            "solution": "# Read the input\nn = int(input())\nnums = list(map(int, input().split()))\n\n# Initialize variables\ncurrent_num = 1\nrounds = 0\n\n# Iterate through the array\nfor i in range(n):\n    # If we find the current number, increment it\n    if nums[i] == current_num:\n        current_num += 1\n        # If we've reached the end of the sequence, increment the round count and reset the current number\n        if current_num > n:\n            rounds += 1\n            current_num = 1\n\n# Print the result\nprint(rounds)\n",
            "passed_test_cases": 1,
            "total_test_cases": 4,
            "mean_time_taken": 0.153448224067688,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Collecting Numbers II",
            "category": "Sorting and Searching",
            "solution": "def solve():\n    n, m = map(int, input().split())\n    arr = list(map(int, input().split()))\n    pos = [0] * (n + 1)\n    for i in range(n):\n        pos[arr[i]] = i\n    correct = [0] * (n + 1)\n    for i in range(1, n + 1):\n        if pos[i] == i - 1:\n            correct[i] = correct[i - 1] + 1\n        else:\n            correct[i] = correct[i - 1]\n    for _ in range(m):\n        a, b = map(int, input().split())\n        arr[a - 1], arr[b - 1] = arr[b - 1], arr[a - 1]\n        pos[arr[a - 1]] = a - 1\n        pos[arr[b - 1]] = b - 1\n        new_correct = correct[max(pos[a], pos[b])]\n        if pos[a] < pos[b]:\n            for i in range(pos[a] + 1, pos[b]):\n                if arr[i] == i + 1:\n                    new_correct += 1\n        print(n - new_correct)\n\nsolve()\n",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.8082766532897949,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Common Divisors",
            "category": "Mathematics",
            "solution": "def gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef max_gcd(numbers):\n    max_gcd = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            current_gcd = gcd(numbers[i], numbers[j])\n            if current_gcd > max_gcd:\n                max_gcd = current_gcd\n    return max_gcd\n\nn = int(input())\nnumbers = list(map(int, input().split()))\nprint(max_gcd(numbers))\n",
            "passed_test_cases": 8,
            "total_test_cases": 17,
            "mean_time_taken": 0.6084246214698342,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                5,
                6,
                7,
                9,
                11,
                14,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Company Queries I",
            "category": "Tree Algorithms",
            "solution": "# Read input\nn, q = map(int, input().split())\nbosses = list(map(int, input().split()))\nqueries = [list(map(int, input().split())) for _ in range(q)]\n\n# Function to find the boss k levels up\ndef find_boss(employee, k):\n    while k > 0 and employee != -1:\n        employee = bosses[employee - 1]\n        k -= 1\n    return employee\n\n# Process queries\nfor query in queries:\n    employee, k = query\n    boss = find_boss(employee, k)\n    print(boss)\n",
            "passed_test_cases": 0,
            "total_test_cases": 13,
            "mean_time_taken": 0.5241702336531419,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CompanyQueriesI_shot_1.py\", line 16, in <module>\n    boss = find_boss(employee, k)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CompanyQueriesI_shot_1.py\", line 9, in find_boss\n    employee = bosses[employee - 1]\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CompanyQueriesI_shot_1.py\", line 16, in <module>\n    boss = find_boss(employee, k)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CompanyQueriesI_shot_1.py\", line 9, in find_boss\n    employee = bosses[employee - 1]\nIndexError: list index out of range\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CompanyQueriesI_shot_1.py\", line 16, in <module>\n    boss = find_boss(employee, k)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CompanyQueriesI_shot_1.py\", line 9, in find_boss\n    employee = bosses[employee - 1]\nIndexError: list index out of range\n",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CompanyQueriesI_shot_1.py\", line 16, in <module>\n    boss = find_boss(employee, k)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CompanyQueriesI_shot_1.py\", line 9, in find_boss\n    employee = bosses[employee - 1]\nIndexError: list index out of range\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CompanyQueriesI_shot_1.py\", line 16, in <module>\n    boss = find_boss(employee, k)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CompanyQueriesI_shot_1.py\", line 9, in find_boss\n    employee = bosses[employee - 1]\nIndexError: list index out of range\n",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CompanyQueriesI_shot_1.py\", line 16, in <module>\n    boss = find_boss(employee, k)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CompanyQueriesI_shot_1.py\", line 9, in find_boss\n    employee = bosses[employee - 1]\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CompanyQueriesI_shot_1.py\", line 16, in <module>\n    boss = find_boss(employee, k)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CompanyQueriesI_shot_1.py\", line 9, in find_boss\n    employee = bosses[employee - 1]\nIndexError: list index out of range\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Company Queries II",
            "category": "Tree Algorithms",
            "solution": "def dfs(node, parent, depth, graph, parent_array, depth_array):\n    parent_array[node] = parent\n    depth_array[node] = depth\n    for child in graph[node]:\n        if child != parent:\n            dfs(child, node, depth + 1, graph, parent_array, depth_array)\n\ndef find_root(node, parent_array):\n    if parent_array[node] == node:\n        return node\n    parent_array[node] = find_root(parent_array[node], parent_array)\n    return parent_array[node]\n\ndef compress_paths(a, b, parent_array, depth_array):\n    root_a = find_root(a, parent_array)\n    root_b = find_root(b, parent_array)\n    if depth_array[root_a] > depth_array[root_b]:\n        parent_array[root_b] = root_a\n    else:\n        parent_array[root_a] = root_b\n        if depth_array[root_a] == depth_array[root_b]:\n            depth_array[root_b] += 1\n    return root_a if depth_array[root_a] > depth_array[root_b] else root_b\n\nn, q = map(int, input().split())\ngraph = [[] for _ in range(n + 1)]\nfor i in range(2, n + 1):\n    parent = int(input())\n    graph[i].append(parent)\n    graph[parent].append(i)\n\nparent_array = [i for i in range(n + 1)]\ndepth_array = [0 for _ in range(n + 1)]\ndfs(1, 1, 0, graph, parent_array, depth_array)\n\nfor _ in range(q):\n    a, b = map(int, input().split())\n    print(compress_paths(a, b, parent_array, depth_array))\n",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.1684091885884603,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CompanyQueriesII_shot_1.py\", line 28, in <module>\n    parent = int(input())\nValueError: invalid literal for int() with base 10: '1 2 3 4 5 6 7 8 9'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CompanyQueriesII_shot_1.py\", line 28, in <module>\n    parent = int(input())\nValueError: invalid literal for int() with base 10: '1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CompanyQueriesII_shot_1.py\", line 28, in <module>\n    parent = int(input())\nValueError: invalid literal for int() with base 10: '1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 34 68 69 7\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CompanyQueriesII_shot_1.py\", line 28, in <module>\n    parent = int(input())\nValueError: invalid literal for int() with base 10: '1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 7\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CompanyQueriesII_shot_1.py\", line 28, in <module>\n    parent = int(input())\nValueError: invalid literal for int() with base 10: '1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 7\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CompanyQueriesII_shot_1.py\", line 28, in <module>\n    parent = int(input())\nValueError: invalid literal for int() with base 10: '1 1 3 1 2 2 5 3 9'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CompanyQueriesII_shot_1.py\", line 28, in <module>\n    parent = int(input())\nValueError: invalid literal for int() with base 10: '1 2 1 2 3 2 1 6 3 1 10 12 13 4 13 16 17 16 6 14 6 10 7 21 22 12 6 2 20 23 23 10 19 21 20 27 31 32 3 24 31 8 9 10 31 17 27 34 16 44 28 14 50 33 28 43 24 47 12 30 4 56 29 43 50 15 37 61 43 24 34 64 48 \n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CompanyQueriesII_shot_1.py\", line 28, in <module>\n    parent = int(input())\nValueError: invalid literal for int() with base 10: '1 1 1 1 1 1 1 1 1'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CompanyQueriesII_shot_1.py\", line 28, in <module>\n    parent = int(input())\nValueError: invalid literal for int() with base 10: '1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CompanyQueriesII_shot_1.py\", line 28, in <module>\n    parent = int(input())\nValueError: invalid literal for int() with base 10: '1 1 1 1 2 3 4 4 1'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CompanyQueriesII_shot_1.py\", line 28, in <module>\n    parent = int(input())\nValueError: invalid literal for int() with base 10: '1 2 3 2 5 3 2 2 4'\n",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Concert Tickets",
            "category": "Sorting and Searching",
            "solution": "import sys\ninput = sys.stdin.readline\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef insert(root, val):\n    if root is None:\n        return Node(val)\n    if val < root.val:\n        root.left = insert(root.left, val)\n    else:\n        root.right = insert(root.right, val)\n    return root\n\ndef find_closest(root, target):\n    if root is None:\n        return -1\n    if root.val == target:\n        return root.val\n    if root.val > target:\n        return find_closest(root.left, target)\n    closest = find_closest(root.right, target)\n    if closest == -1:\n        return root.val\n    return closest\n\ndef remove(root, val):\n    if root is None:\n        return root\n    if val < root.val:\n        root.left = remove(root.left, val)\n    elif val > root.val:\n        root.right = remove(root.right, val)\n    else:\n        if root.left is None:\n            return root.right\n        elif root.right is None:\n            return root.left\n        root.val = find_min(root.right)\n        root.right = remove(root.right, root.val)\n    return root\n\ndef find_min(root):\n    while root.left is not None:\n        root = root.left\n    return root.val\n\nn, m = map(int, input().split())\ntickets = list(map(int, input().split()))\nroot = None\nfor ticket in tickets:\n    root = insert(root, ticket)\nprices = list(map(int, input().split()))\nfor price in prices:\n    ticket = find_closest(root, price)\n    print(ticket)\n    if ticket != -1:\n        root = remove(root, ticket)\n",
            "passed_test_cases": 5,
            "total_test_cases": 11,
            "mean_time_taken": 0.42084613713351166,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ConcertTickets_shot_1.py\", line 56, in <module>\n    root = insert(root, ticket)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ConcertTickets_shot_1.py\", line 16, in insert\n    root.right = insert(root.right, val)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ConcertTickets_shot_1.py\", line 16, in insert\n    root.right = insert(root.right, val)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ConcertTickets_shot_1.py\", line 16, in insert\n    root.right = insert(root.right, val)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ConcertTickets_shot_1.py\", line 12, in insert\n    return Node(val)\nRecursionError: maximum recursion depth exceeded\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ConcertTickets_shot_1.py\", line 56, in <module>\n    root = insert(root, ticket)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ConcertTickets_shot_1.py\", line 16, in insert\n    root.right = insert(root.right, val)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ConcertTickets_shot_1.py\", line 16, in insert\n    root.right = insert(root.right, val)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ConcertTickets_shot_1.py\", line 16, in insert\n    root.right = insert(root.right, val)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ConcertTickets_shot_1.py\", line 12, in insert\n    return Node(val)\nRecursionError: maximum recursion depth exceeded\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ConcertTickets_shot_1.py\", line 56, in <module>\n    root = insert(root, ticket)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ConcertTickets_shot_1.py\", line 16, in insert\n    root.right = insert(root.right, val)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ConcertTickets_shot_1.py\", line 16, in insert\n    root.right = insert(root.right, val)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ConcertTickets_shot_1.py\", line 16, in insert\n    root.right = insert(root.right, val)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ConcertTickets_shot_1.py\", line 12, in insert\n    return Node(val)\nRecursionError: maximum recursion depth exceeded\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ConcertTickets_shot_1.py\", line 56, in <module>\n    root = insert(root, ticket)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ConcertTickets_shot_1.py\", line 14, in insert\n    root.left = insert(root.left, val)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ConcertTickets_shot_1.py\", line 16, in insert\n    root.right = insert(root.right, val)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ConcertTickets_shot_1.py\", line 14, in insert\n    root.left = insert(root.left, val)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ConcertTickets_shot_1.py\", line 16, in insert\n    root.right = insert(root.right, val)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ConcertTickets_shot_1.py\", line 14, in insert\n    root.left = insert(root.left, val)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ConcertTickets_shot_1.py\", line 14, in insert\n    root.left = insert(root.left, val)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ConcertTickets_shot_1.py\", line 14, in insert\n    root.left = insert(root.left, val)\n  [Previous line repeated 989 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ConcertTickets_shot_1.py\", line 16, in insert\n    root.right = insert(root.right, val)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ConcertTickets_shot_1.py\", line 12, in insert\n    return Node(val)\nRecursionError: maximum recursion depth exceeded\n",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                6,
                8,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Convex Hull",
            "category": "Geometry",
            "solution": "import sys\n\ndef cross(p1, p2, p3):\n    return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\ndef convex_hull(points):\n    n = len(points)\n    if n <= 3:\n        return points\n\n    # Sort points lexicographically\n    points.sort()\n\n    # Initialize empty lists for upper and lower hulls\n    lower = []\n    upper = []\n\n    # Process points\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) >= 0:\n            upper.pop()\n        lower.append(p)\n        upper.append(p)\n\n    # Concatenate lower and upper hulls and remove duplicates\n    hull = lower[:-1] + upper[:-1]\n    return hull\n\n# Read input\nn = int(sys.stdin.readline().strip())\npoints = []\nfor _ in range(n):\n    x, y = map(int, sys.stdin.readline().strip().split())\n    points.append((x, y))\n\n# Compute convex hull\nhull = convex_hull(points)\n\n# Print output\nprint(len(hull))\nfor p in hull:\n    print(*p)\n",
            "passed_test_cases": 0,
            "total_test_cases": 9,
            "mean_time_taken": 0.25338029861450195,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Bishops",
            "category": "Additional Problems",
            "solution": "MOD = 10**9 + 7\n\ndef count_bishops(n, k):\n    dp = [[0] * (k + 1) for _ in range(2 * n)]\n    dp[0][0] = 1\n    for i in range(1, 2 * n):\n        for j in range(1, k + 1):\n            dp[i][j] = dp[i - 1][j] + i * dp[i - 1][j - 1]\n            dp[i][j] %= MOD\n    return dp[2 * n - 1][k]\n\nn, k = map(int, input().split())\nprint(count_bishops(n, k))\n",
            "passed_test_cases": 2,
            "total_test_cases": 13,
            "mean_time_taken": 0.17222965680635893,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingBishops_shot_1.py\", line 13, in <module>\n    print(count_bishops(n, k))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingBishops_shot_1.py\", line 4, in count_bishops\n    dp = [[0] * (k + 1) for _ in range(2 * n)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingBishops_shot_1.py\", line 4, in <listcomp>\n    dp = [[0] * (k + 1) for _ in range(2 * n)]\nMemoryError\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Bits",
            "category": "Additional Problems",
            "solution": "# Read the input\nn = int(input())\n\n# Initialize the dp array\ndp = [0] * (n + 1)\n\n# Iterate over all numbers from 1 to n\nfor i in range(1, n + 1):\n    # If i is even, then the number of '1' bits in the binary representation of i is the same as the number of '1' bits in the binary representation of i/2\n    if i % 2 == 0:\n        dp[i] = dp[i // 2]\n    # If i is odd, then the number of '1' bits in the binary representation of i is one more than the number of '1' bits in the binary representation of i/2\n    else:\n        dp[i] = dp[i // 2] + 1\n\n# Print the result\nprint(dp[n])\n",
            "passed_test_cases": 1,
            "total_test_cases": 21,
            "mean_time_taken": 0.13430660111563547,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingBits_shot_1.py\", line 5, in <module>\n    dp = [0] * (n + 1)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingBits_shot_1.py\", line 5, in <module>\n    dp = [0] * (n + 1)\nMemoryError\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingBits_shot_1.py\", line 5, in <module>\n    dp = [0] * (n + 1)\nMemoryError\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingBits_shot_1.py\", line 5, in <module>\n    dp = [0] * (n + 1)\nMemoryError\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingBits_shot_1.py\", line 5, in <module>\n    dp = [0] * (n + 1)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingBits_shot_1.py\", line 5, in <module>\n    dp = [0] * (n + 1)\nMemoryError\n",
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingBits_shot_1.py\", line 5, in <module>\n    dp = [0] * (n + 1)\nMemoryError\n",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingBits_shot_1.py\", line 5, in <module>\n    dp = [0] * (n + 1)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingBits_shot_1.py\", line 5, in <module>\n    dp = [0] * (n + 1)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingBits_shot_1.py\", line 5, in <module>\n    dp = [0] * (n + 1)\nMemoryError\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingBits_shot_1.py\", line 5, in <module>\n    dp = [0] * (n + 1)\nMemoryError\n"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Coprime Pairs",
            "category": "Mathematics",
            "solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef count_coprime_pairs(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if gcd(nums[i], nums[j]) == 1:\n                count += 1\n    return count\n\nif __name__ == \"__main__\":\n    n = int(input())\n    nums = list(map(int, input().split()))\n    print(count_coprime_pairs(nums))\n",
            "passed_test_cases": 2,
            "total_test_cases": 8,
            "mean_time_taken": 0.8177129030227661,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Divisors",
            "category": "Mathematics",
            "solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If divisors are equal, count only once.\n            if i == n//i:\n                count += 1\n            else:\n                # Otherwise, count both.\n                count += 2\n    return count\n\nn = int(input())\nfor _ in range(n):\n    x = int(input())\n    print(count_divisors(x))\n",
            "passed_test_cases": 5,
            "total_test_cases": 16,
            "mean_time_taken": 0.7594374269247055,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                9,
                11,
                13,
                14,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Grids",
            "category": "Mathematics",
            "solution": "import math\n\nMOD = 10**9 + 7\n\ndef burnside(n):\n    # Calculate the number of fixed points for each rotation\n    total = 0\n    for d in range(1, n+1):\n        if n % d != 0:\n            continue\n        g = n // d\n        total += (2**(d*g + (d-1)*(g-1)) * math.gcd(n, d)) % MOD\n    return total % MOD\n\nn = int(input())\nprint(burnside(n))\n",
            "passed_test_cases": 1,
            "total_test_cases": 12,
            "mean_time_taken": 0.34565043449401855,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Necklaces",
            "category": "Mathematics",
            "solution": "import math\nMOD = 10**9 + 7\n\ndef power(a, b):\n    result = 1\n    while b > 0:\n        if b % 2:\n            result = (result * a) % MOD\n        a = (a * a) % MOD\n        b //= 2\n    return result\n\ndef count_necklaces(n, m):\n    result = 0\n    for k in range(1, n + 1):\n        if math.gcd(n, k) == 1:\n            result = (result + power(m, k)) % MOD\n    return result * power(n, MOD - 2) % MOD\n\nn, m = map(int, input().split())\nprint(count_necklaces(n, m))\n",
            "passed_test_cases": 2,
            "total_test_cases": 10,
            "mean_time_taken": 0.29134702682495117,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Numbers",
            "category": "Dynamic Programming",
            "solution": "MOD = 10**9 + 7\n\ndef count_numbers(n, last_digit, tight, dp):\n    if n == 0:\n        return 1 if last_digit == -1 else 0\n\n    if dp[n][last_digit][tight] != -1:\n        return dp[n][last_digit][tight]\n\n    count = 0\n    limit = 9 if tight else 10\n    for digit in range(limit):\n        if digit != last_digit:\n            count += count_numbers(n - 1, digit, tight and digit == limit - 1, dp)\n        count %= MOD\n\n    dp[n][last_digit][tight] = count\n    return count\n\ndef solve(a, b):\n    dp = [[[-1 for _ in range(2)] for _ in range(11)] for _ in range(19)]\n    ans = count_numbers(18, -1, False, dp)\n    ans -= count_numbers(18, -1, True, dp)\n\n    a_str = str(a)\n    b_str = str(b)\n    for i in range(1, 19):\n        if i < len(a_str):\n            ans -= count_numbers(i - 1, -1, True, dp) * (9 - int(a_str[i]))\n        if i < len(b_str):\n            ans += count_numbers(i - 1, -1, True, dp) * (1 + int(b_str[i]))\n\n    for i in range(len(a_str)):\n        ans += count_numbers(len(a_str) - 1 - i, int(a_str[i]), True, dp)\n\n    for i in range(len(b_str)):\n        ans -= count_numbers(len(b_str) - 1 - i, int(b_str[i]), True, dp)\n\n    ans %= MOD\n    if ans < 0:\n        ans += MOD\n\n    return int(ans)\n\na, b = map(int, input().split())\nprint(solve(a, b))\n",
            "passed_test_cases": 0,
            "total_test_cases": 16,
            "mean_time_taken": 0.12483629584312439,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Paths",
            "category": "Tree Algorithms",
            "solution": "def read_input():\n    n, m = map(int, input().split())\n    edges = [list(map(int, input().split())) for _ in range(n-1)]\n    paths = [list(map(int, input().split())) for _ in range(m)]\n    return n, m, edges, paths\n\ndef build_tree(n, edges):\n    tree = [[] for _ in range(n)]\n    for a, b in edges:\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    return tree\n\ndef dfs_subtree_sizes(tree, parent, node, subtree_sizes):\n    subtree_sizes[node] = 1\n    for child in tree[node]:\n        if child != parent:\n            subtree_sizes[node] += dfs_subtree_sizes(tree, node, child, subtree_sizes)\n    return subtree_sizes[node]\n\ndef dfs_lca(tree, parent, node, a, b, lca):\n    if node == a or node == b:\n        return node\n    for child in tree[node]:\n        if child != parent:\n            result = dfs_lca(tree, node, child, a, b, lca)\n            if result != -1:\n                lca[node] = result\n                return result\n    return -1\n\ndef count_paths(n, m, paths, tree, subtree_sizes, lca):\n    paths_count = [0] * n\n    for a, b in paths:\n        a, b = a-1, b-1\n        lca[a] = -1\n        lca[b] = -1\n        dfs_lca(tree, -1, 0, a, b, lca)\n        lca_node = lca[a]\n        if lca_node == -1:\n            lca_node = a\n        for node in range(n):\n            if node != lca_node:\n                paths_count[node] += subtree_sizes[a] * subtree_sizes[b]\n            else:\n                paths_count[node] += subtree_sizes[a] * subtree_sizes[b] - subtree_sizes[node]\n    return paths_count\n\ndef solve():\n    n, m, edges, paths = read_input()\n    tree = build_tree(n, edges)\n    subtree_sizes = [0] * n\n    dfs_subtree_sizes(tree, -1, 0, subtree_sizes)\n    lca = [-1] * n\n    paths_count = count_paths(n, m, paths, tree, subtree_sizes, lca)\n    print(*paths_count)\n\nsolve()\n",
            "passed_test_cases": 0,
            "total_test_cases": 13,
            "mean_time_taken": 0.4849706796499399,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 58, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 53, in solve\n    dfs_subtree_sizes(tree, -1, 0, subtree_sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 18, in dfs_subtree_sizes\n    subtree_sizes[node] += dfs_subtree_sizes(tree, node, child, subtree_sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 18, in dfs_subtree_sizes\n    subtree_sizes[node] += dfs_subtree_sizes(tree, node, child, subtree_sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 18, in dfs_subtree_sizes\n    subtree_sizes[node] += dfs_subtree_sizes(tree, node, child, subtree_sizes)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 17, in dfs_subtree_sizes\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 58, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 53, in solve\n    dfs_subtree_sizes(tree, -1, 0, subtree_sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 18, in dfs_subtree_sizes\n    subtree_sizes[node] += dfs_subtree_sizes(tree, node, child, subtree_sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 18, in dfs_subtree_sizes\n    subtree_sizes[node] += dfs_subtree_sizes(tree, node, child, subtree_sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 18, in dfs_subtree_sizes\n    subtree_sizes[node] += dfs_subtree_sizes(tree, node, child, subtree_sizes)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 17, in dfs_subtree_sizes\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 58, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 53, in solve\n    dfs_subtree_sizes(tree, -1, 0, subtree_sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 18, in dfs_subtree_sizes\n    subtree_sizes[node] += dfs_subtree_sizes(tree, node, child, subtree_sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 18, in dfs_subtree_sizes\n    subtree_sizes[node] += dfs_subtree_sizes(tree, node, child, subtree_sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 18, in dfs_subtree_sizes\n    subtree_sizes[node] += dfs_subtree_sizes(tree, node, child, subtree_sizes)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 17, in dfs_subtree_sizes\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 58, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 53, in solve\n    dfs_subtree_sizes(tree, -1, 0, subtree_sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 18, in dfs_subtree_sizes\n    subtree_sizes[node] += dfs_subtree_sizes(tree, node, child, subtree_sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 18, in dfs_subtree_sizes\n    subtree_sizes[node] += dfs_subtree_sizes(tree, node, child, subtree_sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 18, in dfs_subtree_sizes\n    subtree_sizes[node] += dfs_subtree_sizes(tree, node, child, subtree_sizes)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 17, in dfs_subtree_sizes\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 58, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 53, in solve\n    dfs_subtree_sizes(tree, -1, 0, subtree_sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 18, in dfs_subtree_sizes\n    subtree_sizes[node] += dfs_subtree_sizes(tree, node, child, subtree_sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 18, in dfs_subtree_sizes\n    subtree_sizes[node] += dfs_subtree_sizes(tree, node, child, subtree_sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 18, in dfs_subtree_sizes\n    subtree_sizes[node] += dfs_subtree_sizes(tree, node, child, subtree_sizes)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 17, in dfs_subtree_sizes\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 58, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 53, in solve\n    dfs_subtree_sizes(tree, -1, 0, subtree_sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 18, in dfs_subtree_sizes\n    subtree_sizes[node] += dfs_subtree_sizes(tree, node, child, subtree_sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 18, in dfs_subtree_sizes\n    subtree_sizes[node] += dfs_subtree_sizes(tree, node, child, subtree_sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 18, in dfs_subtree_sizes\n    subtree_sizes[node] += dfs_subtree_sizes(tree, node, child, subtree_sizes)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingPaths_shot_1.py\", line 17, in dfs_subtree_sizes\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Patterns",
            "category": "String Algorithms",
            "solution": "# Read the input string and the number of patterns\ns = input().strip()\nk = int(input().strip())\n\n# Read each pattern and store them in a list\npatterns = [input().strip() for _ in range(k)]\n\n# For each pattern, count the number of times it appears in the string\nfor pattern in patterns:\n    count = 0\n    i = 0\n    while i <= len(s) - len(pattern):\n        if s[i:i + len(pattern)] == pattern:\n            count += 1\n        i += 1\n    print(count)\n",
            "passed_test_cases": 3,
            "total_test_cases": 11,
            "mean_time_taken": 0.7971503301100298,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                7,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Reorders",
            "category": "Additional Problems",
            "solution": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\ndef solve():\n    s = input().strip()\n    n = len(s)\n    count = [0] * 26\n    dp = [[0] * 26 for _ in range(n)]\n    for i in range(n):\n        count[ord(s[i]) - ord('a')] += 1\n    for j in range(26):\n        dp[0][j] = 1 if count[j] > 0 else 0\n    for i in range(1, n):\n        for j in range(26):\n            if count[j] == 0:\n                continue\n            for k in range(26):\n                if k != j:\n                    dp[i][j] += dp[i-1][k]\n                    dp[i][j] %= MOD\n    ans = 0\n    for j in range(26):\n        ans += dp[n-1][j]\n        ans %= MOD\n    print(ans)\n\nsolve()\n",
            "passed_test_cases": 1,
            "total_test_cases": 9,
            "mean_time_taken": 0.20674731996324328,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Rooms",
            "category": "Graph Algorithms",
            "solution": "def dfs(x, y, grid):\n    if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == '#':\n        return\n    grid[x][y] = '#'\n    dfs(x+1, y, grid)\n    dfs(x-1, y, grid)\n    dfs(x, y+1, grid)\n    dfs(x, y-1, grid)\n\ndef count_rooms(grid):\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '.':\n                dfs(i, j, grid)\n                count += 1\n    return count\n\ndef main():\n    n, m = map(int, input().split())\n    grid = []\n    for _ in range(n):\n        grid.append(list(input()))\n    print(count_rooms(grid))\n\nif __name__ == \"__main__\":\n    main()\n",
            "passed_test_cases": 13,
            "total_test_cases": 19,
            "mean_time_taken": 0.16165898975573087,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 27, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 24, in main\n    print(count_rooms(grid))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 15, in count_rooms\n    dfs(i, j, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 993 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 2, in dfs\n    if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == '#':\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 27, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 24, in main\n    print(count_rooms(grid))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 15, in count_rooms\n    dfs(i, j, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 993 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 2, in dfs\n    if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == '#':\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 27, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 24, in main\n    print(count_rooms(grid))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 15, in count_rooms\n    dfs(i, j, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  [Previous line repeated 992 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 2, in dfs\n    if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == '#':\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 27, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 24, in main\n    print(count_rooms(grid))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 15, in count_rooms\n    dfs(i, j, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 993 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 2, in dfs\n    if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == '#':\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 27, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 24, in main\n    print(count_rooms(grid))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 15, in count_rooms\n    dfs(i, j, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 4 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  [Previous line repeated 1 more time]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 5 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 13 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 5 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 1 more time]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 5 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 8 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 6 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 1 more time]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  [Previous line repeated 5 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  [Previous line repeated 2 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 2 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  [Previous line repeated 7 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  [Previous line repeated 7 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 2 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  [Previous line repeated 10 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 1 more time]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 11 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  [Previous line repeated 1 more time]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 4 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 2 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 1 more time]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  [Previous line repeated 6 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 8 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 5 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 3 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 8 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 2 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 3 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 2 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 7 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  [Previous line repeated 7 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 2 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 3 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 2 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  [Previous line repeated 4 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 1 more time]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 5 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 3 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 3 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 2 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 7 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 13 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  [Previous line repeated 4 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 1 more time]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 3 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  [Previous line repeated 7 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 2 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 2 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 4 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 1 more time]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  [Previous line repeated 4 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 2 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 2 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 2 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 1 more time]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 5 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  [Previous line repeated 1 more time]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  [Previous line repeated 2 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  [Previous line repeated 3 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 2 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  [Previous line repeated 4 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  [Previous line repeated 1 more time]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 2 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 2 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 5 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 4 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 5 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 1 more time]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 1 more time]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 1 more time]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 4 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 7 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 3 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 2 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 5 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 4 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 1 more time]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 1 more time]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 8, in dfs\n    dfs(x, y-1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 4 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 6, in dfs\n    dfs(x-1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 7, in dfs\n    dfs(x, y+1, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 2, in dfs\n    if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == '#':\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 27, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 24, in main\n    print(count_rooms(grid))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 15, in count_rooms\n    dfs(i, j, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 5, in dfs\n    dfs(x+1, y, grid)\n  [Previous line repeated 993 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CountingRooms_shot_1.py\", line 2, in dfs\n    if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == '#':\nRecursionError: maximum recursion depth exceeded in comparison\n"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                7,
                8,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Sequences",
            "category": "Additional Problems",
            "solution": "def count_sequences(n, k):\n    MOD = 10**9 + 7\n    fact = [1] * (n+1)\n    inv = [1] * (n+1)\n    for i in range(2, n+1):\n        fact[i] = fact[i-1] * i % MOD\n        inv[i] = pow(fact[i], MOD-2, MOD)\n\n    def choose(n, k):\n        if k > n:\n            return 0\n        return fact[n] * inv[k] * inv[n-k] % MOD\n\n    result = choose(n, k) * k % MOD\n    for i in range(1, k):\n        result = (result - choose(k, i) * choose(n, k-i) * fact[k-i] % MOD * pow(k-i, n-(k-i), MOD) % MOD) % MOD\n    return result % MOD\n\nn, k = map(int, input().split())\nprint(count_sequences(n, k))\n",
            "passed_test_cases": 1,
            "total_test_cases": 10,
            "mean_time_taken": 0.2999570369720459,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Tilings",
            "category": "Dynamic Programming",
            "solution": "# Import necessary libraries\nimport sys\n\n# Define the modulo value\nMOD = 10**9 + 7\n\n# Read the input\nn, m = map(int, sys.stdin.readline().split())\n\n# Initialize a 2D array to store the number of ways to tile a grid of size i x j\ndp = [[0] * (m+1) for _ in range(n+1)]\n\n# Base cases: dp[i][0] = 0, dp[i][1] = 1 for all i\nfor i in range(n+1):\n    dp[i][0] = 0\n    dp[i][1] = 1\n\n# Base cases: dp[0][j] = 0, dp[1][j] = 1 for all j\nfor j in range(m+1):\n    dp[0][j] = 0\n    dp[1][j] = 1\n\n# Calculate the number of ways to tile a grid of size i x j for all i and j\nfor i in range(2, n+1):\n    for j in range(2, m+1):\n        dp[i][j] = (dp[i][j-1] + dp[i-1][j] + dp[i][j-2] - dp[i-1][j-2]) % MOD\n\n# Print the result\nprint(dp[n][m])\n",
            "passed_test_cases": 3,
            "total_test_cases": 15,
            "mean_time_taken": 0.1205453872680664,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                11,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Towers",
            "category": "Dynamic Programming",
            "solution": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\nMAXN = 10**6 + 5\n\nfact = [0]*MAXN\ninv = [0]*MAXN\nfact[0] = inv[0] = 1\nfor i in range(1, MAXN):\n    fact[i] = fact[i-1] * i % MOD\n    inv[i] = pow(fact[i], MOD-2, MOD)\n\ndef C(n, k):\n    if k > n:\n        return 0\n    return fact[n] * inv[k] * inv[n-k] % MOD\n\ndef mul(a, b):\n    n = len(a)\n    m = (n-1) * 2\n    a += [0] * (m - len(a))\n    b += [0] * (m - len(b))\n    assert len(a) == m\n    assert len(b) == m\n\n    x = a[::2] + a[1::2]\n    y = b[::2] + b[1::2]\n    a, b = dft(x), dft(y)\n    for i in range(m):\n        a[i] = a[i] * b[i] % MOD\n    a = idft(a)\n    for i in range(n):\n        a[i] = a[i] * inv[2] % MOD\n    return a[:n]\n\ndef dft(a):\n    n = len(a)\n    if n == 1:\n        return a\n    a0 = a[::2]\n    a1 = a[1::2]\n    y0 = dft(a0)\n    y1 = dft(a1)\n    for i in range(n//2):\n        t = complex(y1[i] * (modpow(5, MOD-2, MOD) ** (2*i)) % MOD, 0)\n        a[i] = (y0[i] + t) % MOD\n        a[i + n//2] = (y0[i] - t + MOD) % MOD\n    return a\n\ndef idft(a):\n    n = len(a)\n    a = [x.conjugate() for x in a]\n    a = dft(a)\n    inv = pow(n, MOD-2, MOD)\n    return [x * inv % MOD for x in a]\n\ndef modpow(a, b, m):\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = res * a % m\n        a = a * a % m\n        b >>= 1\n    return res\n\ndef solve(n):\n    dp = [0]*(n+1)\n    dp[0] = 1\n    dp[1] = 2\n    for i in range(2, n+1):\n        dp[i] = sum(dp[j] * dp[i-j] * C(i, j) % MOD for j in range(1, i)) % MOD\n        dp[i] = (dp[i] + 2) % MOD\n    return dp[n]\n\nt = int(input().strip())\nfor _ in range(t):\n    n = int(input().strip())\n    print(solve(n))\n",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 1.0576161742210388,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Course Schedule",
            "category": "Graph Algorithms",
            "solution": "def course_schedule(n, m, requirements):\n    graph = {i: [] for i in range(1, n + 1)}\n    indegree = {i: 0 for i in range(1, n + 1)}\n\n    for a, b in requirements:\n        graph[a].append(b)\n        indegree[b] += 1\n\n    queue = [i for i in range(1, n + 1) if indegree[i] == 0]\n    result = []\n\n    while queue:\n        node = queue.pop(0)\n        result.append(node)\n\n        for neighbor in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n\n    if len(result) == n:\n        return result\n    else:\n        return \"IMPOSSIBLE\"\n",
            "passed_test_cases": 0,
            "total_test_cases": 16,
            "mean_time_taken": 0.1284700334072113,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Course Schedule II",
            "category": "Additional Problems",
            "solution": "from collections import deque\n\ndef course_schedule(n, m, requirements):\n    # Create an empty graph\n    graph = {i: [] for i in range(1, n + 1)}\n\n    # Create a dictionary to store the incoming edges for each node\n    incoming_edges = {i: 0 for i in range(1, n + 1)}\n\n    # Fill the graph and incoming edges dictionary with the requirements\n    for a, b in requirements:\n        graph[a].append(b)\n        incoming_edges[b] += 1\n\n    # Create a queue and add all nodes with no incoming edges\n    queue = deque([i for i in range(1, n + 1) if incoming_edges[i] == 0])\n\n    # Create a list to store the order of courses\n    order = []\n\n    # Process the queue\n    while queue:\n        # Remove a node from the queue\n        node = queue.popleft()\n\n        # Add the node to the order\n        order.append(node)\n\n        # Remove the outgoing edges of the node\n        for neighbor in graph[node]:\n            incoming_edges[neighbor] -= 1\n\n            # If a node has no incoming edges, add it to the queue\n            if incoming_edges[neighbor] == 0:\n                queue.append(neighbor)\n\n    return order\n\n# Test the function\nn, m = 4, 2\nrequirements = [(2, 1), (2, 3)]\nprint(course_schedule(n, m, requirements))\n",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.12255880236625671,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Creating Offices",
            "category": "Additional Problems",
            "solution": "def dfs(node, parent, depth, d, graph):\n    if depth >= d:\n        offices.add(node)\n    for child in graph[node]:\n        if child != parent:\n            dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n\nn, d = map(int, input().split())\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\noffices = set()\ndfs(1, -1, 0, d, graph)\n\nprint(len(offices))\nprint(*sorted(offices))\n",
            "passed_test_cases": 0,
            "total_test_cases": 22,
            "mean_time_taken": 0.3073793649673462,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 16, in <module>\n    dfs(1, -1, 0, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 2, in dfs\n    if depth >= d:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 16, in <module>\n    dfs(1, -1, 0, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 2, in dfs\n    if depth >= d:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 16, in <module>\n    dfs(1, -1, 0, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 2, in dfs\n    if depth >= d:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 16, in <module>\n    dfs(1, -1, 0, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 2, in dfs\n    if depth >= d:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 16, in <module>\n    dfs(1, -1, 0, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 2, in dfs\n    if depth >= d:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 16, in <module>\n    dfs(1, -1, 0, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 2, in dfs\n    if depth >= d:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 16, in <module>\n    dfs(1, -1, 0, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 2, in dfs\n    if depth >= d:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 16, in <module>\n    dfs(1, -1, 0, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 2, in dfs\n    if depth >= d:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 16, in <module>\n    dfs(1, -1, 0, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 2, in dfs\n    if depth >= d:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 16, in <module>\n    dfs(1, -1, 0, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1 if depth < d else 1, d, graph)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CreatingOffices_shot_1.py\", line 2, in dfs\n    if depth >= d:\nRecursionError: maximum recursion depth exceeded in comparison\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Creating Strings",
            "category": "Introductory Problems",
            "solution": "import itertools\nimport sys\n\ndef factorial(n):\n    return 1 if n == 0 else n * factorial(n - 1)\n\ndef num_unique_permutations(s):\n    count = [0] * 26\n    for c in s:\n        count[ord(c) - ord('a')] += 1\n    fact = factorial(len(s))\n    for c in count:\n        fact //= factorial(c)\n    return fact\n\ndef solve(s):\n    print(num_unique_permutations(s))\n    for perm in sorted(set(itertools.permutations(s))):\n        print(''.join(perm))\n\nif __name__ == \"__main__\":\n    s = sys.stdin.readline().strip()\n    solve(s)\n",
            "passed_test_cases": 6,
            "total_test_cases": 6,
            "mean_time_taken": 0.1277545690536499,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 5,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Creating Strings II",
            "category": "Mathematics",
            "solution": "MOD = 10**9 + 7\n\ndef factorial(n):\n    res = 1\n    for i in range(2, n + 1):\n        res = (res * i) % MOD\n    return res\n\ndef solve(s):\n    counts = [0] * 26\n    for c in s:\n        counts[ord(c) - ord('a')] += 1\n\n    res = factorial(len(s))\n    for count in counts:\n        res = (res * pow(factorial(count), MOD - 2, MOD)) % MOD\n    return res\n\ns = input().strip()\nprint(solve(s))\n",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.1885903278986613,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Critical Cities",
            "category": "Additional Problems",
            "solution": "def tarjan(node, low, disc, stack, visited, graph):\n    disc[node] = low[node] = idx\n    idx += 1\n    stack.append(node)\n    visited[node] = True\n\n    for neighbour in graph[node]:\n        if disc[neighbour] == -1:\n            tarjan(neighbour, low, disc, stack, visited, graph)\n            low[node] = min(low[node], low[neighbour])\n        elif visited[neighbour]:\n            low[node] = min(low[node], disc[neighbour])\n\n    if low[node] == disc[node]:\n        critical_cities.append(stack.pop(-1))\n\nn, m = map(int, input().split())\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\ndisc = [-1] * (n + 1)\nlow = [-1] * (n + 1)\nvisited = [False] * (n + 1)\nstack = []\nidx = 0\ncritical_cities = []\n\ntarjan(1, low, disc, stack, visited, graph)\nprint(len(critical_cities))\nprint(*sorted(critical_cities))\n",
            "passed_test_cases": 0,
            "total_test_cases": 14,
            "mean_time_taken": 0.23973160130637033,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 30, in <module>\n    tarjan(1, low, disc, stack, visited, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 2, in tarjan\n    disc[node] = low[node] = idx\nUnboundLocalError: local variable 'idx' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 30, in <module>\n    tarjan(1, low, disc, stack, visited, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 2, in tarjan\n    disc[node] = low[node] = idx\nUnboundLocalError: local variable 'idx' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 30, in <module>\n    tarjan(1, low, disc, stack, visited, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 2, in tarjan\n    disc[node] = low[node] = idx\nUnboundLocalError: local variable 'idx' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 30, in <module>\n    tarjan(1, low, disc, stack, visited, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 2, in tarjan\n    disc[node] = low[node] = idx\nUnboundLocalError: local variable 'idx' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 30, in <module>\n    tarjan(1, low, disc, stack, visited, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 2, in tarjan\n    disc[node] = low[node] = idx\nUnboundLocalError: local variable 'idx' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 30, in <module>\n    tarjan(1, low, disc, stack, visited, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 2, in tarjan\n    disc[node] = low[node] = idx\nUnboundLocalError: local variable 'idx' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 30, in <module>\n    tarjan(1, low, disc, stack, visited, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 2, in tarjan\n    disc[node] = low[node] = idx\nUnboundLocalError: local variable 'idx' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 30, in <module>\n    tarjan(1, low, disc, stack, visited, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 2, in tarjan\n    disc[node] = low[node] = idx\nUnboundLocalError: local variable 'idx' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 30, in <module>\n    tarjan(1, low, disc, stack, visited, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 2, in tarjan\n    disc[node] = low[node] = idx\nUnboundLocalError: local variable 'idx' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 30, in <module>\n    tarjan(1, low, disc, stack, visited, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 2, in tarjan\n    disc[node] = low[node] = idx\nUnboundLocalError: local variable 'idx' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 30, in <module>\n    tarjan(1, low, disc, stack, visited, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 2, in tarjan\n    disc[node] = low[node] = idx\nUnboundLocalError: local variable 'idx' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 30, in <module>\n    tarjan(1, low, disc, stack, visited, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 2, in tarjan\n    disc[node] = low[node] = idx\nUnboundLocalError: local variable 'idx' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 30, in <module>\n    tarjan(1, low, disc, stack, visited, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 2, in tarjan\n    disc[node] = low[node] = idx\nUnboundLocalError: local variable 'idx' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 30, in <module>\n    tarjan(1, low, disc, stack, visited, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/CriticalCities_shot_1.py\", line 2, in tarjan\n    disc[node] = low[node] = idx\nUnboundLocalError: local variable 'idx' referenced before assignment\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Cut and Paste",
            "category": "Advanced Techniques",
            "solution": "def cut_and_paste():\n    # Read the input\n    n, m = map(int, input().split())\n    s = list(input())\n    operations = [list(map(int, input().split())) for _ in range(m)]\n\n    # Process the operations\n    for a, b in operations:\n        # Cut the substring from position a to b\n        substring = s[a-1:b]\n        # Remove the substring from the original string\n        del s[a-1:b]\n        # Paste the substring to the end of the string\n        s.extend(substring)\n\n    # Print the final string\n    print(''.join(s))\n\n# Call the function\ncut_and_paste()\n",
            "passed_test_cases": 2,
            "total_test_cases": 7,
            "mean_time_taken": 0.7849358149937221,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Cycle Finding",
            "category": "Graph Algorithms",
            "solution": "import sys\nfrom collections import defaultdict\n\ndef bellman_ford(n, m, edges):\n    dist = [float('inf')] * (n + 1)\n    dist[1] = 0\n    parent = [None] * (n + 1)\n\n    for _ in range(m):\n        for a, b, c in edges:\n            if dist[a] + c < dist[b]:\n                dist[b] = dist[a] + c\n                parent[b] = a\n\n    neg_cycle = None\n    for a, b, c in edges:\n        if dist[a] + c < dist[b]:\n            neg_cycle = b\n            break\n\n    if neg_cycle is None:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        cycle = []\n        node = neg_cycle\n        while node != parent[node]:\n            cycle.append(node)\n            node = parent[node]\n        cycle.append(node)\n        print(*cycle[::-1])\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(m)]\n    bellman_ford(n, m, edges)\n",
            "passed_test_cases": 8,
            "total_test_cases": 27,
            "mean_time_taken": 0.691680766918041,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                11,
                12,
                13,
                14,
                17,
                18,
                19,
                21,
                23,
                24,
                25,
                26
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Cyclic Array",
            "category": "Additional Problems",
            "solution": "n, k = map(int, input().split())\narr = list(map(int, input().split()))\n\nstart = 0\nend = 0\nsum = 0\ncount = 0\n\nwhile end < n:\n    sum += arr[end]\n    while sum > k:\n        sum -= arr[start]\n        start += 1\n        count += 1\n    end += 1\n\nif sum != 0:\n    count += 1\n\nprint(count)\n",
            "passed_test_cases": 7,
            "total_test_cases": 21,
            "mean_time_taken": 0.1324239344823928,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                5,
                7,
                8,
                9,
                10,
                12,
                13,
                14,
                15,
                17,
                18,
                19
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "De Bruijn Sequence",
            "category": "Graph Algorithms",
            "solution": "def de_bruijn(k, n):\n    # Initialize sequence and database\n    seq = []\n    db = {}\n\n    # Recursive function\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                seq.extend(t_seq[:p])\n        else:\n            if t_seq[:t] not in db:\n                db[t_seq[:t]] = 1\n                db(t+1, p)\n            db(t, p-1)\n\n    # Initialize t_seq and call recursive function\n    t_seq = [0] * (n+1)\n    db(1, n)\n\n    # Convert sequence to string and return\n    return ''.join(str(i) for i in seq)\n\n# Read input\nn = int(input())\n\n# Print result\nprint(de_bruijn(2, n))\n",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.15354474385579428,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 28, in <module>\n    print(de_bruijn(2, n))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 19, in de_bruijn\n    db(1, n)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 12, in db\n    if t_seq[:t] not in db:\nTypeError: argument of type 'function' is not iterable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 28, in <module>\n    print(de_bruijn(2, n))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 19, in de_bruijn\n    db(1, n)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 12, in db\n    if t_seq[:t] not in db:\nTypeError: argument of type 'function' is not iterable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 28, in <module>\n    print(de_bruijn(2, n))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 19, in de_bruijn\n    db(1, n)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 12, in db\n    if t_seq[:t] not in db:\nTypeError: argument of type 'function' is not iterable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 28, in <module>\n    print(de_bruijn(2, n))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 19, in de_bruijn\n    db(1, n)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 12, in db\n    if t_seq[:t] not in db:\nTypeError: argument of type 'function' is not iterable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 28, in <module>\n    print(de_bruijn(2, n))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 19, in de_bruijn\n    db(1, n)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 12, in db\n    if t_seq[:t] not in db:\nTypeError: argument of type 'function' is not iterable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 28, in <module>\n    print(de_bruijn(2, n))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 19, in de_bruijn\n    db(1, n)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 12, in db\n    if t_seq[:t] not in db:\nTypeError: argument of type 'function' is not iterable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 28, in <module>\n    print(de_bruijn(2, n))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 19, in de_bruijn\n    db(1, n)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 12, in db\n    if t_seq[:t] not in db:\nTypeError: argument of type 'function' is not iterable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 28, in <module>\n    print(de_bruijn(2, n))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 19, in de_bruijn\n    db(1, n)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 12, in db\n    if t_seq[:t] not in db:\nTypeError: argument of type 'function' is not iterable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 28, in <module>\n    print(de_bruijn(2, n))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 19, in de_bruijn\n    db(1, n)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 12, in db\n    if t_seq[:t] not in db:\nTypeError: argument of type 'function' is not iterable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 28, in <module>\n    print(de_bruijn(2, n))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 19, in de_bruijn\n    db(1, n)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 12, in db\n    if t_seq[:t] not in db:\nTypeError: argument of type 'function' is not iterable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 28, in <module>\n    print(de_bruijn(2, n))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 19, in de_bruijn\n    db(1, n)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 12, in db\n    if t_seq[:t] not in db:\nTypeError: argument of type 'function' is not iterable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 28, in <module>\n    print(de_bruijn(2, n))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 19, in de_bruijn\n    db(1, n)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 12, in db\n    if t_seq[:t] not in db:\nTypeError: argument of type 'function' is not iterable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 28, in <module>\n    print(de_bruijn(2, n))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 19, in de_bruijn\n    db(1, n)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 12, in db\n    if t_seq[:t] not in db:\nTypeError: argument of type 'function' is not iterable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 28, in <module>\n    print(de_bruijn(2, n))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 19, in de_bruijn\n    db(1, n)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 12, in db\n    if t_seq[:t] not in db:\nTypeError: argument of type 'function' is not iterable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 28, in <module>\n    print(de_bruijn(2, n))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 19, in de_bruijn\n    db(1, n)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DeBruijnSequence_shot_1.py\", line 12, in db\n    if t_seq[:t] not in db:\nTypeError: argument of type 'function' is not iterable\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Dice Combinations",
            "category": "Dynamic Programming",
            "solution": "# Function to calculate the number of ways\ndef dice_combinations(n):\n    # Initialize the dp array\n    dp = [0] * (n + 1)\n    # Base case\n    dp[0] = 1\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(1, min(i, 7)):\n            dp[i] = (dp[i] + dp[i - j]) % (10**9 + 7)\n    return dp[n]\n\n# Read the input\nn = int(input())\n# Print the result\nprint(dice_combinations(n))\n",
            "passed_test_cases": 0,
            "total_test_cases": 20,
            "mean_time_taken": 0.22368062734603883,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Dice Probability",
            "category": "Mathematics",
            "solution": "from decimal import Decimal, getcontext\n\ndef dice_probability():\n    n, a, b = map(int, input().split())\n    dp = [[[0 for _ in range(6*n+1)] for _ in range(6*n+1)] for _ in range(n+1)]\n    for j in range(6*n+1):\n        dp[0][j][j] = 1\n    for i in range(1, n+1):\n        for j in range(i, 6*i+1):\n            for k in range(j, 6*i+1):\n                for x in range(1, 7):\n                    if j-x >= 0 and k-x >= 0:\n                        dp[i][j][k] += dp[i-1][j-x][k-x] / 6\n    getcontext().prec = 7\n    getcontext().rounding = Decimal('ROUND_HALF_EVEN')\n    probability = Decimal(dp[n][a][b])\n    print(probability)\n\ndice_probability()\n",
            "passed_test_cases": 0,
            "total_test_cases": 17,
            "mean_time_taken": 0.41511183626511516,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 19, in <module>\n    dice_probability()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 15, in dice_probability\n    getcontext().rounding = Decimal('ROUND_HALF_EVEN')\ndecimal.InvalidOperation: [<class 'decimal.ConversionSyntax'>]\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 19, in <module>\n    dice_probability()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 15, in dice_probability\n    getcontext().rounding = Decimal('ROUND_HALF_EVEN')\ndecimal.InvalidOperation: [<class 'decimal.ConversionSyntax'>]\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 19, in <module>\n    dice_probability()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 15, in dice_probability\n    getcontext().rounding = Decimal('ROUND_HALF_EVEN')\ndecimal.InvalidOperation: [<class 'decimal.ConversionSyntax'>]\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 19, in <module>\n    dice_probability()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 15, in dice_probability\n    getcontext().rounding = Decimal('ROUND_HALF_EVEN')\ndecimal.InvalidOperation: [<class 'decimal.ConversionSyntax'>]\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 19, in <module>\n    dice_probability()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 15, in dice_probability\n    getcontext().rounding = Decimal('ROUND_HALF_EVEN')\ndecimal.InvalidOperation: [<class 'decimal.ConversionSyntax'>]\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 19, in <module>\n    dice_probability()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 15, in dice_probability\n    getcontext().rounding = Decimal('ROUND_HALF_EVEN')\ndecimal.InvalidOperation: [<class 'decimal.ConversionSyntax'>]\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 19, in <module>\n    dice_probability()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 15, in dice_probability\n    getcontext().rounding = Decimal('ROUND_HALF_EVEN')\ndecimal.InvalidOperation: [<class 'decimal.ConversionSyntax'>]\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 19, in <module>\n    dice_probability()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 15, in dice_probability\n    getcontext().rounding = Decimal('ROUND_HALF_EVEN')\ndecimal.InvalidOperation: [<class 'decimal.ConversionSyntax'>]\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 19, in <module>\n    dice_probability()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 15, in dice_probability\n    getcontext().rounding = Decimal('ROUND_HALF_EVEN')\ndecimal.InvalidOperation: [<class 'decimal.ConversionSyntax'>]\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 19, in <module>\n    dice_probability()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 15, in dice_probability\n    getcontext().rounding = Decimal('ROUND_HALF_EVEN')\ndecimal.InvalidOperation: [<class 'decimal.ConversionSyntax'>]\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 19, in <module>\n    dice_probability()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 15, in dice_probability\n    getcontext().rounding = Decimal('ROUND_HALF_EVEN')\ndecimal.InvalidOperation: [<class 'decimal.ConversionSyntax'>]\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 19, in <module>\n    dice_probability()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 15, in dice_probability\n    getcontext().rounding = Decimal('ROUND_HALF_EVEN')\ndecimal.InvalidOperation: [<class 'decimal.ConversionSyntax'>]\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 19, in <module>\n    dice_probability()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 15, in dice_probability\n    getcontext().rounding = Decimal('ROUND_HALF_EVEN')\ndecimal.InvalidOperation: [<class 'decimal.ConversionSyntax'>]\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 19, in <module>\n    dice_probability()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DiceProbability_shot_1.py\", line 15, in dice_probability\n    getcontext().rounding = Decimal('ROUND_HALF_EVEN')\ndecimal.InvalidOperation: [<class 'decimal.ConversionSyntax'>]\n",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Digit Queries",
            "category": "Introductory Problems",
            "solution": "def digit_at_position(k):\n    # Find the length of the numbers up to the point where the length is >= k\n    length = 1\n    count = 9\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n\n    # Find the first number with length digits\n    start = int(1e(length - 1))\n\n    # Find the kth number with length digits\n    num = start + (k - 1) // length\n\n    # Find the kth digit\n    digit = (num % int(1e(length)) - num % int(1e(length - 1))) // int(1e(length - 1))\n\n    return digit\n\nq = int(input())\nfor _ in range(q):\n    k = int(input())\n    print(digit_at_position(k))\n",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.15974843502044678,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DigitQueries_shot_1.py\", line 11\n    start = int(1e(length - 1))\n                ^\nSyntaxError: invalid decimal literal\n",
                "  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DigitQueries_shot_1.py\", line 11\n    start = int(1e(length - 1))\n                ^\nSyntaxError: invalid decimal literal\n",
                "  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DigitQueries_shot_1.py\", line 11\n    start = int(1e(length - 1))\n                ^\nSyntaxError: invalid decimal literal\n",
                "  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DigitQueries_shot_1.py\", line 11\n    start = int(1e(length - 1))\n                ^\nSyntaxError: invalid decimal literal\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distance Queries",
            "category": "Tree Algorithms",
            "solution": "def dfs(node, parent, depth, graph, depths, parents):\n    depths[node] = depth\n    parents[node] = parent\n    for child in graph[node]:\n        if child != parent:\n            dfs(child, node, depth + 1, graph, depths, parents)\n\ndef lca(node1, node2, parents):\n    while node1 != node2:\n        if depths[node1] > depths[node2]:\n            node1 = parents[node1]\n        else:\n            node2 = parents[node2]\n    return node1\n\nn, q = map(int, input().split())\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\ndepths = [0] * (n + 1)\nparents = [0] * (n + 1)\ndfs(1, 0, 0, graph, depths, parents)\n\nfor _ in range(q):\n    a, b = map(int, input().split())\n    l = lca(a, b, parents)\n    print(depths[a] + depths[b] - 2 * depths[l])\n",
            "passed_test_cases": 6,
            "total_test_cases": 11,
            "mean_time_taken": 0.29306873408230866,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistanceQueries_shot_1.py\", line 25, in <module>\n    dfs(1, 0, 0, graph, depths, parents)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistanceQueries_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1, graph, depths, parents)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistanceQueries_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1, graph, depths, parents)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistanceQueries_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1, graph, depths, parents)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistanceQueries_shot_1.py\", line 5, in dfs\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistanceQueries_shot_1.py\", line 25, in <module>\n    dfs(1, 0, 0, graph, depths, parents)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistanceQueries_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1, graph, depths, parents)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistanceQueries_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1, graph, depths, parents)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistanceQueries_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1, graph, depths, parents)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistanceQueries_shot_1.py\", line 5, in dfs\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistanceQueries_shot_1.py\", line 25, in <module>\n    dfs(1, 0, 0, graph, depths, parents)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistanceQueries_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1, graph, depths, parents)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistanceQueries_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1, graph, depths, parents)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistanceQueries_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1, graph, depths, parents)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistanceQueries_shot_1.py\", line 5, in dfs\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistanceQueries_shot_1.py\", line 25, in <module>\n    dfs(1, 0, 0, graph, depths, parents)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistanceQueries_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1, graph, depths, parents)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistanceQueries_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1, graph, depths, parents)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistanceQueries_shot_1.py\", line 6, in dfs\n    dfs(child, node, depth + 1, graph, depths, parents)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistanceQueries_shot_1.py\", line 5, in dfs\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Colors",
            "category": "Tree Algorithms",
            "solution": "def dfs(node, parent):\n    colors = set()\n    for child in adj[node]:\n        if child != parent:\n            colors |= set(dfs(child, node))\n    colors.add(c[node - 1])\n    distinct_colors[node - 1] = len(colors)\n    return list(colors)\n\nn = int(input())\nc = list(map(int, input().split()))\nadj = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    adj[a].append(b)\n    adj[b].append(a)\n\ndistinct_colors = [0] * n\ndfs(1, 0)\nprint(*distinct_colors)\n",
            "passed_test_cases": 7,
            "total_test_cases": 15,
            "mean_time_taken": 0.2910310745239258,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 19, in <module>\n    dfs(1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 5, in dfs\n    colors |= set(dfs(child, node))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 5, in dfs\n    colors |= set(dfs(child, node))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 5, in dfs\n    colors |= set(dfs(child, node))\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 4, in dfs\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 19, in <module>\n    dfs(1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 5, in dfs\n    colors |= set(dfs(child, node))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 5, in dfs\n    colors |= set(dfs(child, node))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 5, in dfs\n    colors |= set(dfs(child, node))\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 4, in dfs\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 19, in <module>\n    dfs(1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 5, in dfs\n    colors |= set(dfs(child, node))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 5, in dfs\n    colors |= set(dfs(child, node))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 5, in dfs\n    colors |= set(dfs(child, node))\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 4, in dfs\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 19, in <module>\n    dfs(1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 5, in dfs\n    colors |= set(dfs(child, node))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 5, in dfs\n    colors |= set(dfs(child, node))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 5, in dfs\n    colors |= set(dfs(child, node))\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 4, in dfs\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 19, in <module>\n    dfs(1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 5, in dfs\n    colors |= set(dfs(child, node))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 5, in dfs\n    colors |= set(dfs(child, node))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 5, in dfs\n    colors |= set(dfs(child, node))\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 4, in dfs\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 19, in <module>\n    dfs(1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 5, in dfs\n    colors |= set(dfs(child, node))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 5, in dfs\n    colors |= set(dfs(child, node))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 5, in dfs\n    colors |= set(dfs(child, node))\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 4, in dfs\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 19, in <module>\n    dfs(1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 5, in dfs\n    colors |= set(dfs(child, node))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 5, in dfs\n    colors |= set(dfs(child, node))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 5, in dfs\n    colors |= set(dfs(child, node))\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 4, in dfs\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 19, in <module>\n    dfs(1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 5, in dfs\n    colors |= set(dfs(child, node))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 5, in dfs\n    colors |= set(dfs(child, node))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 5, in dfs\n    colors |= set(dfs(child, node))\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctColors_shot_1.py\", line 4, in dfs\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n"
            ],
            "failed_test_cases": [
                4,
                5,
                6,
                7,
                9,
                11,
                13,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Numbers",
            "category": "Sorting and Searching",
            "solution": "# Read the number of values\nn = int(input())\n\n# Read the values\nvalues = list(map(int, input().split()))\n\n# Use a set to find the unique values\nunique_values = set(values)\n\n# Print the number of unique values\nprint(len(unique_values))\n",
            "passed_test_cases": 14,
            "total_test_cases": 15,
            "mean_time_taken": 0.20437652269999187,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Routes",
            "category": "Graph Algorithms",
            "solution": "def dfs(room, visited, route, routes):\n    if room == n:\n        routes.add(tuple(route))\n        return\n    for next_room in graph[room]:\n        if not visited[next_room]:\n            visited[next_room] = True\n            route.append(next_room)\n            dfs(next_room, visited, route, routes)\n            route.pop()\n            visited[next_room] = False\n\nn, m = map(int, input().split())\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\nvisited = [False] * (n + 1)\nvisited[1] = True\nroutes = set()\ndfs(1, visited, [1], routes)\n\nprint(len(routes))\nfor route in sorted(routes, key=len, reverse=True):\n    print(len(route))\n    print(*route)\n",
            "passed_test_cases": 5,
            "total_test_cases": 18,
            "mean_time_taken": 0.32412005795372856,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                8,
                10,
                12,
                13,
                14,
                15,
                16,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Routes II",
            "category": "Advanced Techniques",
            "solution": "def distinct_routes(n, m, k, teleporters):\n    # Create a graph\n    graph = [[] for _ in range(n + 1)]\n    for a, b in teleporters:\n        graph[a].append(b)\n\n    # Find all paths using DFS\n    paths = []\n    def dfs(node, path):\n        if node == n:\n            paths.append(path)\n            return\n        for neighbor in graph[node]:\n            dfs(neighbor, path + [neighbor])\n    dfs(1, [1])\n\n    # Dynamic programming to find the minimum number of coins\n    dp = [[float('inf')] * (k + 1) for _ in range(len(paths) + 1)]\n    dp[0][0] = 0\n    for i in range(1, len(paths) + 1):\n        for j in range(1, k + 1):\n            dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1] + sum(1 for _ in set(paths[i - 1]) if _ != n))\n\n    # Reconstruct the routes\n    routes = []\n    i, j = len(paths), k\n    while i > 0:\n        if dp[i][j] == dp[i - 1][j]:\n            i -= 1\n        else:\n            route = paths[i - 1]\n            routes.append(route)\n            i -= 1\n            j -= 1\n\n    if dp[-1][-1] == float('inf'):\n        return -1\n    else:\n        print(dp[-1][-1])\n        for route in routes[::-1]:\n            print(len(route))\n            print(' '.join(map(str, route)))\n\n# Test the function\ndistinct_routes(8, 10, 2, [(1, 2), (1, 3), (2, 5), (2, 4), (3, 5), (3, 6), (4, 8), (5, 8), (6, 7), (7, 8)])\n",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.12867169380187987,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Substrings",
            "category": "String Algorithms",
            "solution": "# Read the input string\ns = input()\n\n# Initialize a set to store distinct substrings\nsubstrings = set()\n\n# Generate all possible substrings\nfor i in range(len(s)):\n    for j in range(i, len(s)):\n        # Add the substring to the set\n        substrings.add(s[i:j+1])\n\n# Print the number of distinct substrings\nprint(len(substrings))\n",
            "passed_test_cases": 1,
            "total_test_cases": 7,
            "mean_time_taken": 0.40696981975010466,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctSubstrings_shot_1.py\", line 11, in <module>\n    substrings.add(s[i:j+1])\nMemoryError\nError in sys.excepthook:\nTraceback (most recent call last):\n  File \"/usr/lib/python3/dist-packages/apport_python_hook.py\", line 55, in apport_excepthook\n    import apt_pkg\n  File \"<frozen importlib._bootstrap>\", line 1027, in _find_and_load\n  File \"<frozen importlib._bootstrap>\", line 1002, in _find_and_load_unlocked\n  File \"<frozen importlib._bootstrap>\", line 945, in _find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1439, in find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1411, in _get_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1548, in find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1591, in _fill_cache\nOSError: [Errno 12] Cannot allocate memory: '/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp'\n\nOriginal exception was:\nTraceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctSubstrings_shot_1.py\", line 11, in <module>\n    substrings.add(s[i:j+1])\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctSubstrings_shot_1.py\", line 11, in <module>\n    substrings.add(s[i:j+1])\nMemoryError\nError in sys.excepthook:\nTraceback (most recent call last):\n  File \"/usr/lib/python3/dist-packages/apport_python_hook.py\", line 55, in apport_excepthook\n    import apt_pkg\n  File \"<frozen importlib._bootstrap>\", line 1027, in _find_and_load\n  File \"<frozen importlib._bootstrap>\", line 1002, in _find_and_load_unlocked\n  File \"<frozen importlib._bootstrap>\", line 945, in _find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1439, in find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1411, in _get_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1548, in find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1591, in _fill_cache\nOSError: [Errno 12] Cannot allocate memory: '/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp'\n\nOriginal exception was:\nTraceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctSubstrings_shot_1.py\", line 11, in <module>\n    substrings.add(s[i:j+1])\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctSubstrings_shot_1.py\", line 11, in <module>\n    substrings.add(s[i:j+1])\nMemoryError\nError in sys.excepthook:\nTraceback (most recent call last):\n  File \"/usr/lib/python3/dist-packages/apport_python_hook.py\", line 55, in apport_excepthook\n    import apt_pkg\n  File \"<frozen importlib._bootstrap>\", line 1027, in _find_and_load\n  File \"<frozen importlib._bootstrap>\", line 1002, in _find_and_load_unlocked\n  File \"<frozen importlib._bootstrap>\", line 945, in _find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1439, in find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1411, in _get_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1548, in find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1591, in _fill_cache\nOSError: [Errno 12] Cannot allocate memory: '/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp'\n\nOriginal exception was:\nTraceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctSubstrings_shot_1.py\", line 11, in <module>\n    substrings.add(s[i:j+1])\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctSubstrings_shot_1.py\", line 11, in <module>\n    substrings.add(s[i:j+1])\nMemoryError\nError in sys.excepthook:\nTraceback (most recent call last):\n  File \"/usr/lib/python3/dist-packages/apport_python_hook.py\", line 55, in apport_excepthook\n    import apt_pkg\n  File \"<frozen importlib._bootstrap>\", line 1027, in _find_and_load\n  File \"<frozen importlib._bootstrap>\", line 1002, in _find_and_load_unlocked\n  File \"<frozen importlib._bootstrap>\", line 945, in _find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1439, in find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1411, in _get_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1548, in find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1591, in _fill_cache\nOSError: [Errno 12] Cannot allocate memory: '/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp'\n\nOriginal exception was:\nTraceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctSubstrings_shot_1.py\", line 11, in <module>\n    substrings.add(s[i:j+1])\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctSubstrings_shot_1.py\", line 11, in <module>\n    substrings.add(s[i:j+1])\nMemoryError\nError in sys.excepthook:\nTraceback (most recent call last):\n  File \"/usr/lib/python3/dist-packages/apport_python_hook.py\", line 55, in apport_excepthook\n    import apt_pkg\n  File \"<frozen importlib._bootstrap>\", line 1027, in _find_and_load\n  File \"<frozen importlib._bootstrap>\", line 1002, in _find_and_load_unlocked\n  File \"<frozen importlib._bootstrap>\", line 945, in _find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1439, in find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1411, in _get_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1548, in find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1591, in _fill_cache\nOSError: [Errno 12] Cannot allocate memory: '/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp'\n\nOriginal exception was:\nTraceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctSubstrings_shot_1.py\", line 11, in <module>\n    substrings.add(s[i:j+1])\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctSubstrings_shot_1.py\", line 11, in <module>\n    substrings.add(s[i:j+1])\nMemoryError\nError in sys.excepthook:\nTraceback (most recent call last):\n  File \"/usr/lib/python3/dist-packages/apport_python_hook.py\", line 55, in apport_excepthook\n    import apt_pkg\n  File \"<frozen importlib._bootstrap>\", line 1027, in _find_and_load\n  File \"<frozen importlib._bootstrap>\", line 1002, in _find_and_load_unlocked\n  File \"<frozen importlib._bootstrap>\", line 945, in _find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1439, in find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1411, in _get_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1548, in find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1591, in _fill_cache\nOSError: [Errno 12] Cannot allocate memory: '/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp'\n\nOriginal exception was:\nTraceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctSubstrings_shot_1.py\", line 11, in <module>\n    substrings.add(s[i:j+1])\nMemoryError\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Values Queries",
            "category": "Range Queries",
            "solution": "def build_tree(arr, tree, start, end, pos):\n    if start == end:\n        tree[pos] = [arr[start], 1]\n    else:\n        mid = (start + end) // 2\n        build_tree(arr, tree, start, mid, 2 * pos + 1)\n        build_tree(arr, tree, mid + 1, end, 2 * pos + 2)\n        tree[pos] = merge(tree[2 * pos + 1], tree[2 * pos + 2])\n\ndef merge(a, b):\n    result = [0] * (len(a) + len(b))\n    i = j = k = 0\n    while i < len(a) and j < len(b):\n        if a[i] < b[j]:\n            result[k] = a[i]\n            i += 1\n        else:\n            result[k] = b[j]\n            j += 1\n        k += 1\n    while i < len(a):\n        result[k] = a[i]\n        i += 1\n        k += 1\n    while j < len(b):\n        result[k] = b[j]\n        j += 1\n        k += 1\n    return [result[:k], k]\n\ndef query(tree, start, end, left, right, pos):\n    if left <= start and end <= right:\n        return tree[pos]\n    mid = (start + end) // 2\n    if right <= mid:\n        return query(tree, start, mid, left, right, 2 * pos + 1)\n    if left > mid:\n        return query(tree, mid + 1, end, left, right, 2 * pos + 2)\n    left_res = query(tree, start, mid, left, mid, 2 * pos + 1)\n    right_res = query(tree, mid + 1, end, mid + 1, right, 2 * pos + 2)\n    return merge(left_res, right_res)\n\nn, q = map(int, input().split())\narr = list(map(int, input().split()))\nindex_map = {val: i for i, val in enumerate(sorted(set(arr)))}\nmapped_arr = [index_map[val] for val in arr]\ntree_size = 4 * n\ntree = [0] * tree_size\nbuild_tree(mapped_arr, tree, 0, n - 1, 0)\nfor _ in range(q):\n    left, right = map(int, input().split())\n    result, count = query(tree, 0, n - 1, left - 1, right - 1, 0)\n    print(count)\n",
            "passed_test_cases": 1,
            "total_test_cases": 14,
            "mean_time_taken": 0.2088820423398699,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 49, in <module>\n    build_tree(mapped_arr, tree, 0, n - 1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  [Previous line repeated 2 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 8, in build_tree\n    tree[pos] = merge(tree[2 * pos + 1], tree[2 * pos + 2])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 14, in merge\n    if a[i] < b[j]:\nTypeError: '<' not supported between instances of 'int' and 'list'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 49, in <module>\n    build_tree(mapped_arr, tree, 0, n - 1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  [Previous line repeated 13 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 8, in build_tree\n    tree[pos] = merge(tree[2 * pos + 1], tree[2 * pos + 2])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 14, in merge\n    if a[i] < b[j]:\nTypeError: '<' not supported between instances of 'int' and 'list'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 49, in <module>\n    build_tree(mapped_arr, tree, 0, n - 1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  [Previous line repeated 13 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 8, in build_tree\n    tree[pos] = merge(tree[2 * pos + 1], tree[2 * pos + 2])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 14, in merge\n    if a[i] < b[j]:\nTypeError: '<' not supported between instances of 'int' and 'list'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 49, in <module>\n    build_tree(mapped_arr, tree, 0, n - 1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  [Previous line repeated 13 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 8, in build_tree\n    tree[pos] = merge(tree[2 * pos + 1], tree[2 * pos + 2])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 14, in merge\n    if a[i] < b[j]:\nTypeError: '<' not supported between instances of 'list' and 'int'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 49, in <module>\n    build_tree(mapped_arr, tree, 0, n - 1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  [Previous line repeated 13 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 8, in build_tree\n    tree[pos] = merge(tree[2 * pos + 1], tree[2 * pos + 2])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 14, in merge\n    if a[i] < b[j]:\nTypeError: '<' not supported between instances of 'int' and 'list'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 49, in <module>\n    build_tree(mapped_arr, tree, 0, n - 1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  [Previous line repeated 13 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 8, in build_tree\n    tree[pos] = merge(tree[2 * pos + 1], tree[2 * pos + 2])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 14, in merge\n    if a[i] < b[j]:\nTypeError: '<' not supported between instances of 'int' and 'list'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 49, in <module>\n    build_tree(mapped_arr, tree, 0, n - 1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  [Previous line repeated 13 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 8, in build_tree\n    tree[pos] = merge(tree[2 * pos + 1], tree[2 * pos + 2])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 14, in merge\n    if a[i] < b[j]:\nTypeError: '<' not supported between instances of 'list' and 'int'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 49, in <module>\n    build_tree(mapped_arr, tree, 0, n - 1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  [Previous line repeated 13 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 8, in build_tree\n    tree[pos] = merge(tree[2 * pos + 1], tree[2 * pos + 2])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 14, in merge\n    if a[i] < b[j]:\nTypeError: '<' not supported between instances of 'int' and 'list'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 49, in <module>\n    build_tree(mapped_arr, tree, 0, n - 1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  [Previous line repeated 13 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 8, in build_tree\n    tree[pos] = merge(tree[2 * pos + 1], tree[2 * pos + 2])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 14, in merge\n    if a[i] < b[j]:\nTypeError: '<' not supported between instances of 'int' and 'list'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 49, in <module>\n    build_tree(mapped_arr, tree, 0, n - 1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  [Previous line repeated 13 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 8, in build_tree\n    tree[pos] = merge(tree[2 * pos + 1], tree[2 * pos + 2])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 14, in merge\n    if a[i] < b[j]:\nTypeError: '<' not supported between instances of 'list' and 'int'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 49, in <module>\n    build_tree(mapped_arr, tree, 0, n - 1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  [Previous line repeated 13 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 8, in build_tree\n    tree[pos] = merge(tree[2 * pos + 1], tree[2 * pos + 2])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 14, in merge\n    if a[i] < b[j]:\nTypeError: '<' not supported between instances of 'int' and 'list'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 49, in <module>\n    build_tree(mapped_arr, tree, 0, n - 1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  [Previous line repeated 13 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 8, in build_tree\n    tree[pos] = merge(tree[2 * pos + 1], tree[2 * pos + 2])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 14, in merge\n    if a[i] < b[j]:\nTypeError: '<' not supported between instances of 'list' and 'int'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 49, in <module>\n    build_tree(mapped_arr, tree, 0, n - 1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 6, in build_tree\n    build_tree(arr, tree, start, mid, 2 * pos + 1)\n  [Previous line repeated 12 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 8, in build_tree\n    tree[pos] = merge(tree[2 * pos + 1], tree[2 * pos + 2])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DistinctValuesQueries_shot_1.py\", line 14, in merge\n    if a[i] < b[j]:\nTypeError: '<' not supported between instances of 'int' and 'list'\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distributing Apples",
            "category": "Mathematics",
            "solution": "# Function to calculate binomial coefficient\ndef binomial_coeff(n, k, mod):\n    dp = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(min(i, k) + 1):\n            if j == 0 or j == i:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % mod\n    return dp[n][k]\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print result\nprint(binomial_coeff(n + m - 1, n - 1, 10**9 + 7))\n",
            "passed_test_cases": 7,
            "total_test_cases": 13,
            "mean_time_taken": 0.5547776222229004,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                8,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Divisor Analysis",
            "category": "Mathematics",
            "solution": "import sympy\nMOD = 10**9 + 7\n\ndef divisor_analysis(n):\n    num_divisors = 1\n    sum_divisors = 1\n    product_divisors = 1\n\n    for _ in range(n):\n        x, k = map(int, input().split())\n        num_divisors = (num_divisors * (k+1)) % MOD\n        sum_divisors = (sum_divisors * ((sympy.pow(x, k+1, MOD) - 1) // (x-1))) % MOD\n        product_divisors = (product_divisors * sympy.pow(x, k * (k+1) // 2, MOD)) % MOD\n\n    print(num_divisors, sum_divisors, product_divisors)\n\nn = int(input())\ndivisor_analysis(n)\n",
            "passed_test_cases": 0,
            "total_test_cases": 7,
            "mean_time_taken": 0.27604525429861887,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DivisorAnalysis_shot_1.py\", line 18, in <module>\n    divisor_analysis(n)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DivisorAnalysis_shot_1.py\", line 12, in divisor_analysis\n    sum_divisors = (sum_divisors * ((sympy.pow(x, k+1, MOD) - 1) // (x-1))) % MOD\nAttributeError: module 'sympy' has no attribute 'pow'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DivisorAnalysis_shot_1.py\", line 18, in <module>\n    divisor_analysis(n)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DivisorAnalysis_shot_1.py\", line 12, in divisor_analysis\n    sum_divisors = (sum_divisors * ((sympy.pow(x, k+1, MOD) - 1) // (x-1))) % MOD\nAttributeError: module 'sympy' has no attribute 'pow'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DivisorAnalysis_shot_1.py\", line 18, in <module>\n    divisor_analysis(n)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DivisorAnalysis_shot_1.py\", line 12, in divisor_analysis\n    sum_divisors = (sum_divisors * ((sympy.pow(x, k+1, MOD) - 1) // (x-1))) % MOD\nAttributeError: module 'sympy' has no attribute 'pow'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DivisorAnalysis_shot_1.py\", line 18, in <module>\n    divisor_analysis(n)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DivisorAnalysis_shot_1.py\", line 12, in divisor_analysis\n    sum_divisors = (sum_divisors * ((sympy.pow(x, k+1, MOD) - 1) // (x-1))) % MOD\nAttributeError: module 'sympy' has no attribute 'pow'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DivisorAnalysis_shot_1.py\", line 18, in <module>\n    divisor_analysis(n)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DivisorAnalysis_shot_1.py\", line 12, in divisor_analysis\n    sum_divisors = (sum_divisors * ((sympy.pow(x, k+1, MOD) - 1) // (x-1))) % MOD\nAttributeError: module 'sympy' has no attribute 'pow'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DivisorAnalysis_shot_1.py\", line 18, in <module>\n    divisor_analysis(n)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DivisorAnalysis_shot_1.py\", line 12, in divisor_analysis\n    sum_divisors = (sum_divisors * ((sympy.pow(x, k+1, MOD) - 1) // (x-1))) % MOD\nAttributeError: module 'sympy' has no attribute 'pow'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DivisorAnalysis_shot_1.py\", line 18, in <module>\n    divisor_analysis(n)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DivisorAnalysis_shot_1.py\", line 12, in divisor_analysis\n    sum_divisors = (sum_divisors * ((sympy.pow(x, k+1, MOD) - 1) // (x-1))) % MOD\nAttributeError: module 'sympy' has no attribute 'pow'\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Download Speed",
            "category": "Graph Algorithms",
            "solution": "from collections import defaultdict\n\ndef ford_fulkerson(graph, source, sink):\n    def bfs(graph, parent, visited, source, sink):\n        visited[source] = True\n        queue = [source]\n        while queue:\n            u = queue.pop(0)\n            for ind, (v, residual) in enumerate(graph[u]):\n                if not visited[v] and residual > 0:\n                    parent[v] = u, ind\n                    queue.append(v)\n                    visited[v] = True\n        return sink in visited\n\n    parent = [-1] * len(graph)\n    max_flow = 0\n    while bfs(graph, parent, [False] * len(graph), source, sink):\n        path_flow = float('Inf')\n        s = sink\n        while s != source:\n            path_flow = min(path_flow, graph[parent[s][0]][parent[s][1]][1])\n            s = parent[s][0]\n        max_flow += path_flow\n        v = sink\n        while v != source:\n            u, ind = parent[v]\n            graph[u][ind][1] -= path_flow\n            graph[v][ind][1] += path_flow\n            v = u\n    return max_flow\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        graph[a].append([b, c])\n        graph[b].append([a, 0])  # residual capacity is 0 in reverse direction\n    print(int(ford_fulkerson(graph, 1, n)))\n\nsolve()\n",
            "passed_test_cases": 0,
            "total_test_cases": 21,
            "mean_time_taken": 0.15332797595432826,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 42, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 40, in solve\n    print(int(ford_fulkerson(graph, 1, n)))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 18, in ford_fulkerson\n    while bfs(graph, parent, [False] * len(graph), source, sink):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 10, in bfs\n    if not visited[v] and residual > 0:\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 42, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 40, in solve\n    print(int(ford_fulkerson(graph, 1, n)))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 18, in ford_fulkerson\n    while bfs(graph, parent, [False] * len(graph), source, sink):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 10, in bfs\n    if not visited[v] and residual > 0:\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 42, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 40, in solve\n    print(int(ford_fulkerson(graph, 1, n)))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 18, in ford_fulkerson\n    while bfs(graph, parent, [False] * len(graph), source, sink):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 10, in bfs\n    if not visited[v] and residual > 0:\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 42, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 40, in solve\n    print(int(ford_fulkerson(graph, 1, n)))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 18, in ford_fulkerson\n    while bfs(graph, parent, [False] * len(graph), source, sink):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 10, in bfs\n    if not visited[v] and residual > 0:\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 42, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 40, in solve\n    print(int(ford_fulkerson(graph, 1, n)))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 18, in ford_fulkerson\n    while bfs(graph, parent, [False] * len(graph), source, sink):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 10, in bfs\n    if not visited[v] and residual > 0:\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 42, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 40, in solve\n    print(int(ford_fulkerson(graph, 1, n)))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 18, in ford_fulkerson\n    while bfs(graph, parent, [False] * len(graph), source, sink):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 10, in bfs\n    if not visited[v] and residual > 0:\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 42, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 40, in solve\n    print(int(ford_fulkerson(graph, 1, n)))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 18, in ford_fulkerson\n    while bfs(graph, parent, [False] * len(graph), source, sink):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 10, in bfs\n    if not visited[v] and residual > 0:\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 42, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 40, in solve\n    print(int(ford_fulkerson(graph, 1, n)))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 18, in ford_fulkerson\n    while bfs(graph, parent, [False] * len(graph), source, sink):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 10, in bfs\n    if not visited[v] and residual > 0:\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 42, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 40, in solve\n    print(int(ford_fulkerson(graph, 1, n)))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 18, in ford_fulkerson\n    while bfs(graph, parent, [False] * len(graph), source, sink):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 10, in bfs\n    if not visited[v] and residual > 0:\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 42, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 40, in solve\n    print(int(ford_fulkerson(graph, 1, n)))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 18, in ford_fulkerson\n    while bfs(graph, parent, [False] * len(graph), source, sink):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 10, in bfs\n    if not visited[v] and residual > 0:\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 42, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 40, in solve\n    print(int(ford_fulkerson(graph, 1, n)))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 18, in ford_fulkerson\n    while bfs(graph, parent, [False] * len(graph), source, sink):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 10, in bfs\n    if not visited[v] and residual > 0:\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 42, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 40, in solve\n    print(int(ford_fulkerson(graph, 1, n)))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 18, in ford_fulkerson\n    while bfs(graph, parent, [False] * len(graph), source, sink):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 10, in bfs\n    if not visited[v] and residual > 0:\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 42, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 40, in solve\n    print(int(ford_fulkerson(graph, 1, n)))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 18, in ford_fulkerson\n    while bfs(graph, parent, [False] * len(graph), source, sink):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 10, in bfs\n    if not visited[v] and residual > 0:\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 42, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 40, in solve\n    print(int(ford_fulkerson(graph, 1, n)))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 18, in ford_fulkerson\n    while bfs(graph, parent, [False] * len(graph), source, sink):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 10, in bfs\n    if not visited[v] and residual > 0:\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 42, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 40, in solve\n    print(int(ford_fulkerson(graph, 1, n)))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 18, in ford_fulkerson\n    while bfs(graph, parent, [False] * len(graph), source, sink):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 10, in bfs\n    if not visited[v] and residual > 0:\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 42, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 40, in solve\n    print(int(ford_fulkerson(graph, 1, n)))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 18, in ford_fulkerson\n    while bfs(graph, parent, [False] * len(graph), source, sink):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 10, in bfs\n    if not visited[v] and residual > 0:\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 42, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 40, in solve\n    print(int(ford_fulkerson(graph, 1, n)))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 18, in ford_fulkerson\n    while bfs(graph, parent, [False] * len(graph), source, sink):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 10, in bfs\n    if not visited[v] and residual > 0:\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 42, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 40, in solve\n    print(int(ford_fulkerson(graph, 1, n)))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 18, in ford_fulkerson\n    while bfs(graph, parent, [False] * len(graph), source, sink):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 10, in bfs\n    if not visited[v] and residual > 0:\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 42, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 40, in solve\n    print(int(ford_fulkerson(graph, 1, n)))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 18, in ford_fulkerson\n    while bfs(graph, parent, [False] * len(graph), source, sink):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 10, in bfs\n    if not visited[v] and residual > 0:\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 42, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 40, in solve\n    print(int(ford_fulkerson(graph, 1, n)))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 18, in ford_fulkerson\n    while bfs(graph, parent, [False] * len(graph), source, sink):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 10, in bfs\n    if not visited[v] and residual > 0:\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 42, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 40, in solve\n    print(int(ford_fulkerson(graph, 1, n)))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 18, in ford_fulkerson\n    while bfs(graph, parent, [False] * len(graph), source, sink):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DownloadSpeed_shot_1.py\", line 10, in bfs\n    if not visited[v] and residual > 0:\nIndexError: list index out of range\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Dynamic Connectivity",
            "category": "Advanced Techniques",
            "solution": "class DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x == root_y:\n            return\n        if self.size[root_x] < self.size[root_y]:\n            self.parent[root_x] = root_y\n            self.size[root_y] += self.size[root_x]\n        else:\n            self.parent[root_y] = root_x\n            self.size[root_x] += self.size[root_y]\n        self.num_sets -= 1\n\n    def get_num_sets(self):\n        return self.num_sets\n\ndef main():\n    n, m, k = map(int, input().split())\n    dsu = DSU(n)\n    edges = []\n    for _ in range(m):\n        a, b = map(int, input().split())\n        edges.append((a, b))\n        dsu.union(a - 1, b - 1)\n    print(dsu.get_num_sets(), end=\" \")\n    for _ in range(k):\n        t, a, b = map(int, input().split())\n        a -= 1\n        b -= 1\n        if t == 1:\n            if not (a, b) in edges and not (b, a) in edges:\n                dsu.union(a, b)\n                edges.append((a, b))\n        else:\n            if (a, b) in edges:\n                edges.remove((a, b))\n                dsu.union(a, dsu.find(b))\n        print(dsu.get_num_sets(), end=\" \")\n    print()\n\nif __name__ == \"__main__\":\n    main()\n",
            "passed_test_cases": 0,
            "total_test_cases": 7,
            "mean_time_taken": 0.7836062226976667,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Dynamic Range Minimum Queries",
            "category": "Range Queries",
            "solution": "class Node:\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n        self.min = float('inf')\n        self.left = None\n        self.right = None\n\ndef build_tree(arr, tree, ss, se, si):\n    if ss == se:\n        tree[si] = Node(ss, se, arr[ss])\n        return tree[si]\n    mid = (ss + se) // 2\n    tree[si] = Node(ss, se)\n    tree[si].left = build_tree(arr, tree, ss, mid, 2*si+1)\n    tree[si].right = build_tree(arr, tree, mid+1, se, 2*si+2)\n    tree[si].min = min(tree[si].left.min, tree[si].right.min)\n    return tree[si]\n\ndef update_value(tree, ss, se, si, i, diff):\n    if i < ss or i > se:\n        return\n    tree[si].min += diff\n    if ss != se:\n        mid = (ss + se) // 2\n        update_value(tree, ss, mid, 2*si+1, i, diff)\n        update_value(tree, mid+1, se, 2*si+2, i, diff)\n\ndef get_min_value(tree, ss, se, qs, qe, si):\n    if qs <= ss and qe >= se:\n        return tree[si].min\n    if se < qs or ss > qe:\n        return float('inf')\n    mid = (ss + se) // 2\n    return min(get_min_value(tree, ss, mid, qs, qe, 2*si+1),\n               get_min_value(tree, mid+1, se, qs, qe, 2*si+2))\n\ndef main():\n    n, q = map(int, input().split())\n    arr = list(map(int, input().split()))\n    max_size = 2*(10**5)\n    tree = [None] * (2*max_size)\n    build_tree(arr, tree, 0, n-1, 0)\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            diff = query[2] - arr[query[1]-1]\n            arr[query[1]-1] = query[2]\n            update_value(tree, 0, n-1, 0, query[1]-1, diff)\n        else:\n            print(get_min_value(tree, 0, n-1, query[1]-1, query[2]-1, 0))\n\nif __name__ == \"__main__\":\n    main()\n",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.1725292205810547,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DynamicRangeMinimumQueries_shot_1.py\", line 54, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DynamicRangeMinimumQueries_shot_1.py\", line 43, in main\n    build_tree(arr, tree, 0, n-1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DynamicRangeMinimumQueries_shot_1.py\", line 15, in build_tree\n    tree[si].left = build_tree(arr, tree, ss, mid, 2*si+1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DynamicRangeMinimumQueries_shot_1.py\", line 15, in build_tree\n    tree[si].left = build_tree(arr, tree, ss, mid, 2*si+1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DynamicRangeMinimumQueries_shot_1.py\", line 15, in build_tree\n    tree[si].left = build_tree(arr, tree, ss, mid, 2*si+1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DynamicRangeMinimumQueries_shot_1.py\", line 11, in build_tree\n    tree[si] = Node(ss, se, arr[ss])\nTypeError: Node.__init__() takes 3 positional arguments but 4 were given\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DynamicRangeMinimumQueries_shot_1.py\", line 54, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DynamicRangeMinimumQueries_shot_1.py\", line 43, in main\n    build_tree(arr, tree, 0, n-1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DynamicRangeMinimumQueries_shot_1.py\", line 15, in build_tree\n    tree[si].left = build_tree(arr, tree, ss, mid, 2*si+1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DynamicRangeMinimumQueries_shot_1.py\", line 15, in build_tree\n    tree[si].left = build_tree(arr, tree, ss, mid, 2*si+1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DynamicRangeMinimumQueries_shot_1.py\", line 15, in build_tree\n    tree[si].left = build_tree(arr, tree, ss, mid, 2*si+1)\n  [Previous line repeated 15 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DynamicRangeMinimumQueries_shot_1.py\", line 11, in build_tree\n    tree[si] = Node(ss, se, arr[ss])\nTypeError: Node.__init__() takes 3 positional arguments but 4 were given\n"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Dynamic Range Sum Queries",
            "category": "Range Queries",
            "solution": "class Node:\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n        self.sum = 0\n        self.left = None\n        self.right = None\n\ndef build_tree(arr, tree, start, end, idx):\n    if start == end:\n        tree[idx].sum = arr[start]\n        return tree[idx].sum\n\n    mid = (start + end) // 2\n    tree[idx].left = Node(start, mid)\n    tree[idx].right = Node(mid + 1, end)\n\n    tree[idx].sum = build_tree(arr, tree, start, mid, 2 * idx + 1) + build_tree(arr, tree, mid + 1, end, 2 * idx + 2)\n    return tree[idx].sum\n\ndef update_value(tree, start, end, idx, pos, value):\n    if start == end:\n        tree[idx].sum = value\n        return value\n\n    mid = (start + end) // 2\n    if pos <= mid:\n        tree[idx].left.sum = update_value(tree, start, mid, 2 * idx + 1, pos, value)\n    else:\n        tree[idx].right.sum = update_value(tree, mid + 1, end, 2 * idx + 2, pos, value)\n\n    tree[idx].sum = tree[idx].left.sum + tree[idx].right.sum\n    return tree[idx].sum\n\ndef get_sum(tree, start, end, idx, left, right):\n    if start > right or end < left:\n        return 0\n\n    if start >= left and end <= right:\n        return tree[idx].sum\n\n    mid = (start + end) // 2\n    return get_sum(tree, start, mid, 2 * idx + 1, left, right) + get_sum(tree, mid + 1, end, 2 * idx + 2, left, right)\n\nn, q = map(int, input().split())\narr = list(map(int, input().split()))\ntree = [None] * (4 * n)\nbuild_tree(arr, tree, 0, n - 1, 0)\n\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    if query[0] == 1:\n        update_value(tree, 0, n - 1, 0, query[1] - 1, query[2])\n    else:\n        print(get_sum(tree, 0, n - 1, 0, query[1] - 1, query[2] - 1))\n",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.17240548133850098,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DynamicRangeSumQueries_shot_1.py\", line 48, in <module>\n    build_tree(arr, tree, 0, n - 1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DynamicRangeSumQueries_shot_1.py\", line 15, in build_tree\n    tree[idx].left = Node(start, mid)\nAttributeError: 'NoneType' object has no attribute 'left'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DynamicRangeSumQueries_shot_1.py\", line 48, in <module>\n    build_tree(arr, tree, 0, n - 1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/DynamicRangeSumQueries_shot_1.py\", line 15, in build_tree\n    tree[idx].left = Node(start, mid)\nAttributeError: 'NoneType' object has no attribute 'left'\n"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Edit Distance",
            "category": "Dynamic Programming",
            "solution": "def edit_distance(s1, s2):\n    n = len(s1)\n    m = len(s2)\n\n    # Create a table to store the lengths of longest common suffixes of substrings.\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n\n    return dp[n][m]\n\n# Read the input\ns1 = input().strip()\ns2 = input().strip()\n\n# Print the result\nprint(edit_distance(s1, s2))\n",
            "passed_test_cases": 10,
            "total_test_cases": 17,
            "mean_time_taken": 0.5033749131595388,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                5,
                6,
                7,
                9,
                11,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Elevator Rides",
            "category": "Dynamic Programming",
            "solution": "# Read the input\nn, x = map(int, input().split())\nweights = list(map(int, input().split()))\n\n# Sort the weights in descending order\nweights.sort(reverse=True)\n\n# Initialize the number of rides\nrides = 0\n\n# Initialize the current weight in the elevator\ncurrent_weight = 0\n\n# Iterate over the weights\nfor weight in weights:\n    # If adding the current person's weight exceeds the maximum allowed weight\n    if current_weight + weight > x:\n        # Start a new ride\n        rides += 1\n        current_weight = weight\n    # Otherwise, add the current person's weight to the current weight in the elevator\n    else:\n        current_weight += weight\n\n# If there are still people left in the elevator, increment the number of rides\nif current_weight > 0:\n    rides += 1\n\n# Print the minimum number of rides\nprint(rides)\n",
            "passed_test_cases": 11,
            "total_test_cases": 39,
            "mean_time_taken": 0.10864628278292142,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                6,
                7,
                8,
                9,
                10,
                11,
                13,
                16,
                17,
                18,
                19,
                20,
                22,
                23,
                24,
                25,
                26,
                28,
                30,
                31,
                32,
                35,
                36,
                38,
                39
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Empty String",
            "category": "Additional Problems",
            "solution": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\ndef solve():\n    s = input().strip()\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    last = -1\n    count = 0\n    for i in range(n):\n        if s[i] == s[last]:\n            count += 1\n        else:\n            last = i\n            count = 1\n        dp[i + 1] = (dp[i] + dp[i - count] * count % MOD) % MOD\n    return dp[n]\n\nprint(solve())\n",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.12204259634017944,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Eulerian Subgraphs",
            "category": "Advanced Techniques",
            "solution": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\ndef power(a, b):\n    result = 1\n    while b > 0:\n        if b % 2:\n            result = (result * a) % MOD\n        a = (a * a) % MOD\n        b //= 2\n    return result\n\ndef solve():\n    n, m = map(int, input().split())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n\n    dp = [0] * (1 << m)\n    dp[0] = 1\n    for mask in range(1, 1 << m):\n        degrees = [0] * (n + 1)\n        for i in range(m):\n            if mask & (1 << i):\n                a, b = adj[i + 1][0], adj[i + 1][1]\n                degrees[a] += 1\n                degrees[b] += 1\n        if all(degrees[i] % 2 == 0 for i in range(1, n + 1)):\n            dp[mask] = dp[mask - 1]\n        else:\n            dp[mask] = 0\n\n    return dp[-1] * power(2, m) % MOD\n\nprint(solve())\n",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 0.17940719922383627,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EulerianSubgraphs_shot_1.py\", line 39, in <module>\n    print(solve())\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EulerianSubgraphs_shot_1.py\", line 29, in solve\n    a, b = adj[i + 1][0], adj[i + 1][1]\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EulerianSubgraphs_shot_1.py\", line 39, in <module>\n    print(solve())\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EulerianSubgraphs_shot_1.py\", line 23, in solve\n    dp = [0] * (1 << m)\nOverflowError: cannot fit 'int' into an index-sized integer\n",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Even Outdegree Edges",
            "category": "Additional Problems",
            "solution": "def dfs(node, parent, graph, odd_nodes):\n    degree = 1\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            degree += dfs(neighbor, node, graph, odd_nodes)\n    if degree % 2 == 1:\n        odd_nodes.append(node)\n    return degree\n\ndef direct_edges(node, parent, graph, result):\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            if neighbor in odd_nodes:\n                result.append((node, neighbor))\n                direct_edges(neighbor, node, graph, result)\n            else:\n                result.append((neighbor, node))\n                direct_edges(neighbor, node, graph, result)\n\nn, m = map(int, input().split())\ngraph = [[] for _ in range(n + 1)]\nodd_nodes = []\nfor _ in range(m):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\nfor node in range(1, n + 1):\n    if graph[node]:\n        if dfs(node, 0, graph, odd_nodes) % 2 == 1:\n            print(\"IMPOSSIBLE\")\n            exit()\n\nresult = []\nfor node in range(1, n + 1):\n    if graph[node]:\n        direct_edges(node, 0, graph, result)\n\nfor a, b in result:\n    print(a, b)\n",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.2750205397605896,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 30, in <module>\n    if dfs(node, 0, graph, odd_nodes) % 2 == 1:\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 5, in dfs\n    degree += dfs(neighbor, node, graph, odd_nodes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 5, in dfs\n    degree += dfs(neighbor, node, graph, odd_nodes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 5, in dfs\n    degree += dfs(neighbor, node, graph, odd_nodes)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 4, in dfs\n    if neighbor != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 30, in <module>\n    if dfs(node, 0, graph, odd_nodes) % 2 == 1:\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 5, in dfs\n    degree += dfs(neighbor, node, graph, odd_nodes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 5, in dfs\n    degree += dfs(neighbor, node, graph, odd_nodes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 5, in dfs\n    degree += dfs(neighbor, node, graph, odd_nodes)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 4, in dfs\n    if neighbor != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 30, in <module>\n    if dfs(node, 0, graph, odd_nodes) % 2 == 1:\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 5, in dfs\n    degree += dfs(neighbor, node, graph, odd_nodes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 5, in dfs\n    degree += dfs(neighbor, node, graph, odd_nodes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 5, in dfs\n    degree += dfs(neighbor, node, graph, odd_nodes)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 4, in dfs\n    if neighbor != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 30, in <module>\n    if dfs(node, 0, graph, odd_nodes) % 2 == 1:\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 5, in dfs\n    degree += dfs(neighbor, node, graph, odd_nodes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 5, in dfs\n    degree += dfs(neighbor, node, graph, odd_nodes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 5, in dfs\n    degree += dfs(neighbor, node, graph, odd_nodes)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 4, in dfs\n    if neighbor != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 30, in <module>\n    if dfs(node, 0, graph, odd_nodes) % 2 == 1:\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 5, in dfs\n    degree += dfs(neighbor, node, graph, odd_nodes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 5, in dfs\n    degree += dfs(neighbor, node, graph, odd_nodes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 5, in dfs\n    degree += dfs(neighbor, node, graph, odd_nodes)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 4, in dfs\n    if neighbor != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 30, in <module>\n    if dfs(node, 0, graph, odd_nodes) % 2 == 1:\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 5, in dfs\n    degree += dfs(neighbor, node, graph, odd_nodes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 5, in dfs\n    degree += dfs(neighbor, node, graph, odd_nodes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 5, in dfs\n    degree += dfs(neighbor, node, graph, odd_nodes)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 4, in dfs\n    if neighbor != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 30, in <module>\n    if dfs(node, 0, graph, odd_nodes) % 2 == 1:\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 5, in dfs\n    degree += dfs(neighbor, node, graph, odd_nodes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 5, in dfs\n    degree += dfs(neighbor, node, graph, odd_nodes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 5, in dfs\n    degree += dfs(neighbor, node, graph, odd_nodes)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 4, in dfs\n    if neighbor != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 30, in <module>\n    if dfs(node, 0, graph, odd_nodes) % 2 == 1:\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 5, in dfs\n    degree += dfs(neighbor, node, graph, odd_nodes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 5, in dfs\n    degree += dfs(neighbor, node, graph, odd_nodes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 5, in dfs\n    degree += dfs(neighbor, node, graph, odd_nodes)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/EvenOutdegreeEdges_shot_1.py\", line 4, in dfs\n    if neighbor != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Exponentiation",
            "category": "Mathematics",
            "solution": "# Function to calculate (a^b) % modulo\ndef power(a, b, mod):\n    result = 1\n    while b > 0:\n        # If b is odd, multiply a with result\n        if b % 2:\n            result = (result * a) % mod\n        # Here we are doing a = a^2 % mod\n        a = (a * a) % mod\n        # Reduce b by half\n        b //= 2\n    return result % mod\n\n# Read the number of calculations\nn = int(input())\nmodulo = 10**9 + 7\n\n# Perform each calculation\nfor _ in range(n):\n    # Read a and b\n    a, b = map(int, input().split())\n    # Print the result\n    print(power(a, b, modulo))\n",
            "passed_test_cases": 1,
            "total_test_cases": 3,
            "mean_time_taken": 0.7560065587361654,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Exponentiation II",
            "category": "Mathematics",
            "solution": "# Function to calculate b^c\ndef power(b, c):\n    if c == 0:\n        return 1\n    elif c % 2 == 0:\n        y = power(b, c // 2)\n        return y * y\n    else:\n        return b * power(b, c - 1)\n\n# Function to calculate a^(b^c) modulo 10^9+7\ndef modulo_power(a, b, modulo):\n    result = 1\n    while b > 0:\n        if b % 2:\n            result = (result * a) % modulo\n        a = (a * a) % modulo\n        b //= 2\n    return result % modulo\n\n# Reading the input\nn = int(input())\nfor _ in range(n):\n    a, b, c = map(int, input().split())\n    # Calculating the result\n    result = modulo_power(a, power(b, c), 10**9 + 7)\n    # Printing the result\n    print(result)\n",
            "passed_test_cases": 6,
            "total_test_cases": 13,
            "mean_time_taken": 0.6172352387354925,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                5,
                6,
                8,
                10,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Factory Machines",
            "category": "Sorting and Searching",
            "solution": "n, t = map(int, input().split())\nk = list(map(int, input().split()))\n\nk.sort()\ntime = 0\n\nwhile t > 0:\n    products_made = min(t, time // k[0] + 1) * (time % k[0] == 0)\n    t -= products_made\n    time += 1\n\nprint(time)\n",
            "passed_test_cases": 2,
            "total_test_cases": 18,
            "mean_time_taken": 0.3761573102739122,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                15,
                16,
                17,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Ferris Wheel",
            "category": "Sorting and Searching",
            "solution": "# Read the input\nn, x = map(int, input().split())\nweights = list(map(int, input().split()))\n\n# Sort the weights\nweights.sort()\n\n# Initialize the number of gondolas\ngondolas = 0\n\n# Iterate through the weights\ni = 0\nwhile i < n:\n    # If there are no more children, break the loop\n    if i == n:\n        break\n\n    # Increment the number of gondolas\n    gondolas += 1\n\n    # Try to pair the current child with the next child\n    if i < n - 1 and weights[i] + weights[i + 1] <= x:\n        i += 2\n    else:\n        i += 1\n\n# Print the result\nprint(gondolas)\n",
            "passed_test_cases": 9,
            "total_test_cases": 13,
            "mean_time_taken": 0.15125258152301496,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                7,
                8,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Fibonacci Numbers",
            "category": "Mathematics",
            "solution": "# Define the matrix for Fibonacci numbers\nF = [[1, 1],\n     [1, 0]]\n\n# Define the modulo value\nMOD = 10**9 + 7\n\ndef multiply(F, M):\n    x = (F[0][0] * M[0][0] + F[0][1] * M[1][0]) % MOD\n    y = (F[0][0] * M[0][1] + F[0][1] * M[1][1]) % MOD\n    z = (F[1][0] * M[0][0] + F[1][1] * M[1][0]) % MOD\n    w = (F[1][0] * M[0][1] + F[1][1] * M[1][1]) % MOD\n\n    return [[x, y],\n            [z, w]]\n\ndef power(F, n):\n    M = [[1, 0],\n         [0, 1]]\n\n    while n > 0:\n        if n % 2:\n            M = multiply(M, F)\n        n //= 2\n        F = multiply(F, F)\n\n    return M\n\ndef fib(n):\n    if n == 0:\n        return 0\n    else:\n        F_n = power(F, n - 1)\n        return F_n[0][0] % MOD\n\n# Read the input\nn = int(input())\n\n# Print the result\nprint(fib(n))\n",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.12262910604476929,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Filling Trominos",
            "category": "Additional Problems",
            "solution": "def fill_grid(n, m):\n    grid = [[' ' for _ in range(m)] for _ in range(n)]\n    letter = 'A'\n    for i in range(n):\n        for j in range(m):\n            if (i + j) % 3 == 0:\n                grid[i][j] = letter\n                if i < n - 1:\n                    grid[i+1][j] = letter\n                if j < m - 1:\n                    grid[i][j+1] = letter\n                letter = chr(ord(letter) + 1 if letter != 'Z' else ord('A'))\n    return grid\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        n, m = map(int, input().split())\n        if (n * m) % 3 != 0:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n            grid = fill_grid(n, m)\n            for row in grid:\n                print(''.join(row))\n\nsolve()\n",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.148368239402771,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding Borders",
            "category": "String Algorithms",
            "solution": "def z_function(s):\n    n = len(s)\n    z = [0] * n\n    l, r = 0, 0\n    for i in range(1, n):\n        if i <= r:\n            z[i] = min(r - i, z[i - l])\n        while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n            z[i] += 1\n        if i + z[i] > r:\n            l, r = i, i + z[i]\n    return z\n\ndef find_borders(s):\n    z = z_function(s)\n    borders = []\n    for i, zi in enumerate(z):\n        if zi == i:\n            borders.append(zi)\n    return borders\n\ns = input()\nborders = find_borders(s)\nprint(*borders)\n",
            "passed_test_cases": 0,
            "total_test_cases": 11,
            "mean_time_taken": 0.24354436180808328,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding Patterns",
            "category": "String Algorithms",
            "solution": "# Read the input string\nn = input().strip()\n\n# Read the number of patterns\nk = int(input().strip())\n\n# Initialize an empty list to store the patterns\npatterns = []\n\n# Read each pattern and append it to the list\nfor _ in range(k):\n    patterns.append(input().strip())\n\n# For each pattern, check if it appears in the string and print the result\nfor pattern in patterns:\n    if pattern in n:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
            "passed_test_cases": 15,
            "total_test_cases": 17,
            "mean_time_taken": 0.3444688881144804,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                8,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding Periods",
            "category": "String Algorithms",
            "solution": "def z_function(s):\n    n = len(s)\n    z = [0] * n\n    l, r = 0, 0\n    for i in range(1, n):\n        if i <= r:\n            z[i] = min(r - i, z[i - l])\n        while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n            z[i] += 1\n        if i + z[i] > r:\n            l, r = i, i + z[i]\n    return z\n\ndef find_periods(s):\n    n = len(s)\n    t = s + \"#\" + s\n    z = z_function(t)\n    periods = []\n    for i in range(1, 2 * n + 1):\n        if z[i] == n:\n            periods.append(i)\n    return periods\n\ns = input()\nperiods = find_periods(s)\nprint(*periods)\n",
            "passed_test_cases": 0,
            "total_test_cases": 14,
            "mean_time_taken": 0.43454534666878836,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding a Centroid",
            "category": "Tree Algorithms",
            "solution": "def dfs(node, parent, sizes):\n    size = 1\n    max_subtree = 0\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            subtree_size = dfs(neighbor, node, sizes)\n            size += subtree_size\n            max_subtree = max(max_subtree, subtree_size)\n    sizes[node] = size, max_subtree\n    return size\n\nn = int(input())\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\nsizes = [None] * (n + 1)\ndfs(1, None, sizes)\n\ncentroid = 1\nfor node in range(1, n + 1):\n    size, max_subtree = sizes[node]\n    if n - size > max_subtree:\n        centroid = node\n\nprint(centroid)\n",
            "passed_test_cases": 1,
            "total_test_cases": 16,
            "mean_time_taken": 0.21552027761936188,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FindingaCentroid_shot_1.py\", line 20, in <module>\n    dfs(1, None, sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FindingaCentroid_shot_1.py\", line 6, in dfs\n    subtree_size = dfs(neighbor, node, sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FindingaCentroid_shot_1.py\", line 6, in dfs\n    subtree_size = dfs(neighbor, node, sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FindingaCentroid_shot_1.py\", line 6, in dfs\n    subtree_size = dfs(neighbor, node, sizes)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FindingaCentroid_shot_1.py\", line 5, in dfs\n    if neighbor != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FindingaCentroid_shot_1.py\", line 20, in <module>\n    dfs(1, None, sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FindingaCentroid_shot_1.py\", line 6, in dfs\n    subtree_size = dfs(neighbor, node, sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FindingaCentroid_shot_1.py\", line 6, in dfs\n    subtree_size = dfs(neighbor, node, sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FindingaCentroid_shot_1.py\", line 6, in dfs\n    subtree_size = dfs(neighbor, node, sizes)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FindingaCentroid_shot_1.py\", line 5, in dfs\n    if neighbor != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FindingaCentroid_shot_1.py\", line 20, in <module>\n    dfs(1, None, sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FindingaCentroid_shot_1.py\", line 6, in dfs\n    subtree_size = dfs(neighbor, node, sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FindingaCentroid_shot_1.py\", line 6, in dfs\n    subtree_size = dfs(neighbor, node, sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FindingaCentroid_shot_1.py\", line 6, in dfs\n    subtree_size = dfs(neighbor, node, sizes)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FindingaCentroid_shot_1.py\", line 5, in dfs\n    if neighbor != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FindingaCentroid_shot_1.py\", line 20, in <module>\n    dfs(1, None, sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FindingaCentroid_shot_1.py\", line 6, in dfs\n    subtree_size = dfs(neighbor, node, sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FindingaCentroid_shot_1.py\", line 6, in dfs\n    subtree_size = dfs(neighbor, node, sizes)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FindingaCentroid_shot_1.py\", line 6, in dfs\n    subtree_size = dfs(neighbor, node, sizes)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FindingaCentroid_shot_1.py\", line 5, in dfs\n    if neighbor != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Fixed-Length Paths I",
            "category": "Tree Algorithms",
            "solution": "def dfs(node, depth, k, graph, count):\n    if depth == k:\n        count[0] += 1\n        return\n    for child in graph[node]:\n        dfs(child, depth + 1, k, graph, count)\n\ndef count_paths(n, k, edges):\n    graph = [[] for _ in range(n + 1)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = [0]\n    for i in range(1, n + 1):\n        dfs(i, 1, k, graph, count)\n    return count[0] // 2\n\nn, k = map(int, input().split())\nedges = [list(map(int, input().split())) for _ in range(n - 1)]\nprint(count_paths(n, k, edges))\n",
            "passed_test_cases": 0,
            "total_test_cases": 20,
            "mean_time_taken": 0.4926576495170593,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 20, in <module>\n    print(count_paths(n, k, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 15, in count_paths\n    dfs(i, 1, k, graph, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 6, in dfs\n    dfs(child, depth + 1, k, graph, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 6, in dfs\n    dfs(child, depth + 1, k, graph, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 6, in dfs\n    dfs(child, depth + 1, k, graph, count)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 2, in dfs\n    if depth == k:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 20, in <module>\n    print(count_paths(n, k, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 15, in count_paths\n    dfs(i, 1, k, graph, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 6, in dfs\n    dfs(child, depth + 1, k, graph, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 6, in dfs\n    dfs(child, depth + 1, k, graph, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 6, in dfs\n    dfs(child, depth + 1, k, graph, count)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 2, in dfs\n    if depth == k:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 20, in <module>\n    print(count_paths(n, k, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 15, in count_paths\n    dfs(i, 1, k, graph, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 6, in dfs\n    dfs(child, depth + 1, k, graph, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 6, in dfs\n    dfs(child, depth + 1, k, graph, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 6, in dfs\n    dfs(child, depth + 1, k, graph, count)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 2, in dfs\n    if depth == k:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 20, in <module>\n    print(count_paths(n, k, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 15, in count_paths\n    dfs(i, 1, k, graph, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 6, in dfs\n    dfs(child, depth + 1, k, graph, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 6, in dfs\n    dfs(child, depth + 1, k, graph, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 6, in dfs\n    dfs(child, depth + 1, k, graph, count)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 2, in dfs\n    if depth == k:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 20, in <module>\n    print(count_paths(n, k, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 15, in count_paths\n    dfs(i, 1, k, graph, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 6, in dfs\n    dfs(child, depth + 1, k, graph, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 6, in dfs\n    dfs(child, depth + 1, k, graph, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 6, in dfs\n    dfs(child, depth + 1, k, graph, count)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 2, in dfs\n    if depth == k:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 20, in <module>\n    print(count_paths(n, k, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 15, in count_paths\n    dfs(i, 1, k, graph, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 6, in dfs\n    dfs(child, depth + 1, k, graph, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 6, in dfs\n    dfs(child, depth + 1, k, graph, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 6, in dfs\n    dfs(child, depth + 1, k, graph, count)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 2, in dfs\n    if depth == k:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 20, in <module>\n    print(count_paths(n, k, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 15, in count_paths\n    dfs(i, 1, k, graph, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 6, in dfs\n    dfs(child, depth + 1, k, graph, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 6, in dfs\n    dfs(child, depth + 1, k, graph, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 6, in dfs\n    dfs(child, depth + 1, k, graph, count)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 2, in dfs\n    if depth == k:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 20, in <module>\n    print(count_paths(n, k, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 15, in count_paths\n    dfs(i, 1, k, graph, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 6, in dfs\n    dfs(child, depth + 1, k, graph, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 6, in dfs\n    dfs(child, depth + 1, k, graph, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 6, in dfs\n    dfs(child, depth + 1, k, graph, count)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsI_shot_1.py\", line 2, in dfs\n    if depth == k:\nRecursionError: maximum recursion depth exceeded in comparison\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Fixed-Length Paths II",
            "category": "Tree Algorithms",
            "solution": "def dfs(node, depth, k1, k2):\n    global paths\n    if depth >= k1 and depth <= k2:\n        paths += 1\n    if depth == k2:\n        return\n    for child in graph[node]:\n        dfs(child, depth + 1, k1, k2)\n\nn, k1, k2 = map(int, input().split())\ngraph = {i: [] for i in range(1, n + 1)}\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\npaths = 0\nfor node in graph:\n    dfs(node, 0, k1, k2)\n    for child in graph[node]:\n        graph[child].remove(node)\n        paths -= dfs(child, 1, k1, k2)\n        graph[child].append(node)\n\nprint(paths // 2)\n",
            "passed_test_cases": 1,
            "total_test_cases": 23,
            "mean_time_taken": 0.47572740264560864,
            "mean_memory_used": 736.8695652173913,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 19, in <module>\n    dfs(node, 0, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 3, in dfs\n    if depth >= k1 and depth <= k2:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 19, in <module>\n    dfs(node, 0, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 3, in dfs\n    if depth >= k1 and depth <= k2:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 22, in <module>\n    paths -= dfs(child, 1, k1, k2)\nTypeError: unsupported operand type(s) for -=: 'int' and 'NoneType'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 19, in <module>\n    dfs(node, 0, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 3, in dfs\n    if depth >= k1 and depth <= k2:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 19, in <module>\n    dfs(node, 0, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 3, in dfs\n    if depth >= k1 and depth <= k2:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 22, in <module>\n    paths -= dfs(child, 1, k1, k2)\nTypeError: unsupported operand type(s) for -=: 'int' and 'NoneType'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 22, in <module>\n    paths -= dfs(child, 1, k1, k2)\nTypeError: unsupported operand type(s) for -=: 'int' and 'NoneType'\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 19, in <module>\n    dfs(node, 0, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 3, in dfs\n    if depth >= k1 and depth <= k2:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 19, in <module>\n    dfs(node, 0, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 3, in dfs\n    if depth >= k1 and depth <= k2:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 22, in <module>\n    paths -= dfs(child, 1, k1, k2)\nTypeError: unsupported operand type(s) for -=: 'int' and 'NoneType'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 19, in <module>\n    dfs(node, 0, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 3, in dfs\n    if depth >= k1 and depth <= k2:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 22, in <module>\n    paths -= dfs(child, 1, k1, k2)\nTypeError: unsupported operand type(s) for -=: 'int' and 'NoneType'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 19, in <module>\n    dfs(node, 0, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 3, in dfs\n    if depth >= k1 and depth <= k2:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 22, in <module>\n    paths -= dfs(child, 1, k1, k2)\nTypeError: unsupported operand type(s) for -=: 'int' and 'NoneType'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 19, in <module>\n    dfs(node, 0, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 3, in dfs\n    if depth >= k1 and depth <= k2:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 19, in <module>\n    dfs(node, 0, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 3, in dfs\n    if depth >= k1 and depth <= k2:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 19, in <module>\n    dfs(node, 0, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 3, in dfs\n    if depth >= k1 and depth <= k2:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 19, in <module>\n    dfs(node, 0, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 8, in dfs\n    dfs(child, depth + 1, k1, k2)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Fixed-LengthPathsII_shot_1.py\", line 3, in dfs\n    if depth >= k1 and depth <= k2:\nRecursionError: maximum recursion depth exceeded in comparison\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Flight Discount",
            "category": "Graph Algorithms",
            "solution": "import heapq\n\ndef dijkstra(n, m, flights):\n    graph = [[] for _ in range(n + 1)]\n    for a, b, c in flights:\n        graph[a].append((b, c))\n\n    dist = [float('inf')] * (n + 1)\n    dist_with_coupon = [float('inf')] * (n + 1)\n    dist[1] = 0\n    dist_with_coupon[1] = 0\n\n    pq = [(0, 1, False)]\n    while pq:\n        d, node, coupon_used = heapq.heappop(pq)\n        if coupon_used:\n            if d > dist_with_coupon[node]:\n                continue\n        else:\n            if d > dist[node]:\n                continue\n\n        for next_node, next_d in graph[node]:\n            new_d = d + next_d\n            if not coupon_used:\n                if new_d // 2 < dist_with_coupon[next_node]:\n                    dist_with_coupon[next_node] = new_d // 2\n                    heapq.heappush(pq, (new_d // 2, next_node, True))\n\n                if new_d < dist[next_node]:\n                    dist[next_node] = new_d\n                    heapq.heappush(pq, (new_d, next_node, False))\n            else:\n                if new_d < dist[next_node]:\n                    dist[next_node] = new_d\n                    heapq.heappush(pq, (new_d, next_node, False))\n\n    return min(dist[n], dist_with_coupon[n])\n\n# Test the function\nn, m = map(int, input().split())\nflights = [tuple(map(int, input().split())) for _ in range(m)]\nprint(dijkstra(n, m, flights))\n",
            "passed_test_cases": 1,
            "total_test_cases": 24,
            "mean_time_taken": 0.30774709582328796,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Flight Route Requests",
            "category": "Additional Problems",
            "solution": "def find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, a, b):\n    a = find(parent, a)\n    b = find(parent, b)\n    if a < b:\n        parent[b] = a\n    else:\n        parent[a] = b\n\nn, m = map(int, input().split())\nparent = list(range(n+1))\nfor _ in range(m):\n    a, b = map(int, input().split())\n    union(parent, a, b)\n\ngroups = set(find(parent, i) for i in range(1, n+1))\nresult = n - len(groups)\nprint(result)\n",
            "passed_test_cases": 8,
            "total_test_cases": 17,
            "mean_time_taken": 0.15826481931349812,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                9,
                11,
                12,
                15,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Flight Routes",
            "category": "Graph Algorithms",
            "solution": "import heapq\nimport sys\n\ndef dijkstra(n, m, k, flights):\n    graph = [[] for _ in range(n + 1)]\n    for a, b, c in flights:\n        graph[a].append((b, c))\n\n    dist = [sys.maxsize] * (n + 1)\n    dist[1] = 0\n    pq = [(0, 1)]\n\n    while pq:\n        d, u = heapq.heappop(pq)\n\n        if d > dist[u]:\n            continue\n\n        for v, c in graph[u]:\n            alt = d + c\n            if alt < dist[v]:\n                dist[v] = alt\n                heapq.heappush(pq, (alt, v))\n\n    return dist[n]\n\ndef flight_routes(n, m, k, flights):\n    prices = []\n    for _ in range(k):\n        price = dijkstra(n, m, k, flights)\n        prices.append(price)\n        flights.remove((1, price[1], price[2]))\n    return prices\n\nif __name__ == \"__main__\":\n    n, m, k = map(int, input().split())\n    flights = [tuple(map(int, input().split())) for _ in range(m)]\n    print(*flight_routes(n, m, k, flights))\n",
            "passed_test_cases": 0,
            "total_test_cases": 17,
            "mean_time_taken": 0.27721604178933534,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 38, in <module>\n    print(*flight_routes(n, m, k, flights))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 32, in flight_routes\n    flights.remove((1, price[1], price[2]))\nTypeError: 'int' object is not subscriptable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 38, in <module>\n    print(*flight_routes(n, m, k, flights))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 32, in flight_routes\n    flights.remove((1, price[1], price[2]))\nTypeError: 'int' object is not subscriptable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 38, in <module>\n    print(*flight_routes(n, m, k, flights))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 32, in flight_routes\n    flights.remove((1, price[1], price[2]))\nTypeError: 'int' object is not subscriptable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 38, in <module>\n    print(*flight_routes(n, m, k, flights))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 32, in flight_routes\n    flights.remove((1, price[1], price[2]))\nTypeError: 'int' object is not subscriptable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 38, in <module>\n    print(*flight_routes(n, m, k, flights))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 32, in flight_routes\n    flights.remove((1, price[1], price[2]))\nTypeError: 'int' object is not subscriptable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 38, in <module>\n    print(*flight_routes(n, m, k, flights))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 32, in flight_routes\n    flights.remove((1, price[1], price[2]))\nTypeError: 'int' object is not subscriptable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 38, in <module>\n    print(*flight_routes(n, m, k, flights))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 32, in flight_routes\n    flights.remove((1, price[1], price[2]))\nTypeError: 'int' object is not subscriptable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 38, in <module>\n    print(*flight_routes(n, m, k, flights))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 32, in flight_routes\n    flights.remove((1, price[1], price[2]))\nTypeError: 'int' object is not subscriptable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 38, in <module>\n    print(*flight_routes(n, m, k, flights))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 32, in flight_routes\n    flights.remove((1, price[1], price[2]))\nTypeError: 'int' object is not subscriptable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 38, in <module>\n    print(*flight_routes(n, m, k, flights))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 32, in flight_routes\n    flights.remove((1, price[1], price[2]))\nTypeError: 'int' object is not subscriptable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 38, in <module>\n    print(*flight_routes(n, m, k, flights))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 32, in flight_routes\n    flights.remove((1, price[1], price[2]))\nTypeError: 'int' object is not subscriptable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 38, in <module>\n    print(*flight_routes(n, m, k, flights))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 32, in flight_routes\n    flights.remove((1, price[1], price[2]))\nTypeError: 'int' object is not subscriptable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 38, in <module>\n    print(*flight_routes(n, m, k, flights))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 32, in flight_routes\n    flights.remove((1, price[1], price[2]))\nTypeError: 'int' object is not subscriptable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 38, in <module>\n    print(*flight_routes(n, m, k, flights))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 32, in flight_routes\n    flights.remove((1, price[1], price[2]))\nTypeError: 'int' object is not subscriptable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 38, in <module>\n    print(*flight_routes(n, m, k, flights))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 32, in flight_routes\n    flights.remove((1, price[1], price[2]))\nTypeError: 'int' object is not subscriptable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 38, in <module>\n    print(*flight_routes(n, m, k, flights))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 32, in flight_routes\n    flights.remove((1, price[1], price[2]))\nTypeError: 'int' object is not subscriptable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 38, in <module>\n    print(*flight_routes(n, m, k, flights))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FlightRoutes_shot_1.py\", line 32, in flight_routes\n    flights.remove((1, price[1], price[2]))\nTypeError: 'int' object is not subscriptable\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Flight Routes Check",
            "category": "Graph Algorithms",
            "solution": "def tarjan(node, low, disc, stack, visited, graph):\n    disc[node] = low[node] = len(visited)\n    visited.append(node)\n    stack.append(node)\n\n    for neighbour in graph[node]:\n        if disc[neighbour] == -1:\n            low[node] = min(low[node], tarjan(neighbour, low, disc, stack, visited, graph))\n        elif neighbour in stack:\n            low[node] = min(low[node], disc[neighbour])\n\n    if low[node] == disc[node]:\n        scc = []\n        while stack:\n            top = stack.pop()\n            if top == node:\n                break\n            scc.append(top)\n        if len(scc) > 1 or (len(scc) == 1 and len(graph[node]) > 0):\n            return False\n\n    return low[node]\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n+1)]\n    for a, b in edges:\n        graph[a].append(b)\n\n    disc = [-1] * (n+1)\n    low = [-1] * (n+1)\n    stack = []\n    visited = []\n\n    for i in range(1, n+1):\n        if disc[i] == -1:\n            if tarjan(i, low, disc, stack, visited, graph) == False:\n                return \"NO\\n{} {}\".format(i, i+1 if i != n else 1)\n\n    return \"YES\"\n",
            "passed_test_cases": 0,
            "total_test_cases": 20,
            "mean_time_taken": 0.11652437448501587,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Food Division",
            "category": "Additional Problems",
            "solution": "# Read the number of children\nn = int(input())\n\n# Read the current amount of food for each child\ncurrent_food = list(map(int, input().split()))\n\n# Read the required amount of food for each child\nrequired_food = list(map(int, input().split()))\n\n# Calculate the total amount of food that needs to be moved\ntotal_moves = sum([abs(current - required) for current, required in zip(current_food, required_food[1:] + [required_food[0]])])\n\n# Print the result\nprint(total_moves // 2)\n",
            "passed_test_cases": 2,
            "total_test_cases": 5,
            "mean_time_taken": 0.14077601432800294,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Forbidden Cities",
            "category": "Additional Problems",
            "solution": "def dfs(graph, node, target, avoided_node):\n    if node == target:\n        return True\n    if node in graph:\n        for neighbor in graph[node]:\n            if neighbor != avoided_node:\n                if dfs(graph, neighbor, target, avoided_node):\n                    return True\n    return False\n\ndef forbidden_cities():\n    n, m, q = map(int, input().split())\n    graph = {}\n    for _ in range(m):\n        a, b = map(int, input().split())\n        if a not in graph:\n            graph[a] = []\n        if b not in graph:\n            graph[b] = []\n        graph[a].append(b)\n        graph[b].append(a)\n    for _ in range(q):\n        a, b, c = map(int, input().split())\n        if dfs(graph, a, b, c):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nforbidden_cities()\n",
            "passed_test_cases": 1,
            "total_test_cases": 14,
            "mean_time_taken": 0.19574497427259172,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 29, in <module>\n    forbidden_cities()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 24, in forbidden_cities\n    if dfs(graph, a, b, c):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 2, in dfs\n    if node == target:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 29, in <module>\n    forbidden_cities()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 24, in forbidden_cities\n    if dfs(graph, a, b, c):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 2, in dfs\n    if node == target:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 29, in <module>\n    forbidden_cities()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 24, in forbidden_cities\n    if dfs(graph, a, b, c):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 2, in dfs\n    if node == target:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 29, in <module>\n    forbidden_cities()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 24, in forbidden_cities\n    if dfs(graph, a, b, c):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 2, in dfs\n    if node == target:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 29, in <module>\n    forbidden_cities()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 24, in forbidden_cities\n    if dfs(graph, a, b, c):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 2, in dfs\n    if node == target:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 29, in <module>\n    forbidden_cities()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 24, in forbidden_cities\n    if dfs(graph, a, b, c):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 2, in dfs\n    if node == target:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 29, in <module>\n    forbidden_cities()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 24, in forbidden_cities\n    if dfs(graph, a, b, c):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 2, in dfs\n    if node == target:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 29, in <module>\n    forbidden_cities()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 24, in forbidden_cities\n    if dfs(graph, a, b, c):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 2, in dfs\n    if node == target:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 29, in <module>\n    forbidden_cities()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 24, in forbidden_cities\n    if dfs(graph, a, b, c):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 2, in dfs\n    if node == target:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 29, in <module>\n    forbidden_cities()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 24, in forbidden_cities\n    if dfs(graph, a, b, c):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 2, in dfs\n    if node == target:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 29, in <module>\n    forbidden_cities()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 24, in forbidden_cities\n    if dfs(graph, a, b, c):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 2, in dfs\n    if node == target:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 29, in <module>\n    forbidden_cities()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 24, in forbidden_cities\n    if dfs(graph, a, b, c):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 2, in dfs\n    if node == target:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 29, in <module>\n    forbidden_cities()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 24, in forbidden_cities\n    if dfs(graph, a, b, c):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 7, in dfs\n    if dfs(graph, neighbor, target, avoided_node):\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ForbiddenCities_shot_1.py\", line 2, in dfs\n    if node == target:\nRecursionError: maximum recursion depth exceeded in comparison\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Forest Queries",
            "category": "Range Queries",
            "solution": "# Read the size of the forest and the number of queries\nn, q = map(int, input().split())\n\n# Read the forest into an n x n grid\nforest = [list(input()) for _ in range(n)]\n\n# Initialize a prefix sum grid of the same size\nprefix_sum = [[0] * (n + 1) for _ in range(n + 1)]\n\n# Process each cell in the grid\nfor i in range(1, n + 1):\n    for j in range(1, n + 1):\n        if forest[i - 1][j - 1] == '*':\n            prefix_sum[i][j] = prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1] + 1\n        else:\n            prefix_sum[i][j] = prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n# Read each query and calculate the number of trees in the given rectangle\nfor _ in range(q):\n    y1, x1, y2, x2 = map(int, input().split())\n    result = prefix_sum[y2][x2] - prefix_sum[y1 - 1][x2] - prefix_sum[y2][x1 - 1] + prefix_sum[y1 - 1][x1 - 1]\n    print(result)\n",
            "passed_test_cases": 3,
            "total_test_cases": 3,
            "mean_time_taken": 0.6097466150919596,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Forest Queries II",
            "category": "Range Queries",
            "solution": "def main():\n    # Read input\n    n, q = map(int, input().split())\n    grid = [list(input()) for _ in range(n)]\n    queries = [list(map(int, input().split())) for _ in range(q)]\n\n    # Initialize prefix sum array\n    prefix_sum = [[0] * (n + 1) for _ in range(n + 1)]\n\n    # Build prefix sum array\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            prefix_sum[i][j] = prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n            if grid[i - 1][j - 1] == '*':\n                prefix_sum[i][j] += 1\n\n    # Process queries\n    for query in queries:\n        query_type = query[0]\n        if query_type == 1:\n            y, x = query[1], query[2]\n            if grid[y - 1][x - 1] == '.':\n                grid[y - 1][x - 1] = '*'\n                prefix_sum[y][x] += 1\n            else:\n                grid[y - 1][x - 1] = '.'\n                prefix_sum[y][x] -= 1\n        elif query_type == 2:\n            y1, x1, y2, x2 = query[1], query[2], query[3], query[4]\n            result = prefix_sum[y2][x2] - prefix_sum[y1 - 1][x2] - prefix_sum[y2][x1 - 1] + prefix_sum[y1 - 1][x1 - 1]\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n",
            "passed_test_cases": 2,
            "total_test_cases": 5,
            "mean_time_taken": 0.5136368274688721,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Functional Graph Distribution",
            "category": "Additional Problems",
            "solution": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\nMAX = 5000\n\nfact = [0] * (MAX + 1)\nfact[0] = 1\nfor i in range(1, MAX + 1):\n    fact[i] = fact[i - 1] * i % MOD\n\ninv = [0] * (MAX + 1)\ninv[MAX] = pow(fact[MAX], MOD - 2, MOD)\nfor i in range(MAX, 0, -1):\n    inv[i - 1] = inv[i] * i % MOD\n\ndef S1(n, k):\n    if n == k:\n        return 1\n    if k == 1:\n        return fact[n - 1]\n    if k == n - 1:\n        return (n - 1) * S1(n - 1, n - 1) % MOD\n    return (S1(n - 1, k - 1) + (n - 1) * S1(n - 1, k)) % MOD\n\ndef f(n, k):\n    return S1(n, k) * inv[n - k] % MOD\n\nn = int(input().strip())\nfor k in range(1, n + 1):\n    print(f(n, k))\n",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.48255154490470886,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FunctionalGraphDistribution_shot_1.py\", line 31, in <module>\n    print(f(n, k))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FunctionalGraphDistribution_shot_1.py\", line 27, in f\n    return S1(n, k) * inv[n - k] % MOD\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FunctionalGraphDistribution_shot_1.py\", line 24, in S1\n    return (S1(n - 1, k - 1) + (n - 1) * S1(n - 1, k)) % MOD\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FunctionalGraphDistribution_shot_1.py\", line 24, in S1\n    return (S1(n - 1, k - 1) + (n - 1) * S1(n - 1, k)) % MOD\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FunctionalGraphDistribution_shot_1.py\", line 24, in S1\n    return (S1(n - 1, k - 1) + (n - 1) * S1(n - 1, k)) % MOD\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FunctionalGraphDistribution_shot_1.py\", line 18, in S1\n    if n == k:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FunctionalGraphDistribution_shot_1.py\", line 31, in <module>\n    print(f(n, k))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FunctionalGraphDistribution_shot_1.py\", line 27, in f\n    return S1(n, k) * inv[n - k] % MOD\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FunctionalGraphDistribution_shot_1.py\", line 24, in S1\n    return (S1(n - 1, k - 1) + (n - 1) * S1(n - 1, k)) % MOD\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FunctionalGraphDistribution_shot_1.py\", line 24, in S1\n    return (S1(n - 1, k - 1) + (n - 1) * S1(n - 1, k)) % MOD\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FunctionalGraphDistribution_shot_1.py\", line 24, in S1\n    return (S1(n - 1, k - 1) + (n - 1) * S1(n - 1, k)) % MOD\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/FunctionalGraphDistribution_shot_1.py\", line 18, in S1\n    if n == k:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Game Routes",
            "category": "Graph Algorithms",
            "solution": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\ndef game_routes():\n    n, m = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for i in range(n, 0, -1):\n        for j in graph[i]:\n            dp[i] = (dp[i] + dp[j]) % MOD\n    return dp[1]\n\nif __name__ == \"__main__\":\n    print(game_routes())\n",
            "passed_test_cases": 5,
            "total_test_cases": 15,
            "mean_time_taken": 0.15712477366129557,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                5,
                6,
                8,
                9,
                10,
                11,
                12,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Giant Pizza",
            "category": "Graph Algorithms",
            "solution": "# Read the input\nn, m = map(int, input().split())\nwishes = [input().split() for _ in range(n)]\n\n# Create the toppings list\ntoppings = ['-'] * m\n\n# Try to satisfy all wishes\nfor wish in wishes:\n    if wish[0] == '+':\n        if toppings[int(wish[1]) - 1] == '-' and all(wish[1] != w[1] or w[0] == '-' for w in wishes):\n            toppings[int(wish[1]) - 1] = '+'\n    elif wish[0] == '-':\n        if toppings[int(wish[1]) - 1] == '+' and all(wish[1] != w[1] or w[0] == '+' for w in wishes):\n            toppings[int(wish[1]) - 1] = '-'\n\n# Check if all wishes are satisfied\nif all(wish[0] == '+' and toppings[int(wish[1]) - 1] == '+' or wish[0] == '-' and toppings[int(wish[1]) - 1] == '-' for wish in wishes):\n    print(''.join(toppings))\nelse:\n    print(\"IMPOSSIBLE\")\n",
            "passed_test_cases": 2,
            "total_test_cases": 22,
            "mean_time_taken": 0.4135558713566173,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                22
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Graph Girth",
            "category": "Additional Problems",
            "solution": "from collections import defaultdict\n\ndef girth(n, m, edges):\n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    visited = [False] * (n + 1)\n    parent = [None] * (n + 1)\n    depth = [-1] * (n + 1)\n    min_cycle = float('inf')\n\n    def bfs(node):\n        queue = [node]\n        visited[node] = True\n        depth[node] = 0\n        while queue:\n            current = queue.pop(0)\n            for neighbor in graph[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    parent[neighbor] = current\n                    depth[neighbor] = depth[current] + 1\n                    queue.append(neighbor)\n                elif parent[current] != neighbor:\n                    cycle_length = depth[current] - depth[neighbor] + 1\n                    min_cycle = min(min_cycle, cycle_length)\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            bfs(i)\n\n    return min_cycle if min_cycle != float('inf') else -1\n\n# Test the function\nn, m = 5, 6\nedges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 4), (4, 5)]\nprint(girth(n, m, edges))  # Output: 3\n",
            "passed_test_cases": 0,
            "total_test_cases": 20,
            "mean_time_taken": 0.14992878437042237,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 39, in <module>\n    print(girth(n, m, edges))  # Output: 3\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 32, in girth\n    bfs(i)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 28, in bfs\n    min_cycle = min(min_cycle, cycle_length)\nUnboundLocalError: local variable 'min_cycle' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 39, in <module>\n    print(girth(n, m, edges))  # Output: 3\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 32, in girth\n    bfs(i)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 28, in bfs\n    min_cycle = min(min_cycle, cycle_length)\nUnboundLocalError: local variable 'min_cycle' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 39, in <module>\n    print(girth(n, m, edges))  # Output: 3\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 32, in girth\n    bfs(i)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 28, in bfs\n    min_cycle = min(min_cycle, cycle_length)\nUnboundLocalError: local variable 'min_cycle' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 39, in <module>\n    print(girth(n, m, edges))  # Output: 3\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 32, in girth\n    bfs(i)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 28, in bfs\n    min_cycle = min(min_cycle, cycle_length)\nUnboundLocalError: local variable 'min_cycle' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 39, in <module>\n    print(girth(n, m, edges))  # Output: 3\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 32, in girth\n    bfs(i)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 28, in bfs\n    min_cycle = min(min_cycle, cycle_length)\nUnboundLocalError: local variable 'min_cycle' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 39, in <module>\n    print(girth(n, m, edges))  # Output: 3\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 32, in girth\n    bfs(i)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 28, in bfs\n    min_cycle = min(min_cycle, cycle_length)\nUnboundLocalError: local variable 'min_cycle' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 39, in <module>\n    print(girth(n, m, edges))  # Output: 3\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 32, in girth\n    bfs(i)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 28, in bfs\n    min_cycle = min(min_cycle, cycle_length)\nUnboundLocalError: local variable 'min_cycle' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 39, in <module>\n    print(girth(n, m, edges))  # Output: 3\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 32, in girth\n    bfs(i)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 28, in bfs\n    min_cycle = min(min_cycle, cycle_length)\nUnboundLocalError: local variable 'min_cycle' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 39, in <module>\n    print(girth(n, m, edges))  # Output: 3\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 32, in girth\n    bfs(i)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 28, in bfs\n    min_cycle = min(min_cycle, cycle_length)\nUnboundLocalError: local variable 'min_cycle' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 39, in <module>\n    print(girth(n, m, edges))  # Output: 3\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 32, in girth\n    bfs(i)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 28, in bfs\n    min_cycle = min(min_cycle, cycle_length)\nUnboundLocalError: local variable 'min_cycle' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 39, in <module>\n    print(girth(n, m, edges))  # Output: 3\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 32, in girth\n    bfs(i)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 28, in bfs\n    min_cycle = min(min_cycle, cycle_length)\nUnboundLocalError: local variable 'min_cycle' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 39, in <module>\n    print(girth(n, m, edges))  # Output: 3\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 32, in girth\n    bfs(i)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 28, in bfs\n    min_cycle = min(min_cycle, cycle_length)\nUnboundLocalError: local variable 'min_cycle' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 39, in <module>\n    print(girth(n, m, edges))  # Output: 3\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 32, in girth\n    bfs(i)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 28, in bfs\n    min_cycle = min(min_cycle, cycle_length)\nUnboundLocalError: local variable 'min_cycle' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 39, in <module>\n    print(girth(n, m, edges))  # Output: 3\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 32, in girth\n    bfs(i)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 28, in bfs\n    min_cycle = min(min_cycle, cycle_length)\nUnboundLocalError: local variable 'min_cycle' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 39, in <module>\n    print(girth(n, m, edges))  # Output: 3\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 32, in girth\n    bfs(i)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 28, in bfs\n    min_cycle = min(min_cycle, cycle_length)\nUnboundLocalError: local variable 'min_cycle' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 39, in <module>\n    print(girth(n, m, edges))  # Output: 3\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 32, in girth\n    bfs(i)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 28, in bfs\n    min_cycle = min(min_cycle, cycle_length)\nUnboundLocalError: local variable 'min_cycle' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 39, in <module>\n    print(girth(n, m, edges))  # Output: 3\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 32, in girth\n    bfs(i)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 28, in bfs\n    min_cycle = min(min_cycle, cycle_length)\nUnboundLocalError: local variable 'min_cycle' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 39, in <module>\n    print(girth(n, m, edges))  # Output: 3\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 32, in girth\n    bfs(i)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 28, in bfs\n    min_cycle = min(min_cycle, cycle_length)\nUnboundLocalError: local variable 'min_cycle' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 39, in <module>\n    print(girth(n, m, edges))  # Output: 3\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 32, in girth\n    bfs(i)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 28, in bfs\n    min_cycle = min(min_cycle, cycle_length)\nUnboundLocalError: local variable 'min_cycle' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 39, in <module>\n    print(girth(n, m, edges))  # Output: 3\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 32, in girth\n    bfs(i)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphGirth_shot_1.py\", line 28, in bfs\n    min_cycle = min(min_cycle, cycle_length)\nUnboundLocalError: local variable 'min_cycle' referenced before assignment\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Graph Paths I",
            "category": "Mathematics",
            "solution": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\ndef dfs(node, length):\n    if length == k:\n        return 1 if node == n else 0\n    count = 0\n    for neighbor in graph[node]:\n        if not visited[neighbor]:\n            visited[neighbor] = True\n            count += dfs(neighbor, length + 1)\n            visited[neighbor] = False\n    return count % MOD\n\nn, m, k = map(int, input().split())\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\nvisited = [False] * (n + 1)\nvisited[1] = True\nprint(dfs(1, 0))\n",
            "passed_test_cases": 4,
            "total_test_cases": 14,
            "mean_time_taken": 0.5785440376826695,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Graph Paths II",
            "category": "Mathematics",
            "solution": "import sys\n\ndef read_input():\n    n, m, k = map(int, sys.stdin.readline().split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b, c = map(int, sys.stdin.readline().split())\n        graph[a].append((b, c))\n    return n, k, graph\n\ndef dfs(node, path_length, current_length, dp, graph):\n    if path_length == 0:\n        return float('inf') if node != len(dp) - 1 else 0\n    if dp[node][path_length] != -1:\n        return dp[node][path_length]\n    min_length = float('inf')\n    for next_node, edge_weight in graph[node]:\n        min_length = min(min_length, dfs(next_node, path_length - 1, current_length + edge_weight, dp, graph))\n    dp[node][path_length] = min_length + current_length\n    return dp[node][path_length]\n\ndef main():\n    _, k, graph = read_input()\n    dp = [[-1] * (k + 1) for _ in range(len(graph))]\n    print(dfs(1, k, 0, dp, graph) if k else graph[1][0][1] if graph[1] else -1)\n\nif __name__ == \"__main__\":\n    main()\n",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.1360712210337321,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphPathsII_shot_1.py\", line 28, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphPathsII_shot_1.py\", line 24, in main\n    dp = [[-1] * (k + 1) for _ in range(len(graph))]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphPathsII_shot_1.py\", line 24, in <listcomp>\n    dp = [[-1] * (k + 1) for _ in range(len(graph))]\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphPathsII_shot_1.py\", line 28, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphPathsII_shot_1.py\", line 24, in main\n    dp = [[-1] * (k + 1) for _ in range(len(graph))]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphPathsII_shot_1.py\", line 24, in <listcomp>\n    dp = [[-1] * (k + 1) for _ in range(len(graph))]\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphPathsII_shot_1.py\", line 28, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphPathsII_shot_1.py\", line 24, in main\n    dp = [[-1] * (k + 1) for _ in range(len(graph))]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphPathsII_shot_1.py\", line 24, in <listcomp>\n    dp = [[-1] * (k + 1) for _ in range(len(graph))]\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphPathsII_shot_1.py\", line 28, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphPathsII_shot_1.py\", line 24, in main\n    dp = [[-1] * (k + 1) for _ in range(len(graph))]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphPathsII_shot_1.py\", line 24, in <listcomp>\n    dp = [[-1] * (k + 1) for _ in range(len(graph))]\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphPathsII_shot_1.py\", line 28, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphPathsII_shot_1.py\", line 24, in main\n    dp = [[-1] * (k + 1) for _ in range(len(graph))]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphPathsII_shot_1.py\", line 24, in <listcomp>\n    dp = [[-1] * (k + 1) for _ in range(len(graph))]\nMemoryError\n",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphPathsII_shot_1.py\", line 28, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphPathsII_shot_1.py\", line 24, in main\n    dp = [[-1] * (k + 1) for _ in range(len(graph))]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphPathsII_shot_1.py\", line 24, in <listcomp>\n    dp = [[-1] * (k + 1) for _ in range(len(graph))]\nMemoryError\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphPathsII_shot_1.py\", line 28, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphPathsII_shot_1.py\", line 24, in main\n    dp = [[-1] * (k + 1) for _ in range(len(graph))]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GraphPathsII_shot_1.py\", line 24, in <listcomp>\n    dp = [[-1] * (k + 1) for _ in range(len(graph))]\nMemoryError\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Gray Code",
            "category": "Introductory Problems",
            "solution": "def gray_code(n):\n    codes = ['0']\n    for i in range(n):\n        new_codes = codes[:]\n        new_codes.reverse()\n        for code in new_codes:\n            codes.append('1' + code)\n        for j in range(len(codes)):\n            codes[j] = '0' * (i+1) + codes[j]\n    return '\\n'.join(codes)\n\nn = int(input())\nprint(gray_code(n))\n",
            "passed_test_cases": 0,
            "total_test_cases": 16,
            "mean_time_taken": 0.1247209757566452,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Completion",
            "category": "Additional Problems",
            "solution": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\ndef mul(a, b):\n    return (a * b) % MOD\n\ndef power(a, b):\n    res = 1\n    while b:\n        if b & 1:\n            res = mul(res, a)\n        a = mul(a, a)\n        b >>= 1\n    return res\n\ndef factorial(n):\n    res = 1\n    for i in range(1, n + 1):\n        res = mul(res, i)\n    return res\n\ndef C(n, k):\n    return mul(factorial(n), power(factorial(k) * factorial(n - k), MOD - 2))\n\ndef grid(n, grid):\n    dp = [[[-1] * (n + 1) for _ in range(n + 1)] for _ in range(n)]\n\n    def solve(i, remA, remB):\n        if i == n:\n            return 1 if remA == 0 and remB == 0 else 0\n        if dp[i][remA][remB] != -1:\n            return dp[i][remA][remB]\n        dp[i][remA][remB] = 0\n        for j in range(n):\n            if grid[i][j] == '.':\n                dp[i][remA][remB] = (dp[i][remA][remB] + solve(i + 1, remA, remB) + solve(i + 1, remA - 1, remB) * (j == 0 or grid[i][j - 1] != '.') + solve(i + 1, remA, remB - 1) * (j == 0 or grid[i][j - 1] != '.')) % MOD\n            elif grid[i][j] == 'A':\n                dp[i][remA][remB] = (dp[i][remA][remB] + solve(i + 1, remA - 1, remB)) % MOD\n            else:\n                dp[i][remA][remB] = (dp[i][remA][remB] + solve(i + 1, remA, remB - 1)) % MOD\n        return dp[i][remA][remB]\n\n    remA = n - sum([row.count('A') for row in grid])\n    remB = n - sum([row.count('B') for row in grid])\n    return solve(0, remA, remB)\n\nn = int(input().strip())\ngrid = [input().strip() for _ in range(n)]\nprint(grid(n, grid))\n",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.1594479481379191,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridCompletion_shot_1.py\", line 51, in <module>\n    print(grid(n, grid))\nTypeError: 'list' object is not callable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridCompletion_shot_1.py\", line 51, in <module>\n    print(grid(n, grid))\nTypeError: 'list' object is not callable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridCompletion_shot_1.py\", line 51, in <module>\n    print(grid(n, grid))\nTypeError: 'list' object is not callable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridCompletion_shot_1.py\", line 51, in <module>\n    print(grid(n, grid))\nTypeError: 'list' object is not callable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridCompletion_shot_1.py\", line 51, in <module>\n    print(grid(n, grid))\nTypeError: 'list' object is not callable\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridCompletion_shot_1.py\", line 51, in <module>\n    print(grid(n, grid))\nTypeError: 'list' object is not callable\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Path Construction",
            "category": "Additional Problems",
            "solution": "def is_possible(n, m, y1, x1, y2, x2):\n    if (n*m) % 2 == 1 and not (n%2 == 1 and y1 == y2 == n//2 + 1 and x1 == x2 == m//2 + 1):\n        return False\n    return True\n\ndef get_path(n, m, y1, x1, y2, x2):\n    path = []\n    if y1 == y2:\n        path += ['R']*(x2-x1) if x1 < x2 else ['L']*(x1-x2)\n        x1, x2 = m, m-1\n    elif x1 == x2:\n        path += ['D']*(y2-y1) if y1 < y2 else ['U']*(y1-y2)\n        y1, y2 = n, n-1\n    else:\n        path += ['D']*(y2-y1) if y1 < y2 else ['U']*(y1-y2)\n        path += ['R']*(x2-x1) if x1 < x2 else ['L']*(x1-x2)\n        y1, y2, x1, x2 = n-1, n, m-1, m\n    for i in range(y1-1, y2-1, -2):\n        for j in range(x1-1, x2-1, -2):\n            path += ['R', 'D'] if i%2 == 0 else ['D', 'R']\n    return path\n\nt = int(input())\nfor _ in range(t):\n    n, m, y1, x1, y2, x2 = map(int, input().split())\n    if is_possible(n, m, y1, x1, y2, x2):\n        print(\"YES\")\n        print(''.join(get_path(n, m, y1-1, x1-1, y2-1, x2-1)))\n    else:\n        print(\"NO\")\n",
            "passed_test_cases": 0,
            "total_test_cases": 20,
            "mean_time_taken": 0.11843492984771728,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Paths",
            "category": "Introductory Problems",
            "solution": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\ndef grid_paths(n, m, traps):\n    dp = [[0] * (n+1) for _ in range(n+1)]\n    dp[1][1] = 1\n\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if (i, j) in traps:\n                dp[i][j] = 0\n            elif i == 1 and j == 1:\n                dp[i][j] = 1\n            elif i == 1:\n                dp[i][j] = dp[i][j-1] % MOD\n            elif j == 1:\n                dp[i][j] = dp[i-1][j] % MOD\n            else:\n                dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD\n\n    return dp[n][n]\n\nn, m = map(int, input().split())\ntraps = set()\nfor _ in range(m):\n    y, x = map(int, input().split())\n    traps.add((y, x))\n\nprint(grid_paths(n, m, traps))\n",
            "passed_test_cases": 5,
            "total_test_cases": 20,
            "mean_time_taken": 0.18723640441894532,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 25, in <module>\n    n, m = map(int, input().split())\nValueError: invalid literal for int() with base 10: '????D???L??D?L??????????????R??D???????????D??R?'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 25, in <module>\n    n, m = map(int, input().split())\nValueError: not enough values to unpack (expected 2, got 1)\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 31, in <module>\n    print(grid_paths(n, m, traps))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 7, in grid_paths\n    dp = [[0] * (n+1) for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 7, in <listcomp>\n    dp = [[0] * (n+1) for _ in range(n+1)]\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 25, in <module>\n    n, m = map(int, input().split())\nValueError: not enough values to unpack (expected 2, got 1)\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 31, in <module>\n    print(grid_paths(n, m, traps))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 7, in grid_paths\n    dp = [[0] * (n+1) for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 7, in <listcomp>\n    dp = [[0] * (n+1) for _ in range(n+1)]\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 25, in <module>\n    n, m = map(int, input().split())\nValueError: invalid literal for int() with base 10: '?????????R??R?????????????R????U????????????????'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 31, in <module>\n    print(grid_paths(n, m, traps))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 7, in grid_paths\n    dp = [[0] * (n+1) for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 7, in <listcomp>\n    dp = [[0] * (n+1) for _ in range(n+1)]\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 25, in <module>\n    n, m = map(int, input().split())\nValueError: not enough values to unpack (expected 2, got 1)\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 25, in <module>\n    n, m = map(int, input().split())\nValueError: invalid literal for int() with base 10: '???????????????????????????????????????????????D'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 31, in <module>\n    print(grid_paths(n, m, traps))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 7, in grid_paths\n    dp = [[0] * (n+1) for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 7, in <listcomp>\n    dp = [[0] * (n+1) for _ in range(n+1)]\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 31, in <module>\n    print(grid_paths(n, m, traps))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 7, in grid_paths\n    dp = [[0] * (n+1) for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 7, in <listcomp>\n    dp = [[0] * (n+1) for _ in range(n+1)]\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 25, in <module>\n    n, m = map(int, input().split())\nValueError: invalid literal for int() with base 10: '???????????L????????L??????????L????????????????'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 25, in <module>\n    n, m = map(int, input().split())\nValueError: invalid literal for int() with base 10: '????L???????????????????????????????????????????'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 25, in <module>\n    n, m = map(int, input().split())\nValueError: not enough values to unpack (expected 2, got 1)\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 25, in <module>\n    n, m = map(int, input().split())\nValueError: not enough values to unpack (expected 2, got 1)\n"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                12,
                14,
                16,
                17,
                18,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Paths",
            "category": "Introductory Problems",
            "solution": "def count_paths(s):\n    # Create a 2D grid to store the number of ways to reach each cell\n    dp = [[0] * 8 for _ in range(8)]\n    dp[0][0] = 1  # There's 1 way to reach the starting cell\n\n    # Iterate over the string\n    for i, c in enumerate(s):\n        x, y = i // 7, i % 7  # Calculate the current cell\n\n        # If the character is '?', we can come from any direction\n        if c == '?':\n            if x > 0:\n                dp[x][y] += dp[x - 1][y]\n            if y > 0:\n                dp[x][y] += dp[x][y - 1]\n            if x < 7:\n                dp[x][y] += dp[x + 1][y]\n            if y < 7:\n                dp[x][y] += dp[x][y + 1]\n\n        # If the character is not '?', we can only come from one direction\n        elif c == 'D':\n            if x < 7:\n                dp[x + 1][y] += dp[x][y]\n        elif c == 'U':\n            if x > 0:\n                dp[x - 1][y] += dp[x][y]\n        elif c == 'L':\n            if y > 0:\n                dp[x][y - 1] += dp[x][y]\n        elif c == 'R':\n            if y < 7:\n                dp[x][y + 1] += dp[x][y]\n\n    return dp[7][0]  # Return the number of ways to reach the bottom-left cell\n\n# Read the input string\ns = input().strip()\n\n# Print the number of paths that match the description\nprint(count_paths(s))\n",
            "passed_test_cases": 4,
            "total_test_cases": 20,
            "mean_time_taken": 0.10823180675506591,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                9,
                10,
                11,
                12,
                14,
                15,
                16,
                17,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Paths",
            "category": "Introductory Problems",
            "solution": "def grid_paths(n, grid):\n    MOD = 10**9 + 7\n    dp = [[0]*n for _ in range(n)]  # dp[i][j] will store the number of paths to reach cell (i, j)\n    dp[0][0] = 1  # there is 1 path to reach the top-left cell\n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == '*':  # if the cell is a trap, no paths can reach it\n                dp[i][j] = 0\n            elif i > 0:  # add the number of paths from the cell above\n                dp[i][j] += dp[i-1][j]\n            elif j > 0:  # add the number of paths from the cell to the left\n                dp[i][j] += dp[i][j-1]\n            elif i > 0 and j > 0:  # add the number of paths from both the cell above and the cell to the left\n                dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD\n\n    return dp[n-1][n-1]  # return the number of paths to reach the bottom-right cell\n\n# read input\nn = int(input())\ngrid = [input() for _ in range(n)]\n\n# print output\nprint(grid_paths(n, grid))\n",
            "passed_test_cases": 7,
            "total_test_cases": 20,
            "mean_time_taken": 0.1408049464225769,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 20, in <module>\n    n = int(input())\nValueError: invalid literal for int() with base 10: '????D???L??D?L??????????????R??D???????????D??R?'\n",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 20, in <module>\n    n = int(input())\nValueError: invalid literal for int() with base 10: '?????????R??R?????????????R????U????????????????'\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 20, in <module>\n    n = int(input())\nValueError: invalid literal for int() with base 10: '???????????????????????????????????????????????D'\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 20, in <module>\n    n = int(input())\nValueError: invalid literal for int() with base 10: '???????????L????????L??????????L????????????????'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPaths_shot_1.py\", line 20, in <module>\n    n = int(input())\nValueError: invalid literal for int() with base 10: '????L???????????????????????????????????????????'\n"
            ],
            "failed_test_cases": [
                1,
                2,
                6,
                7,
                8,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Puzzle I",
            "category": "Additional Problems",
            "solution": "def grid_puzzle():\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    grid = [['.' for _ in range(n)] for _ in range(n)]\n\n    # Fill rows\n    for i in range(n):\n        for j in range(a[i]):\n            if b[j] > 0:\n                grid[i][j] = 'X'\n                b[j] -= 1\n            elif b[j] == 0:\n                break\n            else:\n                return print(-1)\n\n    # Fill columns\n    for j in range(n):\n        if b[j] > 0:\n            for i in range(n):\n                if a[i] > 0 and grid[i][j] == '.':\n                    grid[i][j] = 'X'\n                    a[i] -= 1\n                    b[j] -= 1\n                    if b[j] == 0:\n                        break\n            else:\n                return print(-1)\n\n    # Print grid\n    for row in grid:\n        print(''.join(row))\n\ngrid_puzzle()\n",
            "passed_test_cases": 4,
            "total_test_cases": 12,
            "mean_time_taken": 0.12465876340866089,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                6,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Puzzle II",
            "category": "Additional Problems",
            "solution": "from collections import deque\n\ndef grid_puzzle_ii():\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    grid = [list(map(int, input().split())) for _ in range(n)]\n\n    # Create a flow network\n    source, sink = 0, 2 * n * n + 1\n    capacity = [[] for _ in range(2 * n * n + 2)]\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            node = (i - 1) * n + j\n            capacity[source].append((node, a[i - 1]))\n            capacity[node + n * n].append((sink, b[j - 1]))\n            if grid[i - 1][j - 1] > 0:\n                capacity[node].append((node + n * n, grid[i - 1][j - 1]))\n                capacity[node + n * n].append((node, 0))\n\n    def bfs():\n        queue = deque([source])\n        visited = [False] * (2 * n * n + 2)\n        parent = [-1] * (2 * n * n + 2)\n        visited[source] = True\n        while queue:\n            node = queue.popleft()\n            for neighbor, _ in capacity[node]:\n                if not visited[neighbor] and capacity[node][capacity[node].index((neighbor, _))][1] > 0:\n                    queue.append(neighbor)\n                    visited[neighbor] = True\n                    parent[neighbor] = node\n        return parent\n\n    def send_flow(parent, min_flow):\n        node = sink\n        while node != source:\n            capacity[parent[node]][capacity[parent[node]].index((node, _))][1] -= min_flow\n            capacity[node][capacity[node].index((parent[node], _))][1] += min_flow\n            node = parent[node]\n\n    max_flow = 0\n    while True:\n        parent = bfs()\n        if parent[sink] == -1:\n            break\n        min_flow = float('inf')\n        node = sink\n        while node != source:\n            min_flow = min(min_flow, capacity[parent[node]][capacity[parent[node]].index((node, _))][1])\n            node = parent[node]\n        max_flow += min_flow\n        send_flow(parent, min_flow)\n\n    if max_flow != sum(a) * 1000:\n        print(-1)\n        return\n\n    print(max_flow)\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if capacity[(i - 1) * n + j][capacity[(i - 1) * n + j].index((j + n * n, _))][1] > 0:\n                print('X', end='')\n            else:\n                print('.', end='')\n        print()\n\ngrid_puzzle_ii()\n",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.17738792300224304,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPuzzleII_shot_1.py\", line 68, in <module>\n    grid_puzzle_ii()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPuzzleII_shot_1.py\", line 50, in grid_puzzle_ii\n    min_flow = min(min_flow, capacity[parent[node]][capacity[parent[node]].index((node, _))][1])\nNameError: name '_' is not defined\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPuzzleII_shot_1.py\", line 68, in <module>\n    grid_puzzle_ii()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPuzzleII_shot_1.py\", line 50, in grid_puzzle_ii\n    min_flow = min(min_flow, capacity[parent[node]][capacity[parent[node]].index((node, _))][1])\nNameError: name '_' is not defined\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPuzzleII_shot_1.py\", line 68, in <module>\n    grid_puzzle_ii()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPuzzleII_shot_1.py\", line 50, in grid_puzzle_ii\n    min_flow = min(min_flow, capacity[parent[node]][capacity[parent[node]].index((node, _))][1])\nNameError: name '_' is not defined\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPuzzleII_shot_1.py\", line 68, in <module>\n    grid_puzzle_ii()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPuzzleII_shot_1.py\", line 50, in grid_puzzle_ii\n    min_flow = min(min_flow, capacity[parent[node]][capacity[parent[node]].index((node, _))][1])\nNameError: name '_' is not defined\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPuzzleII_shot_1.py\", line 68, in <module>\n    grid_puzzle_ii()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPuzzleII_shot_1.py\", line 50, in grid_puzzle_ii\n    min_flow = min(min_flow, capacity[parent[node]][capacity[parent[node]].index((node, _))][1])\nNameError: name '_' is not defined\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPuzzleII_shot_1.py\", line 68, in <module>\n    grid_puzzle_ii()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPuzzleII_shot_1.py\", line 62, in grid_puzzle_ii\n    if capacity[(i - 1) * n + j][capacity[(i - 1) * n + j].index((j + n * n, _))][1] > 0:\nNameError: name '_' is not defined\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPuzzleII_shot_1.py\", line 68, in <module>\n    grid_puzzle_ii()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPuzzleII_shot_1.py\", line 50, in grid_puzzle_ii\n    min_flow = min(min_flow, capacity[parent[node]][capacity[parent[node]].index((node, _))][1])\nNameError: name '_' is not defined\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPuzzleII_shot_1.py\", line 68, in <module>\n    grid_puzzle_ii()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/GridPuzzleII_shot_1.py\", line 50, in grid_puzzle_ii\n    min_flow = min(min_flow, capacity[parent[node]][capacity[parent[node]].index((node, _))][1])\nNameError: name '_' is not defined\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grundy's Game",
            "category": "Mathematics",
            "solution": "def winner(n):\n    # If n is a power of 2, the second player wins. Otherwise, the first player wins.\n    return 'second' if (n != 0 and (n & (n - 1)) == 0) else 'first'\n\n# Read the number of tests\nt = int(input())\n\n# For each test\nfor _ in range(t):\n    # Read the number of coins\n    n = int(input())\n\n    # Print the winner\n    print(winner(n))\n",
            "passed_test_cases": 1,
            "total_test_cases": 3,
            "mean_time_taken": 0.2206573486328125,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Hamiltonian Flights",
            "category": "Graph Algorithms",
            "solution": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n\n    dp = [[0]*(1<<n) for _ in range(n+1)]\n    dp[1][1] = 1\n\n    for i in range(1, n):\n        for j in range(1, 1<<n):\n            if j&(1<<(i-1)):\n                for k in graph[i]:\n                    dp[i][j] += dp[k][j^(1<<(i-1))]\n                    dp[i][j] %= MOD\n\n    print(dp[n][(1<<n)-1])\n\nsolve()\n",
            "passed_test_cases": 0,
            "total_test_cases": 20,
            "mean_time_taken": 0.5853377342224121,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Hamming Distance",
            "category": "Advanced Techniques",
            "solution": "# Read the input\nn, k = map(int, input().split())\nbit_strings = [input() for _ in range(n)]\n\n# Initialize the minimum Hamming distance\nmin_hamming_distance = k\n\n# Iterate over all pairs of bit strings\nfor i in range(n):\n    for j in range(i + 1, n):\n        # Calculate the Hamming distance\n        hamming_distance = sum(b1 != b2 for b1, b2 in zip(bit_strings[i], bit_strings[j]))\n        # Update the minimum Hamming distance\n        min_hamming_distance = min(min_hamming_distance, hamming_distance)\n\n# Print the minimum Hamming distance\nprint(min_hamming_distance)\n",
            "passed_test_cases": 6,
            "total_test_cases": 15,
            "mean_time_taken": 0.7247178872426351,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                5,
                6,
                7,
                8,
                9,
                12,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "High Score",
            "category": "Graph Algorithms",
            "solution": "import sys\n\ndef bellman_ford(n, m, edges):\n    dist = [sys.maxsize] * (n + 1)\n    dist[1] = 0\n\n    for _ in range(n - 1):\n        for a, b, x in edges:\n            if dist[a] != sys.maxsize and dist[a] + x < dist[b]:\n                dist[b] = dist[a] + x\n\n    for a, b, x in edges:\n        if dist[a] != sys.maxsize and dist[a] + x < dist[b]:\n            return -1\n\n    return dist[n]\n\ndef main():\n    n, m = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(m)]\n    print(bellman_ford(n, m, edges))\n\nif __name__ == \"__main__\":\n    main()\n",
            "passed_test_cases": 19,
            "total_test_cases": 43,
            "mean_time_taken": 0.21391135038331496,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                9,
                11,
                14,
                15,
                16,
                17,
                18,
                20,
                21,
                22,
                23,
                24,
                26,
                31,
                32,
                35,
                37,
                38,
                39,
                43
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Hotel Queries",
            "category": "Range Queries",
            "solution": "# Read the input\nn, m = map(int, input().split())\nhotels = list(map(int, input().split()))\ngroups = list(map(int, input().split()))\n\n# Initialize the result list\nresult = []\n\n# Process each group\nfor group in groups:\n    for i in range(n):\n        if hotels[i] >= group:\n            hotels[i] -= group\n            result.append(i + 1)\n            break\n    else:\n        result.append(0)\n\n# Print the result\nprint(*result)\n",
            "passed_test_cases": 6,
            "total_test_cases": 11,
            "mean_time_taken": 0.5424721240997314,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Houses and Schools",
            "category": "Advanced Techniques",
            "solution": "def min_distance(n, k, children):\n    # Sort houses based on number of children\n    houses = sorted(range(n), key=lambda i: -children[i])\n    schools = [houses[0]]\n    distance = 0\n\n    for i in range(1, n):\n        # Calculate distance to the last school\n        d = houses[i] - schools[-1]\n\n        # If the house should have a school, assign it\n        if i >= k or d > children[houses[i - k]]:\n            schools.append(houses[i])\n\n        # Add distance to total\n        distance += d * children[houses[i]]\n\n    return distance\n\n# Read input\nn, k = map(int, input().split())\nchildren = list(map(int, input().split()))\n\n# Print output\nprint(min_distance(n, k, children))\n",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.12193584442138672,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Increasing Array",
            "category": "Introductory Problems",
            "solution": "# Read the input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Initialize the count of moves and the first element as minimum\ncount = 0\nmin_val = arr[0]\n\n# Iterate over the array\nfor i in range(1, n):\n    # If the current element is less than the minimum value,\n    # increase it to the minimum value and update the count\n    if arr[i] < min_val:\n        count += min_val - arr[i]\n        arr[i] = min_val\n    # Update the minimum value\n    min_val = max(min_val, arr[i])\n\n# Print the result\nprint(count)\n",
            "passed_test_cases": 7,
            "total_test_cases": 7,
            "mean_time_taken": 0.14789492743355886,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Increasing Array II",
            "category": "Additional Problems",
            "solution": "def min_moves(arr):\n    moves = 0\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i - 1]:\n            diff = arr[i - 1] - arr[i]\n            arr[i] += diff\n            moves += diff\n    return moves\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(min_moves(arr))\n",
            "passed_test_cases": 3,
            "total_test_cases": 7,
            "mean_time_taken": 0.1483321189880371,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Increasing Array Queries",
            "category": "Range Queries",
            "solution": "def min_operations(n, q, arr, queries):\n    # Create a prefix array to store the minimum value at each index\n    prefix = [0] * (n + 1)\n    prefix[1] = arr[0]\n    for i in range(2, n + 1):\n        prefix[i] = min(prefix[i - 1], arr[i - 1])\n\n    # Process each query\n    for a, b in queries:\n        # Find the minimum number of operations required to make the subarray increasing\n        min_val = prefix[a - 1]\n        operations = 0\n        for i in range(a - 1, b):\n            if arr[i] < min_val:\n                operations += min_val - arr[i]\n            min_val = max(min_val, arr[i] + 1)\n        print(operations)\n\n# Read the input\nn, q = map(int, input().split())\narr = list(map(int, input().split()))\nqueries = [list(map(int, input().split())) for _ in range(q)]\n\n# Call the function\nmin_operations(n, q, arr, queries)\n",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.9360946714878082,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Increasing Subsequence",
            "category": "Dynamic Programming",
            "solution": "n = int(input())\narr = list(map(int, input().split()))\n\n# Step 1: Initialize dp array\ndp = [1] * n\n\n# Step 2: Iterate over the array\nfor i in range(1, n):\n    for j in range(i):\n        # Step 3: Check if current element can be added to subsequence\n        if arr[i] > arr[j]:\n            dp[i] = max(dp[i], dp[j] + 1)\n\n# Step 4: Find the longest increasing subsequence\nprint(max(dp))\n",
            "passed_test_cases": 11,
            "total_test_cases": 17,
            "mean_time_taken": 0.44175135388093834,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                9,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Increasing Subsequence II",
            "category": "Additional Problems",
            "solution": "def num_increasing_subsequences(arr):\n    n = len(arr)\n    dp = [1] * n\n    mod = 10**9 + 7\n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = (dp[i] + dp[j]) % mod\n\n    return sum(dp) % mod\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Print output\nprint(num_increasing_subsequences(arr))\n",
            "passed_test_cases": 6,
            "total_test_cases": 10,
            "mean_time_taken": 0.4868889808654785,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Intersection Points",
            "category": "Additional Problems",
            "solution": "def solve():\n    n = int(input())\n    lines = [list(map(int, input().split())) for _ in range(n)]\n\n    horizontal = [line for line in lines if line[1] == line[3]]\n    vertical = [line for line in lines if line[0] == line[2]]\n\n    horizontal.sort(key=lambda x: x[1])\n    vertical.sort(key=lambda x: x[0])\n\n    intersections = 0\n    i = j = 0\n\n    while i < len(horizontal) and j < len(vertical):\n        h, y1, _, y2 = horizontal[i]\n        x1, _, x2, v = vertical[j]\n\n        if y1 < v < y2 and x1 < h < x2:\n            intersections += 1\n\n        if y2 < v or (y2 == v and h < x2):\n            i += 1\n        else:\n            j += 1\n\n    print(intersections)\n\nsolve()\n",
            "passed_test_cases": 0,
            "total_test_cases": 5,
            "mean_time_taken": 0.1760847568511963,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Inverse Inversions",
            "category": "Additional Problems",
            "solution": "def solve(n, k):\n    # Start with a sorted list of numbers from 1 to n\n    permutation = list(range(1, n + 1))\n\n    # Create k inversions\n    for i in range(n - 1, -1, -1):\n        # Find the smallest number that can be swapped with permutation[i]\n        # to create a new inversion\n        num_inversions = min(i, k)\n        swap_index = i - num_inversions\n\n        # Swap the numbers\n        permutation[i], permutation[swap_index] = permutation[swap_index], permutation[i]\n\n        # Update the number of remaining inversions to create\n        k -= num_inversions\n\n    return permutation\n\n# Read the input\nn, k = map(int, input().split())\n\n# Solve the problem\npermutation = solve(n, k)\n\n# Print the output\nprint(*permutation)\n",
            "passed_test_cases": 5,
            "total_test_cases": 10,
            "mean_time_taken": 0.19682908058166504,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                8,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Inversion Probability",
            "category": "Mathematics",
            "solution": "def inversion_probability():\n    n = int(input())\n    r = list(map(int, input().split()))\n    result = 0\n    for a in range(n):\n        for b in range(a+1, n):\n            if r[a] <= r[b]:\n                result += r[a] * (r[b] - r[a]//2) / (r[a] * r[b])\n            else:\n                result += r[b] * (r[a] - r[b]//2) / (r[a] * r[b])\n    print(round(result, 6))\n\ninversion_probability()\n",
            "passed_test_cases": 0,
            "total_test_cases": 20,
            "mean_time_taken": 0.11653715372085571,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Investigation",
            "category": "Graph Algorithms",
            "solution": "import heapq\nMOD = 10**9 + 7\n\ndef investigate(n, m, flights):\n    graph = [[] for _ in range(n + 1)]\n    for a, b, c in flights:\n        graph[a].append((b, c))\n\n    pq = [(0, 1, 0, 1)]  # (price, count, min_flights, max_flights)\n    while pq:\n        price, count, min_flights, max_flights = heapq.heappop(pq)\n        if len(graph[min_flights]):\n            for b, c in graph[min_flights]:\n                new_price = price + c\n                new_count = count % MOD\n                new_min_flights = min_flights + 1\n                new_max_flights = max(max_flights, new_min_flights)\n                heapq.heappush(pq, (new_price, new_count, new_min_flights, new_max_flights))\n        else:\n            if min_flights == n:\n                return price, count % MOD, min_flights - 1, max_flights - 1\n\nn, m = map(int, input().split())\nflights = [tuple(map(int, input().split())) for _ in range(m)]\nprint(*investigate(n, m, flights))\n",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.26776437759399413,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Investigation_shot_1.py\", line 25, in <module>\n    print(*investigate(n, m, flights))\nTypeError: print() argument after * must be an iterable, not NoneType\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Investigation_shot_1.py\", line 25, in <module>\n    print(*investigate(n, m, flights))\nTypeError: print() argument after * must be an iterable, not NoneType\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Investigation_shot_1.py\", line 25, in <module>\n    print(*investigate(n, m, flights))\nTypeError: print() argument after * must be an iterable, not NoneType\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Investigation_shot_1.py\", line 25, in <module>\n    print(*investigate(n, m, flights))\nTypeError: print() argument after * must be an iterable, not NoneType\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Investigation_shot_1.py\", line 25, in <module>\n    print(*investigate(n, m, flights))\nTypeError: print() argument after * must be an iterable, not NoneType\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Investigation_shot_1.py\", line 25, in <module>\n    print(*investigate(n, m, flights))\nTypeError: print() argument after * must be an iterable, not NoneType\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Investigation_shot_1.py\", line 25, in <module>\n    print(*investigate(n, m, flights))\nTypeError: print() argument after * must be an iterable, not NoneType\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Investigation_shot_1.py\", line 25, in <module>\n    print(*investigate(n, m, flights))\nTypeError: print() argument after * must be an iterable, not NoneType\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Investigation_shot_1.py\", line 25, in <module>\n    print(*investigate(n, m, flights))\nTypeError: print() argument after * must be an iterable, not NoneType\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Investigation_shot_1.py\", line 25, in <module>\n    print(*investigate(n, m, flights))\nTypeError: print() argument after * must be an iterable, not NoneType\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Josephus Problem I",
            "category": "Sorting and Searching",
            "solution": "def josephus_problem(n):\n    # Initialize an empty list to store the removal order\n    removal_order = []\n\n    # Start from 1 and go up to n\n    for i in range(1, n+1):\n        # If i is even, add it to the removal order\n        if i % 2 == 0:\n            removal_order.append(i)\n        # If i is odd and less than n, add n - i + 1 to the removal order\n        elif i < n:\n            removal_order.append(n - i + 1)\n\n    # Return the removal order\n    return removal_order\n\n# Read the input\nn = int(input())\n\n# Print the removal order\nprint(*josephus_problem(n))\n",
            "passed_test_cases": 0,
            "total_test_cases": 13,
            "mean_time_taken": 0.12742086557241586,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Josephus Problem II",
            "category": "Sorting and Searching",
            "solution": "def josephus(n, k):\n    # Create a list to store the removal order\n    result = [0] * n\n\n    # Initialize variables\n    start = 0\n    index = 0\n    step = 1\n\n    # Main loop\n    while step <= n:\n        if index >= n:\n            # Reset index and increment start\n            index = start\n            start += step\n\n        # If the position is not yet assigned, assign it and increment index\n        if result[index] == -1:\n            result[index] = step\n            index += 1\n\n        # Increment step\n        step += 1\n\n    # Shift the result to start from 1\n    return [r + 1 for r in result[start - 1:] + result[:start - 1]]\n\n# Read input\nn, k = map(int, input().split())\n\n# Print the removal order\nprint(*josephus(n, k))\n",
            "passed_test_cases": 5,
            "total_test_cases": 17,
            "mean_time_taken": 0.12959502725040212,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                9,
                11,
                13,
                14,
                15,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Josephus Queries",
            "category": "Mathematics",
            "solution": "def power(x, y):\n    result = 1\n    while y > 0:\n        if y % 2 == 1:\n            result = (result * x) % 2\n        x = (x * x) % 2\n        y //= 2\n    return result\n\ndef josephus_queries(n, k):\n    result = 0\n    i = 1\n    while n > 0:\n        x = power(2, i)\n        if k <= x:\n            result += (k - 1) * (x // 2)\n            k = x\n        else:\n            result += (x // 2) * (n - x)\n            k -= x\n        n -= x\n        i += 1\n    return result + 1\n\nq = int(input())\nfor _ in range(q):\n    n, k = map(int, input().split())\n    print(josephus_queries(n, k))\n",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 1.051741600036621,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Knight's Tour",
            "category": "Graph Algorithms",
            "solution": "def knight_moves(x, y):\n    moves = [(1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1)]\n    return [(x + dx, y + dy) for dx, dy in moves if 1 <= x + dx <= 8 and 1 <= y + dy <= 8]\n\ndef knight_tour(start):\n    x, y = start\n    board = [[0] * 9 for _ in range(9)]\n    board[x][y] = 1\n    move_count = 1\n\n    while move_count < 64:\n        next_moves = knight_moves(x, y)\n        next_moves = sorted(next_moves, key=lambda move: len(knight_moves(*move)), reverse=True)\n\n        for nx, ny in next_moves:\n            if board[nx][ny] == 0:\n                board[nx][ny] = move_count + 1\n                x, y = nx, ny\n                move_count += 1\n                break\n\n    return [row[1:] for row in board[1:]]\n\nif __name__ == \"__main__\":\n    x, y = map(int, input().split())\n    for row in knight_tour((x, y)):\n        print(*row)\n",
            "passed_test_cases": 0,
            "total_test_cases": 23,
            "mean_time_taken": 1.0484372947527014,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Knuth Division",
            "category": "Advanced Techniques",
            "solution": "import sys\nimport heapq\n\ndef read_input():\n    n = int(sys.stdin.readline())\n    arr = list(map(int, sys.stdin.readline().split()))\n    return n, arr\n\ndef knuth_division(n, arr):\n    pq = [(sum(arr), 0, n)]  # initial subarray\n    total_cost = 0\n    while pq:\n        _, i, j = heapq.heappop(pq)\n        total_cost += sum(arr[i:j])\n        if j - i > 1:  # still needs to be split\n            mid = (i + j) // 2\n            heapq.heappush(pq, (arr[i] + arr[mid], i, mid + 1))\n            heapq.heappush(pq, (sum(arr[mid + 1:j]), mid + 1, j))\n    return total_cost\n\ndef main():\n    n, arr = read_input()\n    print(knuth_division(n, arr))\n\nmain()\n",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 1.0502325693766277,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Labyrinth",
            "category": "Graph Algorithms",
            "solution": "from collections import deque\n\ndef is_valid(x, y, n, m, grid):\n    if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] not in ['.', 'B']:\n        return False\n    return True\n\ndef bfs(grid, n, m):\n    dx = [-1, 0, 1, 0]\n    dy = [0, 1, 0, -1]\n    moves = ['U', 'R', 'D', 'L']\n\n    start = None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'A':\n                start = (i, j)\n                break\n        if start is not None:\n            break\n\n    queue = deque([(start, \"\", 0)])\n    grid[start[0]][start[1]] = '.'\n\n    while queue:\n        (x, y), path, length = queue.popleft()\n\n        if grid[x][y] == 'B':\n            return length, path + moves[0]\n\n        for i in range(4):\n            nx = x + dx[i]\n            ny = y + dy[i]\n\n            if is_valid(nx, ny, n, m, grid):\n                queue.append(((nx, ny), path + moves[i], length + 1))\n                grid[nx][ny] = '#'\n\n    return -1, \"\"\n\ndef main():\n    n, m = map(int, input().split())\n    grid = [input() for _ in range(n)]\n\n    length, path = bfs(grid, n, m)\n\n    if length != -1:\n        print(\"YES\")\n        print(length)\n        print(path)\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n",
            "passed_test_cases": 0,
            "total_test_cases": 17,
            "mean_time_taken": 0.1565081091488109,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 55, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 45, in main\n    length, path = bfs(grid, n, m)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 23, in bfs\n    grid[start[0]][start[1]] = '.'\nTypeError: 'str' object does not support item assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 55, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 45, in main\n    length, path = bfs(grid, n, m)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 23, in bfs\n    grid[start[0]][start[1]] = '.'\nTypeError: 'str' object does not support item assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 55, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 45, in main\n    length, path = bfs(grid, n, m)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 23, in bfs\n    grid[start[0]][start[1]] = '.'\nTypeError: 'str' object does not support item assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 55, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 45, in main\n    length, path = bfs(grid, n, m)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 23, in bfs\n    grid[start[0]][start[1]] = '.'\nTypeError: 'str' object does not support item assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 55, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 45, in main\n    length, path = bfs(grid, n, m)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 23, in bfs\n    grid[start[0]][start[1]] = '.'\nTypeError: 'str' object does not support item assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 55, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 45, in main\n    length, path = bfs(grid, n, m)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 23, in bfs\n    grid[start[0]][start[1]] = '.'\nTypeError: 'str' object does not support item assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 55, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 45, in main\n    length, path = bfs(grid, n, m)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 23, in bfs\n    grid[start[0]][start[1]] = '.'\nTypeError: 'str' object does not support item assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 55, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 45, in main\n    length, path = bfs(grid, n, m)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 23, in bfs\n    grid[start[0]][start[1]] = '.'\nTypeError: 'str' object does not support item assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 55, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 45, in main\n    length, path = bfs(grid, n, m)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 23, in bfs\n    grid[start[0]][start[1]] = '.'\nTypeError: 'str' object does not support item assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 55, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 45, in main\n    length, path = bfs(grid, n, m)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 23, in bfs\n    grid[start[0]][start[1]] = '.'\nTypeError: 'str' object does not support item assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 55, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 45, in main\n    length, path = bfs(grid, n, m)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 23, in bfs\n    grid[start[0]][start[1]] = '.'\nTypeError: 'str' object does not support item assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 55, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 45, in main\n    length, path = bfs(grid, n, m)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 23, in bfs\n    grid[start[0]][start[1]] = '.'\nTypeError: 'str' object does not support item assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 55, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 45, in main\n    length, path = bfs(grid, n, m)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 23, in bfs\n    grid[start[0]][start[1]] = '.'\nTypeError: 'str' object does not support item assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 55, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 45, in main\n    length, path = bfs(grid, n, m)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 23, in bfs\n    grid[start[0]][start[1]] = '.'\nTypeError: 'str' object does not support item assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 55, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 45, in main\n    length, path = bfs(grid, n, m)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 23, in bfs\n    grid[start[0]][start[1]] = '.'\nTypeError: 'str' object does not support item assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 55, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 45, in main\n    length, path = bfs(grid, n, m)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 23, in bfs\n    grid[start[0]][start[1]] = '.'\nTypeError: 'str' object does not support item assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 55, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 45, in main\n    length, path = bfs(grid, n, m)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Labyrinth_shot_1.py\", line 23, in bfs\n    grid[start[0]][start[1]] = '.'\nTypeError: 'str' object does not support item assignment\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Letter Pair Move Game",
            "category": "Additional Problems",
            "solution": "def solve(n, boxes):\n    # Find the initial empty spots\n    empty_spots = [i for i, x in enumerate(boxes) if x == '.']\n    moves = []\n    k = 0\n\n    # Iterate through the boxes\n    for i in range(2 * n):\n        # If we find a 'B' and there are still 'A's to its left\n        if boxes[i] == 'B' and boxes[:i].count('A') > 0:\n            # Move the 'B' to the rightmost empty spot\n            boxes[i], boxes[empty_spots[-1]] = boxes[empty_spots[-1]], boxes[i]\n            boxes[empty_spots[-1] + 1], boxes[empty_spots[-2]] = boxes[empty_spots[-2]], boxes[empty_spots[-1] + 1]\n            empty_spots[-2], empty_spots[-1] = empty_spots[-1], empty_spots[-2]\n            moves.append(boxes)\n            k += 1\n\n    # If we've made more than 1000 moves, there's no solution\n    if k > 1000:\n        return [-1]\n\n    # Otherwise, return the number of moves and the moves themselves\n    return [k] + moves\n\n# Test the function\nn = 3\nboxes = list('AB..BA')\nprint(solve(n, boxes))\n",
            "passed_test_cases": 0,
            "total_test_cases": 24,
            "mean_time_taken": 0.11566867431004842,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Line Segment Intersection",
            "category": "Geometry",
            "solution": "import sys\n\ndef orientation(p, q, r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0\n    return 1 if val > 0 else 2\n\ndef on_segment(p, q, r):\n    return min(p[0], q[0]) <= r[0] <= max(p[0], q[0]) and min(p[1], q[1]) <= r[1] <= max(p[1], q[1])\n\ndef do_intersect(p1, q1, p2, q2):\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    if o1 == 0 and on_segment(p1, q1, p2):\n        return True\n\n    if o2 == 0 and on_segment(p1, q1, q2):\n        return True\n\n    if o3 == 0 and on_segment(p2, q2, p1):\n        return True\n\n    if o4 == 0 and on_segment(p2, q2, q1):\n        return True\n\n    return False\n\nt = int(sys.stdin.readline().strip())\nfor _ in range(t):\n    p1, q1, p2, q2 = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(2)]\n    if do_intersect(p1, q1, p2, q2):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.16049094994862875,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LineSegmentIntersection_shot_1.py\", line 37, in <module>\n    p1, q1, p2, q2 = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(2)]\nValueError: not enough values to unpack (expected 4, got 2)\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LineSegmentIntersection_shot_1.py\", line 37, in <module>\n    p1, q1, p2, q2 = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(2)]\nValueError: not enough values to unpack (expected 4, got 2)\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LineSegmentIntersection_shot_1.py\", line 37, in <module>\n    p1, q1, p2, q2 = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(2)]\nValueError: not enough values to unpack (expected 4, got 2)\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LineSegmentIntersection_shot_1.py\", line 37, in <module>\n    p1, q1, p2, q2 = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(2)]\nValueError: not enough values to unpack (expected 4, got 2)\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LineSegmentIntersection_shot_1.py\", line 37, in <module>\n    p1, q1, p2, q2 = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(2)]\nValueError: not enough values to unpack (expected 4, got 2)\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LineSegmentIntersection_shot_1.py\", line 37, in <module>\n    p1, q1, p2, q2 = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(2)]\nValueError: not enough values to unpack (expected 4, got 2)\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "List Removals",
            "category": "Range Queries",
            "solution": "# Read the initial size of the list\nn = int(input())\n\n# Read the contents of the list\nx = list(map(int, input().split()))\n\n# Read the positions of the elements to be removed\np = list(map(int, input().split()))\n\n# List to store the removed elements\nremoved = []\n\n# Loop to remove the elements at the given positions\nfor i in range(n):\n    # Remove the element at the given position\n    removed.append(x[p[i] - 1])\n    # Remove the element from the list\n    del x[p[i] - 1]\n    # Update the positions of the remaining elements\n    for j in range(i + 1, n):\n        if p[j] > p[i]:\n            p[j] -= 1\n\n# Print the removed elements\nprint(*removed)\n",
            "passed_test_cases": 1,
            "total_test_cases": 9,
            "mean_time_taken": 0.42801565594143337,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "List of Sums",
            "category": "Additional Problems",
            "solution": "def list_of_sums():\n    n = int(input())\n    B = list(map(int, input().split()))\n    B.sort()\n    A = []\n    smallest = B[0]\n    for i in range(len(B)):\n        if B[i] != smallest:\n            A.append(B[i] - smallest)\n            smallest = B[i] - smallest\n        else:\n            A.append(smallest)\n    while len(A) < n:\n        A.append(smallest)\n    return A\n\nprint(*list_of_sums())\n",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.12429370880126953,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Longest Flight Route",
            "category": "Graph Algorithms",
            "solution": "def dfs(city, visited, path, graph):\n    visited[city] = True\n    path.append(city)\n\n    if city == len(graph) - 1:\n        longest_path.append(path[:])\n        max_length = max(max_length, len(path))\n        path.pop()\n        visited[city] = False\n        return\n\n    for neighbor in graph[city]:\n        if not visited[neighbor]:\n            dfs(neighbor, visited, path, graph)\n\n    path.pop()\n    visited[city] = False\n\nn, m = map(int, input().split())\ngraph = [[] for _ in range(n + 1)]\n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\nvisited = [False] * (n + 1)\nlongest_path = []\nmax_length = 0\ndfs(1, visited, [], graph)\n\nif max_length == 0:\n    print(\"IMPOSSIBLE\")\nelse:\n    for path in longest_path:\n        if len(path) == max_length:\n            print(max_length)\n            print(*path)\n            break\n",
            "passed_test_cases": 2,
            "total_test_cases": 24,
            "mean_time_taken": 0.2564455469449361,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 29, in <module>\n    dfs(1, visited, [], graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 7, in dfs\n    max_length = max(max_length, len(path))\nUnboundLocalError: local variable 'max_length' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 29, in <module>\n    dfs(1, visited, [], graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  [Previous line repeated 1 more time]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 7, in dfs\n    max_length = max(max_length, len(path))\nUnboundLocalError: local variable 'max_length' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 29, in <module>\n    dfs(1, visited, [], graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 7, in dfs\n    max_length = max(max_length, len(path))\nUnboundLocalError: local variable 'max_length' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 29, in <module>\n    dfs(1, visited, [], graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 7, in dfs\n    max_length = max(max_length, len(path))\nUnboundLocalError: local variable 'max_length' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 29, in <module>\n    dfs(1, visited, [], graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 3, in dfs\n    path.append(city)\nRecursionError: maximum recursion depth exceeded while calling a Python object\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 29, in <module>\n    dfs(1, visited, [], graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  [Previous line repeated 10 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 7, in dfs\n    max_length = max(max_length, len(path))\nUnboundLocalError: local variable 'max_length' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 29, in <module>\n    dfs(1, visited, [], graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 7, in dfs\n    max_length = max(max_length, len(path))\nUnboundLocalError: local variable 'max_length' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 29, in <module>\n    dfs(1, visited, [], graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 3, in dfs\n    path.append(city)\nRecursionError: maximum recursion depth exceeded while calling a Python object\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 29, in <module>\n    dfs(1, visited, [], graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  [Previous line repeated 9 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 7, in dfs\n    max_length = max(max_length, len(path))\nUnboundLocalError: local variable 'max_length' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 29, in <module>\n    dfs(1, visited, [], graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 3, in dfs\n    path.append(city)\nRecursionError: maximum recursion depth exceeded while calling a Python object\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 29, in <module>\n    dfs(1, visited, [], graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 3, in dfs\n    path.append(city)\nRecursionError: maximum recursion depth exceeded while calling a Python object\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 29, in <module>\n    dfs(1, visited, [], graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  [Previous line repeated 8 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 7, in dfs\n    max_length = max(max_length, len(path))\nUnboundLocalError: local variable 'max_length' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 29, in <module>\n    dfs(1, visited, [], graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 7, in dfs\n    max_length = max(max_length, len(path))\nUnboundLocalError: local variable 'max_length' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 29, in <module>\n    dfs(1, visited, [], graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 7, in dfs\n    max_length = max(max_length, len(path))\nUnboundLocalError: local variable 'max_length' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 29, in <module>\n    dfs(1, visited, [], graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  [Previous line repeated 5 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 7, in dfs\n    max_length = max(max_length, len(path))\nUnboundLocalError: local variable 'max_length' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 29, in <module>\n    dfs(1, visited, [], graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 7, in dfs\n    max_length = max(max_length, len(path))\nUnboundLocalError: local variable 'max_length' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 29, in <module>\n    dfs(1, visited, [], graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 3, in dfs\n    path.append(city)\nRecursionError: maximum recursion depth exceeded while calling a Python object\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 29, in <module>\n    dfs(1, visited, [], graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 7, in dfs\n    max_length = max(max_length, len(path))\nUnboundLocalError: local variable 'max_length' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 29, in <module>\n    dfs(1, visited, [], graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 7, in dfs\n    max_length = max(max_length, len(path))\nUnboundLocalError: local variable 'max_length' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 29, in <module>\n    dfs(1, visited, [], graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  [Previous line repeated 1 more time]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 7, in dfs\n    max_length = max(max_length, len(path))\nUnboundLocalError: local variable 'max_length' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 29, in <module>\n    dfs(1, visited, [], graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 14, in dfs\n    dfs(neighbor, visited, path, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/LongestFlightRoute_shot_1.py\", line 7, in dfs\n    max_length = max(max_length, len(path))\nUnboundLocalError: local variable 'max_length' referenced before assignment\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                10,
                11,
                12,
                13,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Longest Palindrome",
            "category": "String Algorithms",
            "solution": "def longest_palindrome(s):\n    n = len(s)\n    dp = [[False for _ in range(n)] for _ in range(n)]\n    max_length = 1\n    start_index = 0\n\n    # All substrings of length 1 are palindromes\n    for i in range(n):\n        dp[i][i] = True\n\n    # Check for substring of length 2\n    for i in range(n - 1):\n        if s[i] == s[i + 1]:\n            dp[i][i + 1] = True\n            start_index = i\n            max_length = 2\n\n    # Check for lengths greater than 2\n    for k in range(3, n + 1):\n        for i in range(n - k + 1):\n            j = i + k - 1\n            if dp[i + 1][j - 1] and s[i] == s[j]:\n                dp[i][j] = True\n                if k > max_length:\n                    start_index = i\n                    max_length = k\n\n    return s[start_index:start_index + max_length]\n\n# Read input\ns = input().strip()\n\n# Find and print longest palindrome\nprint(longest_palindrome(s))\n",
            "passed_test_cases": 11,
            "total_test_cases": 19,
            "mean_time_taken": 0.5171017772273013,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                6,
                10,
                11,
                13,
                14,
                16,
                18,
                19
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Mail Delivery",
            "category": "Graph Algorithms",
            "solution": "from collections import defaultdict\n\ndef eulerian_cycle(graph, start):\n    path = []\n    stack = [start]\n    while stack:\n        current = stack[-1]\n        if not graph[current]:\n            path.append(current)\n            stack.pop()\n        else:\n            stack.append(graph[current].pop())\n    return path[::-1]\n\ndef solve(n, m, edges):\n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    if not all(len(neighbors) % 2 == 0 for neighbors in graph.values()):\n        return \"IMPOSSIBLE\"\n    return eulerian_cycle(graph, 1)\n\nn, m = map(int, input().split())\nedges = [list(map(int, input().split())) for _ in range(m)]\nprint(*solve(n, m, edges))\n",
            "passed_test_cases": 0,
            "total_test_cases": 16,
            "mean_time_taken": 0.261723056435585,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Maximum Building I",
            "category": "Additional Problems",
            "solution": "def max_building_area(forest):\n    n, m = len(forest), len(forest[0])\n    dp = [[0] * m for _ in range(n)]\n    max_area = 0\n\n    for i in range(n):\n        for j in range(m):\n            if forest[i][j] == '.':\n                if i == 0:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i-1][j] + 1\n                max_area = max(max_area, dp[i][j])\n\n    for i in range(n):\n        for j in range(m):\n            if forest[i][j] == '.':\n                width = 1\n                while j + width < m and forest[i][j + width] == '.':\n                    width += 1\n                area = min(dp[i][j:j+width]) * width\n                max_area = max(max_area, area)\n\n    return max_area\n\n# Test the function\nforest = [\n    \"...*.*.\",\n    \".*.....\",\n    \".......\",\n    \"......*\"\n]\nprint(max_building_area(forest))\n",
            "passed_test_cases": 2,
            "total_test_cases": 12,
            "mean_time_taken": 0.1241987943649292,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Maximum Building II",
            "category": "Additional Problems",
            "solution": "def max_building(n, m, forest):\n    dp = [[0]*(m+1) for _ in range(n+1)]\n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            if forest[i-1][j-1] == '.':\n                dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + 1\n    return dp\n\ndef print_ways(dp):\n    n, m = len(dp), len(dp[0])\n    for i in range(n, 0, -1):\n        for j in range(m, 0, -1):\n            print(dp[i][j], end=' ')\n        print()\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    forest = [input() for _ in range(n)]\n    dp = max_building(n, m, forest)\n    print_ways(dp)\n",
            "passed_test_cases": 0,
            "total_test_cases": 13,
            "mean_time_taken": 0.26970630425673264,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MaximumBuildingII_shot_1.py\", line 20, in <module>\n    print_ways(dp)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MaximumBuildingII_shot_1.py\", line 13, in print_ways\n    print(dp[i][j], end=' ')\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MaximumBuildingII_shot_1.py\", line 20, in <module>\n    print_ways(dp)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MaximumBuildingII_shot_1.py\", line 13, in print_ways\n    print(dp[i][j], end=' ')\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MaximumBuildingII_shot_1.py\", line 20, in <module>\n    print_ways(dp)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MaximumBuildingII_shot_1.py\", line 13, in print_ways\n    print(dp[i][j], end=' ')\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MaximumBuildingII_shot_1.py\", line 20, in <module>\n    print_ways(dp)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MaximumBuildingII_shot_1.py\", line 13, in print_ways\n    print(dp[i][j], end=' ')\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MaximumBuildingII_shot_1.py\", line 20, in <module>\n    print_ways(dp)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MaximumBuildingII_shot_1.py\", line 13, in print_ways\n    print(dp[i][j], end=' ')\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MaximumBuildingII_shot_1.py\", line 20, in <module>\n    print_ways(dp)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MaximumBuildingII_shot_1.py\", line 13, in print_ways\n    print(dp[i][j], end=' ')\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MaximumBuildingII_shot_1.py\", line 20, in <module>\n    print_ways(dp)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MaximumBuildingII_shot_1.py\", line 13, in print_ways\n    print(dp[i][j], end=' ')\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MaximumBuildingII_shot_1.py\", line 20, in <module>\n    print_ways(dp)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MaximumBuildingII_shot_1.py\", line 13, in print_ways\n    print(dp[i][j], end=' ')\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MaximumBuildingII_shot_1.py\", line 20, in <module>\n    print_ways(dp)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MaximumBuildingII_shot_1.py\", line 13, in print_ways\n    print(dp[i][j], end=' ')\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MaximumBuildingII_shot_1.py\", line 20, in <module>\n    print_ways(dp)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MaximumBuildingII_shot_1.py\", line 13, in print_ways\n    print(dp[i][j], end=' ')\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MaximumBuildingII_shot_1.py\", line 20, in <module>\n    print_ways(dp)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MaximumBuildingII_shot_1.py\", line 13, in print_ways\n    print(dp[i][j], end=' ')\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MaximumBuildingII_shot_1.py\", line 20, in <module>\n    print_ways(dp)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MaximumBuildingII_shot_1.py\", line 13, in print_ways\n    print(dp[i][j], end=' ')\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MaximumBuildingII_shot_1.py\", line 20, in <module>\n    print_ways(dp)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MaximumBuildingII_shot_1.py\", line 13, in print_ways\n    print(dp[i][j], end=' ')\nIndexError: list index out of range\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Maximum Subarray Sum",
            "category": "Sorting and Searching",
            "solution": "def max_subarray_sum(arr):\n    max_current = max_global = arr[0]\n    for num in arr[1:]:\n        max_current = max(num, max_current + num)\n        max_global = max(max_global, max_current)\n    return max_global\n\n# Read the input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Print the output\nprint(max_subarray_sum(arr))\n",
            "passed_test_cases": 15,
            "total_test_cases": 15,
            "mean_time_taken": 0.1341434637705485,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Maximum Subarray Sum II",
            "category": "Sorting and Searching",
            "solution": "def max_subarray_sum(arr, a, b):\n    n = len(arr)\n    max_sum = 0\n    current_max = 0\n    start = 0\n\n    for end in range(n):\n        current_max += arr[end]\n        if end - start + 1 < a:\n            continue\n        if end - start + 1 > b:\n            current_max -= arr[start]\n            start += 1\n        max_sum = max(max_sum, current_max)\n\n    return max_sum\n\n# Read input\nn, a, b = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Print output\nprint(max_subarray_sum(arr, a, b))\n",
            "passed_test_cases": 8,
            "total_test_cases": 23,
            "mean_time_taken": 0.13546777808147928,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                8,
                9,
                10,
                13,
                14,
                16,
                17,
                19,
                20,
                21,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Maximum Xor Subarray",
            "category": "Additional Problems",
            "solution": "class TrieNode:\n    def __init__(self):\n        self.children = [None] * 2\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, num):\n        node = self.root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if not node.children[bit]:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def query(self, num):\n        node = self.root\n        max_xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if node.children[1 - bit]:\n                max_xor = (max_xor << 1) | (1 - bit)\n                node = node.children[1 - bit]\n            else:\n                max_xor = (max_xor << 1) | bit\n                node = node.children[bit]\n        return max_xor\n\ndef maxXorSubarray(nums):\n    trie = Trie()\n    trie.insert(0)\n    max_xor = float('-inf')\n    curr_xor = 0\n    for num in nums:\n        curr_xor ^= num\n        max_xor = max(max_xor, trie.query(curr_xor))\n        trie.insert(curr_xor)\n    return max_xor\n",
            "passed_test_cases": 0,
            "total_test_cases": 14,
            "mean_time_taken": 0.1236323458807809,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Meet in the Middle",
            "category": "Advanced Techniques",
            "solution": "from collections import defaultdict\n\ndef meet_in_the_middle(nums, target):\n    n = len(nums)\n    half = n // 2\n\n    # Calculate all possible sums for the first half\n    sums1 = defaultdict(int)\n    sums1[0] = 1  # Empty subset\n    for num in nums[:half]:\n        new_sums = defaultdict(int)\n        for sum in sums1:\n            new_sums[sum + num] += sums1[sum]\n        for sum in new_sums:\n            sums1[sum] += new_sums[sum]\n\n    # Count the number of pairs of sums that add up to the target sum\n    count = 0\n    for num in nums[half:]:\n        new_sums = defaultdict(int)\n        for sum in sums1:\n            new_sums[target - sum] += sums1[sum]\n        count += new_sums[num]\n\n    return count\n\n# Read input\nn, x = map(int, input().split())\nnums = list(map(int, input().split()))\n\n# Print output\nprint(meet_in_the_middle(nums, x))\n",
            "passed_test_cases": 6,
            "total_test_cases": 40,
            "mean_time_taken": 0.6175919771194458,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                24,
                26,
                28,
                29,
                30,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                40
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Message Route",
            "category": "Graph Algorithms",
            "solution": "from collections import deque\n\ndef bfs(graph, start, end):\n    queue = deque([start])\n    path = {start: None}\n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return path\n        for neighbor in graph[node]:\n            if neighbor not in path:\n                path[neighbor] = node\n                queue.append(neighbor)\n    return None\n\ndef print_path(path, start, end):\n    if path is None:\n        print(\"IMPOSSIBLE\")\n    else:\n        route = []\n        node = end\n        while node is not None:\n            route.append(node)\n            node = path[node]\n        print(len(route))\n        print(*route[::-1])\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = {i: [] for i in range(1, n+1)}\n    for _ in range(m):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    path = bfs(graph, 1, n)\n    print_path(path, 1, n)\n\nif __name__ == \"__main__\":\n    solve()\n",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.21611958742141724,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Minimal Rotation",
            "category": "String Algorithms",
            "solution": "def minimal_rotation(s):\n    # Concatenate the string with itself\n    s += s\n    min_string = s[:len(s) // 2]\n    for i in range(1, len(s) // 2):\n        # Check if the current window is lexicographically smaller than the current minimum\n        if s[i:i + len(s) // 2] < min_string:\n            min_string = s[i:i + len(s) // 2]\n    return min_string\n\n# Read the input string\ns = input()\n\n# Print the lexicographically minimal rotation\nprint(minimal_rotation(s))\n",
            "passed_test_cases": 12,
            "total_test_cases": 20,
            "mean_time_taken": 0.4853890061378479,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                6,
                11,
                12,
                14,
                15,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Minimizing Coins",
            "category": "Dynamic Programming",
            "solution": "# Read the input\nn, x = map(int, input().split())\ncoins = list(map(int, input().split()))\n\n# Initialize a dp array with size x+1, filled with max integer values\n# dp[i] will store the minimum number of coins required to form the sum i\ndp = [float('inf')] * (x+1)\n\n# Base case: 0 sum can be formed with 0 coins\ndp[0] = 0\n\n# Iterate over the coin values\nfor coin in coins:\n    # Iterate backwards to avoid duplicates\n    for i in range(x, -1, -1):\n        # If the current coin value is less than or equal to i,\n        # check if using this coin would minimize the number of coins used\n        if coin <= i:\n            dp[i] = min(dp[i], dp[i-coin] + 1)\n\n# If the desired sum can be formed, print the minimum number of coins, otherwise print -1\nprint(dp[x] if dp[x] != float('inf') else -1)\n",
            "passed_test_cases": 5,
            "total_test_cases": 16,
            "mean_time_taken": 0.47763127088546753,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                6,
                7,
                8,
                9,
                10,
                12,
                13,
                14,
                15,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Minimum Euclidean Distance",
            "category": "Geometry",
            "solution": "def min_euclidean_distance_squared(points):\n    n = len(points)\n    min_distance_squared = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            dx = points[i][0] - points[j][0]\n            dy = points[i][1] - points[j][1]\n            distance_squared = dx * dx + dy * dy\n            min_distance_squared = min(min_distance_squared, distance_squared)\n    return min_distance_squared\n\n# Read the input\nn = int(input())\npoints = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\n# Compute and print the result\nprint(min_euclidean_distance_squared(points))\n",
            "passed_test_cases": 15,
            "total_test_cases": 27,
            "mean_time_taken": 0.5293513227392126,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                4,
                9,
                10,
                12,
                16,
                17,
                19,
                20,
                22,
                23,
                24
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Missing Coin Sum",
            "category": "Sorting and Searching",
            "solution": "def missing_coin_sum():\n    n = int(input())\n    coins = list(map(int, input().split()))\n    coins.sort()\n\n    current_sum = 0\n    for coin in coins:\n        if coin > current_sum + 1:\n            return current_sum + 1\n        current_sum += coin\n\n    return current_sum + 1\n\nprint(missing_coin_sum())\n",
            "passed_test_cases": 9,
            "total_test_cases": 9,
            "mean_time_taken": 0.14252424240112305,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Missing Coin Sum Queries",
            "category": "Additional Problems",
            "solution": "n, q = map(int, input().split())\ncoins = list(map(int, input().split()))\nprefix_sum = [0] * (n+1)\nfor i in range(1, n+1):\n    prefix_sum[i] = prefix_sum[i-1] + coins[i-1]\nfor _ in range(q):\n    a, b = map(int, input().split())\n    current_sum = 0\n    result = 1\n    for i in range(a, b+1):\n        if current_sum + prefix_sum[i] - prefix_sum[a-1] < result:\n            result = current_sum + prefix_sum[i] - prefix_sum[a-1] + 1\n        current_sum += coins[i-1]\n    print(result)\n",
            "passed_test_cases": 1,
            "total_test_cases": 8,
            "mean_time_taken": 0.7019794881343842,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Missing Number",
            "category": "Introductory Problems",
            "solution": "# Read the input\nn = int(input())\nnumbers = list(map(int, input().split()))\n\n# Calculate the sum of all numbers from 1 to n\nexpected_sum = n * (n + 1) // 2\n\n# Calculate the sum of the given numbers\nactual_sum = sum(numbers)\n\n# The difference is the missing number\nmissing_number = expected_sum - actual_sum\n\n# Print the missing number\nprint(missing_number)\n",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.12933080536978586,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Money Sums",
            "category": "Dynamic Programming",
            "solution": "# Read the input\nn = int(input())\ncoins = list(map(int, input().split()))\n\n# Initialize the set of sums\nsums = {0}\n\n# Iterate over the coins\nfor coin in coins:\n    # Create a new set of sums\n    new_sums = set()\n    for s in sums:\n        new_sums.add(s + coin)\n    # Update the set of sums\n    sums |= new_sums\n\n# Print the number of distinct sums and all possible sums\nprint(len(sums))\nprint(*sorted(sums))\n",
            "passed_test_cases": 0,
            "total_test_cases": 13,
            "mean_time_taken": 0.15746421080369216,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Monotone Subsequences",
            "category": "Additional Problems",
            "solution": "def monotone_subsequences():\n    t = int(input())\n    for _ in range(t):\n        n, k = map(int, input().split())\n        if k == 1:\n            print(\"IMPOSSIBLE\")\n        elif k == n:\n            print(*range(1, n+1))\n        else:\n            print(*range(n-k+1, 0, -1), *range(n-k+2, n+1))\n\nmonotone_subsequences()\n",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.1244359016418457,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Monster Game I",
            "category": "Advanced Techniques",
            "solution": "def monster_game(n, x, strengths, skill_factors):\n    time = 0\n    for i in range(n):\n        if x > skill_factors[i]:\n            time += strengths[i] * x\n            x = skill_factors[i]\n    return time\n\nn, x = map(int, input().split())\nstrengths = list(map(int, input().split()))\nskill_factors = list(map(int, input().split()))\n\nprint(monster_game(n, x, strengths, skill_factors))\n",
            "passed_test_cases": 0,
            "total_test_cases": 5,
            "mean_time_taken": 0.15987896919250488,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Monster Game II",
            "category": "Advanced Techniques",
            "solution": "def monster_game_ii():\n    n, x = map(int, input().split())\n    s = list(map(int, input().split()))\n    f = list(map(int, input().split()))\n\n    dp = [[float('inf') for _ in range(x+1)] for _ in range(n+1)]\n    dp[0][x] = 0\n\n    for i in range(1, n+1):\n        for j in range(1, x+1):\n            if i < n:\n                dp[i][j] = min(dp[i][j], dp[i-1][j])\n            dp[i][j] = min(dp[i][j], dp[i-1][f[i-1]] + s[i-1] * j)\n\n    print(dp[n][x])\n\nmonster_game_ii()\n",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.7946938872337341,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MonsterGameII_shot_1.py\", line 17, in <module>\n    monster_game_ii()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MonsterGameII_shot_1.py\", line 6, in monster_game_ii\n    dp = [[float('inf') for _ in range(x+1)] for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MonsterGameII_shot_1.py\", line 6, in <listcomp>\n    dp = [[float('inf') for _ in range(x+1)] for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MonsterGameII_shot_1.py\", line 6, in <listcomp>\n    dp = [[float('inf') for _ in range(x+1)] for _ in range(n+1)]\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MonsterGameII_shot_1.py\", line 17, in <module>\n    monster_game_ii()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MonsterGameII_shot_1.py\", line 6, in monster_game_ii\n    dp = [[float('inf') for _ in range(x+1)] for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MonsterGameII_shot_1.py\", line 6, in <listcomp>\n    dp = [[float('inf') for _ in range(x+1)] for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MonsterGameII_shot_1.py\", line 6, in <listcomp>\n    dp = [[float('inf') for _ in range(x+1)] for _ in range(n+1)]\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MonsterGameII_shot_1.py\", line 17, in <module>\n    monster_game_ii()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MonsterGameII_shot_1.py\", line 6, in monster_game_ii\n    dp = [[float('inf') for _ in range(x+1)] for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MonsterGameII_shot_1.py\", line 6, in <listcomp>\n    dp = [[float('inf') for _ in range(x+1)] for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MonsterGameII_shot_1.py\", line 6, in <listcomp>\n    dp = [[float('inf') for _ in range(x+1)] for _ in range(n+1)]\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MonsterGameII_shot_1.py\", line 17, in <module>\n    monster_game_ii()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MonsterGameII_shot_1.py\", line 6, in monster_game_ii\n    dp = [[float('inf') for _ in range(x+1)] for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MonsterGameII_shot_1.py\", line 6, in <listcomp>\n    dp = [[float('inf') for _ in range(x+1)] for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MonsterGameII_shot_1.py\", line 6, in <listcomp>\n    dp = [[float('inf') for _ in range(x+1)] for _ in range(n+1)]\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MonsterGameII_shot_1.py\", line 17, in <module>\n    monster_game_ii()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MonsterGameII_shot_1.py\", line 6, in monster_game_ii\n    dp = [[float('inf') for _ in range(x+1)] for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MonsterGameII_shot_1.py\", line 6, in <listcomp>\n    dp = [[float('inf') for _ in range(x+1)] for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MonsterGameII_shot_1.py\", line 6, in <listcomp>\n    dp = [[float('inf') for _ in range(x+1)] for _ in range(n+1)]\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MonsterGameII_shot_1.py\", line 17, in <module>\n    monster_game_ii()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MonsterGameII_shot_1.py\", line 6, in monster_game_ii\n    dp = [[float('inf') for _ in range(x+1)] for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MonsterGameII_shot_1.py\", line 6, in <listcomp>\n    dp = [[float('inf') for _ in range(x+1)] for _ in range(n+1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/MonsterGameII_shot_1.py\", line 6, in <listcomp>\n    dp = [[float('inf') for _ in range(x+1)] for _ in range(n+1)]\nMemoryError\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Monsters",
            "category": "Graph Algorithms",
            "solution": "from collections import deque\n\ndef is_valid(x, y, n, m, grid):\n    if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] == '#':\n        return False\n    return True\n\ndef bfs(n, m, grid):\n    dx = [-1, 0, 1, 0]\n    dy = [0, -1, 0, 1]\n    dist = [[-1] * m for _ in range(n)]\n    dist[0][0] = 0\n    q = deque()\n    q.append((0, 0, ''))\n    while q:\n        x, y, path = q.popleft()\n        for i in range(4):\n            nx, ny = x + dx[i], y + dy[i]\n            if is_valid(nx, ny, n, m, grid) and dist[nx][ny] == -1:\n                if grid[nx][ny] == 'A':\n                    return 'YES\\n' + str(dist[x][y] + 1) + '\\n' + path + 'UDLR'[i]\n                if grid[nx][ny] == '.':\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny, path + 'UDLR'[i]))\n    return 'NO'\n\ndef main():\n    n, m = map(int, input().split())\n    grid = [list(input()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'M':\n                grid[i][j] = '#'\n    print(bfs(n, m, grid))\n\nif __name__ == \"__main__\":\n    main()\n",
            "passed_test_cases": 11,
            "total_test_cases": 28,
            "mean_time_taken": 0.17024595396859304,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                5,
                6,
                7,
                8,
                9,
                11,
                13,
                14,
                18,
                21,
                22,
                24,
                25,
                27,
                28
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Movie Festival",
            "category": "Sorting and Searching",
            "solution": "def movie_festival():\n    # Read the number of movies\n    n = int(input())\n\n    # Initialize an empty list to store the movies\n    movies = []\n\n    # Read the starting and ending times of each movie\n    for _ in range(n):\n        start, end = map(int, input().split())\n        movies.append((start, end))\n\n    # Sort the movies by their ending times\n    movies.sort(key=lambda x: x[1])\n\n    # Initialize the count of movies and the ending time of the last selected movie\n    count = 0\n    last_end = 0\n\n    # Iterate over the sorted movies\n    for start, end in movies:\n        # If the starting time of the current movie is greater than or equal to the ending time of the last selected movie\n        if start >= last_end:\n            # Increment the count of movies\n            count += 1\n            # Update the ending time of the last selected movie\n            last_end = end\n\n    # Print the maximum number of movies\n    print(count)\n\n# Call the function\nmovie_festival()\n",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.18600990555503152,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Movie Festival II",
            "category": "Sorting and Searching",
            "solution": "def movie_festival():\n    # Read the input\n    n, k = map(int, input().split())\n    movies = [list(map(int, input().split())) for _ in range(n)]\n\n    # Sort the movies by their starting times\n    movies.sort(key=lambda x: x[0])\n\n    # Initialize an array to keep track of when each club member is free\n    free_times = [0] * k\n\n    # Initialize a variable to keep track of the total number of movies watched\n    total_movies = 0\n\n    # Iterate over the movies\n    for movie in movies:\n        start, end = movie\n\n        # Find the first club member who is free to watch the movie\n        member = find_free_member(free_times, start)\n\n        # If a member is free, they will watch the movie\n        if member != -1:\n            free_times[member] = end\n            total_movies += 1\n\n    # Print the total number of movies watched\n    print(total_movies)\n\ndef find_free_member(free_times, start):\n    # Find the first club member who is free at the movie's starting time\n    for i, time in enumerate(free_times):\n        if time <= start:\n            return i\n    return -1\n\n# Call the function to start the program\nmovie_festival()\n",
            "passed_test_cases": 6,
            "total_test_cases": 13,
            "mean_time_taken": 0.36817479133605957,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                5,
                8,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Movie Festival Queries",
            "category": "Additional Problems",
            "solution": "class SegmentTree:\n    def __init__(self, n):\n        self.n = n\n        self.size = 1 << (n.__radd__(1)).bit_length()\n        self.tree = [0] * (2 * self.size)\n\n    def build(self, arr, x, px, lx, rx):\n        if rx - lx == 1:\n            if lx < self.n and arr[lx] != 0:\n                self.tree[x] = 1\n            return self.tree[x]\n        m = (lx + rx) // 2\n        self.tree[x] = max(self.tree[x], self.build(arr, 2*x+1, px, lx, m) + self.build(arr, 2*x+2, px, m, rx))\n        return self.tree[x]\n\n    def query(self, a, b, x, px, lx, rx):\n        if rx <= a or b <= lx:\n            return 0\n        if a <= lx and rx <= b:\n            return self.tree[x]\n        m = (lx + rx) // 2\n        return max(self.query(a, b, 2*x+1, px, lx, m), self.query(a, b, 2*x+2, px, m, rx))\n\ndef main():\n    n, q = map(int, input().split())\n    movies = [list(map(int, input().split())) for _ in range(n)]\n    queries = [list(map(int, input().split())) for _ in range(q)]\n    movies.sort()\n    dp = [0] * (n + 1)\n    for i, (start, end) in enumerate(movies):\n        dp[i + 1] = dp[i] + 1 if start >= movies[dp[i]][1] else dp[i]\n    st = SegmentTree(n)\n    st.build(dp, 0, 0, 0, st.size)\n    for a, b in queries:\n        idx = next((i for i, (start, _) in enumerate(movies) if start >= a), n)\n        print(st.query(idx, n, 0, 0, 0, st.size))\n\nif __name__ == \"__main__\":\n    main()\n",
            "passed_test_cases": 0,
            "total_test_cases": 5,
            "mean_time_taken": 0.6789018154144287,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Moving Robots",
            "category": "Mathematics",
            "solution": "from collections import defaultdict\n\ndef move_robots(k):\n    dp = [[1.0] * 8 for _ in range(8)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    for _ in range(k):\n        new_dp = [[0.0] * 8 for _ in range(8)]\n        for i in range(8):\n            for j in range(8):\n                for dx, dy in directions:\n                    x, y = i + dx, j + dy\n                    if 0 <= x < 8 and 0 <= y < 8:\n                        new_dp[i][j] += dp[x][y] / 4\n        dp = new_dp\n\n    return round(sum(sum(row) for row in dp), 6)\n\n# Test the function\nprint(move_robots(10))\n",
            "passed_test_cases": 0,
            "total_test_cases": 16,
            "mean_time_taken": 0.11986406147480011,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Multiplication Table",
            "category": "Additional Problems",
            "solution": "# Read the input\nn = int(input())\n\n# Calculate the middle element\n# The middle numbers in both ranges (1 to n) are (n + 1) // 2\n# So, the middle element is the product of these middle numbers\nmiddle_element = ((n + 1) // 2) ** 2\n\n# Print the result\nprint(middle_element)\n",
            "passed_test_cases": 1,
            "total_test_cases": 8,
            "mean_time_taken": 0.1253911554813385,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Nearest Smaller Values",
            "category": "Sorting and Searching",
            "solution": "def nearest_smaller_values(n, arr):\n    stack = []\n    result = [0] * n\n\n    # Process each element in the array\n    for i in range(n):\n        # While the stack is not empty and the top element is greater than or equal to the current element\n        while stack and arr[stack[-1]] >= arr[i]:\n            # Pop the top element from the stack\n            stack.pop()\n\n        # If the stack is not empty, the nearest smaller value is at the top of the stack\n        if stack:\n            result[i] = stack[-1] + 1\n\n        # Push the current index onto the stack\n        stack.append(i)\n\n    return result\n\n# Read the input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Print the output\nprint(*nearest_smaller_values(n, arr))\n",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.15558026387141302,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Necessary Cities",
            "category": "Advanced Techniques",
            "solution": "from collections import defaultdict\n\ndef dfs(node, parent, low, disc, visited, timer, graph, ap):\n    visited[node] = True\n    disc[node] = low[node] = timer\n    timer += 1\n    children = 0\n\n    for neighbour in graph[node]:\n        if neighbour == parent:\n            continue\n        if not visited[neighbour]:\n            children += 1\n            dfs(neighbour, node, low, disc, visited, timer, graph, ap)\n            low[node] = min(low[node], low[neighbour])\n            if parent != -1 and low[neighbour] >= disc[node]:\n                ap.add(node)\n        elif neighbour != parent:\n            low[node] = min(low[node], disc[neighbour])\n\n    if parent == -1 and children > 1:\n        ap.add(node)\n\ndef find_articulation_points(n, m, edges):\n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    visited = [False] * (n + 1)\n    disc = [float('inf')] * (n + 1)\n    low = [float('inf')] * (n + 1)\n    timer = 0\n    ap = set()\n\n    for node in range(1, n + 1):\n        if not visited[node]:\n            dfs(node, -1, low, disc, visited, timer, graph, ap)\n\n    return ap\n\n# Read input\nn, m = map(int, input().split())\nedges = [list(map(int, input().split())) for _ in range(m)]\n\n# Find articulation points\nap = find_articulation_points(n, m, edges)\n\n# Print output\nprint(len(ap))\nprint(*sorted(ap))\n",
            "passed_test_cases": 2,
            "total_test_cases": 8,
            "mean_time_taken": 0.1769745945930481,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NecessaryCities_shot_1.py\", line 47, in <module>\n    ap = find_articulation_points(n, m, edges)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NecessaryCities_shot_1.py\", line 38, in find_articulation_points\n    dfs(node, -1, low, disc, visited, timer, graph, ap)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NecessaryCities_shot_1.py\", line 14, in dfs\n    dfs(neighbour, node, low, disc, visited, timer, graph, ap)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NecessaryCities_shot_1.py\", line 14, in dfs\n    dfs(neighbour, node, low, disc, visited, timer, graph, ap)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NecessaryCities_shot_1.py\", line 14, in dfs\n    dfs(neighbour, node, low, disc, visited, timer, graph, ap)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NecessaryCities_shot_1.py\", line 9, in dfs\n    for neighbour in graph[node]:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NecessaryCities_shot_1.py\", line 47, in <module>\n    ap = find_articulation_points(n, m, edges)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NecessaryCities_shot_1.py\", line 38, in find_articulation_points\n    dfs(node, -1, low, disc, visited, timer, graph, ap)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NecessaryCities_shot_1.py\", line 14, in dfs\n    dfs(neighbour, node, low, disc, visited, timer, graph, ap)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NecessaryCities_shot_1.py\", line 14, in dfs\n    dfs(neighbour, node, low, disc, visited, timer, graph, ap)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NecessaryCities_shot_1.py\", line 14, in dfs\n    dfs(neighbour, node, low, disc, visited, timer, graph, ap)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NecessaryCities_shot_1.py\", line 9, in dfs\n    for neighbour in graph[node]:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Necessary Roads",
            "category": "Advanced Techniques",
            "solution": "def find_bridges(adj, n, m, low, disc, parent, bridges):\n    for u in range(n):\n        if disc[u] == -1:\n            dfs_find_bridges(u, adj, n, m, low, disc, parent, bridges)\n\ndef dfs_find_bridges(u, adj, n, m, low, disc, parent, bridges):\n    disc[u] = low[u] = len(bridges)\n    for v in adj[u]:\n        if disc[v] == -1:\n            parent[v] = u\n            dfs_find_bridges(v, adj, n, m, low, disc, parent, bridges)\n            low[u] = min(low[u], low[v])\n            if low[v] > disc[u]:\n                bridges.append([u, v])\n        elif v != parent[u]:\n            low[u] = min(low[u], disc[v])\n\ndef necessary_roads(n, m, edges):\n    adj = [[] for _ in range(n)]\n    for a, b in edges:\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n    low = [-1] * n\n    disc = [-1] * n\n    parent = [-1] * n\n    bridges = []\n    find_bridges(adj, n, m, low, disc, parent, bridges)\n    print(len(bridges))\n    for bridge in bridges:\n        print(bridge[0] + 1, bridge[1] + 1)\n\n# Test the function\nnecessary_roads(5, 5, [[1, 2], [1, 4], [2, 4], [3, 5], [4, 5]])\n",
            "passed_test_cases": 1,
            "total_test_cases": 5,
            "mean_time_taken": 0.12665810585021972,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Nested Ranges Check",
            "category": "Sorting and Searching",
            "solution": "def nested_ranges_check():\n    n = int(input())\n    ranges = [tuple(map(int, input().split())) for _ in range(n)]\n\n    # Sort the ranges by their starting points\n    sorted_ranges = sorted(ranges)\n\n    contains = [0] * n\n    contained = [0] * n\n\n    # Iterate over the sorted ranges\n    for i, (a, b) in enumerate(sorted_ranges):\n        for j, (c, d) in enumerate(sorted_ranges[:i]):\n            if a <= c and d <= b:\n                contains[ranges.index((c, d))] = 1\n                contained[ranges.index((a, b))] = 1\n                break\n\n    print(' '.join(map(str, contains)))\n    print(' '.join(map(str, contained)))\n\nnested_ranges_check()\n",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.6615398526191711,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Nested Ranges Count",
            "category": "Sorting and Searching",
            "solution": "# Read the number of ranges\nn = int(input())\n\n# Initialize two lists to store the contain and contained counts\ncontain_counts = [0] * n\ncontained_counts = [0] * n\n\n# Initialize a list to store the ranges\nranges = []\n\n# Read the ranges\nfor i in range(n):\n    x, y = map(int, input().split())\n    ranges.append((x, y))\n\n# Iterate over the ranges\nfor i in range(n):\n    x1, y1 = ranges[i]\n    for j in range(n):\n        if i == j:\n            continue\n        x2, y2 = ranges[j]\n        if x1 <= x2 and y2 <= y1:\n            contain_counts[i] += 1\n        if x2 <= x1 and y1 <= y2:\n            contained_counts[i] += 1\n\n# Print the contain counts\nprint(' '.join(map(str, contain_counts)))\n\n# Print the contained counts\nprint(' '.join(map(str, contained_counts)))\n",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.6624366641044617,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Network Breakdown",
            "category": "Additional Problems",
            "solution": "def initialize(n):\n    parent = [i for i in range(n + 1)]\n    size = [1] * (n + 1)\n    return parent, size\n\ndef find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, size, x, y):\n    root_x = find(parent, x)\n    root_y = find(parent, y)\n    if root_x != root_y:\n        if size[root_x] < size[root_y]:\n            parent[root_x] = root_y\n            size[root_y] += size[root_x]\n        else:\n            parent[root_y] = root_x\n            size[root_x] += size[root_y]\n\nn, m, k = map(int, input().split())\nparent, size = initialize(n)\n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    union(parent, size, a, b)\n\nfor _ in range(k):\n    a, b = map(int, input().split())\n    if find(parent, a) == find(parent, b):\n        size[find(parent, a)] -= 1\n        print(max(size[find(parent, a)], size[find(parent, b)]))\n",
            "passed_test_cases": 0,
            "total_test_cases": 13,
            "mean_time_taken": 0.3106614076174222,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Network Renovation",
            "category": "Additional Problems",
            "solution": "def find(parent, i):\n    if parent[i] != i:\n        parent[i] = find(parent, parent[i])\n    return parent[i]\n\ndef union(parent, rank, x, y):\n    root_x = find(parent, x)\n    root_y = find(parent, y)\n\n    if rank[root_x] < rank[root_y]:\n        parent[root_x] = root_y\n    elif rank[root_x] > rank[root_y]:\n        parent[root_y] = root_x\n    else:\n        parent[root_y] = root_x\n        rank[root_x] += 1\n\ndef kruskal(n, edges):\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n    mst = []\n    i = 0\n\n    edges.sort(key=lambda item: item[2])\n\n    while len(mst) < n - 1:\n        u, v, w = edges[i]\n        i += 1\n        x = find(parent, u)\n        y = find(parent, v)\n\n        if x != y:\n            mst.append([u, v])\n            union(parent, rank, x, y)\n\n    return mst\n\ndef dfs(graph, visited, node, parent):\n    visited[node] = True\n\n    for child in graph[node]:\n        if not visited[child]:\n            dfs(graph, visited, child, node)\n        elif child != parent:\n            print(node, child)\n\ndef solution(n, edges):\n    graph = [[] for _ in range(n + 1)]\n\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False] * (n + 1)\n    dfs(graph, visited, 1, -1)\n\nn = int(input())\nedges = []\n\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append([u, v, 0])\n\nmst = kruskal(n, edges)\nsolution(n, mst)\n",
            "passed_test_cases": 0,
            "total_test_cases": 21,
            "mean_time_taken": 0.17108585720970518,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NetworkRenovation_shot_1.py\", line 65, in <module>\n    solution(n, mst)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NetworkRenovation_shot_1.py\", line 55, in solution\n    dfs(graph, visited, 1, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NetworkRenovation_shot_1.py\", line 43, in dfs\n    dfs(graph, visited, child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NetworkRenovation_shot_1.py\", line 43, in dfs\n    dfs(graph, visited, child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NetworkRenovation_shot_1.py\", line 43, in dfs\n    dfs(graph, visited, child, node)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NetworkRenovation_shot_1.py\", line 44, in dfs\n    elif child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NetworkRenovation_shot_1.py\", line 65, in <module>\n    solution(n, mst)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NetworkRenovation_shot_1.py\", line 55, in solution\n    dfs(graph, visited, 1, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NetworkRenovation_shot_1.py\", line 43, in dfs\n    dfs(graph, visited, child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NetworkRenovation_shot_1.py\", line 43, in dfs\n    dfs(graph, visited, child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NetworkRenovation_shot_1.py\", line 43, in dfs\n    dfs(graph, visited, child, node)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NetworkRenovation_shot_1.py\", line 44, in dfs\n    elif child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NetworkRenovation_shot_1.py\", line 65, in <module>\n    solution(n, mst)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NetworkRenovation_shot_1.py\", line 55, in solution\n    dfs(graph, visited, 1, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NetworkRenovation_shot_1.py\", line 43, in dfs\n    dfs(graph, visited, child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NetworkRenovation_shot_1.py\", line 43, in dfs\n    dfs(graph, visited, child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NetworkRenovation_shot_1.py\", line 43, in dfs\n    dfs(graph, visited, child, node)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/NetworkRenovation_shot_1.py\", line 44, in dfs\n    elif child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "New Flight Routes",
            "category": "Additional Problems",
            "solution": "def find_root(parent, i):\n    if parent[i] != i:\n        parent[i] = find_root(parent, parent[i])\n    return parent[i]\n\ndef union(parent, rank, x, y):\n    root_x = find_root(parent, x)\n    root_y = find_root(parent, y)\n\n    if rank[root_x] > rank[root_y]:\n        parent[root_y] = root_x\n    elif rank[root_x] < rank[root_y]:\n        parent[root_x] = root_y\n    else:\n        parent[root_y] = root_x\n        rank[root_x] += 1\n\ndef new_flight_routes(n, m, flights):\n    parent = [i for i in range(n+1)]\n    rank = [0] * (n+1)\n\n    for a, b in flights:\n        union(parent, rank, a, b)\n\n    roots = set()\n    for i in range(1, n+1):\n        roots.add(find_root(parent, i))\n\n    new_flights = len(roots) - 1\n    result = []\n\n    for i in range(1, n+1):\n        root_i = find_root(parent, i)\n        if len(roots) > 1 and root_i == roots.pop():\n            result.append((i, min(roots)))\n\n    return new_flights, result\n\nn, m = map(int, input().split())\nflights = [list(map(int, input().split())) for _ in range(m)]\n\nnew_flights, new_routes = new_flight_routes(n, m, flights)\n\nprint(new_flights)\nfor a, b in new_routes:\n    print(a, b)\n",
            "passed_test_cases": 1,
            "total_test_cases": 26,
            "mean_time_taken": 0.18867093783158523,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "New Roads Queries",
            "category": "Advanced Techniques",
            "solution": "def find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, rank, x, y):\n    rootX = find(parent, x)\n    rootY = find(parent, y)\n\n    if rootX != rootY:\n        if rank[rootX] > rank[rootY]:\n            parent[rootY] = rootX\n        elif rank[rootX] < rank[rootY]:\n            parent[rootX] = rootY\n        else:\n            parent[rootY] = rootX\n            rank[rootX] += 1\n\ndef new_roads_queries(n, m, q, roads, queries):\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n    graph = [[] for _ in range(m + 1)]\n\n    for i, (x, y) in enumerate(roads, 1):\n        graph[i] = (x, y)\n\n    days = [0] * q\n    for i, (x, y) in enumerate(queries):\n        low, high = 0, m\n        while low <= high:\n            mid = (low + high) // 2\n            for j in range(1, mid + 1):\n                union(parent, rank, *graph[j])\n            if find(parent, x) == find(parent, y):\n                days[i] = mid\n                break\n            else:\n                for j in range(mid + 1, m + 1):\n                    parent[graph[j][0]] = graph[j][0]\n                    parent[graph[j][1]] = graph[j][1]\n                high = mid - 1\n\n    return days\n",
            "passed_test_cases": 0,
            "total_test_cases": 7,
            "mean_time_taken": 0.12521185193743026,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Nim Game I",
            "category": "Mathematics",
            "solution": "def nim_game(tests):\n    for _ in range(tests):\n        n = int(input())\n        heaps = list(map(int, input().split()))\n        nim_sum = 0\n        for heap in heaps:\n            nim_sum ^= heap\n        print(\"first\" if nim_sum else \"second\")\n\nif __name__ == \"__main__\":\n    tests = int(input())\n    nim_game(tests)\n",
            "passed_test_cases": 4,
            "total_test_cases": 4,
            "mean_time_taken": 0.1343996524810791,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Nim Game II",
            "category": "Mathematics",
            "solution": "# Read the number of test cases\nt = int(input())\n\nfor _ in range(t):\n    # Read the number of heaps\n    n = int(input())\n\n    # Read the sizes of the heaps\n    heaps = list(map(int, input().split()))\n\n    # Compute the Nim-sum of the heap sizes\n    nim_sum = 0\n    for heap in heaps:\n        nim_sum ^= heap\n\n    # Print the winner\n    if nim_sum == 0:\n        print(\"second\")\n    else:\n        print(\"first\")\n",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.15572434663772583,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Number Grid",
            "category": "Additional Problems",
            "solution": "# Read the input\ny, x = map(int, input().split())\n\n# Calculate the value at square (y, x)\nvalue = max(y, x) - 1\n\n# Print the result\nprint(value)\n",
            "passed_test_cases": 5,
            "total_test_cases": 20,
            "mean_time_taken": 0.11849849224090576,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                12,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Number Spiral",
            "category": "Introductory Problems",
            "solution": "def number_spiral(y, x):\n    # Calculate the side length of the square that contains the target\n    side = max(abs(y), abs(x))\n    while side**2 < abs(y) + abs(x):\n        side += 1\n\n    # Calculate the corner of the square that contains the target\n    corner = (side - 1)**2\n\n    # Calculate the offset from the corner to the target\n    offset = abs(y) + abs(x) - 2 * (side - 1)\n\n    # Calculate the number at the target position\n    number = corner + offset\n\n    # Adjust the number based on the target's quadrant\n    if y < 0 and x >= 0:\n        number -= offset\n    elif y < 0 and x < 0:\n        number = corner - offset\n    elif y >= 0 and x < 0:\n        number += offset\n\n    return number\n\n# Read the number of tests\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the row and column\n    y, x = map(int, input().split())\n\n    # Calculate and print the number at the target position\n    print(number_spiral(y - 1, x - 1))\n",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.38927268981933594,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "One Bit Positions",
            "category": "Advanced Techniques",
            "solution": "# Read the input\ns = input()\nn = len(s)\n\n# Initialize the counts list\ncounts = [0] * (n-1)\n\n# Iterate over the string\nfor i in range(n):\n    if s[i] == '1':\n        # Iterate over the previous k positions\n        for j in range(max(0, i-n+1), i):\n            if s[j] == '1':\n                # Increment the count for the corresponding distance\n                counts[i-j-1] += 1\n\n# Print the counts\nprint(' '.join(map(str, counts)))\n",
            "passed_test_cases": 1,
            "total_test_cases": 5,
            "mean_time_taken": 0.8640982627868652,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Palindrome Queries",
            "category": "String Algorithms",
            "solution": "def is_palindrome(s, a, b):\n    while a < b:\n        if s[a] != s[b]:\n            return False\n        a += 1\n        b -= 1\n    return True\n\nn, m = map(int, input().split())\ns = input()\nfor _ in range(m):\n    operation = list(map(str, input().split()))\n    if operation[0] == '1':\n        k, x = int(operation[1]), operation[2]\n        s = s[:k-1] + x + s[k:]\n    elif operation[0] == '2':\n        a, b = int(operation[1]), int(operation[2])\n        if is_palindrome(s, a-1, b-1):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n",
            "passed_test_cases": 7,
            "total_test_cases": 14,
            "mean_time_taken": 0.6186280931745257,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                8,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Palindrome Reorder",
            "category": "Introductory Problems",
            "solution": "def palindrome_reorder(s):\n    # Count the frequency of each character\n    char_freq = {}\n    for char in s:\n        char_freq[char] = char_freq.get(char, 0) + 1\n\n    # Check if more than one character has an odd frequency\n    odd_freq_chars = 0\n    odd_freq_char = ''\n    for char, freq in char_freq.items():\n        if freq % 2 == 1:\n            odd_freq_chars += 1\n            odd_freq_char = char\n            if odd_freq_chars > 1:\n                return \"NO SOLUTION\"\n\n    # Build the palindrome\n    palindrome = ''\n    for char, freq in char_freq.items():\n        if char != odd_freq_char:\n            palindrome += char * (freq // 2)\n    palindrome = palindrome * 2\n    if odd_freq_char:\n        palindrome = palindrome[:len(palindrome)//2] + odd_freq_char + palindrome[len(palindrome)//2:]\n    return palindrome\n\n# Read the input\ns = input().strip()\n\n# Print the result\nprint(palindrome_reorder(s))\n",
            "passed_test_cases": 9,
            "total_test_cases": 17,
            "mean_time_taken": 0.13176490278805003,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                6,
                7,
                8,
                9,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Parcel Delivery",
            "category": "Advanced Techniques",
            "solution": "import heapq\n\ndef dijkstra(graph, start, end, k):\n    heap = [(0, start, k)]\n    visited = set()\n    while heap:\n        (cost, city, parcels) = heapq.heappop(heap)\n        if (city, parcels) in visited:\n            continue\n        visited.add((city, parcels))\n        if city == end and parcels == 0:\n            return cost\n        for neighbor, (r, c) in graph[city]:\n            if parcels >= r:\n                new_parcels = parcels - r\n            else:\n                new_parcels = 0\n                r = parcels\n            new_cost = cost + r * c\n            heapq.heappush(heap, (new_cost, neighbor, new_parcels))\n    return -1\n\ndef main():\n    n, m, k = map(int, input().split())\n    graph = {city: [] for city in range(1, n + 1)}\n    for _ in range(m):\n        a, b, r, c = map(int, input().split())\n        graph[a].append((b, (r, c)))\n    print(dijkstra(graph, 1, n, k))\n\nif __name__ == \"__main__\":\n    main()\n",
            "passed_test_cases": 1,
            "total_test_cases": 13,
            "mean_time_taken": 0.12458881965050331,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Path Queries",
            "category": "Tree Algorithms",
            "solution": "def dfs(node, parent):\n    for child in graph[node]:\n        if child != parent:\n            parent[child] = node\n            sums[child] = sums[node] + values[child]\n            dfs(child, node)\n\nn, q = map(int, input().split())\nvalues = list(map(int, input().split()))\ngraph = [[] for _ in range(n)]\nparent = [-1] * n\nsums = [0] * n\n\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    graph[a - 1].append(b - 1)\n    graph[b - 1].append(a - 1)\n\ndfs(0, -1)\n\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    if query[0] == 1:\n        values[query[1] - 1] = query[2]\n        sums[query[1] - 1] = sums[parent[query[1] - 1]] + values[query[1] - 1] if parent[query[1] - 1] != -1 else values[query[1] - 1]\n    else:\n        print(sums[query[1] - 1])\n",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.2856632947921753,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueries_shot_1.py\", line 19, in <module>\n    dfs(0, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueries_shot_1.py\", line 4, in dfs\n    parent[child] = node\nTypeError: 'int' object does not support item assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueries_shot_1.py\", line 19, in <module>\n    dfs(0, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueries_shot_1.py\", line 4, in dfs\n    parent[child] = node\nTypeError: 'int' object does not support item assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueries_shot_1.py\", line 19, in <module>\n    dfs(0, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueries_shot_1.py\", line 4, in dfs\n    parent[child] = node\nTypeError: 'int' object does not support item assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueries_shot_1.py\", line 19, in <module>\n    dfs(0, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueries_shot_1.py\", line 4, in dfs\n    parent[child] = node\nTypeError: 'int' object does not support item assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueries_shot_1.py\", line 19, in <module>\n    dfs(0, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueries_shot_1.py\", line 4, in dfs\n    parent[child] = node\nTypeError: 'int' object does not support item assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueries_shot_1.py\", line 19, in <module>\n    dfs(0, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueries_shot_1.py\", line 4, in dfs\n    parent[child] = node\nTypeError: 'int' object does not support item assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueries_shot_1.py\", line 19, in <module>\n    dfs(0, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueries_shot_1.py\", line 4, in dfs\n    parent[child] = node\nTypeError: 'int' object does not support item assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueries_shot_1.py\", line 19, in <module>\n    dfs(0, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueries_shot_1.py\", line 4, in dfs\n    parent[child] = node\nTypeError: 'int' object does not support item assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueries_shot_1.py\", line 19, in <module>\n    dfs(0, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueries_shot_1.py\", line 4, in dfs\n    parent[child] = node\nTypeError: 'int' object does not support item assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueries_shot_1.py\", line 19, in <module>\n    dfs(0, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueries_shot_1.py\", line 4, in dfs\n    parent[child] = node\nTypeError: 'int' object does not support item assignment\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Path Queries II",
            "category": "Tree Algorithms",
            "solution": "class SegmentTree:\n    def __init__(self, v):\n        n = len(v)\n        self.seg = [0] * (2 * n)\n        self.v = v\n        self.build(1, 0, n - 1)\n\n    def build(self, node, start, end):\n        if start == end:\n            self.seg[node] = self.v[start]\n        else:\n            mid = (start + end) // 2\n            self.build(node * 2, start, mid)\n            self.build(node * 2 + 1, mid + 1, end)\n            self.seg[node] = max(self.seg[node * 2], self.seg[node * 2 + 1])\n\n    def update(self, node, start, end, idx, val):\n        if start == end:\n            self.seg[node] = val\n        else:\n            mid = (start + end) // 2\n            if idx <= mid:\n                self.update(node * 2, start, mid, idx, val)\n            else:\n                self.update(node * 2 + 1, mid + 1, end, idx, val)\n            self.seg[node] = max(self.seg[node * 2], self.seg[node * 2 + 1])\n\n    def query(self, node, start, end, L, R):\n        if L > end or R < start:\n            return float('-inf')\n        if L <= start and end <= R:\n            return self.seg[node]\n        mid = (start + end) // 2\n        return max(self.query(node * 2, start, mid, L, R), self.query(node * 2 + 1, mid + 1, end, L, R))\n\ndef dfs(u, p, depth, ancestor, adj, tree_size):\n    depth[u] = depth[p] + 1\n    ancestor[u] = [p]\n    for v in adj[u]:\n        if v != p:\n            dfs(v, u, depth, ancestor, adj, tree_size)\n            ancestor[u].append(ancestor[v][-1])\n            tree_size[u] += tree_size[v]\n\ndef lca(u, v, ancestor):\n    if len(ancestor[u]) < len(ancestor[v]):\n        u, v = v, u\n    d = len(ancestor[u]) - len(ancestor[v])\n    u = ancestor[u][d]\n    for i in range(len(ancestor[u]), 0, -1):\n        if ancestor[u][i - 1] != ancestor[v][i - 1]:\n            u = ancestor[u][i - 1]\n            v = ancestor[v][i - 1]\n    return u\n\ndef main():\n    n, q = map(int, input().split())\n    v = list(map(int, input().split()))\n    adj = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    depth = [0] * n\n    ancestor = [{0}] * n\n    tree_size = [1] * n\n    dfs(0, -1, depth, ancestor, adj, tree_size)\n    st = SegmentTree(v)\n    for _ in range(q):\n        t, u, v = map(int, input().split())\n        if t == 1:\n            u -= 1\n            st.update(1, 0, n - 1, u, v)\n            v = [v]\n        else:\n            u -= 1\n            v -= 1\n            lca_node = lca(u, v, ancestor)\n            print(max(st.query(1, 0, n - 1, u, lca_node), st.query(1, 0, n - 1, v, lca_node)))\n\nif __name__ == \"__main__\":\n    main()\n",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.34182593822479246,
            "mean_memory_used": 1101.2,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 84, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 70, in main\n    st = SegmentTree(v)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 3, in __init__\n    n = len(v)\nTypeError: object of type 'int' has no len()\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 84, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 69, in main\n    dfs(0, -1, depth, ancestor, adj, tree_size)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 41, in dfs\n    dfs(v, u, depth, ancestor, adj, tree_size)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 41, in dfs\n    dfs(v, u, depth, ancestor, adj, tree_size)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 41, in dfs\n    dfs(v, u, depth, ancestor, adj, tree_size)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 40, in dfs\n    if v != p:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 84, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 69, in main\n    dfs(0, -1, depth, ancestor, adj, tree_size)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 41, in dfs\n    dfs(v, u, depth, ancestor, adj, tree_size)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 41, in dfs\n    dfs(v, u, depth, ancestor, adj, tree_size)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 41, in dfs\n    dfs(v, u, depth, ancestor, adj, tree_size)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 40, in dfs\n    if v != p:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 84, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 70, in main\n    st = SegmentTree(v)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 3, in __init__\n    n = len(v)\nTypeError: object of type 'int' has no len()\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 84, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 70, in main\n    st = SegmentTree(v)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 3, in __init__\n    n = len(v)\nTypeError: object of type 'int' has no len()\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 84, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 69, in main\n    dfs(0, -1, depth, ancestor, adj, tree_size)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 41, in dfs\n    dfs(v, u, depth, ancestor, adj, tree_size)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 41, in dfs\n    dfs(v, u, depth, ancestor, adj, tree_size)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 41, in dfs\n    dfs(v, u, depth, ancestor, adj, tree_size)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 40, in dfs\n    if v != p:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 84, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 70, in main\n    st = SegmentTree(v)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 3, in __init__\n    n = len(v)\nTypeError: object of type 'int' has no len()\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 84, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 69, in main\n    dfs(0, -1, depth, ancestor, adj, tree_size)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 41, in dfs\n    dfs(v, u, depth, ancestor, adj, tree_size)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 41, in dfs\n    dfs(v, u, depth, ancestor, adj, tree_size)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 41, in dfs\n    dfs(v, u, depth, ancestor, adj, tree_size)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 40, in dfs\n    if v != p:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 84, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 70, in main\n    st = SegmentTree(v)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 3, in __init__\n    n = len(v)\nTypeError: object of type 'int' has no len()\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 84, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 69, in main\n    dfs(0, -1, depth, ancestor, adj, tree_size)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 41, in dfs\n    dfs(v, u, depth, ancestor, adj, tree_size)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 41, in dfs\n    dfs(v, u, depth, ancestor, adj, tree_size)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 41, in dfs\n    dfs(v, u, depth, ancestor, adj, tree_size)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PathQueriesII_shot_1.py\", line 40, in dfs\n    if v != p:\nRecursionError: maximum recursion depth exceeded in comparison\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Pattern Positions",
            "category": "String Algorithms",
            "solution": "# Read the input string and the number of patterns\ns = input().strip()\nk = int(input().strip())\n\n# Initialize an empty list to store the results\nresults = []\n\n# Iterate over each pattern\nfor _ in range(k):\n    pattern = input().strip()\n\n    # Find the first position of the pattern in the string\n    position = s.find(pattern)\n\n    # If the pattern is found, add the position plus one to the results\n    # (since the positions are 1-indexed)\n    if position != -1:\n        results.append(position + 1)\n    # If the pattern is not found, add -1 to the results\n    else:\n        results.append(-1)\n\n# Print each result on a new line\nfor result in results:\n    print(result)\n",
            "passed_test_cases": 9,
            "total_test_cases": 10,
            "mean_time_taken": 0.34792461395263674,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Permutation Inversions",
            "category": "Additional Problems",
            "solution": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\nMAX = 501\n\nfact = [0]*MAX\ninv = [0]*MAX\nfact[0] = inv[0] = 1\nfor i in range(1, MAX):\n    fact[i] = fact[i-1]*i%MOD\n    inv[i] = pow(fact[i], MOD-2, MOD)\n\ndef C(n, k):\n    if k > n or k < 0:\n        return 0\n    return fact[n]*inv[k]*inv[n-k]%MOD\n\ndef solve(n, k):\n    dp = [[0]*(k+1) for _ in range(n+1)]\n    for i in range(1, n+1):\n        dp[i][0] = 1\n    for i in range(1, k+1):\n        dp[1][i] = 0\n    for i in range(2, n+1):\n        for j in range(1, k+1):\n            dp[i][j] = (dp[i-1][j] + dp[i-1][j-1])%MOD\n    return dp[n][k]\n\nn, k = map(int, input().split())\nprint(solve(n, k))\n",
            "passed_test_cases": 6,
            "total_test_cases": 16,
            "mean_time_taken": 0.2690899521112442,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                9,
                11,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Permutations",
            "category": "Introductory Problems",
            "solution": "def beautiful_permutation(n):\n    if n == 1:\n        return [1]\n    if n == 2:\n        return [1, 2]\n    if n == 3:\n        return \"NO SOLUTION\"\n\n    result = []\n    for i in range(n if n % 2 else n-1, 0, -2):\n        result.append(i)\n    for i in range(n-2 if n % 2 else n, 0, -2):\n        result.append(i)\n\n    return result\n\n# Read input\nn = int(input().strip())\n\n# Print output\nprint(*beautiful_permutation(n))\n",
            "passed_test_cases": 1,
            "total_test_cases": 21,
            "mean_time_taken": 0.16223505565098353,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Permutations II",
            "category": "Additional Problems",
            "solution": "MOD = 10**9 + 7\ndp = [0] * 1001\ndp[1] = 1\ndp[2] = 2\n\ndef count_beautiful_permutations(n):\n    for i in range(3, n+1):\n        dp[i] = (dp[i-1] + dp[i-2]) % MOD\n    return dp[n]\n\nn = int(input())\nprint(count_beautiful_permutations(n))\n",
            "passed_test_cases": 1,
            "total_test_cases": 23,
            "mean_time_taken": 0.11554630942966627,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Pizzeria Queries",
            "category": "Range Queries",
            "solution": "class SegmentTree:\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (2 * self.n)\n        self.lazy = [0] * (2 * self.n)\n        self.build_tree(arr, 0, self.n - 1, 0)\n\n    def build_tree(self, arr, low, high, pos):\n        if low == high:\n            self.tree[pos] = arr[low]\n            return\n        mid = (low + high) // 2\n        self.build_tree(arr, low, mid, 2 * pos + 1)\n        self.build_tree(arr, mid + 1, high, 2 * pos + 2)\n        self.tree[pos] = min(self.tree[2 * pos + 1], self.tree[2 * pos + 2])\n\n    def propagate(self, low, high, pos):\n        if self.lazy[pos] == 0:\n            return\n        self.tree[pos] += self.lazy[pos]\n        if low != high:\n            self.lazy[2 * pos + 1] += self.lazy[pos]\n            self.lazy[2 * pos + 2] += self.lazy[pos]\n        self.lazy[pos] = 0\n\n    def update_range(self, i, j, inc, low, high, pos):\n        if i > high or j < low:\n            return\n        self.propagate(low, high, pos)\n        if i <= low and j >= high:\n            self.lazy[pos] += inc\n            self.propagate(low, high, pos)\n            return\n        mid = (low + high) // 2\n        self.update_range(i, j, inc, low, mid, 2 * pos + 1)\n        self.update_range(i, j, inc, mid + 1, high, 2 * pos + 2)\n        self.tree[pos] = min(self.tree[2 * pos + 1], self.tree[2 * pos + 2])\n\n    def query(self, i, j, low, high, pos):\n        if i > high or j < low:\n            return float('inf')\n        self.propagate(low, high, pos)\n        if i <= low and j >= high:\n            return self.tree[pos]\n        mid = (low + high) // 2\n        left_min = self.query(i, j, low, mid, 2 * pos + 1)\n        right_min = self.query(i, j, mid + 1, high, 2 * pos + 2)\n        return min(left_min, right_min)\n\n    def update(self, i, inc):\n        self.update_range(i, i, inc, 0, self.n - 1, 0)\n\n    def get_min(self, i, j):\n        return self.query(i, j, 0, self.n - 1, 0)\n\ndef main():\n    n, q = map(int, input().split())\n    p = list(map(int, input().split()))\n    tree = SegmentTree(p)\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            tree.update(query[1] - 1, query[2] - p[query[1] - 1])\n            p[query[1] - 1] = query[2]\n        else:\n            min_price = tree.get_min(0, query[1] - 1)\n            min_price_right = tree.get_min(query[1], n - 1)\n            print(min(min_price + query[1] - 1, min_price_right + n - query[1]))\n\nif __name__ == \"__main__\":\n    main()\n",
            "passed_test_cases": 1,
            "total_test_cases": 4,
            "mean_time_taken": 0.21289288997650146,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 71, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 59, in main\n    tree = SegmentTree(p)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 6, in __init__\n    self.build_tree(arr, 0, self.n - 1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 14, in build_tree\n    self.build_tree(arr, mid + 1, high, 2 * pos + 2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 13, in build_tree\n    self.build_tree(arr, low, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 13, in build_tree\n    self.build_tree(arr, low, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 14, in build_tree\n    self.build_tree(arr, mid + 1, high, 2 * pos + 2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 13, in build_tree\n    self.build_tree(arr, low, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 13, in build_tree\n    self.build_tree(arr, low, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 14, in build_tree\n    self.build_tree(arr, mid + 1, high, 2 * pos + 2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 10, in build_tree\n    self.tree[pos] = arr[low]\nIndexError: list assignment index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 71, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 59, in main\n    tree = SegmentTree(p)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 6, in __init__\n    self.build_tree(arr, 0, self.n - 1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 14, in build_tree\n    self.build_tree(arr, mid + 1, high, 2 * pos + 2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 13, in build_tree\n    self.build_tree(arr, low, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 13, in build_tree\n    self.build_tree(arr, low, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 13, in build_tree\n    self.build_tree(arr, low, mid, 2 * pos + 1)\n  [Previous line repeated 1 more time]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 14, in build_tree\n    self.build_tree(arr, mid + 1, high, 2 * pos + 2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 14, in build_tree\n    self.build_tree(arr, mid + 1, high, 2 * pos + 2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 13, in build_tree\n    self.build_tree(arr, low, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 14, in build_tree\n    self.build_tree(arr, mid + 1, high, 2 * pos + 2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 13, in build_tree\n    self.build_tree(arr, low, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 14, in build_tree\n    self.build_tree(arr, mid + 1, high, 2 * pos + 2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 13, in build_tree\n    self.build_tree(arr, low, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 13, in build_tree\n    self.build_tree(arr, low, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 13, in build_tree\n    self.build_tree(arr, low, mid, 2 * pos + 1)\n  [Previous line repeated 3 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 14, in build_tree\n    self.build_tree(arr, mid + 1, high, 2 * pos + 2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 10, in build_tree\n    self.tree[pos] = arr[low]\nIndexError: list assignment index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 71, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 59, in main\n    tree = SegmentTree(p)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 6, in __init__\n    self.build_tree(arr, 0, self.n - 1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 14, in build_tree\n    self.build_tree(arr, mid + 1, high, 2 * pos + 2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 13, in build_tree\n    self.build_tree(arr, low, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 13, in build_tree\n    self.build_tree(arr, low, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 13, in build_tree\n    self.build_tree(arr, low, mid, 2 * pos + 1)\n  [Previous line repeated 1 more time]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 14, in build_tree\n    self.build_tree(arr, mid + 1, high, 2 * pos + 2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 14, in build_tree\n    self.build_tree(arr, mid + 1, high, 2 * pos + 2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 13, in build_tree\n    self.build_tree(arr, low, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 14, in build_tree\n    self.build_tree(arr, mid + 1, high, 2 * pos + 2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 13, in build_tree\n    self.build_tree(arr, low, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 14, in build_tree\n    self.build_tree(arr, mid + 1, high, 2 * pos + 2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 13, in build_tree\n    self.build_tree(arr, low, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 13, in build_tree\n    self.build_tree(arr, low, mid, 2 * pos + 1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 13, in build_tree\n    self.build_tree(arr, low, mid, 2 * pos + 1)\n  [Previous line repeated 3 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 14, in build_tree\n    self.build_tree(arr, mid + 1, high, 2 * pos + 2)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PizzeriaQueries_shot_1.py\", line 10, in build_tree\n    self.tree[pos] = arr[low]\nIndexError: list assignment index out of range\n"
            ],
            "failed_test_cases": [
                1,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Planets Cycles",
            "category": "Graph Algorithms",
            "solution": "def dfs(planet, teleporters, visited, cycle_length):\n    if visited[planet - 1] != -1:\n        return visited[planet - 1]\n\n    visited[planet - 1] = 0\n    next_planet = teleporters[planet - 1]\n\n    while visited[next_planet - 1] == -1:\n        visited[next_planet - 1] = visited[planet - 1] + 1\n        next_planet = teleporters[next_planet - 1]\n\n    cycle_length[planet - 1] = visited[next_planet - 1] - visited[planet - 1]\n    return visited[next_planet - 1]\n\nn = int(input())\nteleporters = list(map(int, input().split()))\n\nvisited = [-1] * n\ncycle_length = [0] * n\n\nfor i in range(n):\n    if visited[i] == -1:\n        dfs(i + 1, teleporters, visited, cycle_length)\n\nfor i in range(n):\n    if cycle_length[i] == 0:\n        print(visited[i] + 1, end=' ')\n    else:\n        print((visited[i] + 1) % cycle_length[i], end=' ')\n",
            "passed_test_cases": 2,
            "total_test_cases": 14,
            "mean_time_taken": 0.17649597781045095,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Planets Queries I",
            "category": "Graph Algorithms",
            "solution": "def binary_exponentiation(x, k, teleporters):\n    while k > 0:\n        if k % 2:\n            x = teleporters[x]\n            k -= 1\n        else:\n            teleporters[x] = teleporters[teleporters[x]]\n            k //= 2\n    return x\n\nn, q = map(int, input().split())\nteleporters = list(map(int, input().split()))\nfor _ in range(q):\n    x, k = map(int, input().split())\n    print(binary_exponentiation(x, k, teleporters))\n",
            "passed_test_cases": 1,
            "total_test_cases": 13,
            "mean_time_taken": 0.32503377474271333,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsQueriesI_shot_1.py\", line 15, in <module>\n    print(binary_exponentiation(x, k, teleporters))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsQueriesI_shot_1.py\", line 7, in binary_exponentiation\n    teleporters[x] = teleporters[teleporters[x]]\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsQueriesI_shot_1.py\", line 15, in <module>\n    print(binary_exponentiation(x, k, teleporters))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsQueriesI_shot_1.py\", line 7, in binary_exponentiation\n    teleporters[x] = teleporters[teleporters[x]]\nIndexError: list index out of range\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsQueriesI_shot_1.py\", line 15, in <module>\n    print(binary_exponentiation(x, k, teleporters))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsQueriesI_shot_1.py\", line 7, in binary_exponentiation\n    teleporters[x] = teleporters[teleporters[x]]\nIndexError: list index out of range\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsQueriesI_shot_1.py\", line 15, in <module>\n    print(binary_exponentiation(x, k, teleporters))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsQueriesI_shot_1.py\", line 7, in binary_exponentiation\n    teleporters[x] = teleporters[teleporters[x]]\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsQueriesI_shot_1.py\", line 15, in <module>\n    print(binary_exponentiation(x, k, teleporters))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsQueriesI_shot_1.py\", line 7, in binary_exponentiation\n    teleporters[x] = teleporters[teleporters[x]]\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsQueriesI_shot_1.py\", line 15, in <module>\n    print(binary_exponentiation(x, k, teleporters))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsQueriesI_shot_1.py\", line 4, in binary_exponentiation\n    x = teleporters[x]\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsQueriesI_shot_1.py\", line 15, in <module>\n    print(binary_exponentiation(x, k, teleporters))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsQueriesI_shot_1.py\", line 4, in binary_exponentiation\n    x = teleporters[x]\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsQueriesI_shot_1.py\", line 15, in <module>\n    print(binary_exponentiation(x, k, teleporters))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsQueriesI_shot_1.py\", line 7, in binary_exponentiation\n    teleporters[x] = teleporters[teleporters[x]]\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsQueriesI_shot_1.py\", line 15, in <module>\n    print(binary_exponentiation(x, k, teleporters))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsQueriesI_shot_1.py\", line 4, in binary_exponentiation\n    x = teleporters[x]\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsQueriesI_shot_1.py\", line 15, in <module>\n    print(binary_exponentiation(x, k, teleporters))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsQueriesI_shot_1.py\", line 4, in binary_exponentiation\n    x = teleporters[x]\nIndexError: list index out of range\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Planets Queries II",
            "category": "Graph Algorithms",
            "solution": "def find(x):\n    if x != parent[x]:\n        parent[x] = find(parent[x])\n    return parent[x]\n\ndef union(a, b):\n    rootA = find(a)\n    rootB = find(b)\n    if rootA != rootB:\n        if rank[rootA] < rank[rootB]:\n            parent[rootA] = rootB\n            rank[rootB] += rank[rootA]\n        else:\n            parent[rootB] = rootA\n            rank[rootA] += rank[rootB]\n\nn, q = map(int, input().split())\nteleporters = list(map(int, input().split()))\nparent = list(range(n + 1))\nrank = [1] * (n + 1)\n\nfor i in range(1, n + 1):\n    union(i, teleporters[i - 1])\n\nfor _ in range(q):\n    a, b = map(int, input().split())\n    rootA = find(a)\n    rootB = find(b)\n    if rootA == rootB:\n        print(rank[rootA] - 2)\n    else:\n        print(-1)\n",
            "passed_test_cases": 1,
            "total_test_cases": 15,
            "mean_time_taken": 0.39753664334615074,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Planets and Kingdoms",
            "category": "Graph Algorithms",
            "solution": "def find(parent, i):\n    if parent[i] != i:\n        parent[i] = find(parent, parent[i])\n    return parent[i]\n\ndef union(parent, rank, x, y):\n    rootX = find(parent, x)\n    rootY = find(parent, y)\n\n    if rootX != rootY:\n        if rank[rootX] > rank[rootY]:\n            parent[rootY] = rootX\n        elif rank[rootX] < rank[rootY]:\n            parent[rootX] = rootY\n        else:\n            parent[rootY] = rootX\n            rank[rootX] += 1\n\nn, m = map(int, input().split())\nparent = [i for i in range(n+1)]\nrank = [0] * (n+1)\n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    union(parent, rank, a, b)\n\nkingdoms = set()\nfor i in range(1, n+1):\n    kingdoms.add(find(parent, i))\n\nprint(len(kingdoms))\nfor i in range(1, n+1):\n    print(kingdoms.index(find(parent, i)) + 1, end=' ')\n",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.27905702590942383,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsandKingdoms_shot_1.py\", line 33, in <module>\n    print(kingdoms.index(find(parent, i)) + 1, end=' ')\nAttributeError: 'set' object has no attribute 'index'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsandKingdoms_shot_1.py\", line 33, in <module>\n    print(kingdoms.index(find(parent, i)) + 1, end=' ')\nAttributeError: 'set' object has no attribute 'index'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsandKingdoms_shot_1.py\", line 33, in <module>\n    print(kingdoms.index(find(parent, i)) + 1, end=' ')\nAttributeError: 'set' object has no attribute 'index'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsandKingdoms_shot_1.py\", line 33, in <module>\n    print(kingdoms.index(find(parent, i)) + 1, end=' ')\nAttributeError: 'set' object has no attribute 'index'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsandKingdoms_shot_1.py\", line 33, in <module>\n    print(kingdoms.index(find(parent, i)) + 1, end=' ')\nAttributeError: 'set' object has no attribute 'index'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsandKingdoms_shot_1.py\", line 33, in <module>\n    print(kingdoms.index(find(parent, i)) + 1, end=' ')\nAttributeError: 'set' object has no attribute 'index'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsandKingdoms_shot_1.py\", line 33, in <module>\n    print(kingdoms.index(find(parent, i)) + 1, end=' ')\nAttributeError: 'set' object has no attribute 'index'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsandKingdoms_shot_1.py\", line 33, in <module>\n    print(kingdoms.index(find(parent, i)) + 1, end=' ')\nAttributeError: 'set' object has no attribute 'index'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsandKingdoms_shot_1.py\", line 33, in <module>\n    print(kingdoms.index(find(parent, i)) + 1, end=' ')\nAttributeError: 'set' object has no attribute 'index'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PlanetsandKingdoms_shot_1.py\", line 33, in <module>\n    print(kingdoms.index(find(parent, i)) + 1, end=' ')\nAttributeError: 'set' object has no attribute 'index'\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Playlist",
            "category": "Sorting and Searching",
            "solution": "def longest_unique_sequence(songs):\n    start = 0\n    max_length = 0\n    seen_songs = {}\n\n    for end in range(len(songs)):\n        if songs[end] in seen_songs:\n            while start <= seen_songs[songs[end]]:\n                del seen_songs[songs[start]]\n                start += 1\n        seen_songs[songs[end]] = end + 1\n        max_length = max(max_length, end - start + 1)\n\n    return max_length\n\n# Read input\nn = int(input())\nsongs = list(map(int, input().split()))\n\n# Print output\nprint(longest_unique_sequence(songs))\n",
            "passed_test_cases": 7,
            "total_test_cases": 20,
            "mean_time_taken": 0.20675420761108398,
            "mean_memory_used": 150084.8,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Playlist_shot_1.py\", line 21, in <module>\n    print(longest_unique_sequence(songs))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Playlist_shot_1.py\", line 8, in longest_unique_sequence\n    while start <= seen_songs[songs[end]]:\nKeyError: 1\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Playlist_shot_1.py\", line 21, in <module>\n    print(longest_unique_sequence(songs))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Playlist_shot_1.py\", line 8, in longest_unique_sequence\n    while start <= seen_songs[songs[end]]:\nKeyError: 818804343\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Playlist_shot_1.py\", line 21, in <module>\n    print(longest_unique_sequence(songs))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Playlist_shot_1.py\", line 8, in longest_unique_sequence\n    while start <= seen_songs[songs[end]]:\nKeyError: 1\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Playlist_shot_1.py\", line 21, in <module>\n    print(longest_unique_sequence(songs))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Playlist_shot_1.py\", line 8, in longest_unique_sequence\n    while start <= seen_songs[songs[end]]:\nKeyError: 1\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Playlist_shot_1.py\", line 21, in <module>\n    print(longest_unique_sequence(songs))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Playlist_shot_1.py\", line 8, in longest_unique_sequence\n    while start <= seen_songs[songs[end]]:\nKeyError: 850000\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Playlist_shot_1.py\", line 21, in <module>\n    print(longest_unique_sequence(songs))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Playlist_shot_1.py\", line 8, in longest_unique_sequence\n    while start <= seen_songs[songs[end]]:\nKeyError: 542\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Playlist_shot_1.py\", line 21, in <module>\n    print(longest_unique_sequence(songs))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Playlist_shot_1.py\", line 8, in longest_unique_sequence\n    while start <= seen_songs[songs[end]]:\nKeyError: 2\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Playlist_shot_1.py\", line 21, in <module>\n    print(longest_unique_sequence(songs))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Playlist_shot_1.py\", line 8, in longest_unique_sequence\n    while start <= seen_songs[songs[end]]:\nKeyError: 5\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Playlist_shot_1.py\", line 21, in <module>\n    print(longest_unique_sequence(songs))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Playlist_shot_1.py\", line 8, in longest_unique_sequence\n    while start <= seen_songs[songs[end]]:\nKeyError: 3\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Playlist_shot_1.py\", line 21, in <module>\n    print(longest_unique_sequence(songs))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Playlist_shot_1.py\", line 8, in longest_unique_sequence\n    while start <= seen_songs[songs[end]]:\nKeyError: 215794\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Playlist_shot_1.py\", line 21, in <module>\n    print(longest_unique_sequence(songs))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Playlist_shot_1.py\", line 8, in longest_unique_sequence\n    while start <= seen_songs[songs[end]]:\nKeyError: 2\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Playlist_shot_1.py\", line 21, in <module>\n    print(longest_unique_sequence(songs))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Playlist_shot_1.py\", line 8, in longest_unique_sequence\n    while start <= seen_songs[songs[end]]:\nKeyError: 1\n"
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                6,
                8,
                10,
                12,
                13,
                14,
                15,
                16,
                17,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Point Location Test",
            "category": "Geometry",
            "solution": "def point_location(x1, y1, x2, y2, x3, y3):\n    # Calculate the cross product\n    cross_product = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1)\n\n    if cross_product > 0:\n        return \"LEFT\"\n    elif cross_product < 0:\n        return \"RIGHT\"\n    else:\n        return \"TOUCH\"\n\nt = int(input())\nfor _ in range(t):\n    x1, y1, x2, y2, x3, y3 = map(int, input().split())\n    print(point_location(x1, y1, x2, y2, x3, y3))\n",
            "passed_test_cases": 6,
            "total_test_cases": 6,
            "mean_time_taken": 0.2785078287124634,
            "mean_memory_used": 6.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Point in Polygon",
            "category": "Geometry",
            "solution": "def is_inside(polygon, point):\n    n = len(polygon)\n    x, y = point\n    count = 0\n    i = 0\n\n    # Pick a point outside the polygon, for example the rightmost point\n    outside_point = (max(p[0] for p in polygon) + 1, y)\n\n    while True:\n        j = (i + 1) % n\n        px, py = polygon[i]\n        qx, qy = polygon[j]\n\n        # Check if the line from the point to the outside point intersects with the edge of the polygon\n        if ((py <= y and qy > y) or (py > y and qy <= y)) and (x < (qx - px) * (y - py) / (qy - py) + px):\n            count += 1\n\n        i = j\n        if i == 0:\n            break\n\n    if count % 2 == 0:\n        return \"OUTSIDE\"\n    else:\n        return \"INSIDE\"\n\ndef is_on_boundary(polygon, point):\n    n = len(polygon)\n    x, y = point\n    for i in range(n):\n        px, py = polygon[i]\n        qx, qy = polygon[(i + 1) % n]\n        if (py == y and px <= x <= qx) or (py == qy and min(px, qx) <= x <= max(px, qx)):\n            return \"BOUNDARY\"\n    return \"NOT_BOUNDARY\"\n\nn, m = map(int, input().split())\npolygon = [list(map(int, input().split())) for _ in range(n)]\nfor _ in range(m):\n    point = list(map(int, input().split()))\n    boundary_check = is_on_boundary(polygon, point)\n    if boundary_check == \"BOUNDARY\":\n        print(boundary_check)\n    else:\n        print(is_inside(polygon, point))\n",
            "passed_test_cases": 2,
            "total_test_cases": 8,
            "mean_time_taken": 0.1549433469772339,
            "mean_memory_used": 2.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Police Chase",
            "category": "Graph Algorithms",
            "solution": "from collections import defaultdict\n\nclass Graph:\n    def __init__(self, vertices):\n        self.graph = defaultdict(list)\n        self.V = vertices\n\n    def add_edge(self, u, v, w):\n        self.graph[u].append([v, w])\n        self.graph[v].append([u, w])\n\n    def edmonds_karp(self, s, t):\n        parent = [-1] * (self.V)\n        res = 0\n\n        def bfs(s, t, parent):\n            visited = [False] * (self.V)\n            queue = [(s, float('inf'))]\n\n            while queue:\n                (u, min_res) = queue.pop(0)\n                visited[u] = True\n\n                for (v, w) in self.graph[u]:\n                    if visited[v] == False and w > 0:\n                        queue.append((v, min(min_res, w)))\n                        parent[v] = u\n\n            return visited[t]\n\n        while bfs(s, t, parent):\n            path_flow = float('inf')\n            v = t\n            while(v != s):\n                u = parent[v]\n                path_flow = min(path_flow, self.graph[u][self.graph[u].index([v, self.graph[u][-1]])][1])\n                v = u\n\n            v = t\n            while(v != s):\n                u = parent[v]\n                self.graph[u][self.graph[u].index([v, self.graph[u][-1]])][1] -= path_flow\n                self.graph[v][self.graph[v].index([u, self.graph[v][-1]])][1] += path_flow\n                v = u\n\n            res += path_flow\n\n        return res\n\ndef police_chase(n, m, edges):\n    g = Graph(n)\n    for edge in edges:\n        g.add_edge(edge[0] - 1, edge[1] - 1, 1)\n    min_streets = g.edmonds_karp(0, n - 1)\n    print(min_streets)\n    return min_streets\n",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.12675917943318685,
            "mean_memory_used": 0.8,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Polygon Area",
            "category": "Geometry",
            "solution": "# Read the number of vertices\nn = int(input())\n\n# Initialize variables\narea = 0\nx_prev, y_prev = 0, 0\n\n# Iterate over the vertices\nfor i in range(n):\n    x, y = map(int, input().split())\n    area += x * y_prev - y * x_prev\n    x_prev, y_prev = x, y\n\n# Close the polygon by connecting the last vertex to the first\nfirst_x, first_y = map(int, input().split())\narea += first_x * y_prev - first_y * x_prev\n\n# Calculate the absolute value and double it\narea = abs(area) * 2\n\n# Print the result\nprint(int(area))\n",
            "passed_test_cases": 0,
            "total_test_cases": 5,
            "mean_time_taken": 0.16364555358886718,
            "mean_memory_used": 2.4,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PolygonArea_shot_1.py\", line 15, in <module>\n    first_x, first_y = map(int, input().split())\nEOFError: EOF when reading a line\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PolygonArea_shot_1.py\", line 15, in <module>\n    first_x, first_y = map(int, input().split())\nEOFError: EOF when reading a line\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PolygonArea_shot_1.py\", line 15, in <module>\n    first_x, first_y = map(int, input().split())\nEOFError: EOF when reading a line\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PolygonArea_shot_1.py\", line 15, in <module>\n    first_x, first_y = map(int, input().split())\nEOFError: EOF when reading a line\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PolygonArea_shot_1.py\", line 15, in <module>\n    first_x, first_y = map(int, input().split())\nEOFError: EOF when reading a line\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Polygon Lattice Points",
            "category": "Geometry",
            "solution": "def is_inside(x, y, poly):\n    n = len(poly)\n    inside = False\n    p1x, p1y = poly[0]\n    for i in range(1, n+1):\n        p2x, p2y = poly[i % n]\n        if y > min(p1y, p2y):\n            if y <= max(p1y, p2y):\n                if x <= max(p1x, p2x):\n                    if p1y != p2y:\n                        xints = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                    if p1x == p2x or x <= xints:\n                        inside = not inside\n        p1x, p1y = p2x, p2y\n    return inside\n\ndef count_lattice_points(poly):\n    xmin, ymin, xmax, ymax = min(poly, key=lambda x:x[0])[0], min(poly, key=lambda x:x[1])[1], max(poly, key=lambda x:x[0])[0], max(poly, key=lambda x:x[1])[1]\n    inside, boundary = 0, 0\n    for x in range(xmin, xmax+1):\n        for y in range(ymin, ymax+1):\n            if (x, y) in poly:\n                boundary += 1\n            elif is_inside(x, y, poly):\n                inside += 1\n    return inside, inside + boundary\n\nn = int(input())\npoly = [tuple(map(int, input().split())) for _ in range(n)]\nprint(*count_lattice_points(poly))\n",
            "passed_test_cases": 0,
            "total_test_cases": 5,
            "mean_time_taken": 0.9814587116241456,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Polynomial Queries",
            "category": "Range Queries",
            "solution": "# Fenwick Tree class\nclass FenwickTree:\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def update(self, i, delta):\n        while i <= self.n:\n            self.tree[i] += delta\n            i += i & -i\n\n    def query(self, i):\n        total = 0\n        while i > 0:\n            total += self.tree[i]\n            i -= i & -i\n        return total\n\n    def range_query(self, a, b):\n        return self.query(b) - self.query(a - 1)\n\n# Main function\ndef main():\n    n, q = map(int, input().split())\n    t = list(map(int, input().split()))\n    tree = FenwickTree(n)\n    for i, value in enumerate(t):\n        tree.update(i + 1, value)\n    for _ in range(q):\n        query_type, a, b = map(int, input().split())\n        if query_type == 1:\n            for i in range(a, b + 1):\n                tree.update(i, i - a + 1)\n        else:\n            print(tree.range_query(a, b))\n\nif __name__ == \"__main__\":\n    main()\n",
            "passed_test_cases": 1,
            "total_test_cases": 3,
            "mean_time_taken": 0.7451086839040121,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Prefix Sum Queries",
            "category": "Range Queries",
            "solution": "def solve():\n    n, q = map(int, input().split())\n    arr = list(map(int, input().split()))\n    prefix_sum = [0]*(n+1)\n    for i in range(1, n+1):\n        prefix_sum[i] = prefix_sum[i-1] + arr[i-1]\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            diff = query[2] - arr[query[1]-1]\n            arr[query[1]-1] = query[2]\n            prefix_sum[query[1]] += diff\n            for i in range(query[1]+1, n+1):\n                prefix_sum[i] += diff\n        else:\n            max_prefix_sum = max(prefix_sum[query[1]-1], prefix_sum[query[2]] - prefix_sum[query[1]-1])\n            print(max_prefix_sum)\n\nsolve()\n",
            "passed_test_cases": 2,
            "total_test_cases": 6,
            "mean_time_taken": 0.3573410113652547,
            "mean_memory_used": 0.6666666666666666,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Prime Multiples",
            "category": "Mathematics",
            "solution": "def solve(n, primes):\n    # Initialize result to the size of the first set\n    result = n // primes[0]\n\n    # Initialize a variable to keep track of the sign in the inclusion-exclusion principle\n    sign = -1\n\n    # Loop through all subsets of the primes\n    for i in range(1, 1 << len(primes)):\n        # Find the intersection of the sets corresponding to the primes in the subset\n        intersection = 1\n        for j in range(len(primes)):\n            if i & (1 << j):\n                intersection *= primes[j]\n\n        # Add or subtract the size of the intersection depending on the current sign\n        result += sign * (n // intersection)\n\n        # Flip the sign for the next iteration\n        sign *= -1\n\n    return result\n\n# Read the input\nn, k = map(int, input().split())\nprimes = list(map(int, input().split()))\n\n# Print the result\nprint(solve(n, primes))\n",
            "passed_test_cases": 0,
            "total_test_cases": 5,
            "mean_time_taken": 0.49441890716552733,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Programmers and Artists",
            "category": "Additional Problems",
            "solution": "# Read the input\na, b, n = map(int, input().split())\napplicants = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    applicants.append((x, y))\n\n# Sort the applicants\napplicants.sort(key=lambda x: (x[0], -x[1]), reverse=True)\n\n# Select the top programmers and artists\nselected = []\nfor i in range(n):\n    if len(selected) < a and applicants[i][0] >= applicants[i][1]:\n        selected.append(applicants[i][0])\n    elif len(selected) < a + b and applicants[i][0] < applicants[i][1]:\n        selected.append(applicants[i][1])\n    if len(selected) == a + b:\n        break\n\n# Print the maximum sum of skills\nprint(sum(selected))\n",
            "passed_test_cases": 3,
            "total_test_cases": 11,
            "mean_time_taken": 0.2091632756319913,
            "mean_memory_used": 1.8181818181818181,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                7,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Projects",
            "category": "Dynamic Programming",
            "solution": "def max_profit(n, projects):\n    # Sort projects based on end times\n    projects.sort(key=lambda x: x[1])\n\n    # Initialize profit array\n    profit = [0] * (10**9 + 1)\n\n    # Iterate through projects\n    for a, b, p in projects:\n        # Find maximum profit before start day\n        max_before = max(profit[:a])\n        # Update profit for end day\n        profit[b] = max(profit[b], max_before + p)\n\n    # Return maximum profit\n    return max(profit)\n\n# Read input\nn = int(input())\nprojects = [list(map(int, input().split())) for _ in range(n)]\n\n# Print output\nprint(max_profit(n, projects))\n",
            "passed_test_cases": 0,
            "total_test_cases": 14,
            "mean_time_taken": 0.2691816602434431,
            "mean_memory_used": 1722.2857142857142,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 23, in <module>\n    print(max_profit(n, projects))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 6, in max_profit\n    profit = [0] * (10**9 + 1)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 23, in <module>\n    print(max_profit(n, projects))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 6, in max_profit\n    profit = [0] * (10**9 + 1)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 23, in <module>\n    print(max_profit(n, projects))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 6, in max_profit\n    profit = [0] * (10**9 + 1)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 23, in <module>\n    print(max_profit(n, projects))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 6, in max_profit\n    profit = [0] * (10**9 + 1)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 23, in <module>\n    print(max_profit(n, projects))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 6, in max_profit\n    profit = [0] * (10**9 + 1)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 23, in <module>\n    print(max_profit(n, projects))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 6, in max_profit\n    profit = [0] * (10**9 + 1)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 23, in <module>\n    print(max_profit(n, projects))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 6, in max_profit\n    profit = [0] * (10**9 + 1)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 23, in <module>\n    print(max_profit(n, projects))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 6, in max_profit\n    profit = [0] * (10**9 + 1)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 23, in <module>\n    print(max_profit(n, projects))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 6, in max_profit\n    profit = [0] * (10**9 + 1)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 23, in <module>\n    print(max_profit(n, projects))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 6, in max_profit\n    profit = [0] * (10**9 + 1)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 23, in <module>\n    print(max_profit(n, projects))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 6, in max_profit\n    profit = [0] * (10**9 + 1)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 23, in <module>\n    print(max_profit(n, projects))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 6, in max_profit\n    profit = [0] * (10**9 + 1)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 23, in <module>\n    print(max_profit(n, projects))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 6, in max_profit\n    profit = [0] * (10**9 + 1)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 23, in <module>\n    print(max_profit(n, projects))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Projects_shot_1.py\", line 6, in max_profit\n    profit = [0] * (10**9 + 1)\nMemoryError\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Pr\u00fcfer Code",
            "category": "Additional Problems",
            "solution": "def prufer_decode(n, prufer):\n    # Initialize nodes with degree 1\n    nodes = [1] * (n+1)\n\n    # Iterate over Pr\u00fcfer code\n    for code in prufer:\n        # Find the smallest leaf node\n        leaf = min(i for i in range(1, n+1) if nodes[i])\n\n        # Connect leaf to the node specified in the code\n        print(leaf, code)\n        nodes[leaf] = 0\n        nodes[code] += 1\n\n    # Connect the remaining two leaf nodes\n    for i in range(1, n+1):\n        if nodes[i]:\n            leaf1 = i\n        elif not leaf1:\n            leaf1 = i\n        elif not leaf2:\n            leaf2 = i\n    print(leaf1, leaf2)\n\n# Read input\nn = int(input())\nprufer = list(map(int, input().split()))\n\n# Decode Pr\u00fcfer code\nprufer_decode(n, prufer)\n",
            "passed_test_cases": 0,
            "total_test_cases": 11,
            "mean_time_taken": 0.5615168701518666,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PrferCode_shot_1.py\", line 30, in <module>\n    prufer_decode(n, prufer)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PrferCode_shot_1.py\", line 19, in prufer_decode\n    elif not leaf1:\nUnboundLocalError: local variable 'leaf1' referenced before assignment\n",
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PrferCode_shot_1.py\", line 30, in <module>\n    prufer_decode(n, prufer)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PrferCode_shot_1.py\", line 19, in prufer_decode\n    elif not leaf1:\nUnboundLocalError: local variable 'leaf1' referenced before assignment\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PrferCode_shot_1.py\", line 30, in <module>\n    prufer_decode(n, prufer)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PrferCode_shot_1.py\", line 19, in prufer_decode\n    elif not leaf1:\nUnboundLocalError: local variable 'leaf1' referenced before assignment\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PrferCode_shot_1.py\", line 30, in <module>\n    prufer_decode(n, prufer)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PrferCode_shot_1.py\", line 19, in prufer_decode\n    elif not leaf1:\nUnboundLocalError: local variable 'leaf1' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PrferCode_shot_1.py\", line 30, in <module>\n    prufer_decode(n, prufer)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PrferCode_shot_1.py\", line 19, in prufer_decode\n    elif not leaf1:\nUnboundLocalError: local variable 'leaf1' referenced before assignment\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PrferCode_shot_1.py\", line 30, in <module>\n    prufer_decode(n, prufer)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/PrferCode_shot_1.py\", line 19, in prufer_decode\n    elif not leaf1:\nUnboundLocalError: local variable 'leaf1' referenced before assignment\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Pyramid Array",
            "category": "Additional Problems",
            "solution": "def count_inversions(arr):\n    # This function counts the number of inversions in an array\n    # using merge sort\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, count_left = merge_sort(arr[:mid])\n        right, count_right = merge_sort(arr[mid:])\n        result, count_merge = merge(left, right)\n        return result, count_left + count_right + count_merge\n\n    def merge(left, right):\n        result = []\n        i = j = inversions = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n                inversions += len(left) - i\n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result, inversions\n\n    return merge_sort(arr)[1]\n\ndef main():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    mid = (n + 1) // 2\n    if n % 2 == 0:\n        second_half = arr[mid:]\n        second_half.sort(reverse=True)\n        arr[mid:] = second_half\n    print(count_inversions(arr))\n\nif __name__ == \"__main__\":\n    main()\n",
            "passed_test_cases": 4,
            "total_test_cases": 12,
            "mean_time_taken": 0.22725979487101236,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                4,
                5,
                6,
                7,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Range Queries and Copies",
            "category": "Range Queries",
            "solution": "def solve():\n    n, q = map(int, input().split())\n    t = list(map(int, input().split()))\n    arrays = [t]\n    array_map = {1: 0}\n    answers = []\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        query_type = query[0]\n        if query_type == 1:\n            k, a, x = query[1:]\n            arrays[array_map[k]][a-1] = x\n        elif query_type == 2:\n            k, a, b = query[1:]\n            sub_array = arrays[array_map[k]]\n            answers.append(sum(sub_array[a-1:b]))\n        else:\n            k = query[1]\n            new_array = arrays[array_map[k]].copy()\n            arrays.append(new_array)\n            array_map[len(arrays)] = len(arrays) - 1\n    for answer in answers:\n        print(answer)\n\nsolve()\n",
            "passed_test_cases": 4,
            "total_test_cases": 7,
            "mean_time_taken": 0.32222206251961844,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RangeQueriesandCopies_shot_1.py\", line 25, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RangeQueriesandCopies_shot_1.py\", line 19, in solve\n    new_array = arrays[array_map[k]].copy()\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RangeQueriesandCopies_shot_1.py\", line 25, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RangeQueriesandCopies_shot_1.py\", line 19, in solve\n    new_array = arrays[array_map[k]].copy()\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RangeQueriesandCopies_shot_1.py\", line 25, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RangeQueriesandCopies_shot_1.py\", line 19, in solve\n    new_array = arrays[array_map[k]].copy()\nMemoryError\n"
            ],
            "failed_test_cases": [
                2,
                4,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Range Update Queries",
            "category": "Range Queries",
            "solution": "class SegmentTree:\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (2 * self.n)\n        self.arr = arr\n        self.build_tree()\n\n    def build_tree(self):\n        for i in range(self.n - 1, -1, -1):\n            self.tree[i] = self.tree[2 * i + 1] + self.tree[2 * i + 2]\n\n    def update_range(self, a, b, u):\n        self._update_range(0, 0, self.n - 1, a, b, u)\n\n    def _update_range(self, node, start, end, a, b, u):\n        if a > end or b < start:\n            return\n        if a <= start and end <= b:\n            self.tree[node] += u * (end - start + 1)\n            return\n        mid = (start + end) // 2\n        self._update_range(2 * node + 1, start, mid, a, b, u)\n        self._update_range(2 * node + 2, mid + 1, end, a, b, u)\n        self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def get_value(self, k):\n        return self._get_value(0, 0, self.n - 1, k)\n\n    def _get_value(self, node, start, end, k):\n        if start == end:\n            return self.tree[node] + self.arr[start]\n        mid = (start + end) // 2\n        if k <= mid:\n            return self._get_value(2 * node + 1, start, mid, k)\n        else:\n            return self._get_value(2 * node + 2, mid + 1, end, k)\n\ndef main():\n    n, q = map(int, input().split())\n    arr = list(map(int, input().split()))\n    tree = SegmentTree([0] * n)\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            tree.update_range(query[1] - 1, query[2] - 1, query[3])\n        else:\n            print(tree.get_value(query[1] - 1))\n\nif __name__ == \"__main__\":\n    main()\n",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 0.17895285288492838,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RangeUpdateQueries_shot_1.py\", line 50, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RangeUpdateQueries_shot_1.py\", line 41, in main\n    tree = SegmentTree([0] * n)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RangeUpdateQueries_shot_1.py\", line 6, in __init__\n    self.build_tree()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RangeUpdateQueries_shot_1.py\", line 10, in build_tree\n    self.tree[i] = self.tree[2 * i + 1] + self.tree[2 * i + 2]\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RangeUpdateQueries_shot_1.py\", line 50, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RangeUpdateQueries_shot_1.py\", line 41, in main\n    tree = SegmentTree([0] * n)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RangeUpdateQueries_shot_1.py\", line 6, in __init__\n    self.build_tree()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RangeUpdateQueries_shot_1.py\", line 10, in build_tree\n    self.tree[i] = self.tree[2 * i + 1] + self.tree[2 * i + 2]\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RangeUpdateQueries_shot_1.py\", line 50, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RangeUpdateQueries_shot_1.py\", line 41, in main\n    tree = SegmentTree([0] * n)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RangeUpdateQueries_shot_1.py\", line 6, in __init__\n    self.build_tree()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RangeUpdateQueries_shot_1.py\", line 10, in build_tree\n    self.tree[i] = self.tree[2 * i + 1] + self.tree[2 * i + 2]\nIndexError: list index out of range\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Range Updates and Sums",
            "category": "Range Queries",
            "solution": "class Node:\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n        self.sum = 0\n        self.lazy = 0\n        self.left = None\n        self.right = None\n\nclass SegmentTree:\n    def __init__(self, arr):\n        self.root = self.build_tree(arr, 0, len(arr) - 1)\n\n    def build_tree(self, arr, start, end):\n        if start > end:\n            return None\n        node = Node(start, end)\n        if start == end:\n            node.sum = arr[start]\n        else:\n            mid = (start + end) // 2\n            node.left = self.build_tree(arr, start, mid)\n            node.right = self.build_tree(arr, mid + 1, end)\n            node.sum = node.left.sum + node.right.sum\n        return node\n\n    def update_range(self, node, start, end, diff):\n        if start > node.end or end < node.start:\n            return\n        if node.lazy != 0:\n            self.propagate(node, node.start, node.end)\n        if start <= node.start and node.end <= end:\n            node.lazy += diff\n            self.propagate(node, node.start, node.end)\n        else:\n            mid = (node.start + node.end) // 2\n            self.update_range(node.left, start, end, diff)\n            self.update_range(node.right, start, end, diff)\n            node.sum = node.left.sum + node.right.sum\n\n    def set_range(self, node, start, end, value):\n        if start > node.end or end < node.start:\n            return\n        if node.lazy != 0:\n            self.propagate(node, node.start, node.end)\n        if start <= node.start and node.end <= end:\n            node.lazy = value - node.sum\n            self.propagate(node, node.start, node.end)\n        else:\n            mid = (node.start + node.end) // 2\n            self.set_range(node.left, start, end, value)\n            self.set_range(node.right, start, end, value)\n            node.sum = node.left.sum + node.right.sum\n\n    def get_sum(self, node, start, end):\n        if start > node.end or end < node.start:\n            return 0\n        if node.lazy != 0:\n            self.propagate(node, node.start, node.end)\n        if start <= node.start and node.end <= end:\n            return node.sum\n        mid = (node.start + node.end) // 2\n        return self.get_sum(node.left, start, end) + self.get_sum(node.right, start, end)\n\n    def propagate(self, node, start, end):\n        node.sum += (end - start + 1) * node.lazy\n        if node.left:\n            node.left.lazy += node.lazy\n        if node.right:\n            node.right.lazy += node.lazy\n        node.lazy = 0\n\ndef main():\n    n, q = map(int, input().split())\n    arr = list(map(int, input().split()))\n    tree = SegmentTree(arr)\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            tree.update_range(tree.root, query[1] - 1, query[2] - 1, query[3])\n        elif query[0] == 2:\n            tree.set_range(tree.root, query[1] - 1, query[2] - 1, query[3])\n        else:\n            print(tree.get_sum(tree.root, query[1] - 1, query[2] - 1))\n\nif __name__ == \"__main__\":\n    main()\n",
            "passed_test_cases": 2,
            "total_test_cases": 4,
            "mean_time_taken": 0.7496668100357056,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RangeUpdatesandSums_shot_1.py\", line 87, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RangeUpdatesandSums_shot_1.py\", line 84, in main\n    print(tree.get_sum(tree.root, query[1] - 1, query[2] - 1))\nValueError: Exceeds the limit (4300) for integer string conversion; use sys.set_int_max_str_digits() to increase the limit\n"
            ],
            "failed_test_cases": [
                1,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Range Xor Queries",
            "category": "Range Queries",
            "solution": "def solve():\n    # Read the input\n    n, q = map(int, input().split())\n    arr = list(map(int, input().split()))\n    queries = [list(map(int, input().split())) for _ in range(q)]\n\n    # Calculate the prefix XOR array\n    prefix_xor = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_xor[i] = prefix_xor[i - 1] ^ arr[i - 1]\n\n    # Process the queries\n    for a, b in queries:\n        print(prefix_xor[b] ^ prefix_xor[a - 1])\n\n# Call the function to start the solution\nsolve()\n",
            "passed_test_cases": 2,
            "total_test_cases": 2,
            "mean_time_taken": 0.24896502494812012,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Reachability Queries",
            "category": "Advanced Techniques",
            "solution": "def dfs(node, reachable, visited):\n    visited[node] = True\n    for neighbor in reachable[node]:\n        if not visited[neighbor]:\n            dfs(neighbor, reachable, visited)\n    return visited\n\ndef solve():\n    n, m, q = map(int, input().split())\n    reachable = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, input().split())\n        reachable[a].append(b)\n    for _ in range(q):\n        a, b = map(int, input().split())\n        visited = [False] * (n + 1)\n        if dfs(a, reachable, visited)[b]:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nsolve()\n",
            "passed_test_cases": 2,
            "total_test_cases": 7,
            "mean_time_taken": 0.43861593518938335,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ReachabilityQueries_shot_1.py\", line 22, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ReachabilityQueries_shot_1.py\", line 17, in solve\n    if dfs(a, reachable, visited)[b]:\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ReachabilityQueries_shot_1.py\", line 5, in dfs\n    dfs(neighbor, reachable, visited)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ReachabilityQueries_shot_1.py\", line 5, in dfs\n    dfs(neighbor, reachable, visited)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ReachabilityQueries_shot_1.py\", line 5, in dfs\n    dfs(neighbor, reachable, visited)\n  [Previous line repeated 995 more times]\nRecursionError: maximum recursion depth exceeded\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ReachabilityQueries_shot_1.py\", line 22, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ReachabilityQueries_shot_1.py\", line 17, in solve\n    if dfs(a, reachable, visited)[b]:\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ReachabilityQueries_shot_1.py\", line 5, in dfs\n    dfs(neighbor, reachable, visited)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ReachabilityQueries_shot_1.py\", line 5, in dfs\n    dfs(neighbor, reachable, visited)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ReachabilityQueries_shot_1.py\", line 5, in dfs\n    dfs(neighbor, reachable, visited)\n  [Previous line repeated 995 more times]\nRecursionError: maximum recursion depth exceeded\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ReachabilityQueries_shot_1.py\", line 22, in <module>\n    solve()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ReachabilityQueries_shot_1.py\", line 17, in solve\n    if dfs(a, reachable, visited)[b]:\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ReachabilityQueries_shot_1.py\", line 5, in dfs\n    dfs(neighbor, reachable, visited)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ReachabilityQueries_shot_1.py\", line 5, in dfs\n    dfs(neighbor, reachable, visited)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ReachabilityQueries_shot_1.py\", line 5, in dfs\n    dfs(neighbor, reachable, visited)\n  [Previous line repeated 995 more times]\nRecursionError: maximum recursion depth exceeded\n",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Reachable Nodes",
            "category": "Advanced Techniques",
            "solution": "def dfs(node, graph, visited, count):\n    visited[node] = True\n    for neighbor in graph[node]:\n        if not visited[neighbor]:\n            count[node] += 1\n            dfs(neighbor, graph, visited, count)\n    count[node] += 1\n\nn, m = map(int, input().split())\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\nvisited = [False] * (n + 1)\ncount = [0] * (n + 1)\nfor i in range(1, n + 1):\n    if not visited[i]:\n        dfs(i, graph, visited, count)\n\nprint(*count[1:])\n",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.20428812503814697,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ReachableNodes_shot_1.py\", line 19, in <module>\n    dfs(i, graph, visited, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ReachableNodes_shot_1.py\", line 6, in dfs\n    dfs(neighbor, graph, visited, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ReachableNodes_shot_1.py\", line 6, in dfs\n    dfs(neighbor, graph, visited, count)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ReachableNodes_shot_1.py\", line 6, in dfs\n    dfs(neighbor, graph, visited, count)\n  [Previous line repeated 996 more times]\nRecursionError: maximum recursion depth exceeded\n",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Reading Books",
            "category": "Sorting and Searching",
            "solution": "# Read the number of books\nn = int(input())\n\n# Read the reading times for each book\ntimes = list(map(int, input().split()))\n\n# Sort the reading times\ntimes.sort()\n\n# Initialize total time\ntotal_time = 0\n\n# Have two people read the books\nfor i in range(n):\n    # Person 1 reads the book with the smallest reading time\n    if i % 2 == 0:\n        total_time += times[i]\n    # Person 2 reads the book with the largest reading time\n    else:\n        total_time += times[-i-1]\n\n# Print the total time\nprint(total_time)\n",
            "passed_test_cases": 4,
            "total_test_cases": 13,
            "mean_time_taken": 0.1363943356734056,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Rectangle Cutting",
            "category": "Dynamic Programming",
            "solution": "def min_cuts(a, b):\n    def count_odd_factors(n):\n        count = 0\n        while n % 2 == 0:\n            n //= 2\n        while n > 1:\n            if n % 2 == 1:\n                count += 1\n                n = 1\n            else:\n                n //= 2\n        return count\n\n    return count_odd_factors(a) + count_odd_factors(b) - 1\n\na, b = map(int, input().split())\nprint(min_cuts(a, b))\n",
            "passed_test_cases": 1,
            "total_test_cases": 26,
            "mean_time_taken": 0.11442550329061654,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                26
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Removal Game",
            "category": "Dynamic Programming",
            "solution": "def removal_game(arr):\n    n = len(arr)\n    dp = [[0] * n for _ in range(n)]\n\n    # Base case: subarrays of size 1\n    for i in range(n):\n        dp[i][i] = arr[i]\n\n    # Bottom-up approach: consider larger subarrays\n    for length in range(2, n+1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            dp[i][j] = max(arr[i] - dp[i+1][j], arr[j] - dp[i][j-1])\n\n    return dp[0][n-1]\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Print output\nprint(removal_game(arr))\n",
            "passed_test_cases": 1,
            "total_test_cases": 14,
            "mean_time_taken": 0.5888791084289551,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Removing Digits",
            "category": "Dynamic Programming",
            "solution": "def remove_digits(n):\n    # Convert the number to a string so we can easily iterate over its digits\n    n_str = str(n)\n    # Initialize a counter to keep track of the number of steps\n    steps = 0\n    # Continue until the number is 0\n    while n > 0:\n        # Find the largest digit in the number\n        max_digit = max(n_str)\n        # Subtract the largest digit from the number\n        n -= int(max_digit)\n        # Increment the step counter\n        steps += 1\n        # Update the string representation of the number\n        n_str = str(n)\n    # Return the number of steps\n    return steps\n\n# Read the input number\nn = int(input())\n# Print the minimum number of steps\nprint(remove_digits(n))\n",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.13511579377310617,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Removing Digits II",
            "category": "Additional Problems",
            "solution": "# Read the input\nn = int(input())\n\n# Initialize the count of steps\ncount = 0\n\n# Iterate over the digits of the number from left to right\nwhile n > 0:\n    # Find the largest digit that is not 0\n    digit = 9\n    while digit > 0 and n % 10 != digit:\n        digit -= 1\n\n    # If all digits are 0, break the loop\n    if digit == 0:\n        break\n\n    # Subtract the digit from the number\n    n -= digit\n\n    # Increment the count of steps\n    count += 1\n\n    # Remove the last digit from the number\n    n //= 10\n\n# Print the result\nprint(count)\n",
            "passed_test_cases": 2,
            "total_test_cases": 9,
            "mean_time_taken": 0.12488767835828993,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Repeating Substring",
            "category": "String Algorithms",
            "solution": "def longest_repeat_substring(s):\n    # Build suffix array\n    from sortedcontainers import SortedList\n    suffix_array = [\"\"]\n    for i in range(len(s)):\n        suffix_array.append(s[i:])\n    suffix_array = sorted(suffix_array)\n\n    # Build longest common prefix array\n    lcp_array = [0] * len(suffix_array)\n    k = 0\n    for i in range(len(suffix_array) - 1):\n        x, y = suffix_array[i], suffix_array[i + 1]\n        while k < len(x) and k < len(y) and x[k] == y[k]:\n            k += 1\n        lcp_array[i + 1] = k\n        if k > 0:\n            k -= 1\n\n    # Find longest repeating substring\n    return max(lcp_array) if max(lcp_array) > 0 else -1\n\n# Read input\ns = input().strip()\n\n# Print result\nprint(longest_repeat_substring(s))\n",
            "passed_test_cases": 1,
            "total_test_cases": 8,
            "mean_time_taken": 0.27671539783477783,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RepeatingSubstring_shot_1.py\", line 27, in <module>\n    print(longest_repeat_substring(s))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RepeatingSubstring_shot_1.py\", line 6, in longest_repeat_substring\n    suffix_array.append(s[i:])\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RepeatingSubstring_shot_1.py\", line 27, in <module>\n    print(longest_repeat_substring(s))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RepeatingSubstring_shot_1.py\", line 6, in longest_repeat_substring\n    suffix_array.append(s[i:])\nMemoryError\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RepeatingSubstring_shot_1.py\", line 27, in <module>\n    print(longest_repeat_substring(s))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RepeatingSubstring_shot_1.py\", line 6, in longest_repeat_substring\n    suffix_array.append(s[i:])\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RepeatingSubstring_shot_1.py\", line 27, in <module>\n    print(longest_repeat_substring(s))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RepeatingSubstring_shot_1.py\", line 6, in longest_repeat_substring\n    suffix_array.append(s[i:])\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RepeatingSubstring_shot_1.py\", line 27, in <module>\n    print(longest_repeat_substring(s))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RepeatingSubstring_shot_1.py\", line 6, in longest_repeat_substring\n    suffix_array.append(s[i:])\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RepeatingSubstring_shot_1.py\", line 27, in <module>\n    print(longest_repeat_substring(s))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RepeatingSubstring_shot_1.py\", line 6, in longest_repeat_substring\n    suffix_array.append(s[i:])\nMemoryError\n"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Repetitions",
            "category": "Introductory Problems",
            "solution": "# Read the DNA sequence\ndna = input()\n\n# Initialize max_length and current_length\nmax_length = 0\ncurrent_length = 1\n\n# Iterate over the DNA sequence\nfor i in range(1, len(dna)):\n    # If the current character is the same as the previous one\n    if dna[i] == dna[i-1]:\n        # Increment current_length\n        current_length += 1\n    else:\n        # Reset current_length\n        current_length = 1\n\n    # Update max_length\n    max_length = max(max_length, current_length)\n\n# Print the length of the longest repetition\nprint(max_length)\n",
            "passed_test_cases": 11,
            "total_test_cases": 12,
            "mean_time_taken": 0.2025651534398397,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Required Substring",
            "category": "String Algorithms",
            "solution": "# Read the input\nn = int(input())\npattern = input()\nm = len(pattern)\n\n# Calculate the number of strings\nif n < m:\n    print(0)\nelse:\n    # The pattern can be placed in (n - m + 1) positions in the string\n    # There are 26 choices for each of the remaining (n - m) characters\n    # The result is calculated modulo 10^9+7\n    result = (n - m + 1) * (26 ** (n - m)) % (10 ** 9 + 7)\n    print(int(result))\n",
            "passed_test_cases": 4,
            "total_test_cases": 19,
            "mean_time_taken": 0.12251291776958265,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                16,
                17,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Restaurant Customers",
            "category": "Sorting and Searching",
            "solution": "# Read the number of customers\nn = int(input())\n\n# Initialize an empty list to store the events\nevents = []\n\n# Read the arrival and leaving times for each customer\nfor _ in range(n):\n    a, b = map(int, input().split())\n    events.append((a, 1))  # 1 represents an arrival\n    events.append((b, -1))  # -1 represents a leaving\n\n# Sort the events by time\nevents.sort()\n\n# Initialize the current number of customers and the maximum number of customers\ncurrent_customers = 0\nmax_customers = 0\n\n# Iterate over the sorted events\nfor time, change in events:\n    # Update the current number of customers\n    current_customers += change\n    # Update the maximum number of customers if necessary\n    max_customers = max(max_customers, current_customers)\n\n# Print the maximum number of customers\nprint(max_customers)\n",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.2352886438369751,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Reversal Sorting",
            "category": "Additional Problems",
            "solution": "def reversal_sorting(n, arr):\n    reversals = []\n    for i in range(n):\n        if arr[i] != i+1:\n            j = arr.index(i+1)\n            arr[i:j+1] = arr[i:j+1][::-1]\n            reversals.append((i+1, j+1))\n    print(len(reversals))\n    for a, b in reversals:\n        print(a, b)\n\nn = int(input())\narr = list(map(int, input().split()))\nreversal_sorting(n, arr)\n",
            "passed_test_cases": 10,
            "total_test_cases": 12,
            "mean_time_taken": 0.27801541487375897,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Reversals and Sums",
            "category": "Advanced Techniques",
            "solution": "# Read the input\nn, m = map(int, input().split())\narr = list(map(int, input().split()))\nfor _ in range(m):\n    t, a, b = map(int, input().split())\n    if t == 1:\n        # Reverse the subarray\n        arr[a-1:b] = arr[a-1:b][::-1]\n    else:\n        # Calculate and print the sum of the subarray\n        print(sum(arr[a-1:b]))\n",
            "passed_test_cases": 2,
            "total_test_cases": 4,
            "mean_time_taken": 0.5896105766296387,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Road Construction",
            "category": "Graph Algorithms",
            "solution": "def find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, rank, x, y):\n    rootX = find(parent, x)\n    rootY = find(parent, y)\n\n    if rank[rootX] > rank[rootY]:\n        parent[rootY] = rootX\n    elif rank[rootX] < rank[rootY]:\n        parent[rootX] = rootY\n    else:\n        parent[rootY] = rootX\n        rank[rootX] += 1\n\nn, m = map(int, input().split())\nparent = [i for i in range(n+1)]\nrank = [0] * (n+1)\nsize = [1] * (n+1)\nmax_size = n\n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    rootA = find(parent, a)\n    rootB = find(parent, b)\n\n    if rootA != rootB:\n        union(parent, rank, rootA, rootB)\n        size[rootA] += size[rootB]\n        max_size = max(max_size, size[rootA])\n\n    print(n - _ - 1, max_size)\n",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.2929452955722809,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Road Reparation",
            "category": "Graph Algorithms",
            "solution": "import heapq\n\ndef find_parent(parent, x):\n    if parent[x] != x:\n        parent[x] = find_parent(parent, parent[x])\n    return parent[x]\n\ndef union_parent(parent, a, b):\n    a = find_parent(parent, a)\n    b = find_parent(parent, b)\n    if a < b:\n        parent[b] = a\n    else:\n        parent[a] = b\n\ndef solution(n, edges):\n    edges.sort(key=lambda x: x[2])\n    parent = [0] * (n + 1)\n    for i in range(1, n + 1):\n        parent[i] = i\n\n    answer = 0\n    count = 0\n    for edge in edges:\n        a, b, cost = edge\n        if find_parent(parent, a) != find_parent(parent, b):\n            union_parent(parent, a, b)\n            answer += cost\n            count += 1\n        if count == n - 1:\n            break\n\n    if count != n - 1:\n        return \"IMPOSSIBLE\"\n    else:\n        return answer\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        edges.append([a, b, c])\n    print(solution(n, edges))\n",
            "passed_test_cases": 16,
            "total_test_cases": 16,
            "mean_time_taken": 0.25421471893787384,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Robot Path",
            "category": "Additional Problems",
            "solution": "# Read the number of commands\nn = int(input())\n\n# Initialize the robot's position and the set of visited positions\ncurrent_position = (0, 0)\nvisited_positions = set([current_position])\ntotal_distance = 0\n\nfor _ in range(n):\n    # Read the command\n    direction, distance = input().split()\n    distance = int(distance)\n\n    # Calculate the new position\n    new_position = None\n    if direction == 'U':\n        new_position = (current_position[0], current_position[1] + distance)\n    elif direction == 'D':\n        new_position = (current_position[0], current_position[1] - distance)\n    elif direction == 'L':\n        new_position = (current_position[0] - distance, current_position[1])\n    elif direction == 'R':\n        new_position = (current_position[0] + distance, current_position[1])\n\n    # If the new position is not in visited_positions, update the current position,\n    # add the new position to visited_positions, and update total_distance\n    if new_position not in visited_positions:\n        current_position = new_position\n        visited_positions.add(new_position)\n        total_distance += distance\n    else:\n        # If the new position is in visited_positions, stop moving the robot\n        break\n\n# Print the total distance\nprint(total_distance)\n",
            "passed_test_cases": 10,
            "total_test_cases": 35,
            "mean_time_taken": 0.14695350102015903,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                5,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                20,
                21,
                24,
                25,
                27,
                28,
                29,
                31,
                34,
                35
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Room Allocation",
            "category": "Sorting and Searching",
            "solution": "import sys\nimport heapq\n\ndef main():\n    n = int(sys.stdin.readline())\n    times = [tuple(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    times.sort()\n    pq = []\n    rooms = 0\n    allocation = []\n    for arrival, departure in times:\n        if not pq or pq[0] <= arrival:\n            heapq.heappop(pq)\n        else:\n            rooms += 1\n        heapq.heappush(pq, departure)\n        allocation.append(rooms)\n    print(rooms)\n    print(*allocation)\n\nif __name__ == \"__main__\":\n    main()\n",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.22896037499109903,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoomAllocation_shot_1.py\", line 22, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoomAllocation_shot_1.py\", line 13, in main\n    heapq.heappop(pq)\nIndexError: index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoomAllocation_shot_1.py\", line 22, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoomAllocation_shot_1.py\", line 13, in main\n    heapq.heappop(pq)\nIndexError: index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoomAllocation_shot_1.py\", line 22, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoomAllocation_shot_1.py\", line 13, in main\n    heapq.heappop(pq)\nIndexError: index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoomAllocation_shot_1.py\", line 22, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoomAllocation_shot_1.py\", line 13, in main\n    heapq.heappop(pq)\nIndexError: index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoomAllocation_shot_1.py\", line 22, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoomAllocation_shot_1.py\", line 13, in main\n    heapq.heappop(pq)\nIndexError: index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoomAllocation_shot_1.py\", line 22, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoomAllocation_shot_1.py\", line 13, in main\n    heapq.heappop(pq)\nIndexError: index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoomAllocation_shot_1.py\", line 22, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoomAllocation_shot_1.py\", line 13, in main\n    heapq.heappop(pq)\nIndexError: index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoomAllocation_shot_1.py\", line 22, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoomAllocation_shot_1.py\", line 13, in main\n    heapq.heappop(pq)\nIndexError: index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoomAllocation_shot_1.py\", line 22, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoomAllocation_shot_1.py\", line 13, in main\n    heapq.heappop(pq)\nIndexError: index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoomAllocation_shot_1.py\", line 22, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoomAllocation_shot_1.py\", line 13, in main\n    heapq.heappop(pq)\nIndexError: index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoomAllocation_shot_1.py\", line 22, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoomAllocation_shot_1.py\", line 13, in main\n    heapq.heappop(pq)\nIndexError: index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoomAllocation_shot_1.py\", line 22, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoomAllocation_shot_1.py\", line 13, in main\n    heapq.heappop(pq)\nIndexError: index out of range\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Round Trip",
            "category": "Graph Algorithms",
            "solution": "def dfs(city, parent, visited, path, graph):\n    visited[city] = True\n    path.append(city)\n\n    for neighbor in graph[city]:\n        if not visited[neighbor]:\n            if dfs(neighbor, city, visited, path, graph):\n                return True\n        elif neighbor != parent:\n            path.append(neighbor)\n            return True\n\n    path.pop()\n    return False\n\ndef round_trip(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    visited = [False] * (n + 1)\n    path = []\n\n    for city in range(1, n + 1):\n        if not visited[city]:\n            if dfs(city, -1, visited, path, graph):\n                break\n\n    if len(path) < 3:\n        print(\"IMPOSSIBLE\")\n    else:\n        print(len(path))\n        print(*path)\n\n# Test the function\nn, m = map(int, input().split())\nedges = [list(map(int, input().split())) for _ in range(m)]\nround_trip(n, m, edges)\n",
            "passed_test_cases": 5,
            "total_test_cases": 26,
            "mean_time_taken": 0.1756753371312068,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 39, in <module>\n    round_trip(n, m, edges)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 27, in round_trip\n    if dfs(city, -1, visited, path, graph):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 7, in dfs\n    if dfs(neighbor, city, visited, path, graph):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 7, in dfs\n    if dfs(neighbor, city, visited, path, graph):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 7, in dfs\n    if dfs(neighbor, city, visited, path, graph):\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 3, in dfs\n    path.append(city)\nRecursionError: maximum recursion depth exceeded while calling a Python object\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 39, in <module>\n    round_trip(n, m, edges)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 27, in round_trip\n    if dfs(city, -1, visited, path, graph):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 7, in dfs\n    if dfs(neighbor, city, visited, path, graph):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 7, in dfs\n    if dfs(neighbor, city, visited, path, graph):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 7, in dfs\n    if dfs(neighbor, city, visited, path, graph):\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 3, in dfs\n    path.append(city)\nRecursionError: maximum recursion depth exceeded while calling a Python object\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 39, in <module>\n    round_trip(n, m, edges)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 27, in round_trip\n    if dfs(city, -1, visited, path, graph):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 7, in dfs\n    if dfs(neighbor, city, visited, path, graph):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 7, in dfs\n    if dfs(neighbor, city, visited, path, graph):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 7, in dfs\n    if dfs(neighbor, city, visited, path, graph):\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 3, in dfs\n    path.append(city)\nRecursionError: maximum recursion depth exceeded while calling a Python object\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 39, in <module>\n    round_trip(n, m, edges)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 27, in round_trip\n    if dfs(city, -1, visited, path, graph):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 7, in dfs\n    if dfs(neighbor, city, visited, path, graph):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 7, in dfs\n    if dfs(neighbor, city, visited, path, graph):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 7, in dfs\n    if dfs(neighbor, city, visited, path, graph):\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 3, in dfs\n    path.append(city)\nRecursionError: maximum recursion depth exceeded while calling a Python object\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 39, in <module>\n    round_trip(n, m, edges)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 27, in round_trip\n    if dfs(city, -1, visited, path, graph):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 7, in dfs\n    if dfs(neighbor, city, visited, path, graph):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 7, in dfs\n    if dfs(neighbor, city, visited, path, graph):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 7, in dfs\n    if dfs(neighbor, city, visited, path, graph):\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTrip_shot_1.py\", line 3, in dfs\n    path.append(city)\nRecursionError: maximum recursion depth exceeded while calling a Python object\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Round Trip II",
            "category": "Graph Algorithms",
            "solution": "def dfs(city, visited, rec_stack, graph):\n    visited[city] = True\n    rec_stack[city] = True\n\n    for neighbor in graph[city]:\n        if not visited[neighbor]:\n            if dfs(neighbor, visited, rec_stack, graph):\n                return True\n        elif rec_stack[neighbor]:\n            path.append(neighbor)\n            return True\n\n    rec_stack[city] = False\n    return False\n\nn, m = map(int, input().split())\ngraph = [[] for _ in range(n+1)]\n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\nvisited = [False] * (n+1)\nrec_stack = [False] * (n+1)\npath = []\n\nfor city in range(1, n+1):\n    if not visited[city]:\n        if dfs(city, visited, rec_stack, graph):\n            path.append(city)\n            break\n\nif path:\n    print(len(path))\n    print(*path)\nelse:\n    print(\"IMPOSSIBLE\")\n",
            "passed_test_cases": 6,
            "total_test_cases": 20,
            "mean_time_taken": 0.17835838794708253,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTripII_shot_1.py\", line 29, in <module>\n    if dfs(city, visited, rec_stack, graph):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTripII_shot_1.py\", line 7, in dfs\n    if dfs(neighbor, visited, rec_stack, graph):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTripII_shot_1.py\", line 7, in dfs\n    if dfs(neighbor, visited, rec_stack, graph):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/RoundTripII_shot_1.py\", line 7, in dfs\n    if dfs(neighbor, visited, rec_stack, graph):\n  [Previous line repeated 996 more times]\nRecursionError: maximum recursion depth exceeded\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                18,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Salary Queries",
            "category": "Range Queries",
            "solution": "# Fenwick tree class\nclass Fenwick:\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def update(self, i, delta):\n        while i <= self.n:\n            self.tree[i] += delta\n            i += i & -i\n\n    def query(self, i):\n        total = 0\n        while i > 0:\n            total += self.tree[i]\n            i -= i & -i\n        return total\n\n# Main function\ndef main():\n    n, q = map(int, input().split())\n    salaries = list(map(int, input().split()))\n    salary_map = {salary: i for i, salary in enumerate(sorted(set(salaries)))}\n\n    fenwick = Fenwick(len(salary_map))\n    for salary in salaries:\n        fenwick.update(salary_map[salary], 1)\n\n    for _ in range(q):\n        query = input().split()\n        if query[0] == '!':\n            k, x = map(int, query[1:])\n            old_salary = salaries[k - 1]\n            new_salary = x\n            salaries[k - 1] = new_salary\n            fenwick.update(salary_map[old_salary], -1)\n            if new_salary in salary_map:\n                fenwick.update(salary_map[new_salary], 1)\n            else:\n                salary_map[new_salary] = len(salary_map)\n                fenwick.update(len(salary_map) - 1, 1)\n        else:\n            a, b = map(int, query[1:])\n            if a not in salary_map:\n                a_index = salary_map[min(salary for salary in salary_map if salary > a)]\n            else:\n                a_index = salary_map[a]\n            if b not in salary_map:\n                b_index = len(salary_map)\n            else:\n                b_index = salary_map[b] + 1\n            print(fenwick.query(b_index) - fenwick.query(a_index))\n\nif __name__ == \"__main__\":\n    main()\n",
            "passed_test_cases": 3,
            "total_test_cases": 13,
            "mean_time_taken": 1.0535350212684045,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "School Dance",
            "category": "Graph Algorithms",
            "solution": "from collections import defaultdict\n\ndef bipartite_matching(graph):\n    matchR = [0] * len(graph)\n    seen = [False] * len(graph)\n\n    def dfs(u):\n        for i, v in enumerate(graph[u]):\n            if seen[i]:\n                continue\n            seen[i] = True\n            if matchR[v] == -1 or dfs(matchR[v]):\n                matchR[v] = u\n                return True\n        return False\n\n    res = 0\n    for u in range(len(graph)):\n        seen = [False] * len(graph)\n        if dfs(u):\n            res += 1\n    return res, matchR\n\ndef school_dance():\n    n, m, k = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(k):\n        a, b = map(int, input().split())\n        graph[a - 1].append(b - 1)\n\n    max_pairs, matchR = bipartite_matching(list(graph.values()))\n    print(max_pairs)\n    for i, v in enumerate(matchR):\n        if v != -1:\n            print(i + 1, v + 1)\n\nschool_dance()\n",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.13290063540140787,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SchoolDance_shot_1.py\", line 37, in <module>\n    school_dance()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SchoolDance_shot_1.py\", line 31, in school_dance\n    max_pairs, matchR = bipartite_matching(list(graph.values()))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SchoolDance_shot_1.py\", line 20, in bipartite_matching\n    if dfs(u):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SchoolDance_shot_1.py\", line 12, in dfs\n    if matchR[v] == -1 or dfs(matchR[v]):\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SchoolDance_shot_1.py\", line 37, in <module>\n    school_dance()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SchoolDance_shot_1.py\", line 31, in school_dance\n    max_pairs, matchR = bipartite_matching(list(graph.values()))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SchoolDance_shot_1.py\", line 20, in bipartite_matching\n    if dfs(u):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SchoolDance_shot_1.py\", line 12, in dfs\n    if matchR[v] == -1 or dfs(matchR[v]):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SchoolDance_shot_1.py\", line 9, in dfs\n    if seen[i]:\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SchoolDance_shot_1.py\", line 37, in <module>\n    school_dance()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SchoolDance_shot_1.py\", line 31, in school_dance\n    max_pairs, matchR = bipartite_matching(list(graph.values()))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SchoolDance_shot_1.py\", line 20, in bipartite_matching\n    if dfs(u):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SchoolDance_shot_1.py\", line 12, in dfs\n    if matchR[v] == -1 or dfs(matchR[v]):\nIndexError: list index out of range\n",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SchoolDance_shot_1.py\", line 37, in <module>\n    school_dance()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SchoolDance_shot_1.py\", line 31, in school_dance\n    max_pairs, matchR = bipartite_matching(list(graph.values()))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SchoolDance_shot_1.py\", line 20, in bipartite_matching\n    if dfs(u):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SchoolDance_shot_1.py\", line 12, in dfs\n    if matchR[v] == -1 or dfs(matchR[v]):\nIndexError: list index out of range\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SchoolDance_shot_1.py\", line 37, in <module>\n    school_dance()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SchoolDance_shot_1.py\", line 31, in school_dance\n    max_pairs, matchR = bipartite_matching(list(graph.values()))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SchoolDance_shot_1.py\", line 20, in bipartite_matching\n    if dfs(u):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SchoolDance_shot_1.py\", line 12, in dfs\n    if matchR[v] == -1 or dfs(matchR[v]):\nIndexError: list index out of range\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "School Excursion",
            "category": "Additional Problems",
            "solution": "def read_input():\n    n, m = map(int, input().split())\n    wishes = [list(map(int, input().split())) for _ in range(m)]\n    return n, wishes\n\ndef initialize_dsu(n):\n    parent = list(range(n))\n    size = [1] * n\n    return parent, size\n\ndef find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, size, x, y):\n    root_x = find(parent, x)\n    root_y = find(parent, y)\n    if root_x == root_y:\n        return\n    if size[root_x] < size[root_y]:\n        parent[root_x] = root_y\n        size[root_y] += size[root_x]\n    else:\n        parent[root_y] = root_x\n        size[root_x] += size[root_y]\n\ndef solve(n, wishes):\n    parent, size = initialize_dsu(n)\n    for a, b in wishes:\n        union(parent, size, a - 1, b - 1)\n    groups = [size[find(parent, i)] for i in range(n)]\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for group_size in groups:\n        for i in range(n, -1, -1):\n            if i >= group_size:\n                dp[i] |= dp[i - group_size]\n    return dp[1:]\n\ndef main():\n    n, wishes = read_input()\n    result = solve(n, wishes)\n    print(''.join(map(str, result)))\n\nif __name__ == '__main__':\n    main()\n",
            "passed_test_cases": 4,
            "total_test_cases": 13,
            "mean_time_taken": 0.619732930110051,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                10,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Shortest Routes I",
            "category": "Graph Algorithms",
            "solution": "import heapq\n\ndef dijkstra(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for a, b, c in edges:\n        graph[a].append((b, c))\n\n    distances = [float('inf')] * (n + 1)\n    distances[1] = 0\n    queue = [(0, 1)]\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[1:]\n\ndef main():\n    n, m = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(m)]\n    print(*dijkstra(n, m, edges))\n\nif __name__ == \"__main__\":\n    main()\n",
            "passed_test_cases": 23,
            "total_test_cases": 23,
            "mean_time_taken": 0.28953583344169287,
            "mean_memory_used": 256.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Shortest Routes II",
            "category": "Graph Algorithms",
            "solution": "import heapq\n\ndef dijkstra(adj, s):\n    dist = [float('inf')] * len(adj)\n    dist[s] = 0\n    pq = [(0, s)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in adj[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n    return dist\n\nn, m, q = map(int, input().split())\nadj = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    adj[a - 1].append((b - 1, c))\n    adj[b - 1].append((a - 1, c))\ndist = dijkstra(adj, 0)\nfor _ in range(q):\n    a, b = map(int, input().split())\n    ans = dist[a - 1] if dist[a - 1] < float('inf') else -1\n    print(ans)\n",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.29414456685384116,
            "mean_memory_used": 0.8,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Shortest Subsequence",
            "category": "Additional Problems",
            "solution": "def shortest_subsequence(s):\n    # Initialize an empty dictionary to store the last occurrence of each character\n    last_occurrence = {}\n\n    # Initialize an empty string to store the result\n    result = \"\"\n\n    # Iterate over the characters in the string\n    for c in s:\n        # If the character is not in the dictionary, add it with its index\n        if c not in last_occurrence:\n            last_occurrence[c] = len(result)\n\n        # Update the result with the character that has the smallest last occurrence index\n        result += min(last_occurrence, key=last_occurrence.get)\n\n    # Return the result plus one more character that is different from the last one\n    return result + ('A' if result[-1] != 'A' else 'C')\n\n# Read the input\ns = input()\n\n# Print the shortest DNA sequence that is not a subsequence of the original sequence\nprint(shortest_subsequence(s))\n",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.2292715072631836,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Signal Processing",
            "category": "Advanced Techniques",
            "solution": "# Read the input\nn, m = map(int, input().split())\nsignal = list(map(int, input().split()))\nmask = list(map(int, input().split()))\n\n# Initialize the results list\nresults = []\n\n# Iterate over the signal\nfor i in range(n + m - 1):\n    # Calculate the sum of products of aligned values\n    sum_of_products = sum(signal[j] * mask[k] for j, k in enumerate(range(max(0, i - m + 1), min(i + 1, n))) if 0 <= j < n and 0 <= k < m)\n    results.append(sum_of_products)\n\n# Print the results\nprint(*results)\n",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.7392685413360596,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sliding Window Cost",
            "category": "Sorting and Searching",
            "solution": "import sys\nimport heapq\n\ndef sliding_window_cost(n, k, arr):\n    costs = []\n    min_heap = []\n    max_heap = []\n\n    for i in range(k):\n        heapq.heappush(max_heap, (-arr[i], arr[i]))\n        heapq.heappush(min_heap, arr[i])\n        balance_heaps(max_heap, min_heap)\n\n    costs.append(calculate_cost(max_heap, min_heap, arr[i]))\n\n    for i in range(k, n):\n        remove_from_heaps(max_heap, min_heap, arr[i - k])\n        heapq.heappush(max_heap, (-arr[i], arr[i]))\n        heapq.heappush(min_heap, arr[i])\n        balance_heaps(max_heap, min_heap)\n        costs.append(calculate_cost(max_heap, min_heap, arr[i]))\n\n    return costs\n\ndef balance_heaps(max_heap, min_heap):\n    while len(max_heap) > len(min_heap) + 1:\n        heapq.heappush(min_heap, -heapq.heappop(max_heap)[1])\n\n    while len(max_heap) < len(min_heap):\n        heapq.heappush(max_heap, (-heapq.heappop(min_heap), -heapq.heappop(min_heap)))\n\ndef calculate_cost(max_heap, min_heap, current):\n    if len(max_heap) > len(min_heap):\n        return abs(current - max_heap[0][1])\n    else:\n        return abs(current - min_heap[0])\n\ndef remove_from_heaps(max_heap, min_heap, value):\n    if max_heap[0][1] == value:\n        heapq.heappop(max_heap)\n    elif min_heap[0] == value:\n        heapq.heappop(min_heap)\n    else:\n        remove_value_from_heap(max_heap, value)\n        remove_value_from_heap(min_heap, -value)\n\ndef remove_value_from_heap(heap, value):\n    index = heap.index(value)\n    heap[index] = heap[-1]\n    del heap[-1]\n    heapq.heapify(heap)\n\nif __name__ == \"__main__\":\n    n, k = map(int, sys.stdin.readline().split())\n    arr = list(map(int, sys.stdin.readline().split()))\n    print(*sliding_window_cost(n, k, arr))\n",
            "passed_test_cases": 2,
            "total_test_cases": 34,
            "mean_time_taken": 0.17409288883209229,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 56, in <module>\n    print(*sliding_window_cost(n, k, arr))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 17, in sliding_window_cost\n    remove_from_heaps(max_heap, min_heap, arr[i - k])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 44, in remove_from_heaps\n    remove_value_from_heap(max_heap, value)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 48, in remove_value_from_heap\n    index = heap.index(value)\nValueError: 3 is not in list\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 56, in <module>\n    print(*sliding_window_cost(n, k, arr))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 17, in sliding_window_cost\n    remove_from_heaps(max_heap, min_heap, arr[i - k])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 44, in remove_from_heaps\n    remove_value_from_heap(max_heap, value)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 48, in remove_value_from_heap\n    index = heap.index(value)\nValueError: 3 is not in list\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 56, in <module>\n    print(*sliding_window_cost(n, k, arr))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 17, in sliding_window_cost\n    remove_from_heaps(max_heap, min_heap, arr[i - k])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 44, in remove_from_heaps\n    remove_value_from_heap(max_heap, value)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 48, in remove_value_from_heap\n    index = heap.index(value)\nValueError: 814779220 is not in list\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 56, in <module>\n    print(*sliding_window_cost(n, k, arr))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 17, in sliding_window_cost\n    remove_from_heaps(max_heap, min_heap, arr[i - k])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 44, in remove_from_heaps\n    remove_value_from_heap(max_heap, value)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 48, in remove_value_from_heap\n    index = heap.index(value)\nValueError: 7 is not in list\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 56, in <module>\n    print(*sliding_window_cost(n, k, arr))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 17, in sliding_window_cost\n    remove_from_heaps(max_heap, min_heap, arr[i - k])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 41, in remove_from_heaps\n    elif min_heap[0] == value:\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 56, in <module>\n    print(*sliding_window_cost(n, k, arr))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 17, in sliding_window_cost\n    remove_from_heaps(max_heap, min_heap, arr[i - k])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 44, in remove_from_heaps\n    remove_value_from_heap(max_heap, value)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 48, in remove_value_from_heap\n    index = heap.index(value)\nValueError: 6 is not in list\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 56, in <module>\n    print(*sliding_window_cost(n, k, arr))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 17, in sliding_window_cost\n    remove_from_heaps(max_heap, min_heap, arr[i - k])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 44, in remove_from_heaps\n    remove_value_from_heap(max_heap, value)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 48, in remove_value_from_heap\n    index = heap.index(value)\nValueError: 15965863 is not in list\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 56, in <module>\n    print(*sliding_window_cost(n, k, arr))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 17, in sliding_window_cost\n    remove_from_heaps(max_heap, min_heap, arr[i - k])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 44, in remove_from_heaps\n    remove_value_from_heap(max_heap, value)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 48, in remove_value_from_heap\n    index = heap.index(value)\nValueError: 3 is not in list\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 56, in <module>\n    print(*sliding_window_cost(n, k, arr))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 17, in sliding_window_cost\n    remove_from_heaps(max_heap, min_heap, arr[i - k])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 44, in remove_from_heaps\n    remove_value_from_heap(max_heap, value)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 48, in remove_value_from_heap\n    index = heap.index(value)\nValueError: 4 is not in list\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 56, in <module>\n    print(*sliding_window_cost(n, k, arr))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 17, in sliding_window_cost\n    remove_from_heaps(max_heap, min_heap, arr[i - k])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 41, in remove_from_heaps\n    elif min_heap[0] == value:\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 56, in <module>\n    print(*sliding_window_cost(n, k, arr))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 17, in sliding_window_cost\n    remove_from_heaps(max_heap, min_heap, arr[i - k])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 44, in remove_from_heaps\n    remove_value_from_heap(max_heap, value)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 48, in remove_value_from_heap\n    index = heap.index(value)\nValueError: 3 is not in list\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 56, in <module>\n    print(*sliding_window_cost(n, k, arr))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 17, in sliding_window_cost\n    remove_from_heaps(max_heap, min_heap, arr[i - k])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 41, in remove_from_heaps\n    elif min_heap[0] == value:\nIndexError: list index out of range\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 56, in <module>\n    print(*sliding_window_cost(n, k, arr))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 17, in sliding_window_cost\n    remove_from_heaps(max_heap, min_heap, arr[i - k])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 44, in remove_from_heaps\n    remove_value_from_heap(max_heap, value)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 48, in remove_value_from_heap\n    index = heap.index(value)\nValueError: 5 is not in list\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 56, in <module>\n    print(*sliding_window_cost(n, k, arr))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 17, in sliding_window_cost\n    remove_from_heaps(max_heap, min_heap, arr[i - k])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 44, in remove_from_heaps\n    remove_value_from_heap(max_heap, value)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 48, in remove_value_from_heap\n    index = heap.index(value)\nValueError: 458534336 is not in list\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 56, in <module>\n    print(*sliding_window_cost(n, k, arr))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 17, in sliding_window_cost\n    remove_from_heaps(max_heap, min_heap, arr[i - k])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 44, in remove_from_heaps\n    remove_value_from_heap(max_heap, value)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 48, in remove_value_from_heap\n    index = heap.index(value)\nValueError: 6 is not in list\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 56, in <module>\n    print(*sliding_window_cost(n, k, arr))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 17, in sliding_window_cost\n    remove_from_heaps(max_heap, min_heap, arr[i - k])\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 44, in remove_from_heaps\n    remove_value_from_heap(max_heap, value)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowCost_shot_1.py\", line 48, in remove_value_from_heap\n    index = heap.index(value)\nValueError: 927665663 is not in list\n",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                34
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sliding Window Median",
            "category": "Sorting and Searching",
            "solution": "import sys\nimport heapq\n\ndef read_input():\n    n, k = map(int, input().split())\n    arr = list(map(int, input().split()))\n    return n, k, arr\n\ndef sliding_window_median(arr, k):\n    min_heap = []\n    max_heap = []\n    medians = []\n\n    for i in range(len(arr)):\n        # Add element to the correct heap\n        if not min_heap or -min_heap[0] <= arr[i]:\n            heapq.heappush(min_heap, -arr[i])\n        else:\n            heapq.heappush(max_heap, arr[i])\n\n        # Rebalance heaps if necessary\n        if len(min_heap) > len(max_heap) + 1:\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap):\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n\n        # Calculate median and slide window\n        if i >= k - 1:\n            if len(min_heap) == len(max_heap):\n                medians.append(-min_heap[0])\n            else:\n                medians.append((-min_heap[0] + max_heap[0]) / 2)\n\n            # Remove the first element of the current window\n            if arr[i - k + 1] <= -min_heap[0]:\n                min_heap = [-x for x in min_heap if x != -arr[i - k + 1]]\n                heapq.heapify(min_heap)\n            else:\n                max_heap = [x for x in max_heap if x != arr[i - k + 1]]\n                heapq.heapify(max_heap)\n\n    return medians\n\ndef main():\n    n, k, arr = read_input()\n    medians = sliding_window_median(arr, k)\n    print(*medians)\n\nif __name__ == \"__main__\":\n    main()\n",
            "passed_test_cases": 4,
            "total_test_cases": 40,
            "mean_time_taken": 0.32077391147613527,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowMedian_shot_1.py\", line 50, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowMedian_shot_1.py\", line 46, in main\n    medians = sliding_window_median(arr, k)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowMedian_shot_1.py\", line 32, in sliding_window_median\n    medians.append((-min_heap[0] + max_heap[0]) / 2)\nIndexError: list index out of range\n",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowMedian_shot_1.py\", line 50, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowMedian_shot_1.py\", line 46, in main\n    medians = sliding_window_median(arr, k)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowMedian_shot_1.py\", line 32, in sliding_window_median\n    medians.append((-min_heap[0] + max_heap[0]) / 2)\nIndexError: list index out of range\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowMedian_shot_1.py\", line 50, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowMedian_shot_1.py\", line 46, in main\n    medians = sliding_window_median(arr, k)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowMedian_shot_1.py\", line 32, in sliding_window_median\n    medians.append((-min_heap[0] + max_heap[0]) / 2)\nIndexError: list index out of range\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowMedian_shot_1.py\", line 50, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowMedian_shot_1.py\", line 46, in main\n    medians = sliding_window_median(arr, k)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowMedian_shot_1.py\", line 32, in sliding_window_median\n    medians.append((-min_heap[0] + max_heap[0]) / 2)\nIndexError: list index out of range\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowMedian_shot_1.py\", line 50, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowMedian_shot_1.py\", line 46, in main\n    medians = sliding_window_median(arr, k)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowMedian_shot_1.py\", line 32, in sliding_window_median\n    medians.append((-min_heap[0] + max_heap[0]) / 2)\nIndexError: list index out of range\n",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowMedian_shot_1.py\", line 50, in <module>\n    main()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowMedian_shot_1.py\", line 46, in main\n    medians = sliding_window_median(arr, k)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SlidingWindowMedian_shot_1.py\", line 32, in sliding_window_median\n    medians.append((-min_heap[0] + max_heap[0]) / 2)\nIndexError: list index out of range\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                27,
                28,
                30,
                31,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                40
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sorting Methods",
            "category": "Additional Problems",
            "solution": "def count_inversions(arr):\n    return sum(i < j for i, j in zip(arr, arr[1:]))\n\ndef count_wrong_positions(arr):\n    return sum(arr[i] != i+1 for i in range(len(arr)))\n\ndef count_moves(arr):\n    moves = 0\n    sorted_positions = 0\n    for i, num in enumerate(arr):\n        if num == i+1:\n            sorted_positions += 1\n        elif num < arr[i-1]:\n            moves += 1\n    return len(arr) - sorted_positions - moves\n\ndef count_cycles(arr):\n    visited = [False] * len(arr)\n    cycles = 0\n    for i in range(len(arr)):\n        if not visited[i]:\n            cycles += 1\n            j = i\n            while not visited[j]:\n                visited[j] = True\n                j = arr[j] - 1\n    return cycles\n\nn = int(input())\narr = list(map(int, input().split()))\narr_index = [i+1 for i in range(n)]\nfor i, num in enumerate(arr):\n    arr_index[num-1] = i+1\n\nprint(count_inversions(arr), count_wrong_positions(arr), count_moves(arr), count_cycles(arr_index))\n",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.1726747751235962,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Special Substrings",
            "category": "Additional Problems",
            "solution": "def count_special_substrings(s):\n    n = len(s)\n    # Initialize the prefix sum array\n    prefix_sum = [0] * 26\n    for i in range(n):\n        prefix_sum[ord(s[i]) - ord('a')] += 1\n    # Count the number of special substrings\n    count = 0\n    # Iterate over all possible substrings\n    for i in range(n):\n        for j in range(i, n):\n            # Check if the current substring is special\n            special = True\n            for k in range(26):\n                if prefix_sum[k] * (j - i + 1) != (prefix_sum[k] - (prefix_sum[k] - (j - i + 1) * (prefix_sum[k] if i == 0 else prefix_sum[k] - prefix_sum[k]))) and prefix_sum[k] != 0:\n                    special = False\n                    break\n            if special:\n                count += 1\n            # Update the prefix sum array\n            if j < n - 1:\n                prefix_sum[ord(s[j + 1]) - ord('a')] += 1\n    return count\n\n# Read the input string\ns = input().strip()\n# Print the number of special substrings\nprint(count_special_substrings(s))\n",
            "passed_test_cases": 1,
            "total_test_cases": 8,
            "mean_time_taken": 0.818695455789566,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Stack Weights",
            "category": "Additional Problems",
            "solution": "# Initialize the left and right stacks\nleft_stack = []\nright_stack = []\n\n# Read the number of coins\nn = int(input())\n\n# Process each move\nfor _ in range(n):\n    # Read the coin and stack\n    coin, stack = map(int, input().split())\n\n    # Add the coin to the appropriate stack\n    if stack == 1:\n        left_stack.append(coin)\n    else:\n        right_stack.append(coin)\n\n    # Compare the stacks\n    if len(left_stack) > len(right_stack):\n        print('>')\n    elif len(left_stack) < len(right_stack):\n        print('<')\n    else:\n        # If the stacks have the same number of coins, we can't be sure which is heavier\n        print('?')\n",
            "passed_test_cases": 0,
            "total_test_cases": 5,
            "mean_time_taken": 0.4922943115234375,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Stair Game",
            "category": "Mathematics",
            "solution": "def win(n, p):\n    for i in range(2, n):\n        if p[i] >= p[i - 1]:\n            p[i - 1] += p[i]\n            p[i] = 0\n            return \"first\"\n    return \"second\"\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = list(map(int, input().split()))\n    print(win(n, p))\n",
            "passed_test_cases": 2,
            "total_test_cases": 7,
            "mean_time_taken": 0.1383256231035505,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Static Range Minimum Queries",
            "category": "Range Queries",
            "solution": "class Node:\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n        self.min_val = float('inf')\n        self.left = None\n        self.right = None\n\ndef build_tree(arr, tree, tree_index, start, end):\n    if start == end:\n        tree[tree_index] = Node(start, end, arr[start])\n        return tree[tree_index].min_val\n    mid = (start + end) // 2\n    tree[tree_index] = Node(start, end)\n    tree[tree_index].left = build_tree(arr, tree, 2*tree_index+1, start, mid)\n    tree[tree_index].right = build_tree(arr, tree, 2*tree_index+2, mid+1, end)\n    tree[tree_index].min_val = min(tree[tree_index].left.min_val, tree[tree_index].right.min_val)\n    return tree[tree_index].min_val\n\ndef query(tree, tree_index, start, end, q_start, q_end):\n    if start > q_end or end < q_start:\n        return float('inf')\n    if start >= q_start and end <= q_end:\n        return tree[tree_index].min_val\n    mid = (start + end) // 2\n    return min(query(tree, 2*tree_index+1, start, mid, q_start, q_end), query(tree, 2*tree_index+2, mid+1, end, q_start, q_end))\n\nn, q = map(int, input().split())\narr = list(map(int, input().split()))\nmax_size = 2*pow(2, int(ceil(log2(n))))\ntree = [None]*int(max_size)\nbuild_tree(arr, tree, 0, 0, n-1)\nfor _ in range(q):\n    a, b = map(int, input().split())\n    print(query(tree, 0, 0, n-1, a-1, b-1))\n",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.17590761184692383,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/StaticRangeMinimumQueries_shot_1.py\", line 30, in <module>\n    max_size = 2*pow(2, int(ceil(log2(n))))\nNameError: name 'ceil' is not defined\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/StaticRangeMinimumQueries_shot_1.py\", line 30, in <module>\n    max_size = 2*pow(2, int(ceil(log2(n))))\nNameError: name 'ceil' is not defined\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/StaticRangeMinimumQueries_shot_1.py\", line 30, in <module>\n    max_size = 2*pow(2, int(ceil(log2(n))))\nNameError: name 'ceil' is not defined\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/StaticRangeMinimumQueries_shot_1.py\", line 30, in <module>\n    max_size = 2*pow(2, int(ceil(log2(n))))\nNameError: name 'ceil' is not defined\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Static Range Sum Queries",
            "category": "Range Queries",
            "solution": "def solve():\n    # Read the input\n    n, q = map(int, input().split())\n    arr = list(map(int, input().split()))\n    queries = [list(map(int, input().split())) for _ in range(q)]\n\n    # Create the prefix sum array\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1]\n\n    # Process the queries\n    for a, b in queries:\n        print(prefix_sum[b] - prefix_sum[a - 1])\n\n# Call the function to start the solution\nsolve()\n",
            "passed_test_cases": 2,
            "total_test_cases": 2,
            "mean_time_taken": 0.2583932876586914,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Stick Divisions",
            "category": "Additional Problems",
            "solution": "def stick_divisions():\n    # Read the input\n    x, n = map(int, input().split())\n    d = list(map(int, input().split()))\n\n    # Sort the sticks in descending order\n    d.sort(reverse=True)\n\n    # Initialize the cost\n    cost = 0\n\n    # Start with the full length stick\n    current_stick = x\n\n    # Iterate over the sticks\n    for i in d:\n        # If the current stick is smaller than the target stick, something went wrong\n        if current_stick < i:\n            return -1\n        # Otherwise, subtract the target stick from the current stick\n        else:\n            current_stick -= i\n            # And add the original length of the current stick to the cost\n            cost += i\n\n    return cost\n\n# Print the result\nprint(stick_divisions())\n",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.15166755517323813,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Stick Game",
            "category": "Mathematics",
            "solution": "n, k = map(int, input().split())\nmoves = list(map(int, input().split()))\n\n# Initialize all positions as losing positions\ndp = ['L'] * (n+1)\n\n# Iterate over all positions\nfor i in range(1, n+1):\n    # If there is a move that leads to a losing position, the current position is winning\n    if any(dp[i - move] == 'L' for move in moves):\n        dp[i] = 'W'\n    else:\n        dp[i] = 'L'\n\n# Print the result for all positions except 0\nprint(''.join(dp[1:]))\n",
            "passed_test_cases": 2,
            "total_test_cases": 6,
            "mean_time_taken": 0.41192694505055744,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Stick Lengths",
            "category": "Sorting and Searching",
            "solution": "import sys\nimport statistics\n\ndef min_cost(n, sticks):\n    # Find the median of the stick lengths\n    median = statistics.median(sticks)\n\n    # Calculate the total cost of adjusting the sticks to the median length\n    total_cost = sum(abs(stick - median) for stick in sticks)\n\n    return total_cost\n\n# Read the input\nn = int(sys.stdin.readline())\nsticks = list(map(int, sys.stdin.readline().split()))\n\n# Print the minimum total cost\nprint(min_cost(n, sticks))\n",
            "passed_test_cases": 5,
            "total_test_cases": 11,
            "mean_time_taken": 0.14257942546497693,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                5,
                7,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "String Functions",
            "category": "String Algorithms",
            "solution": "def z_function(s):\n    n = len(s)\n    z = [0] * n\n    l, r = 0, 0\n    for i in range(1, n):\n        if i <= r:\n            z[i] = min(r - i + 1, z[i - l])\n        while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n            z[i] += 1\n        if i + z[i] - 1 > r:\n            l, r = i, i + z[i] - 1\n    return z\n\ndef pi_function(s):\n    n = len(s)\n    pi = [0] * n\n    for i in range(1, n):\n        k = pi[i-1]\n        while k > 0 and s[k] != s[i]:\n            k = pi[k-1]\n        if s[k] == s[i]:\n            k += 1\n        pi[i] = k\n    return pi\n\ns = input().strip()\nz = z_function(s)\npi = pi_function(s)\nprint(*z)\nprint(*pi)\n",
            "passed_test_cases": 0,
            "total_test_cases": 5,
            "mean_time_taken": 0.8151996612548829,
            "mean_memory_used": 6340.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "String Matching",
            "category": "String Algorithms",
            "solution": "# Read the input\nstring = input().strip()\npattern = input().strip()\n\n# Count the occurrences\noccurrences = string.count(pattern)\n\n# Print the result\nprint(occurrences)\n",
            "passed_test_cases": 35,
            "total_test_cases": 37,
            "mean_time_taken": 0.11306861284616831,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                16,
                36
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "String Removals",
            "category": "Additional Problems",
            "solution": "# Read the input string\ns = input()\n\n# Length of the string\nn = len(s)\n\n# Modulo value\nMOD = 10**9 + 7\n\n# The number of substrings is 2^n\n# Since n can be large, we calculate 2^n using a loop\n# and take modulo at each step to avoid overflow\nresult = 1\nfor i in range(n):\n    result = (result * 2) % MOD\n\n# Print the result\nprint(result)\n",
            "passed_test_cases": 0,
            "total_test_cases": 7,
            "mean_time_taken": 0.13161710330418178,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "String Reorder",
            "category": "Additional Problems",
            "solution": "def string_reorder(s):\n    from collections import Counter\n    freq = Counter(s)\n    chars = sorted(freq.keys(), key=lambda x: (-freq[x], x))\n    result = []\n    while chars:\n        for c in chars:\n            if not result or result[-1] != c:\n                result.append(c)\n                freq[c] -= 1\n                if freq[c] == 0:\n                    chars.remove(c)\n                break\n        else:\n            return -1\n    return ''.join(result)\n\ns = input()\nprint(string_reorder(s))\n",
            "passed_test_cases": 9,
            "total_test_cases": 15,
            "mean_time_taken": 0.18142863909403484,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                7,
                13,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "String Transform",
            "category": "Additional Problems",
            "solution": "# Read the input\ns = input().strip()\n\n# Find the position of '#'\npos = s.index('#')\n\n# Construct the original string\noriginal = s[pos+1:] + s[:pos]\n\n# Print the original string\nprint(original)\n",
            "passed_test_cases": 2,
            "total_test_cases": 6,
            "mean_time_taken": 0.12760571638743082,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Strongly Connected Edges",
            "category": "Additional Problems",
            "solution": "def dfs(node, parent, graph, oriented_graph):\n    for neighbor in graph[node]:\n        if neighbor == parent:\n            continue\n        if neighbor not in oriented_graph:\n            oriented_graph[node].append(neighbor)\n            dfs(neighbor, node, graph, oriented_graph)\n        elif oriented_graph[neighbor] and not any(node_neighbor == node for node_neighbor in oriented_graph[neighbor]):\n            oriented_graph[neighbor].append(node)\n\ndef orient_edges(n, m, edges):\n    graph = {node: [] for node in range(1, n + 1)}\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    oriented_graph = {node: [] for node in range(1, n + 1)}\n    for node in range(1, n + 1):\n        if not oriented_graph[node]:\n            dfs(node, -1, graph, oriented_graph)\n\n    if sum(len(node_edges) for node_edges in oriented_graph.values()) != m:\n        return \"IMPOSSIBLE\"\n\n    result = []\n    for node, edges in oriented_graph.items():\n        for edge in edges:\n            result.append((node, edge))\n    return result\n\nn, m = map(int, input().split())\nedges = [list(map(int, input().split())) for _ in range(m)]\nresult = orient_edges(n, m, edges)\nif result == \"IMPOSSIBLE\":\n    print(\"IMPOSSIBLE\")\nelse:\n    for edge in result:\n        print(*edge)\n",
            "passed_test_cases": 6,
            "total_test_cases": 11,
            "mean_time_taken": 0.2090433727611195,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Distinct Values",
            "category": "Sorting and Searching",
            "solution": "def subarray_distinct_values(n, k, arr):\n    result = 0\n    start = 0\n    distinct = {}\n\n    # Process each element in the array\n    for end in range(n):\n        # Add the rightmost element to the window\n        distinct[arr[end]] = distinct.get(arr[end], 0) + 1\n\n        # While the window has more than k distinct elements, remove the leftmost element from the window\n        while len(distinct) > k:\n            distinct[arr[start]] -= 1\n            if distinct[arr[start]] == 0:\n                del distinct[arr[start]]\n            start += 1\n\n        # Add the number of subarrays formed by the current window to the result\n        result += (end - start + 1) * (end - start + 2) // 2\n\n    return result\n\n# Read the input\nn, k = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Print the result\nprint(subarray_distinct_values(n, k, arr))\n",
            "passed_test_cases": 1,
            "total_test_cases": 10,
            "mean_time_taken": 0.26711392402648926,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Divisibility",
            "category": "Sorting and Searching",
            "solution": "n = int(input())\narr = list(map(int, input().split()))\n\nmod_sum = 0\ncount = 0\nprefix_sum_count = {0: 1}\n\nfor num in arr:\n    mod_sum = (mod_sum + num) % n\n    count += prefix_sum_count.get(mod_sum, 0)\n    prefix_sum_count[mod_sum] = prefix_sum_count.get(mod_sum, 0) + 1\n\nprint(count)\n",
            "passed_test_cases": 9,
            "total_test_cases": 10,
            "mean_time_taken": 0.22366814613342284,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Squares",
            "category": "Advanced Techniques",
            "solution": "import sys\n\ndef min_cost(n, k, arr):\n    # Create a 2D DP table\n    dp = [[sys.maxsize for _ in range(n)] for _ in range(k + 1)]\n\n    # Initialize base cases\n    dp[0][0] = 0\n    for i in range(1, n + 1):\n        dp[1][i - 1] = sum(arr[:i]) ** 2\n\n    # Fill the DP table\n    for i in range(2, k + 1):\n        for j in range(i, n + 1):\n            for l in range(1, j + 1):\n                dp[i][j - 1] = min(dp[i][j - 1], dp[i - 1][j - l - 1] + (sum(arr[j - l:j])) ** 2)\n\n    return dp[k][n - 1]\n\n# Read input\nn, k = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Calculate and print the minimum total cost\nprint(min_cost(n, k, arr))\n",
            "passed_test_cases": 4,
            "total_test_cases": 11,
            "mean_time_taken": 0.7513467832045122,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                7,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Sum Queries",
            "category": "Range Queries",
            "solution": "class Node:\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n        self.max_sum = float('-inf')\n        self.left = None\n        self.right = None\n\ndef build_tree(arr, tree, index, start, end):\n    if start == end:\n        tree[index] = Node(start, end)\n        tree[index].max_sum = arr[start]\n        return tree[index].max_sum\n    mid = (start + end) // 2\n    tree[index] = Node(start, end)\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n    tree[index].right = build_tree(arr, tree, 2*index+2, mid+1, end)\n    tree[index].max_sum = max(tree[index].left.max_sum, tree[index].right.max_sum, tree[index].left.max_sum + tree[index].right.max_sum)\n    return tree[index].max_sum\n\ndef update_tree(tree, index, start, end, pos, value):\n    if start == end:\n        tree[index].max_sum = value\n        return value\n    mid = (start + end) // 2\n    if pos <= mid:\n        update_tree(tree[index].left, 2*index+1, start, mid, pos, value)\n    else:\n        update_tree(tree[index].right, 2*index+2, mid+1, end, pos, value)\n    tree[index].max_sum = max(tree[index].left.max_sum, tree[index].right.max_sum, tree[index].left.max_sum + tree[index].right.max_sum)\n    return tree[index].max_sum\n\nn, m = map(int, input().split())\narr = list(map(int, input().split()))\ntree = [None for _ in range(4*n)]\nbuild_tree(arr, tree, 0, 0, n-1)\nfor _ in range(m):\n    k, x = map(int, input().split())\n    print(update_tree(tree, 0, 0, n-1, k-1, x))\n",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.1728325049082438,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 36, in <module>\n    build_tree(arr, tree, 0, 0, n-1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 18, in build_tree\n    tree[index].max_sum = max(tree[index].left.max_sum, tree[index].right.max_sum, tree[index].left.max_sum + tree[index].right.max_sum)\nAttributeError: 'int' object has no attribute 'max_sum'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 36, in <module>\n    build_tree(arr, tree, 0, 0, n-1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 18, in build_tree\n    tree[index].max_sum = max(tree[index].left.max_sum, tree[index].right.max_sum, tree[index].left.max_sum + tree[index].right.max_sum)\nAttributeError: 'int' object has no attribute 'max_sum'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 36, in <module>\n    build_tree(arr, tree, 0, 0, n-1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  [Previous line repeated 14 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 18, in build_tree\n    tree[index].max_sum = max(tree[index].left.max_sum, tree[index].right.max_sum, tree[index].left.max_sum + tree[index].right.max_sum)\nAttributeError: 'int' object has no attribute 'max_sum'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 36, in <module>\n    build_tree(arr, tree, 0, 0, n-1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 18, in build_tree\n    tree[index].max_sum = max(tree[index].left.max_sum, tree[index].right.max_sum, tree[index].left.max_sum + tree[index].right.max_sum)\nAttributeError: 'int' object has no attribute 'max_sum'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 36, in <module>\n    build_tree(arr, tree, 0, 0, n-1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  [Previous line repeated 14 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 18, in build_tree\n    tree[index].max_sum = max(tree[index].left.max_sum, tree[index].right.max_sum, tree[index].left.max_sum + tree[index].right.max_sum)\nAttributeError: 'int' object has no attribute 'max_sum'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 36, in <module>\n    build_tree(arr, tree, 0, 0, n-1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  [Previous line repeated 14 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 18, in build_tree\n    tree[index].max_sum = max(tree[index].left.max_sum, tree[index].right.max_sum, tree[index].left.max_sum + tree[index].right.max_sum)\nAttributeError: 'int' object has no attribute 'max_sum'\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 36, in <module>\n    build_tree(arr, tree, 0, 0, n-1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 18, in build_tree\n    tree[index].max_sum = max(tree[index].left.max_sum, tree[index].right.max_sum, tree[index].left.max_sum + tree[index].right.max_sum)\nAttributeError: 'int' object has no attribute 'max_sum'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 36, in <module>\n    build_tree(arr, tree, 0, 0, n-1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  [Previous line repeated 14 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 18, in build_tree\n    tree[index].max_sum = max(tree[index].left.max_sum, tree[index].right.max_sum, tree[index].left.max_sum + tree[index].right.max_sum)\nAttributeError: 'int' object has no attribute 'max_sum'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 36, in <module>\n    build_tree(arr, tree, 0, 0, n-1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 18, in build_tree\n    tree[index].max_sum = max(tree[index].left.max_sum, tree[index].right.max_sum, tree[index].left.max_sum + tree[index].right.max_sum)\nAttributeError: 'int' object has no attribute 'max_sum'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 36, in <module>\n    build_tree(arr, tree, 0, 0, n-1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  [Previous line repeated 14 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 18, in build_tree\n    tree[index].max_sum = max(tree[index].left.max_sum, tree[index].right.max_sum, tree[index].left.max_sum + tree[index].right.max_sum)\nAttributeError: 'int' object has no attribute 'max_sum'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 36, in <module>\n    build_tree(arr, tree, 0, 0, n-1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 18, in build_tree\n    tree[index].max_sum = max(tree[index].left.max_sum, tree[index].right.max_sum, tree[index].left.max_sum + tree[index].right.max_sum)\nAttributeError: 'int' object has no attribute 'max_sum'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 36, in <module>\n    build_tree(arr, tree, 0, 0, n-1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  [Previous line repeated 14 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 18, in build_tree\n    tree[index].max_sum = max(tree[index].left.max_sum, tree[index].right.max_sum, tree[index].left.max_sum + tree[index].right.max_sum)\nAttributeError: 'int' object has no attribute 'max_sum'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 36, in <module>\n    build_tree(arr, tree, 0, 0, n-1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 18, in build_tree\n    tree[index].max_sum = max(tree[index].left.max_sum, tree[index].right.max_sum, tree[index].left.max_sum + tree[index].right.max_sum)\nAttributeError: 'int' object has no attribute 'max_sum'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 36, in <module>\n    build_tree(arr, tree, 0, 0, n-1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 16, in build_tree\n    tree[index].left = build_tree(arr, tree, 2*index+1, start, mid)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubarraySumQueries_shot_1.py\", line 18, in build_tree\n    tree[index].max_sum = max(tree[index].left.max_sum, tree[index].right.max_sum, tree[index].left.max_sum + tree[index].right.max_sum)\nAttributeError: 'int' object has no attribute 'max_sum'\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Sums I",
            "category": "Sorting and Searching",
            "solution": "def subarray_sums(n, x, arr):\n    # Initialize a dictionary to store the count of each sum\n    sum_count = {0: 1}  # Base case: sum 0 has count 1 (empty subarray)\n    running_sum = 0  # Initialize running sum\n    count = 0  # Initialize count of subarrays\n\n    # Iterate over the array\n    for i in range(n):\n        running_sum += arr[i]  # Update running sum\n\n        # If running sum minus target sum is in the dictionary,\n        # increment count by its count in the dictionary\n        if running_sum - x in sum_count:\n            count += sum_count[running_sum - x]\n\n        # Increment the count of the current running sum in the dictionary\n        if running_sum in sum_count:\n            sum_count[running_sum] += 1\n        else:\n            sum_count[running_sum] = 1\n\n    return count\n\n# Read input\nn, x = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Print output\nprint(subarray_sums(n, x, arr))\n",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.15539497137069702,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Subarray Sums II",
            "category": "Sorting and Searching",
            "solution": "def subarray_sums(n, x, arr):\n    prefix_sum = {0: 1}  # frequency of prefix sums\n    sum = 0  # current prefix sum\n    count = 0  # number of subarrays with sum x\n\n    for num in arr:\n        sum += num\n        if sum - x in prefix_sum:\n            count += prefix_sum[sum - x]\n        prefix_sum[sum] = prefix_sum.get(sum, 0) + 1\n\n    return count\n\n# Read input\nn, x = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Print output\nprint(subarray_sums(n, x, arr))\n",
            "passed_test_cases": 25,
            "total_test_cases": 27,
            "mean_time_taken": 0.22465742958916557,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subordinates",
            "category": "Tree Algorithms",
            "solution": "def dfs(boss, graph):\n    subordinates = 0\n    for employee in graph[boss]:\n        subordinates += 1 + dfs(employee, graph)\n    return subordinates\n\nn = int(input())\nbosses = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor i in range(1, n):\n    graph[bosses[i - 1]].append(i + 1)\n\nsubordinates = [0] * (n + 1)\nfor i in range(1, n + 1):\n    subordinates[i] = dfs(i, graph)\n\nprint(*subordinates[1:])\n",
            "passed_test_cases": 9,
            "total_test_cases": 12,
            "mean_time_taken": 0.19120399157206217,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Subordinates_shot_1.py\", line 16, in <module>\n    subordinates[i] = dfs(i, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Subordinates_shot_1.py\", line 4, in dfs\n    subordinates += 1 + dfs(employee, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Subordinates_shot_1.py\", line 4, in dfs\n    subordinates += 1 + dfs(employee, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Subordinates_shot_1.py\", line 4, in dfs\n    subordinates += 1 + dfs(employee, graph)\n  [Previous line repeated 996 more times]\nRecursionError: maximum recursion depth exceeded\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Subordinates_shot_1.py\", line 16, in <module>\n    subordinates[i] = dfs(i, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Subordinates_shot_1.py\", line 4, in dfs\n    subordinates += 1 + dfs(employee, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Subordinates_shot_1.py\", line 4, in dfs\n    subordinates += 1 + dfs(employee, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Subordinates_shot_1.py\", line 4, in dfs\n    subordinates += 1 + dfs(employee, graph)\n  [Previous line repeated 996 more times]\nRecursionError: maximum recursion depth exceeded\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Subordinates_shot_1.py\", line 16, in <module>\n    subordinates[i] = dfs(i, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Subordinates_shot_1.py\", line 4, in dfs\n    subordinates += 1 + dfs(employee, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Subordinates_shot_1.py\", line 4, in dfs\n    subordinates += 1 + dfs(employee, graph)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/Subordinates_shot_1.py\", line 4, in dfs\n    subordinates += 1 + dfs(employee, graph)\n  [Previous line repeated 996 more times]\nRecursionError: maximum recursion depth exceeded\n"
            ],
            "failed_test_cases": [
                2,
                3,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Substring Distribution",
            "category": "String Algorithms",
            "solution": "n = len(input().strip())\ns = input().strip()\n\nsubstrings = {}\nstart = 0\n\nfor end in range(n):\n    substring = s[start:end+1]\n    substrings[substring] = substrings.get(substring, 0) + 1\n    if end - start + 1 > end + 1:\n        substrings[s[start]] -= 1\n        if substrings[s[start]] == 0:\n            del substrings[s[start]]\n        start += 1\n\nfor i in range(1, n+1):\n    print(len([k for k in substrings.keys() if len(k) == i]), end=' ')\n",
            "passed_test_cases": 0,
            "total_test_cases": 9,
            "mean_time_taken": 0.16441570387946236,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringDistribution_shot_1.py\", line 2, in <module>\n    s = input().strip()\nEOFError: EOF when reading a line\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringDistribution_shot_1.py\", line 2, in <module>\n    s = input().strip()\nEOFError: EOF when reading a line\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringDistribution_shot_1.py\", line 2, in <module>\n    s = input().strip()\nEOFError: EOF when reading a line\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringDistribution_shot_1.py\", line 2, in <module>\n    s = input().strip()\nEOFError: EOF when reading a line\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringDistribution_shot_1.py\", line 2, in <module>\n    s = input().strip()\nEOFError: EOF when reading a line\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringDistribution_shot_1.py\", line 2, in <module>\n    s = input().strip()\nEOFError: EOF when reading a line\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringDistribution_shot_1.py\", line 2, in <module>\n    s = input().strip()\nEOFError: EOF when reading a line\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringDistribution_shot_1.py\", line 2, in <module>\n    s = input().strip()\nEOFError: EOF when reading a line\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringDistribution_shot_1.py\", line 2, in <module>\n    s = input().strip()\nEOFError: EOF when reading a line\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Substring Order I",
            "category": "String Algorithms",
            "solution": "def kth_substring(s, k):\n    # Generate all distinct substrings\n    substrings = set()\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            substrings.add(s[i:j + 1])\n\n    # Sort substrings lexicographically\n    substrings = sorted(substrings)\n\n    # Return the kth substring\n    return substrings[k - 1]\n\n# Read input\ns = input().strip()\nk = int(input().strip())\n\n# Print the kth smallest distinct substring\nprint(kth_substring(s, k))\n",
            "passed_test_cases": 2,
            "total_test_cases": 9,
            "mean_time_taken": 0.3750099341074626,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 19, in <module>\n    print(kth_substring(s, k))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 6, in kth_substring\n    substrings.add(s[i:j + 1])\nMemoryError\nError in sys.excepthook:\nTraceback (most recent call last):\n  File \"/usr/lib/python3/dist-packages/apport_python_hook.py\", line 55, in apport_excepthook\n    import apt_pkg\n  File \"<frozen importlib._bootstrap>\", line 1027, in _find_and_load\n  File \"<frozen importlib._bootstrap>\", line 1002, in _find_and_load_unlocked\n  File \"<frozen importlib._bootstrap>\", line 945, in _find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1439, in find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1411, in _get_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1548, in find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1591, in _fill_cache\nOSError: [Errno 12] Cannot allocate memory: '/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp'\n\nOriginal exception was:\nTraceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 19, in <module>\n    print(kth_substring(s, k))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 6, in kth_substring\n    substrings.add(s[i:j + 1])\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 19, in <module>\n    print(kth_substring(s, k))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 6, in kth_substring\n    substrings.add(s[i:j + 1])\nMemoryError\nError in sys.excepthook:\nTraceback (most recent call last):\n  File \"/usr/lib/python3/dist-packages/apport_python_hook.py\", line 55, in apport_excepthook\n    import apt_pkg\n  File \"<frozen importlib._bootstrap>\", line 1027, in _find_and_load\n  File \"<frozen importlib._bootstrap>\", line 1002, in _find_and_load_unlocked\n  File \"<frozen importlib._bootstrap>\", line 945, in _find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1439, in find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1411, in _get_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1548, in find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1591, in _fill_cache\nOSError: [Errno 12] Cannot allocate memory: '/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp'\n\nOriginal exception was:\nTraceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 19, in <module>\n    print(kth_substring(s, k))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 6, in kth_substring\n    substrings.add(s[i:j + 1])\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 19, in <module>\n    print(kth_substring(s, k))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 6, in kth_substring\n    substrings.add(s[i:j + 1])\nMemoryError\nError in sys.excepthook:\nTraceback (most recent call last):\n  File \"/usr/lib/python3/dist-packages/apport_python_hook.py\", line 55, in apport_excepthook\n    import apt_pkg\n  File \"<frozen importlib._bootstrap>\", line 1027, in _find_and_load\n  File \"<frozen importlib._bootstrap>\", line 1002, in _find_and_load_unlocked\n  File \"<frozen importlib._bootstrap>\", line 945, in _find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1439, in find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1411, in _get_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1548, in find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1591, in _fill_cache\nOSError: [Errno 12] Cannot allocate memory: '/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp'\n\nOriginal exception was:\nTraceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 19, in <module>\n    print(kth_substring(s, k))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 6, in kth_substring\n    substrings.add(s[i:j + 1])\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 19, in <module>\n    print(kth_substring(s, k))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 6, in kth_substring\n    substrings.add(s[i:j + 1])\nMemoryError\nError in sys.excepthook:\nTraceback (most recent call last):\n  File \"/usr/lib/python3/dist-packages/apport_python_hook.py\", line 55, in apport_excepthook\n    import apt_pkg\n  File \"<frozen importlib._bootstrap>\", line 1027, in _find_and_load\n  File \"<frozen importlib._bootstrap>\", line 1002, in _find_and_load_unlocked\n  File \"<frozen importlib._bootstrap>\", line 945, in _find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1439, in find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1411, in _get_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1548, in find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1591, in _fill_cache\nOSError: [Errno 12] Cannot allocate memory: '/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp'\n\nOriginal exception was:\nTraceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 19, in <module>\n    print(kth_substring(s, k))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 6, in kth_substring\n    substrings.add(s[i:j + 1])\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 19, in <module>\n    print(kth_substring(s, k))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 6, in kth_substring\n    substrings.add(s[i:j + 1])\nMemoryError\nError in sys.excepthook:\nTraceback (most recent call last):\n  File \"/usr/lib/python3/dist-packages/apport_python_hook.py\", line 55, in apport_excepthook\n    import apt_pkg\n  File \"<frozen importlib._bootstrap>\", line 1027, in _find_and_load\n  File \"<frozen importlib._bootstrap>\", line 1002, in _find_and_load_unlocked\n  File \"<frozen importlib._bootstrap>\", line 945, in _find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1439, in find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1411, in _get_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1548, in find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1591, in _fill_cache\nOSError: [Errno 12] Cannot allocate memory: '/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp'\n\nOriginal exception was:\nTraceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 19, in <module>\n    print(kth_substring(s, k))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 6, in kth_substring\n    substrings.add(s[i:j + 1])\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 19, in <module>\n    print(kth_substring(s, k))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 6, in kth_substring\n    substrings.add(s[i:j + 1])\nMemoryError\nError in sys.excepthook:\nTraceback (most recent call last):\n  File \"/usr/lib/python3/dist-packages/apport_python_hook.py\", line 55, in apport_excepthook\n    import apt_pkg\n  File \"<frozen importlib._bootstrap>\", line 1027, in _find_and_load\n  File \"<frozen importlib._bootstrap>\", line 1002, in _find_and_load_unlocked\n  File \"<frozen importlib._bootstrap>\", line 945, in _find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1439, in find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1411, in _get_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1548, in find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1591, in _fill_cache\nOSError: [Errno 12] Cannot allocate memory: '/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp'\n\nOriginal exception was:\nTraceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 19, in <module>\n    print(kth_substring(s, k))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 6, in kth_substring\n    substrings.add(s[i:j + 1])\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 19, in <module>\n    print(kth_substring(s, k))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 6, in kth_substring\n    substrings.add(s[i:j + 1])\nMemoryError\nError in sys.excepthook:\nTraceback (most recent call last):\n  File \"/usr/lib/python3/dist-packages/apport_python_hook.py\", line 55, in apport_excepthook\n    import apt_pkg\n  File \"<frozen importlib._bootstrap>\", line 1027, in _find_and_load\n  File \"<frozen importlib._bootstrap>\", line 1002, in _find_and_load_unlocked\n  File \"<frozen importlib._bootstrap>\", line 945, in _find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1439, in find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1411, in _get_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1548, in find_spec\n  File \"<frozen importlib._bootstrap_external>\", line 1591, in _fill_cache\nOSError: [Errno 12] Cannot allocate memory: '/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp'\n\nOriginal exception was:\nTraceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 19, in <module>\n    print(kth_substring(s, k))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderI_shot_1.py\", line 6, in kth_substring\n    substrings.add(s[i:j + 1])\nMemoryError\n"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Substring Order II",
            "category": "String Algorithms",
            "solution": "class TrieNode:\n    def __init__(self):\n        self.children = [None] * 26\n        self.end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for ch in word:\n            index = ord(ch) - ord('a')\n            if not node.children[index]:\n                node.children[index] = TrieNode()\n            node = node.children[index]\n        node.end_of_word = True\n\n    def find_kth_smallest(self, k):\n        def dfs(node, prefix, k):\n            if not node:\n                return\n            if node.end_of_word:\n                k[0] -= 1\n                if k[0] == 0:\n                    return prefix\n            for i in range(26):\n                result = dfs(node.children[i], prefix + chr(i + ord('a')), k)\n                if k[0] == 0:\n                    return result\n            return None\n\n        return dfs(self.root, \"\", k)\n\ndef kth_smallest_substring(s, k):\n    trie = Trie()\n    n = len(s)\n    for i in range(n):\n        trie.insert(s[i:])\n    return trie.find_kth_smallest(k)\n\ns = input()\nk = int(input())\nprint(kth_smallest_substring(s, k))\n",
            "passed_test_cases": 0,
            "total_test_cases": 9,
            "mean_time_taken": 0.8640543354882134,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderII_shot_1.py\", line 44, in <module>\n    print(kth_smallest_substring(s, k))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderII_shot_1.py\", line 40, in kth_smallest_substring\n    return trie.find_kth_smallest(k)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderII_shot_1.py\", line 33, in find_kth_smallest\n    return dfs(self.root, \"\", k)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderII_shot_1.py\", line 28, in dfs\n    result = dfs(node.children[i], prefix + chr(i + ord('a')), k)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderII_shot_1.py\", line 28, in dfs\n    result = dfs(node.children[i], prefix + chr(i + ord('a')), k)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderII_shot_1.py\", line 29, in dfs\n    if k[0] == 0:\nTypeError: 'int' object is not subscriptable\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderII_shot_1.py\", line 44, in <module>\n    print(kth_smallest_substring(s, k))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderII_shot_1.py\", line 40, in kth_smallest_substring\n    return trie.find_kth_smallest(k)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderII_shot_1.py\", line 33, in find_kth_smallest\n    return dfs(self.root, \"\", k)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderII_shot_1.py\", line 28, in dfs\n    result = dfs(node.children[i], prefix + chr(i + ord('a')), k)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderII_shot_1.py\", line 28, in dfs\n    result = dfs(node.children[i], prefix + chr(i + ord('a')), k)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubstringOrderII_shot_1.py\", line 29, in dfs\n    if k[0] == 0:\nTypeError: 'int' object is not subscriptable\n",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Substring Reversals",
            "category": "Advanced Techniques",
            "solution": "# Read the input\nn, m = map(int, input().split())\ns = list(input())\nfor _ in range(m):\n    a, b = map(int, input().split())\n\n    # Reverse the substring\n    s[a-1:b] = s[a-1:b][::-1]\n\n# Print the result\nprint(''.join(s))\n",
            "passed_test_cases": 2,
            "total_test_cases": 4,
            "mean_time_taken": 0.5920718312263489,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subtree Queries",
            "category": "Tree Algorithms",
            "solution": "def dfs(node, parent):\n    for child in graph[node]:\n        if child != parent:\n            dfs(child, node)\n            subtree_sum[node] += subtree_sum[child]\n\ndef change_value(node, new_value):\n    subtree_sum[node] = new_value\n\ndef get_subtree_sum(node):\n    return subtree_sum[node]\n\nn, q = map(int, input().split())\nvalues = list(map(int, input().split()))\ngraph = [[] for _ in range(n + 1)]\nsubtree_sum = [0] * (n + 1)\n\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\nsubtree_sum = values.copy()\ndfs(1, 0)\n\nfor _ in range(q):\n    query_type, node, *args = map(int, input().split())\n    if query_type == 1:\n        change_value(node, args[0])\n    else:\n        print(get_subtree_sum(node))\n",
            "passed_test_cases": 0,
            "total_test_cases": 13,
            "mean_time_taken": 0.28114030911372256,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 24, in <module>\n    dfs(1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 5, in dfs\n    subtree_sum[node] += subtree_sum[child]\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 24, in <module>\n    dfs(1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 3, in dfs\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 24, in <module>\n    dfs(1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  [Previous line repeated 19 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 5, in dfs\n    subtree_sum[node] += subtree_sum[child]\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 24, in <module>\n    dfs(1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 3, in dfs\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 24, in <module>\n    dfs(1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 3, in dfs\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 24, in <module>\n    dfs(1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 3, in dfs\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 24, in <module>\n    dfs(1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  [Previous line repeated 1 more time]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 5, in dfs\n    subtree_sum[node] += subtree_sum[child]\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 24, in <module>\n    dfs(1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 3, in dfs\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 24, in <module>\n    dfs(1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 5, in dfs\n    subtree_sum[node] += subtree_sum[child]\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 24, in <module>\n    dfs(1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 3, in dfs\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 24, in <module>\n    dfs(1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 5, in dfs\n    subtree_sum[node] += subtree_sum[child]\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 24, in <module>\n    dfs(1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 5, in dfs\n    subtree_sum[node] += subtree_sum[child]\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 24, in <module>\n    dfs(1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 4, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SubtreeQueries_shot_1.py\", line 5, in dfs\n    subtree_sum[node] += subtree_sum[child]\nIndexError: list index out of range\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sum of Divisors",
            "category": "Mathematics",
            "solution": "MOD = 10**9 + 7\n\ndef sum_of_divisors(n):\n    ans = [0] * (n + 1)\n    ans[1] = 1\n    for i in range(1, int(n**0.5) + 1):\n        for j in range(i, n // i + 1):\n            ans[i * j] += i\n    for i in range(1, n + 1):\n        for j in range(i, n + 1, i):\n            ans[j] += ans[j // i]\n    return ans\n\nn = int(input())\nprint(sum(sum_of_divisors(n)) % MOD)\n",
            "passed_test_cases": 0,
            "total_test_cases": 18,
            "mean_time_taken": 0.36283371183607316,
            "mean_memory_used": 166584.66666666666,
            "failure_reasons": [
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SumofDivisors_shot_1.py\", line 15, in <module>\n    print(sum(sum_of_divisors(n)) % MOD)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SumofDivisors_shot_1.py\", line 4, in sum_of_divisors\n    ans = [0] * (n + 1)\nMemoryError\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SumofDivisors_shot_1.py\", line 15, in <module>\n    print(sum(sum_of_divisors(n)) % MOD)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SumofDivisors_shot_1.py\", line 4, in sum_of_divisors\n    ans = [0] * (n + 1)\nMemoryError\n",
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SumofDivisors_shot_1.py\", line 15, in <module>\n    print(sum(sum_of_divisors(n)) % MOD)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SumofDivisors_shot_1.py\", line 4, in sum_of_divisors\n    ans = [0] * (n + 1)\nMemoryError\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SumofDivisors_shot_1.py\", line 15, in <module>\n    print(sum(sum_of_divisors(n)) % MOD)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SumofDivisors_shot_1.py\", line 4, in sum_of_divisors\n    ans = [0] * (n + 1)\nMemoryError\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SumofDivisors_shot_1.py\", line 15, in <module>\n    print(sum(sum_of_divisors(n)) % MOD)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SumofDivisors_shot_1.py\", line 4, in sum_of_divisors\n    ans = [0] * (n + 1)\nMemoryError\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SumofDivisors_shot_1.py\", line 15, in <module>\n    print(sum(sum_of_divisors(n)) % MOD)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/SumofDivisors_shot_1.py\", line 4, in sum_of_divisors\n    ans = [0] * (n + 1)\nMemoryError\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sum of Four Values",
            "category": "Sorting and Searching",
            "solution": "def sum_of_four_values(n, x, a):\n    # Create a hash map to store the elements and their indices\n    num_map = {}\n    for i, num in enumerate(a):\n        if num not in num_map:\n            num_map[num] = [i]\n        else:\n            num_map[num].append(i)\n\n    # Iterate over all pairs of elements\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the new target sum\n            target = x - a[i] - a[j]\n\n            # Check if the new target sum exists in the hash map\n            if target in num_map:\n                # Check if the indices are distinct\n                for k in num_map[target]:\n                    if k != i and k != j:\n                        # Find the fourth index\n                        l = [p for p in num_map[target] if p != k][0]\n                        return [i + 1, j + 1, k + 1, l + 1]\n\n    # If no solution is found, return \"IMPOSSIBLE\"\n    return \"IMPOSSIBLE\"\n",
            "passed_test_cases": 0,
            "total_test_cases": 28,
            "mean_time_taken": 0.0900981000491551,
            "mean_memory_used": 2.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sum of Three Values",
            "category": "Sorting and Searching",
            "solution": "def sum_of_three_values():\n    # Read the input\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    # Create an empty dictionary\n    seen = {}\n\n    # Iterate over the array\n    for i in range(1, n):\n        # Calculate the target for the remaining two numbers\n        target = x - a[i]\n\n        # Iterate over the array again\n        for j in range(i):\n            # Check if target - a[j] is in the dictionary\n            if target - a[j] in seen:\n                # Return the indices\n                print(seen[target - a[j]], j + 1, i + 1)\n                return\n\n        # Add a[i] to the dictionary\n        seen[a[i]] = i + 1\n\n    # Print IMPOSSIBLE if no solution is found\n    print(\"IMPOSSIBLE\")\n\n# Call the function\nsum_of_three_values()\n",
            "passed_test_cases": 13,
            "total_test_cases": 27,
            "mean_time_taken": 0.33757000499301487,
            "mean_memory_used": 0.8888888888888888,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                6,
                8,
                12,
                13,
                14,
                16,
                18,
                21,
                22,
                23,
                24,
                26,
                27
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sum of Two Values",
            "category": "Sorting and Searching",
            "solution": "def sum_of_two_values():\n    # Read the input\n    n, x = map(int, input().split())\n    numbers = list(map(int, input().split()))\n\n    # Initialize an empty dictionary\n    num_dict = {}\n\n    # Iterate over the numbers\n    for i, num in enumerate(numbers):\n        # Check if the complement of the current number is in the dictionary\n        complement = x - num\n        if complement in num_dict:\n            # If it is, we have found our pair and print the indices\n            print(num_dict[complement] + 1, i + 1)\n            return\n        else:\n            # If not, add the current number and its index to the dictionary\n            num_dict[num] = i\n\n    # If no pair was found, print IMPOSSIBLE\n    print(\"IMPOSSIBLE\")\n\n# Call the function\nsum_of_two_values()\n",
            "passed_test_cases": 18,
            "total_test_cases": 27,
            "mean_time_taken": 0.17239764001634386,
            "mean_memory_used": 0.4444444444444444,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                8,
                9,
                10,
                20,
                21,
                22,
                24,
                25
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Swap Game",
            "category": "Additional Problems",
            "solution": "from collections import deque\n\ndef is_goal(state):\n    return state == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\ndef get_neighbors(state):\n    neighbors = []\n    for i in range(3):\n        for j in range(3):\n            if i > 0:\n                neighbors.append(state[:3*i + j] + [state[3*(i-1) + j], state[3*i + j]] + state[3*(i-1) + j + 1:3*i] + state[3*i + j + 1:])\n            if i < 2:\n                neighbors.append(state[:3*i + j] + [state[3*(i+1) + j], state[3*i + j]] + state[3*(i+1) + j + 1:3*(i+1)] + state[3*i + j + 1:])\n            if j > 0:\n                neighbors.append(state[:3*i + j - 1] + [state[3*i + j - 1], state[3*i + j]] + state[3*i + j + 1:])\n            if j < 2:\n                neighbors.append(state[:3*i + j] + [state[3*i + j + 1], state[3*i + j]] + state[3*i + j + 2:])\n    return neighbors\n\ndef solve(state):\n    queue = deque([(state, 0)])\n    visited = set([tuple(state)])\n    while queue:\n        state, moves = queue.popleft()\n        if is_goal(state):\n            return moves\n        for neighbor in get_neighbors(state):\n            if tuple(neighbor) not in visited:\n                visited.add(tuple(neighbor))\n                queue.append((neighbor, moves + 1))\n    return -1\n\ndef main():\n    state = []\n    for i in range(3):\n        state.extend(list(map(int, input().split())))\n    print(solve(state))\n\nif __name__ == \"__main__\":\n    main()\n",
            "passed_test_cases": 1,
            "total_test_cases": 19,
            "mean_time_taken": 0.9943573976817884,
            "mean_memory_used": 0.21052631578947367,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Swap Round Sorting",
            "category": "Additional Problems",
            "solution": "def swap_round_sorting(n, arr):\n    # Create a list to store the next index for each number\n    next_index = [0] * (n + 1)\n    for i in range(n):\n        next_index[arr[i]] = i\n\n    # Initialize the result\n    result = []\n\n    # Iterate through the numbers\n    for i in range(1, n + 1):\n        # Initialize the cycle\n        cycle = []\n\n        # Follow the cycle\n        j = i\n        while j not in cycle:\n            cycle.append(j)\n            j = next_index[j]\n\n        # If the cycle is not already sorted, add a swap round\n        if cycle != sorted(cycle):\n            result.append(len(cycle) - 1)\n            for j in range(len(cycle) - 1):\n                result.append(next_index[cycle[j]] + 1)\n                result.append(next_index[cycle[j + 1]] + 1)\n\n    return result\n\n# Read the input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Solve the problem\nresult = swap_round_sorting(n, arr)\n\n# Print the output\nprint(len(result) // 3)\nfor i in range(0, len(result), 3):\n    print(result[i])\n    for j in range(i + 1, i + result[i] + 1):\n        print(result[j - 1], result[j])\n",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.35605061848958336,
            "mean_memory_used": 0.26666666666666666,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Task Assignment",
            "category": "Advanced Techniques",
            "solution": "import sys\nfrom munkres import Munkres\n\ndef main():\n    input = sys.stdin.read()\n    data = list(map(int, input.split()))\n    n = data[0]\n    data = data[1:]\n    matrix = []\n    for i in range(n):\n        row = data[i * n: (i + 1) * n]\n        matrix.append(row)\n    m = Munkres()\n    indexes = m.compute(matrix)\n    total = 0\n    assignments = []\n    for row, col in indexes:\n        total += matrix[row][col]\n        assignments.append([row + 1, col + 1])\n    print(total)\n    for assignment in assignments:\n        print(*assignment)\n\nif __name__ == \"__main__\":\n    main()\n",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.1321112314860026,
            "mean_memory_used": 0.6666666666666666,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TaskAssignment_shot_1.py\", line 2, in <module>\n    from munkres import Munkres\nModuleNotFoundError: No module named 'munkres'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TaskAssignment_shot_1.py\", line 2, in <module>\n    from munkres import Munkres\nModuleNotFoundError: No module named 'munkres'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TaskAssignment_shot_1.py\", line 2, in <module>\n    from munkres import Munkres\nModuleNotFoundError: No module named 'munkres'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TaskAssignment_shot_1.py\", line 2, in <module>\n    from munkres import Munkres\nModuleNotFoundError: No module named 'munkres'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TaskAssignment_shot_1.py\", line 2, in <module>\n    from munkres import Munkres\nModuleNotFoundError: No module named 'munkres'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TaskAssignment_shot_1.py\", line 2, in <module>\n    from munkres import Munkres\nModuleNotFoundError: No module named 'munkres'\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tasks and Deadlines",
            "category": "Sorting and Searching",
            "solution": "def max_reward(n, tasks):\n    # Sort the tasks based on their immediate reward (deadline - duration)\n    tasks.sort(key=lambda x: x[1] - x[0], reverse=True)\n\n    total_reward = 0\n    time = 0\n\n    for duration, deadline in tasks:\n        # If the current task can still be completed within its deadline\n        if time <= deadline:\n            # Update the time\n            time += duration\n            # Add the reward for this task\n            total_reward += deadline - time\n\n    return total_reward\n\n# Read the input\nn = int(input())\ntasks = [list(map(int, input().split())) for _ in range(n)]\n\n# Print the maximum reward\nprint(max_reward(n, tasks))\n",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.21272818247477213,
            "mean_memory_used": 0.6666666666666666,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Teleporters Path",
            "category": "Graph Algorithms",
            "solution": "def read_input():\n    n, m = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    return graph, n\n\ndef is_eulerian_path_possible(graph, n):\n    visited = [0] * (n + 1)\n    odd_degree_nodes = 0\n\n    def dfs(node):\n        visited[node] = 1\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    for node in range(1, n + 1):\n        if visited[node] == 0:\n            dfs(node)\n            odd_degree_nodes += 1\n\n    return odd_degree_nodes <= 2\n\ndef find_eulerian_path(graph, n):\n    path = []\n    stack = [1]\n\n    while stack:\n        node = stack[-1]\n        if not graph[node]:\n            path.append(stack.pop())\n        else:\n            stack.append(graph[node].pop())\n\n    return path[::-1] if is_eulerian_path_possible(graph, n) else [\"IMPOSSIBLE\"]\n\ngraph, n = read_input()\nprint(*find_eulerian_path(graph, n))\n",
            "passed_test_cases": 6,
            "total_test_cases": 18,
            "mean_time_taken": 0.1900848282708062,
            "mean_memory_used": 1.3333333333333333,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                7,
                9,
                10,
                11,
                12,
                13,
                15,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Throwing Dice",
            "category": "Mathematics",
            "solution": "# Python solution for the problem\nimport sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\nMAX = 10**18 + 7\n\n# Create a list to store the results\ndp = [0] * (MAX)\n\n# Base cases\ndp[0] = 1\nfor i in range(1, 7):\n    dp[i] = 1\n\n# Loop through all the possible sums\nfor i in range(7, MAX):\n    # Loop through all the possible dice values\n    for j in range(1, min(i, 7) + 1):\n        dp[i] = (dp[i] + dp[i - j]) % MOD\n\n# Read the input\nn = int(input().strip())\n\n# Print the result\nprint(dp[n])\n",
            "passed_test_cases": 0,
            "total_test_cases": 32,
            "mean_time_taken": 0.1234489306807518,
            "mean_memory_used": 0.875,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/ThrowingDice_shot_1.py\", line 9, in <module>\n    dp = [0] * (MAX)\nMemoryError\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tower of Hanoi",
            "category": "Introductory Problems",
            "solution": "def hanoi(n, a, b, c, moves):\n    if n > 0:\n        hanoi(n - 1, a, c, b, moves)\n        moves.append((a, b))\n        hanoi(n - 1, c, b, a, moves)\n\ndef main():\n    n = int(input())\n    moves = []\n    hanoi(n, 1, 2, 3, moves)\n    print(len(moves))\n    for move in moves:\n        print(*move)\n\nif __name__ == \"__main__\":\n    main()\n",
            "passed_test_cases": 0,
            "total_test_cases": 16,
            "mean_time_taken": 0.09668345749378204,
            "mean_memory_used": 0.75,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Towers",
            "category": "Sorting and Searching",
            "solution": "import heapq\n\ndef min_towers(n, cubes):\n    towers = []\n    for cube in cubes:\n        if not towers or cube > towers[0]:\n            heapq.heappush(towers, cube)\n        else:\n            heapq.heappop(towers)\n            heapq.heappush(towers, cube)\n    return len(towers)\n\n# Read the input\nn = int(input())\ncubes = list(map(int, input().split()))\n\n# Print the output\nprint(min_towers(n, cubes))\n",
            "passed_test_cases": 3,
            "total_test_cases": 12,
            "mean_time_taken": 0.11218700806299846,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                6,
                7,
                8,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Traffic Lights",
            "category": "Sorting and Searching",
            "solution": "# Read the input\nx, n = map(int, input().split())\npositions = list(map(int, input().split()))\n\n# Sort the positions\npositions.sort()\n\n# Initialize max_length and current_end\nmax_length = x\ncurrent_end = 0\n\n# Process the traffic lights\nfor p in positions:\n    max_length = max(max_length, p - current_end)\n    current_end = p\n    print(max_length)\n",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.14655556281407675,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Trailing Zeros",
            "category": "Introductory Problems",
            "solution": "# Read the input\nn = int(input())\n\n# Initialize the count of trailing zeros\ncount = 0\n\n# Loop until n is greater than 0\nwhile n > 0:\n    # Update the count\n    count += n // 5\n    # Update n\n    n //= 5\n\n# Print the count\nprint(count)\n",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.09374284744262695,
            "mean_memory_used": 133.53846153846155,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Tree Diameter",
            "category": "Tree Algorithms",
            "solution": "def dfs(node, parent, depth, adj):\n    max_depth = depth\n    for child in adj[node]:\n        if child != parent:\n            new_depth = dfs(child, node, depth + 1, adj)\n            max_depth = max(max_depth, new_depth)\n    return max_depth\n\ndef tree_diameter(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for a, b in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    return dfs(1, -1, 0, adj) + dfs(*max((node, -1, 0) for node in range(1, n + 1) if adj[node], key=lambda x: dfs(x[0], x[1], x[2], adj)), adj)\n\nn = int(input())\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\nprint(tree_diameter(n, edges))\n",
            "passed_test_cases": 0,
            "total_test_cases": 18,
            "mean_time_taken": 0.12592040167914498,
            "mean_memory_used": 0.4444444444444444,
            "failure_reasons": [
                "  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDiameter_shot_1.py\", line 14\n    return dfs(1, -1, 0, adj) + dfs(*max((node, -1, 0) for node in range(1, n + 1) if adj[node], key=lambda x: dfs(x[0], x[1], x[2], adj)), adj)\n                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: Generator expression must be parenthesized\n",
                "  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDiameter_shot_1.py\", line 14\n    return dfs(1, -1, 0, adj) + dfs(*max((node, -1, 0) for node in range(1, n + 1) if adj[node], key=lambda x: dfs(x[0], x[1], x[2], adj)), adj)\n                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: Generator expression must be parenthesized\n",
                "  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDiameter_shot_1.py\", line 14\n    return dfs(1, -1, 0, adj) + dfs(*max((node, -1, 0) for node in range(1, n + 1) if adj[node], key=lambda x: dfs(x[0], x[1], x[2], adj)), adj)\n                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: Generator expression must be parenthesized\n",
                "  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDiameter_shot_1.py\", line 14\n    return dfs(1, -1, 0, adj) + dfs(*max((node, -1, 0) for node in range(1, n + 1) if adj[node], key=lambda x: dfs(x[0], x[1], x[2], adj)), adj)\n                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: Generator expression must be parenthesized\n",
                "  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDiameter_shot_1.py\", line 14\n    return dfs(1, -1, 0, adj) + dfs(*max((node, -1, 0) for node in range(1, n + 1) if adj[node], key=lambda x: dfs(x[0], x[1], x[2], adj)), adj)\n                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: Generator expression must be parenthesized\n",
                "  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDiameter_shot_1.py\", line 14\n    return dfs(1, -1, 0, adj) + dfs(*max((node, -1, 0) for node in range(1, n + 1) if adj[node], key=lambda x: dfs(x[0], x[1], x[2], adj)), adj)\n                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: Generator expression must be parenthesized\n",
                "  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDiameter_shot_1.py\", line 14\n    return dfs(1, -1, 0, adj) + dfs(*max((node, -1, 0) for node in range(1, n + 1) if adj[node], key=lambda x: dfs(x[0], x[1], x[2], adj)), adj)\n                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: Generator expression must be parenthesized\n",
                "  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDiameter_shot_1.py\", line 14\n    return dfs(1, -1, 0, adj) + dfs(*max((node, -1, 0) for node in range(1, n + 1) if adj[node], key=lambda x: dfs(x[0], x[1], x[2], adj)), adj)\n                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: Generator expression must be parenthesized\n",
                "  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDiameter_shot_1.py\", line 14\n    return dfs(1, -1, 0, adj) + dfs(*max((node, -1, 0) for node in range(1, n + 1) if adj[node], key=lambda x: dfs(x[0], x[1], x[2], adj)), adj)\n                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: Generator expression must be parenthesized\n",
                "  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDiameter_shot_1.py\", line 14\n    return dfs(1, -1, 0, adj) + dfs(*max((node, -1, 0) for node in range(1, n + 1) if adj[node], key=lambda x: dfs(x[0], x[1], x[2], adj)), adj)\n                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: Generator expression must be parenthesized\n",
                "  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDiameter_shot_1.py\", line 14\n    return dfs(1, -1, 0, adj) + dfs(*max((node, -1, 0) for node in range(1, n + 1) if adj[node], key=lambda x: dfs(x[0], x[1], x[2], adj)), adj)\n                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: Generator expression must be parenthesized\n",
                "  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDiameter_shot_1.py\", line 14\n    return dfs(1, -1, 0, adj) + dfs(*max((node, -1, 0) for node in range(1, n + 1) if adj[node], key=lambda x: dfs(x[0], x[1], x[2], adj)), adj)\n                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: Generator expression must be parenthesized\n",
                "  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDiameter_shot_1.py\", line 14\n    return dfs(1, -1, 0, adj) + dfs(*max((node, -1, 0) for node in range(1, n + 1) if adj[node], key=lambda x: dfs(x[0], x[1], x[2], adj)), adj)\n                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: Generator expression must be parenthesized\n",
                "  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDiameter_shot_1.py\", line 14\n    return dfs(1, -1, 0, adj) + dfs(*max((node, -1, 0) for node in range(1, n + 1) if adj[node], key=lambda x: dfs(x[0], x[1], x[2], adj)), adj)\n                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: Generator expression must be parenthesized\n",
                "  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDiameter_shot_1.py\", line 14\n    return dfs(1, -1, 0, adj) + dfs(*max((node, -1, 0) for node in range(1, n + 1) if adj[node], key=lambda x: dfs(x[0], x[1], x[2], adj)), adj)\n                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: Generator expression must be parenthesized\n",
                "  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDiameter_shot_1.py\", line 14\n    return dfs(1, -1, 0, adj) + dfs(*max((node, -1, 0) for node in range(1, n + 1) if adj[node], key=lambda x: dfs(x[0], x[1], x[2], adj)), adj)\n                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: Generator expression must be parenthesized\n",
                "  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDiameter_shot_1.py\", line 14\n    return dfs(1, -1, 0, adj) + dfs(*max((node, -1, 0) for node in range(1, n + 1) if adj[node], key=lambda x: dfs(x[0], x[1], x[2], adj)), adj)\n                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: Generator expression must be parenthesized\n",
                "  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDiameter_shot_1.py\", line 14\n    return dfs(1, -1, 0, adj) + dfs(*max((node, -1, 0) for node in range(1, n + 1) if adj[node], key=lambda x: dfs(x[0], x[1], x[2], adj)), adj)\n                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: Generator expression must be parenthesized\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Distances I",
            "category": "Tree Algorithms",
            "solution": "from collections import defaultdict\n\ndef dfs(node, parent, depth, graph, max_depth, max_node):\n    if depth > max_depth:\n        max_depth[0] = depth\n        max_node[0] = node\n    for child in graph[node]:\n        if child != parent:\n            dfs(child, node, depth + 1, graph, max_depth, max_node)\n\ndef solve(n, edges):\n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    max_depth = [0]\n    max_node = [0]\n    dfs(1, 0, 0, graph, max_depth, max_node)\n    max_depth[0] = 0\n    max_node[0] = 0\n    dfs(max_node[0], 0, 0, graph, max_depth, max_node)\n    return max_depth[0]\n\nn = int(input())\nedges = [list(map(int, input().split())) for _ in range(n - 1)]\nprint(*solve(n, edges))\n",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.2519291559855143,
            "mean_memory_used": 0.5333333333333333,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 26, in <module>\n    print(*solve(n, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 18, in solve\n    dfs(1, 0, 0, graph, max_depth, max_node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 4, in dfs\n    if depth > max_depth:\nTypeError: '>' not supported between instances of 'int' and 'list'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 26, in <module>\n    print(*solve(n, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 18, in solve\n    dfs(1, 0, 0, graph, max_depth, max_node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 4, in dfs\n    if depth > max_depth:\nTypeError: '>' not supported between instances of 'int' and 'list'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 26, in <module>\n    print(*solve(n, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 18, in solve\n    dfs(1, 0, 0, graph, max_depth, max_node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 4, in dfs\n    if depth > max_depth:\nTypeError: '>' not supported between instances of 'int' and 'list'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 26, in <module>\n    print(*solve(n, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 18, in solve\n    dfs(1, 0, 0, graph, max_depth, max_node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 4, in dfs\n    if depth > max_depth:\nTypeError: '>' not supported between instances of 'int' and 'list'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 26, in <module>\n    print(*solve(n, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 18, in solve\n    dfs(1, 0, 0, graph, max_depth, max_node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 4, in dfs\n    if depth > max_depth:\nTypeError: '>' not supported between instances of 'int' and 'list'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 26, in <module>\n    print(*solve(n, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 18, in solve\n    dfs(1, 0, 0, graph, max_depth, max_node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 4, in dfs\n    if depth > max_depth:\nTypeError: '>' not supported between instances of 'int' and 'list'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 26, in <module>\n    print(*solve(n, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 18, in solve\n    dfs(1, 0, 0, graph, max_depth, max_node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 4, in dfs\n    if depth > max_depth:\nTypeError: '>' not supported between instances of 'int' and 'list'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 26, in <module>\n    print(*solve(n, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 18, in solve\n    dfs(1, 0, 0, graph, max_depth, max_node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 4, in dfs\n    if depth > max_depth:\nTypeError: '>' not supported between instances of 'int' and 'list'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 26, in <module>\n    print(*solve(n, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 18, in solve\n    dfs(1, 0, 0, graph, max_depth, max_node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 4, in dfs\n    if depth > max_depth:\nTypeError: '>' not supported between instances of 'int' and 'list'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 26, in <module>\n    print(*solve(n, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 18, in solve\n    dfs(1, 0, 0, graph, max_depth, max_node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 4, in dfs\n    if depth > max_depth:\nTypeError: '>' not supported between instances of 'int' and 'list'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 26, in <module>\n    print(*solve(n, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 18, in solve\n    dfs(1, 0, 0, graph, max_depth, max_node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 4, in dfs\n    if depth > max_depth:\nTypeError: '>' not supported between instances of 'int' and 'list'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 26, in <module>\n    print(*solve(n, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 18, in solve\n    dfs(1, 0, 0, graph, max_depth, max_node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 4, in dfs\n    if depth > max_depth:\nTypeError: '>' not supported between instances of 'int' and 'list'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 26, in <module>\n    print(*solve(n, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 18, in solve\n    dfs(1, 0, 0, graph, max_depth, max_node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 4, in dfs\n    if depth > max_depth:\nTypeError: '>' not supported between instances of 'int' and 'list'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 26, in <module>\n    print(*solve(n, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 18, in solve\n    dfs(1, 0, 0, graph, max_depth, max_node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 4, in dfs\n    if depth > max_depth:\nTypeError: '>' not supported between instances of 'int' and 'list'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 26, in <module>\n    print(*solve(n, edges))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 18, in solve\n    dfs(1, 0, 0, graph, max_depth, max_node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesI_shot_1.py\", line 4, in dfs\n    if depth > max_depth:\nTypeError: '>' not supported between instances of 'int' and 'list'\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Distances II",
            "category": "Tree Algorithms",
            "solution": "def dfs1(node, parent):\n    size[node] = 1\n    dist_sum[node] = 0\n    for child in graph[node]:\n        if child != parent:\n            dfs1(child, node)\n            size[node] += size[child]\n            dist_sum[node] += dist_sum[child] + size[child]\n\ndef dfs2(node, parent, total_size):\n    for child in graph[node]:\n        if child != parent:\n            dfs2(child, node, total_size)\n            dist_sum[node] += dist_sum[child] + size[child]\n            dist_sum[child] += total_size - 2 * size[child]\n\nn = int(input())\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\nsize = [0] * (n + 1)\ndist_sum = [0] * (n + 1)\ndfs1(1, -1)\ndfs2(1, -1, n)\n\nprint(*dist_sum[1:])\n",
            "passed_test_cases": 1,
            "total_test_cases": 14,
            "mean_time_taken": 0.22585460117885045,
            "mean_memory_used": 532.8571428571429,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesII_shot_1.py\", line 26, in <module>\n    dfs1(1, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesII_shot_1.py\", line 6, in dfs1\n    dfs1(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesII_shot_1.py\", line 6, in dfs1\n    dfs1(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesII_shot_1.py\", line 6, in dfs1\n    dfs1(child, node)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesII_shot_1.py\", line 5, in dfs1\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesII_shot_1.py\", line 26, in <module>\n    dfs1(1, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesII_shot_1.py\", line 6, in dfs1\n    dfs1(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesII_shot_1.py\", line 6, in dfs1\n    dfs1(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesII_shot_1.py\", line 6, in dfs1\n    dfs1(child, node)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesII_shot_1.py\", line 5, in dfs1\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesII_shot_1.py\", line 26, in <module>\n    dfs1(1, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesII_shot_1.py\", line 6, in dfs1\n    dfs1(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesII_shot_1.py\", line 6, in dfs1\n    dfs1(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesII_shot_1.py\", line 6, in dfs1\n    dfs1(child, node)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesII_shot_1.py\", line 5, in dfs1\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesII_shot_1.py\", line 26, in <module>\n    dfs1(1, -1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesII_shot_1.py\", line 6, in dfs1\n    dfs1(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesII_shot_1.py\", line 6, in dfs1\n    dfs1(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesII_shot_1.py\", line 6, in dfs1\n    dfs1(child, node)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeDistancesII_shot_1.py\", line 5, in dfs1\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Isomorphism I",
            "category": "Additional Problems",
            "solution": "from collections import defaultdict\n\ndef dfs(node, parent, graph):\n    subtrees = defaultdict(list)\n    for child in graph[node]:\n        if child != parent:\n            subtrees[min(child, dfs(child, node, graph))].append(child)\n    return (node, tuple(sorted(subtrees.items())))\n\ndef is_isomorphic(n, edges1, edges2):\n    graph1 = defaultdict(list)\n    graph2 = defaultdict(list)\n    for a, b in edges1:\n        graph1[a].append(b)\n        graph1[b].append(a)\n    for a, b in edges2:\n        graph2[a].append(b)\n        graph2[b].append(a)\n    root1 = dfs(1, 0, graph1)\n    root2 = dfs(1, 0, graph2)\n    return root1 == root2\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    edges1 = [list(map(int, input().split())) for _ in range(n-1)]\n    edges2 = [list(map(int, input().split())) for _ in range(n-1)]\n    print('YES' if is_isomorphic(n, edges1, edges2) else 'NO')\n",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.25466602643330893,
            "mean_memory_used": 306.93333333333334,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 28, in <module>\n    print('YES' if is_isomorphic(n, edges1, edges2) else 'NO')\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 19, in is_isomorphic\n    root1 = dfs(1, 0, graph1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\nTypeError: '<' not supported between instances of 'tuple' and 'int'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 28, in <module>\n    print('YES' if is_isomorphic(n, edges1, edges2) else 'NO')\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 19, in is_isomorphic\n    root1 = dfs(1, 0, graph1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\nTypeError: '<' not supported between instances of 'tuple' and 'int'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 28, in <module>\n    print('YES' if is_isomorphic(n, edges1, edges2) else 'NO')\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 19, in is_isomorphic\n    root1 = dfs(1, 0, graph1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\nTypeError: '<' not supported between instances of 'tuple' and 'int'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 28, in <module>\n    print('YES' if is_isomorphic(n, edges1, edges2) else 'NO')\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 19, in is_isomorphic\n    root1 = dfs(1, 0, graph1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 4, in dfs\n    subtrees = defaultdict(list)\nRecursionError: maximum recursion depth exceeded while calling a Python object\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 28, in <module>\n    print('YES' if is_isomorphic(n, edges1, edges2) else 'NO')\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 19, in is_isomorphic\n    root1 = dfs(1, 0, graph1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  [Previous line repeated 1 more time]\nTypeError: '<' not supported between instances of 'tuple' and 'int'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 28, in <module>\n    print('YES' if is_isomorphic(n, edges1, edges2) else 'NO')\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 19, in is_isomorphic\n    root1 = dfs(1, 0, graph1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\nTypeError: '<' not supported between instances of 'tuple' and 'int'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 28, in <module>\n    print('YES' if is_isomorphic(n, edges1, edges2) else 'NO')\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 19, in is_isomorphic\n    root1 = dfs(1, 0, graph1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\nTypeError: '<' not supported between instances of 'tuple' and 'int'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 28, in <module>\n    print('YES' if is_isomorphic(n, edges1, edges2) else 'NO')\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 19, in is_isomorphic\n    root1 = dfs(1, 0, graph1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\nTypeError: '<' not supported between instances of 'tuple' and 'int'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 28, in <module>\n    print('YES' if is_isomorphic(n, edges1, edges2) else 'NO')\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 19, in is_isomorphic\n    root1 = dfs(1, 0, graph1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  [Previous line repeated 3 more times]\nTypeError: '<' not supported between instances of 'tuple' and 'int'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 28, in <module>\n    print('YES' if is_isomorphic(n, edges1, edges2) else 'NO')\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 19, in is_isomorphic\n    root1 = dfs(1, 0, graph1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\nTypeError: '<' not supported between instances of 'tuple' and 'int'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 28, in <module>\n    print('YES' if is_isomorphic(n, edges1, edges2) else 'NO')\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 19, in is_isomorphic\n    root1 = dfs(1, 0, graph1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  [Previous line repeated 2 more times]\nTypeError: '<' not supported between instances of 'tuple' and 'int'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 28, in <module>\n    print('YES' if is_isomorphic(n, edges1, edges2) else 'NO')\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 19, in is_isomorphic\n    root1 = dfs(1, 0, graph1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  [Previous line repeated 2 more times]\nTypeError: '<' not supported between instances of 'tuple' and 'int'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 28, in <module>\n    print('YES' if is_isomorphic(n, edges1, edges2) else 'NO')\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 19, in is_isomorphic\n    root1 = dfs(1, 0, graph1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  [Previous line repeated 1 more time]\nTypeError: '<' not supported between instances of 'tuple' and 'int'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 28, in <module>\n    print('YES' if is_isomorphic(n, edges1, edges2) else 'NO')\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 19, in is_isomorphic\n    root1 = dfs(1, 0, graph1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  [Previous line repeated 1 more time]\nTypeError: '<' not supported between instances of 'tuple' and 'int'\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 28, in <module>\n    print('YES' if is_isomorphic(n, edges1, edges2) else 'NO')\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 19, in is_isomorphic\n    root1 = dfs(1, 0, graph1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismI_shot_1.py\", line 7, in dfs\n    subtrees[min(child, dfs(child, node, graph))].append(child)\nTypeError: '<' not supported between instances of 'tuple' and 'int'\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Isomorphism II",
            "category": "Additional Problems",
            "solution": "from sys import stdin\nfrom collections import defaultdict\n\ndef dfs(graph, node, parent, depth, dfs_seq):\n    dfs_seq[node] = depth\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            depth += 1\n            dfs(graph, neighbor, node, depth, dfs_seq)\n            depth -= 1\n\ndef isomorphic(n, graph1, graph2):\n    for i in range(1, n+1):\n        dfs(graph1, i, -1, 0, dfs_seq1)\n        dfs(graph2, i, -1, 0, dfs_seq2)\n        if dfs_seq1 == dfs_seq2:\n            return True\n    return False\n\ndfs_seq1 = [0] * 10**5\ndfs_seq2 = [0] * 10**5\n\nt = int(stdin.readline())\nfor _ in range(t):\n    n = int(stdin.readline())\n    graph1 = defaultdict(list)\n    graph2 = defaultdict(list)\n    for _ in range(n-1):\n        u, v = map(int, stdin.readline().split())\n        graph1[u].append(v)\n        graph1[v].append(u)\n    for _ in range(n-1):\n        u, v = map(int, stdin.readline().split())\n        graph2[u].append(v)\n        graph2[v].append(u)\n    print(\"YES\" if isomorphic(n, graph1, graph2) else \"NO\")\n",
            "passed_test_cases": 1,
            "total_test_cases": 14,
            "mean_time_taken": 0.33787141527448383,
            "mean_memory_used": 0.2857142857142857,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 36, in <module>\n    print(\"YES\" if isomorphic(n, graph1, graph2) else \"NO\")\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 14, in isomorphic\n    dfs(graph1, i, -1, 0, dfs_seq1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 9, in dfs\n    dfs(graph, neighbor, node, depth, dfs_seq)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 9, in dfs\n    dfs(graph, neighbor, node, depth, dfs_seq)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 9, in dfs\n    dfs(graph, neighbor, node, depth, dfs_seq)\n  [Previous line repeated 16 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 5, in dfs\n    dfs_seq[node] = depth\nIndexError: list assignment index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 36, in <module>\n    print(\"YES\" if isomorphic(n, graph1, graph2) else \"NO\")\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 14, in isomorphic\n    dfs(graph1, i, -1, 0, dfs_seq1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 9, in dfs\n    dfs(graph, neighbor, node, depth, dfs_seq)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 9, in dfs\n    dfs(graph, neighbor, node, depth, dfs_seq)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 9, in dfs\n    dfs(graph, neighbor, node, depth, dfs_seq)\n  [Previous line repeated 994 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 7, in dfs\n    if neighbor != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 36, in <module>\n    print(\"YES\" if isomorphic(n, graph1, graph2) else \"NO\")\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 14, in isomorphic\n    dfs(graph1, i, -1, 0, dfs_seq1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 9, in dfs\n    dfs(graph, neighbor, node, depth, dfs_seq)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 9, in dfs\n    dfs(graph, neighbor, node, depth, dfs_seq)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 9, in dfs\n    dfs(graph, neighbor, node, depth, dfs_seq)\n  [Previous line repeated 14 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 5, in dfs\n    dfs_seq[node] = depth\nIndexError: list assignment index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 36, in <module>\n    print(\"YES\" if isomorphic(n, graph1, graph2) else \"NO\")\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 14, in isomorphic\n    dfs(graph1, i, -1, 0, dfs_seq1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 9, in dfs\n    dfs(graph, neighbor, node, depth, dfs_seq)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 9, in dfs\n    dfs(graph, neighbor, node, depth, dfs_seq)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 9, in dfs\n    dfs(graph, neighbor, node, depth, dfs_seq)\n  [Previous line repeated 12 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 5, in dfs\n    dfs_seq[node] = depth\nIndexError: list assignment index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 36, in <module>\n    print(\"YES\" if isomorphic(n, graph1, graph2) else \"NO\")\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 14, in isomorphic\n    dfs(graph1, i, -1, 0, dfs_seq1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 9, in dfs\n    dfs(graph, neighbor, node, depth, dfs_seq)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 9, in dfs\n    dfs(graph, neighbor, node, depth, dfs_seq)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 9, in dfs\n    dfs(graph, neighbor, node, depth, dfs_seq)\n  [Previous line repeated 21 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 5, in dfs\n    dfs_seq[node] = depth\nIndexError: list assignment index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 36, in <module>\n    print(\"YES\" if isomorphic(n, graph1, graph2) else \"NO\")\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 14, in isomorphic\n    dfs(graph1, i, -1, 0, dfs_seq1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 9, in dfs\n    dfs(graph, neighbor, node, depth, dfs_seq)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 9, in dfs\n    dfs(graph, neighbor, node, depth, dfs_seq)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 9, in dfs\n    dfs(graph, neighbor, node, depth, dfs_seq)\n  [Previous line repeated 22 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 5, in dfs\n    dfs_seq[node] = depth\nIndexError: list assignment index out of range\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 36, in <module>\n    print(\"YES\" if isomorphic(n, graph1, graph2) else \"NO\")\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 14, in isomorphic\n    dfs(graph1, i, -1, 0, dfs_seq1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 9, in dfs\n    dfs(graph, neighbor, node, depth, dfs_seq)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 9, in dfs\n    dfs(graph, neighbor, node, depth, dfs_seq)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 9, in dfs\n    dfs(graph, neighbor, node, depth, dfs_seq)\n  [Previous line repeated 18 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 5, in dfs\n    dfs_seq[node] = depth\nIndexError: list assignment index out of range\n",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 36, in <module>\n    print(\"YES\" if isomorphic(n, graph1, graph2) else \"NO\")\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 14, in isomorphic\n    dfs(graph1, i, -1, 0, dfs_seq1)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 9, in dfs\n    dfs(graph, neighbor, node, depth, dfs_seq)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 9, in dfs\n    dfs(graph, neighbor, node, depth, dfs_seq)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 9, in dfs\n    dfs(graph, neighbor, node, depth, dfs_seq)\n  [Previous line repeated 21 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeIsomorphismII_shot_1.py\", line 5, in dfs\n    dfs_seq[node] = depth\nIndexError: list assignment index out of range\n",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Matching",
            "category": "Tree Algorithms",
            "solution": "def dfs(node, parent):\n    global count\n    for child in graph[node]:\n        if child != parent:\n            dfs(child, node)\n            count += 1\n\nn = int(input())\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\ncount = 0\ndfs(1, 0)\nprint(count // 2)\n",
            "passed_test_cases": 3,
            "total_test_cases": 13,
            "mean_time_taken": 0.20080419687124398,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeMatching_shot_1.py\", line 16, in <module>\n    dfs(1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeMatching_shot_1.py\", line 5, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeMatching_shot_1.py\", line 5, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeMatching_shot_1.py\", line 5, in dfs\n    dfs(child, node)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeMatching_shot_1.py\", line 4, in dfs\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed",
                "Failed",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeMatching_shot_1.py\", line 16, in <module>\n    dfs(1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeMatching_shot_1.py\", line 5, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeMatching_shot_1.py\", line 5, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeMatching_shot_1.py\", line 5, in dfs\n    dfs(child, node)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeMatching_shot_1.py\", line 4, in dfs\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeMatching_shot_1.py\", line 16, in <module>\n    dfs(1, 0)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeMatching_shot_1.py\", line 5, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeMatching_shot_1.py\", line 5, in dfs\n    dfs(child, node)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeMatching_shot_1.py\", line 5, in dfs\n    dfs(child, node)\n  [Previous line repeated 995 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeMatching_shot_1.py\", line 4, in dfs\n    if child != parent:\nRecursionError: maximum recursion depth exceeded in comparison\n",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                10,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Traversals",
            "category": "Additional Problems",
            "solution": "def find_postorder(preorder, inorder):\n    if not preorder or not inorder:\n        return []\n\n    # The first element in the preorder traversal is the root\n    root = preorder[0]\n\n    # Find the index of the root in the inorder traversal\n    root_index = inorder.index(root)\n\n    # Split the inorder traversal into left and right subtrees\n    left_inorder = inorder[:root_index]\n    right_inorder = inorder[root_index + 1:]\n\n    # Find the corresponding preorder traversals of the left and right subtrees\n    left_preorder = preorder[1:len(left_inorder) + 1]\n    right_preorder = preorder[len(left_inorder) + 1:]\n\n    # Recursively find the postorder traversals of the left and right subtrees\n    left_postorder = find_postorder(left_preorder, left_inorder)\n    right_postorder = find_postorder(right_preorder, right_inorder)\n\n    # The postorder traversal is the concatenation of the left and right postorder traversals, followed by the root\n    return left_postorder + right_postorder + [root]\n\n# Read the input\nn = int(input())\npreorder = list(map(int, input().split()))\ninorder = list(map(int, input().split()))\n\n# Find the postorder traversal\npostorder = find_postorder(preorder, inorder)\n\n# Print the result\nprint(*postorder)\n",
            "passed_test_cases": 10,
            "total_test_cases": 12,
            "mean_time_taken": 0.21287572383880615,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeTraversals_shot_1.py\", line 32, in <module>\n    postorder = find_postorder(preorder, inorder)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeTraversals_shot_1.py\", line 20, in find_postorder\n    left_postorder = find_postorder(left_preorder, left_inorder)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeTraversals_shot_1.py\", line 20, in find_postorder\n    left_postorder = find_postorder(left_preorder, left_inorder)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeTraversals_shot_1.py\", line 20, in find_postorder\n    left_postorder = find_postorder(left_preorder, left_inorder)\n  [Previous line repeated 306 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeTraversals_shot_1.py\", line 16, in find_postorder\n    left_preorder = preorder[1:len(left_inorder) + 1]\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeTraversals_shot_1.py\", line 32, in <module>\n    postorder = find_postorder(preorder, inorder)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeTraversals_shot_1.py\", line 21, in find_postorder\n    right_postorder = find_postorder(right_preorder, right_inorder)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeTraversals_shot_1.py\", line 21, in find_postorder\n    right_postorder = find_postorder(right_preorder, right_inorder)\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeTraversals_shot_1.py\", line 21, in find_postorder\n    right_postorder = find_postorder(right_preorder, right_inorder)\n  [Previous line repeated 306 more times]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TreeTraversals_shot_1.py\", line 13, in find_postorder\n    right_inorder = inorder[root_index + 1:]\nMemoryError\n"
            ],
            "failed_test_cases": [
                2,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Two Knights",
            "category": "Introductory Problems",
            "solution": "def two_knights():\n    n = int(input())\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    moves = [(1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            for x in range(1, i + 1):\n                for y in range(1, j + 1):\n                    valid = True\n                    for dx, dy in moves:\n                        nx, ny = x + dx, y + dy\n                        if 1 <= nx <= i and 1 <= ny <= j:\n                            valid = False\n                            break\n                    if valid:\n                        dp[i][j] += 1 + dp[x - 1][j] + dp[i][y - 1] - dp[x - 1][y - 1]\n\n    for i in range(1, n + 1):\n        print(dp[i][i])\n\ntwo_knights()\n",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 0.22022191683451334,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TwoKnights_shot_1.py\", line 22, in <module>\n    two_knights()\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TwoKnights_shot_1.py\", line 3, in two_knights\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TwoKnights_shot_1.py\", line 3, in <listcomp>\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\nMemoryError\n",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Two Sets",
            "category": "Introductory Problems",
            "solution": "def two_sets(n):\n    # Calculate the total sum\n    total_sum = (n * (n + 1)) // 2\n    if total_sum % 2 != 0:\n        return \"NO\"\n    target_sum = total_sum // 2\n\n    # Initialize dp array\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n\n    # Populate dp array\n    for i in range(1, n + 1):\n        for j in range(target_sum, -1, -1):\n            if dp[j]:\n                dp[j + i] = True\n\n    # If we can't find a subset with target sum, return \"NO\"\n    if not dp[target_sum]:\n        return \"NO\"\n\n    # Otherwise, construct the sets\n    set1, set2 = [], []\n    i, j = n, target_sum\n    while i > 0 and j > 0:\n        if dp[j]:\n            i -= 1\n        elif dp[j - i]:\n            set1.append(i)\n            j -= i\n            i -= 1\n    for k in range(1, n + 1):\n        if k not in set1:\n            set2.append(k)\n\n    return \"YES\\n{}\\n{}\\n{}\".format(len(set1), *set1, len(set2), *set2)\n\n# Test the function\nn = int(input())\nprint(two_sets(n))\n",
            "passed_test_cases": 13,
            "total_test_cases": 23,
            "mean_time_taken": 0.10649682127911111,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TwoSets_shot_1.py\", line 40, in <module>\n    print(two_sets(n))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TwoSets_shot_1.py\", line 16, in two_sets\n    dp[j + i] = True\nIndexError: list assignment index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TwoSets_shot_1.py\", line 40, in <module>\n    print(two_sets(n))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TwoSets_shot_1.py\", line 16, in two_sets\n    dp[j + i] = True\nIndexError: list assignment index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TwoSets_shot_1.py\", line 40, in <module>\n    print(two_sets(n))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TwoSets_shot_1.py\", line 9, in two_sets\n    dp = [False] * (target_sum + 1)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TwoSets_shot_1.py\", line 40, in <module>\n    print(two_sets(n))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TwoSets_shot_1.py\", line 16, in two_sets\n    dp[j + i] = True\nIndexError: list assignment index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TwoSets_shot_1.py\", line 40, in <module>\n    print(two_sets(n))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TwoSets_shot_1.py\", line 16, in two_sets\n    dp[j + i] = True\nIndexError: list assignment index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TwoSets_shot_1.py\", line 40, in <module>\n    print(two_sets(n))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TwoSets_shot_1.py\", line 9, in two_sets\n    dp = [False] * (target_sum + 1)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TwoSets_shot_1.py\", line 40, in <module>\n    print(two_sets(n))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TwoSets_shot_1.py\", line 16, in two_sets\n    dp[j + i] = True\nIndexError: list assignment index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TwoSets_shot_1.py\", line 40, in <module>\n    print(two_sets(n))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TwoSets_shot_1.py\", line 16, in two_sets\n    dp[j + i] = True\nIndexError: list assignment index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TwoSets_shot_1.py\", line 40, in <module>\n    print(two_sets(n))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TwoSets_shot_1.py\", line 9, in two_sets\n    dp = [False] * (target_sum + 1)\nMemoryError\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TwoSets_shot_1.py\", line 40, in <module>\n    print(two_sets(n))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/TwoSets_shot_1.py\", line 9, in two_sets\n    dp = [False] * (target_sum + 1)\nMemoryError\n"
            ],
            "failed_test_cases": [
                2,
                7,
                9,
                13,
                14,
                16,
                17,
                18,
                21,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Two Sets II",
            "category": "Dynamic Programming",
            "solution": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\nMAX = 500\n\n# Initialize dp array\ndp = [[0 for _ in range(MAX * (MAX + 1) // 2 + 1)] for _ in range(MAX + 1)]\ndp[0][0] = 1\n\n# Calculate the number of subsets for each sum\nfor i in range(1, MAX + 1):\n    for j in range(MAX * (MAX + 1) // 2 + 1):\n        dp[i][j] = dp[i - 1][j]\n        if j >= i:\n            dp[i][j] = (dp[i][j] + dp[i - 1][j - i]) % MOD\n\n# Read input\nn = int(input().strip())\n\n# Calculate the total sum and half sum\ntotal_sum = n * (n + 1) // 2\nhalf_sum = total_sum // 2\n\n# If the total sum is odd, there are no solutions\nif total_sum % 2:\n    print(0)\n# Otherwise, print the number of subsets with half the total sum\nelse:\n    print(dp[n][half_sum])\n",
            "passed_test_cases": 0,
            "total_test_cases": 24,
            "mean_time_taken": 1.0526071190834045,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Two Stacks Sorting",
            "category": "Additional Problems",
            "solution": "def two_stacks_sorting():\n    n = int(input())\n    nums = list(map(int, input().split()))\n    stack1 = []\n    stack2 = []\n    output = []\n    next_num = 1\n    for num in nums:\n        stack1.append(num)\n        output.append(1)\n        while stack1 and stack1[-1] > next_num:\n            stack2.append(stack1.pop())\n            output.append(2)\n        while stack2 and stack2[-1] == next_num:\n            stack2.pop()\n            next_num += 1\n    if stack2 or next_num <= n:\n        print(\"IMPOSSIBLE\")\n    else:\n        print(*output)\n\ntwo_stacks_sorting()\n",
            "passed_test_cases": 5,
            "total_test_cases": 14,
            "mean_time_taken": 0.12669762543269567,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                5,
                6,
                7,
                8,
                10,
                11,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Visiting Cities",
            "category": "Additional Problems",
            "solution": "import heapq\n\ndef dijkstra(n, m, flights):\n    graph = [[] for _ in range(n + 1)]\n    for a, b, c in flights:\n        graph[a].append((b, c))\n\n    dist = [float('inf')] * (n + 1)\n    prev = [None] * (n + 1)\n    dist[1] = 0\n    queue = [(0, 1)]\n\n    while queue:\n        cur_dist, cur_node = heapq.heappop(queue)\n        if dist[cur_node] < cur_dist:\n            continue\n        for next_node, next_dist in graph[cur_node]:\n            new_dist = cur_dist + next_dist\n            if new_dist < dist[next_node]:\n                dist[next_node] = new_dist\n                prev[next_node] = cur_node\n                heapq.heappush(queue, (new_dist, next_node))\n\n    path = []\n    cur_node = n\n    while cur_node is not None:\n        path.append(cur_node)\n        cur_node = prev[cur_node]\n\n    return sorted(path)\n\nn, m = map(int, input().split())\nflights = [tuple(map(int, input().split())) for _ in range(m)]\nresult = dijkstra(n, m, flights)\nprint(len(result))\nprint(*result)\n",
            "passed_test_cases": 7,
            "total_test_cases": 13,
            "mean_time_taken": 0.2021347559415377,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                7,
                10,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Weird Algorithm",
            "category": "Introductory Problems",
            "solution": "# Read the input\nn = int(input())\n\n# Initialize a list to store the values of n\nvalues = [n]\n\n# While n is not 1\nwhile n != 1:\n    # If n is even, divide it by 2\n    # If n is odd, multiply it by 3 and add 1\n    n = n // 2 if n % 2 == 0 else n * 3 + 1\n    # Add the new value of n to the list\n    values.append(n)\n\n# Print the values\nprint(' '.join(map(str, values)))\n",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.09365545000348773,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Word Combinations",
            "category": "String Algorithms",
            "solution": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\ndef word_combinations():\n    s = input().strip()\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    words = set()\n    for _ in range(int(input())):\n        words.add(input().strip())\n    for i in range(1, n + 1):\n        for word in words:\n            if s[i - len(word):i] == word:\n                dp[i] = (dp[i] + dp[i - len(word)]) % MOD\n    return dp[n]\n\nprint(word_combinations())\n",
            "passed_test_cases": 3,
            "total_test_cases": 6,
            "mean_time_taken": 0.8673249085744222,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Writing Numbers",
            "category": "Additional Problems",
            "solution": "def last_number(n):\n    # If n is less than 10, we can only write numbers from 1 to n.\n    if n < 10:\n        return n\n\n    # Otherwise, we can write all the numbers from 1 to 9,\n    # which uses up 9 * 1 = 9 presses.\n    used_presses = 9\n    result = 9\n\n    # While we still have presses left, we add a digit to our number.\n    # This digit can be 9, and we can add it 10 ^ i times, where i is the position of the digit.\n    # This is because adding a digit in the i-th position increases our number by 10 ^ i.\n    i = 1\n    while used_presses + 9 * i * (10 ** i) <= n:\n        used_presses += 9 * i * (10 ** i)\n        result = result * 10 + 9\n        i += 1\n\n    # If we have any presses left, we add them as the last digit of our number.\n    if used_presses < n:\n        result += (n - used_presses) * (10 ** i)\n\n    return result\n\n# Read the input\nn = int(input())\n\n# Print the last number we can write\nprint(last_number(n))\n",
            "passed_test_cases": 0,
            "total_test_cases": 21,
            "mean_time_taken": 0.09110070410228911,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Xor Pyramid",
            "category": "Additional Problems",
            "solution": "def xor_pyramid(n, numbers):\n    # While there is more than one number left\n    while n > 1:\n        # Initialize new level\n        new_level = []\n        # Iterate through current level in pairs\n        for i in range(0, n, 2):\n            # Append XOR of current pair to new level\n            new_level.append(numbers[i] ^ numbers[i + 1])\n        # Update numbers and size\n        numbers = new_level\n        n = len(new_level)\n    # Return topmost number\n    return numbers[0]\n\n# Read input\nn = int(input())\nnumbers = list(map(int, input().split()))\n\n# Print output\nprint(xor_pyramid(n, numbers))\n",
            "passed_test_cases": 1,
            "total_test_cases": 8,
            "mean_time_taken": 0.1471528708934784,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/XorPyramid_shot_1.py\", line 21, in <module>\n    print(xor_pyramid(n, numbers))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/XorPyramid_shot_1.py\", line 9, in xor_pyramid\n    new_level.append(numbers[i] ^ numbers[i + 1])\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/XorPyramid_shot_1.py\", line 21, in <module>\n    print(xor_pyramid(n, numbers))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/XorPyramid_shot_1.py\", line 9, in xor_pyramid\n    new_level.append(numbers[i] ^ numbers[i + 1])\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/XorPyramid_shot_1.py\", line 21, in <module>\n    print(xor_pyramid(n, numbers))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/XorPyramid_shot_1.py\", line 9, in xor_pyramid\n    new_level.append(numbers[i] ^ numbers[i + 1])\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/XorPyramid_shot_1.py\", line 21, in <module>\n    print(xor_pyramid(n, numbers))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/XorPyramid_shot_1.py\", line 9, in xor_pyramid\n    new_level.append(numbers[i] ^ numbers[i + 1])\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/XorPyramid_shot_1.py\", line 21, in <module>\n    print(xor_pyramid(n, numbers))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/XorPyramid_shot_1.py\", line 9, in xor_pyramid\n    new_level.append(numbers[i] ^ numbers[i + 1])\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/XorPyramid_shot_1.py\", line 21, in <module>\n    print(xor_pyramid(n, numbers))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/XorPyramid_shot_1.py\", line 9, in xor_pyramid\n    new_level.append(numbers[i] ^ numbers[i + 1])\nIndexError: list index out of range\n",
                "Traceback (most recent call last):\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/XorPyramid_shot_1.py\", line 21, in <module>\n    print(xor_pyramid(n, numbers))\n  File \"/home/cherrysilicon/fun/competitive-coding-benchmark-cses-fi/temp/XorPyramid_shot_1.py\", line 9, in xor_pyramid\n    new_level.append(numbers[i] ^ numbers[i + 1])\nIndexError: list index out of range\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        }
    ],
    "total_passed_problems": 26,
    "initial_config": {
        "ignore_time_limits": false,
        "model": "mistral-large-latest",
        "provider": "mistral",
        "categories": [],
        "shots": 1
    }
}