{
    "problems": [
        {
            "title": "Acyclic Graph Edges",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nconst int MAX_NODES = 100005;\n\nstd::vector<int> graph[MAX_NODES];\nint discoveryTime[MAX_NODES], lowTime[MAX_NODES];\nint timeCounter = 0;\n\nvoid dfs(int node, int parent) {\n    discoveryTime[node] = lowTime[node] = timeCounter++;\n    for (int neighbor : graph[node]) {\n        if (neighbor == parent) continue;\n        if (discoveryTime[neighbor] == -1) {\n            dfs(neighbor, node);\n            lowTime[node] = std::min(lowTime[node], lowTime[neighbor]);\n            if (lowTime[neighbor] > discoveryTime[node]) {\n                std::cout << node << \" \" << neighbor << \"\\n\";\n            } else {\n                std::cout << neighbor << \" \" << node << \"\\n\";\n            }\n        } else {\n            lowTime[node] = std::min(lowTime[node], discoveryTime[neighbor]);\n        }\n    }\n}\n\nint main() {\n    int numNodes, numEdges;\n    std::cin >> numNodes >> numEdges;\n\n    for (int i = 0; i < numEdges; i++) {\n        int node1, node2;\n        std::cin >> node1 >> node2;\n        graph[node1].push_back(node2);\n        graph[node2].push_back(node1);\n    }\n\n    std::fill_n(discoveryTime, MAX_NODES, -1);\n    dfs(1, -1);\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 4,
            "mean_time_taken": 0.11893987655639648,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Advertisement",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <map>\n#include <algorithm>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::map<int, int> freq;\n    int maxHeight = 0;\n\n    for (int i = 0; i < n; i++) {\n        int height;\n        std::cin >> height;\n        freq[height]++;\n        maxHeight = std::max(maxHeight, height);\n    }\n\n    int maxWidth = 0;\n    for (const auto& entry : freq) {\n        maxWidth = std::max(maxWidth, entry.second);\n    }\n\n    int maxArea = maxWidth * maxHeight;\n    std::cout << maxArea << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 11,
            "mean_time_taken": 0.12867023728110574,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Another Game",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        int max_coins = 0, max_count = 0;\n        for (int i = 0; i < n; i++) {\n            int coins;\n            cin >> coins;\n            if (coins > max_coins) {\n                max_coins = coins;\n                max_count = 1;\n            } else if (coins == max_coins) {\n                max_count++;\n            }\n        }\n        if (max_count % 2 == 0) {\n            cout << \"second\" << endl;\n        } else {\n            cout << \"first\" << endl;\n        }\n    }\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 0.11214256286621094,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Apartments",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<int> applicants(n);\n    vector<int> apartments(m);\n\n    for (int i = 0; i < n; i++) {\n        cin >> applicants[i];\n    }\n\n    for (int i = 0; i < m; i++) {\n        cin >> apartments[i];\n    }\n\n    sort(applicants.begin(), applicants.end());\n    sort(apartments.begin(), apartments.end());\n\n    int i = 0, j = 0, count = 0;\n\n    while (i < n && j < m) {\n        if (abs(applicants[i] - apartments[j]) <= k) {\n            count++;\n            i++;\n            j++;\n        } else if (applicants[i] < apartments[j]) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n\n    cout << count << endl;\n\n    return 0;\n}",
            "passed_test_cases": 19,
            "total_test_cases": 19,
            "mean_time_taken": 0.1336800550159655,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 1,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Apple Division",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint n;\nvector<int> weights;\n\nint appleDivision(int index, int sum1, int sum2) {\n    if (index == n) {\n        return abs(sum1 - sum2);\n    }\n\n    int includeInFirstGroup = appleDivision(index + 1, sum1 + weights[index], sum2);\n    int includeInSecondGroup = appleDivision(index + 1, sum1, sum2 + weights[index]);\n\n    return min(includeInFirstGroup, includeInSecondGroup);\n}\n\nint main() {\n    cin >> n;\n    weights.resize(n);\n\n    for (int i = 0; i < n; i++) {\n        cin >> weights[i];\n    }\n\n    cout << appleDivision(0, 0, 0) << endl;\n\n    return 0;\n}",
            "passed_test_cases": 16,
            "total_test_cases": 18,
            "mean_time_taken": 0.08245579401652019,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 1,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Apples and Bananas",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    // Read the input\n    long long int numberOfElementsInFirstSet, numberOfElementsInSecondSet, maximumValue;\n    cin >> maximumValue >> numberOfElementsInFirstSet >> numberOfElementsInSecondSet;\n\n    vector<long long int> firstSet(numberOfElementsInFirstSet), secondSet(numberOfElementsInSecondSet);\n    vector<long long int> sumFrequency(2 * maximumValue + 1, 0);\n\n    for (long long int i = 0; i < numberOfElementsInFirstSet; i++) {\n        cin >> firstSet[i];\n    }\n\n    for (long long int i = 0; i < numberOfElementsInSecondSet; i++) {\n        cin >> secondSet[i];\n    }\n\n    // Sort the banana weights\n    sort(secondSet.begin(), secondSet.end());\n\n    // Calculate the frequency of each sum of apple and banana weights\n    for (long long int i = 0; i < numberOfElementsInFirstSet; i++) {\n        for (long long int j = 0; j < numberOfElementsInSecondSet; j++) {\n            sumFrequency[firstSet[i] + secondSet[j]]++;\n        }\n    }\n\n    // Print the frequency of each sum\n    for (long long int i = 2; i <= 2 * maximumValue; i++) {\n        cout << sumFrequency[i] << \" \";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 6,
            "mean_time_taken": 0.7170741160710653,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 1,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Area of Rectangles",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Rectangle {\n    int left, right, bottom, top;\n};\n\nstruct Edge {\n    int x, type, index;\n};\n\nbool compareEdges(Edge a, Edge b) {\n    return a.x < b.x;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<Rectangle> rectangles(n);\n    vector<Edge> edges;\n\n    for (int i = 0; i < n; i++) {\n        cin >> rectangles[i].left >> rectangles[i].bottom >> rectangles[i].right >> rectangles[i].top;\n        edges.push_back({rectangles[i].left, 0, i});\n        edges.push_back({rectangles[i].right, 1, i});\n    }\n\n    sort(edges.begin(), edges.end(), compareEdges);\n\n    set<pair<int, int>> segments;\n    long long totalArea = 0;\n    int prevX = edges[0].x;\n\n    for (Edge edge : edges) {\n        if (!segments.empty()) {\n            auto it = segments.begin();\n            int currY = it->first;\n            int nextY = it->second;\n            totalArea += (long long)(edge.x - prevX) * (nextY - currY);\n            prevX = edge.x;\n        }\n\n        if (edge.type == 0) {\n            auto it = segments.lower_bound({rectangles[edge.index].bottom, 0});\n            if (it != segments.begin() && prev(it)->second > rectangles[edge.index].bottom) {\n                auto prevIt = prev(it);\n                if (prevIt->second > rectangles[edge.index].top) {\n                    segments.insert({rectangles[edge.index].top, prevIt->second});\n                    segments.erase(prevIt);\n                } else {\n                    segments.insert({rectangles[edge.index].bottom, prevIt->second});\n                    segments.erase(prevIt);\n                    segments.insert({prevIt->first, rectangles[edge.index].top});\n                }\n            } else {\n                if (it != segments.end() && it->first < rectangles[edge.index].top) {\n                    segments.insert({it->first, rectangles[edge.index].top});\n                    segments.erase(it);\n                } else {\n                    segments.insert({rectangles[edge.index].bottom, rectangles[edge.index].top});\n                }\n            }\n        } else {\n            auto it = segments.lower_bound({rectangles[edge.index].bottom, 0});\n            if (it->first == rectangles[edge.index].bottom) {\n                if (it->second == rectangles[edge.index].top) {\n                    segments.erase(it);\n                } else {\n                    segments.insert({rectangles[edge.index].top, it->second});\n                    segments.erase(it);\n                }\n            } else {\n                auto prevIt = prev(it);\n                if (prevIt->second == rectangles[edge.index].top) {\n                    segments.erase(prevIt);\n                } else {\n                    segments.insert({prevIt->first, rectangles[edge.index].bottom});\n                    segments.erase(prevIt);\n                }\n            }\n        }\n    }\n\n    cout << totalArea << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.16395201683044433,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 1,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Array Description",
            "category": "Dynamic Programming",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 1,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Array Division",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool isPossible(vector<long long>& prefixSum, long long mid, int k) {\n    int count = 1;\n    long long currSum = 0;\n    for (int i = 0; i < prefixSum.size(); i++) {\n        if (prefixSum[i] - currSum > mid) {\n            count++;\n            currSum = prefixSum[i - 1];\n        }\n        if (count > k) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    vector<long long> arr(n);\n    vector<long long> prefixSum(n);\n    long long maxElement = 0;\n    long long sum = 0;\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n        maxElement = max(maxElement, arr[i]);\n        sum += arr[i];\n        prefixSum[i] = sum;\n    }\n    long long left = maxElement;\n    long long right = sum;\n    long long result = 0;\n    while (left <= right) {\n        long long mid = (left + right) / 2;\n        if (isPossible(prefixSum, mid, k)) {\n            result = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    cout << result << endl;\n    return 0;\n}",
            "passed_test_cases": 18,
            "total_test_cases": 18,
            "mean_time_taken": 0.11102934678395589,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Beautiful Subgrids",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<std::vector<int>> grid(n, std::vector<int>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            std::cin >> grid[i][j];\n        }\n    }\n\n    int count = 0;\n    for (int i = 1; i < n; i++) {\n        for (int j = 1; j < n; j++) {\n            if (grid[i][j] && grid[i - 1][j] && grid[i][j - 1] && grid[i - 1][j - 1]) {\n                count++;\n            }\n        }\n    }\n\n    std::cout << count << std::endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.15713056921958923,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Binary Subsequences",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::string binary_string = \"\";\n\n    while (n > 0) {\n        binary_string = std::to_string(n % 2) + binary_string;\n        n = n >> 1;\n    }\n\n    std::cout << binary_string << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 12,
            "mean_time_taken": 0.08166007200876872,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Binomial Coefficients",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 1000005;\nconst int MOD = 1000000007;\n\nlong long fact[MAXN], inv[MAXN];\n\nlong long power(long long a, long long b) {\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1) res = (res * a) % MOD;\n        a = (a * a) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nvoid precompute() {\n    fact[0] = 1;\n    for (int i = 1; i < MAXN; i++) {\n        fact[i] = (fact[i - 1] * i) % MOD;\n    }\n    inv[MAXN - 1] = power(fact[MAXN - 1], MOD - 2);\n    for (int i = MAXN - 2; i >= 0; i--) {\n        inv[i] = (inv[i + 1] * (i + 1)) % MOD;\n    }\n}\n\nlong long binomial_coefficient(int n, int k) {\n    if (k > n) return 0;\n    return (fact[n] * inv[k] * inv[n - k]) % MOD;\n}\n\nint main() {\n    precompute();\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        cout << binomial_coefficient(n, k) << endl;\n    }\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 11,
            "mean_time_taken": 0.12882410396229138,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bit Inversions",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    string bitString;\n    int m, x;\n    cin >> bitString >> m;\n\n    int n = bitString.length();\n    int left[n], right[n];\n    int max_left = 0, max_right = 0;\n    int max_length = 1;\n\n    // Initialize left array\n    left[0] = 1;\n    for (int i = 1; i < n; i++) {\n        if (bitString[i] == bitString[i - 1]) {\n            left[i] = left[i - 1] + 1;\n            max_left = max(max_left, left[i]);\n        } else {\n            left[i] = 1;\n        }\n    }\n\n    // Initialize right array\n    right[n - 1] = 1;\n    for (int i = n - 2; i >= 0; i--) {\n        if (bitString[i] == bitString[i + 1]) {\n            right[i] = right[i + 1] + 1;\n            max_right = max(max_right, right[i]);\n        } else {\n            right[i] = 1;\n        }\n    }\n\n    // Update max_length after each change\n    for (int i = 0; i < m; i++) {\n        cin >> x;\n        x--; // Adjust index to 0-based\n\n        // Flip the bit\n        bitString[x] = (bitString[x] == '0') ? '1' : '0';\n\n        // Update max_length\n        if (x > 0 && x < n - 1) {\n            if (bitString[x - 1] == bitString[x + 1]) {\n                max_length = max(max_length, left[x - 1] + right[x + 1] + 1);\n            } else {\n                max_length = max(max_left, max_right);\n            }\n        } else if (x == 0) {\n            max_length = max(max_length, right[x + 1]);\n        } else {\n            max_length = max(max_length, left[x - 1]);\n        }\n\n        cout << max_length << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.1499757170677185,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bit Problem",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nconst int MAX_N = 1000005;\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> numbers(n);\n    std::vector<int> count_divisible(MAX_N, 0);\n    std::vector<int> count_and(MAX_N, 0);\n    std::vector<int> count_non_zero_and(MAX_N, 0);\n\n    // Read the input numbers and count the number of occurrences of each\n    for (int i = 0; i < n; i++) {\n        std::cin >> numbers[i];\n        count_divisible[numbers[i]]++;\n    }\n\n    // For each number, count the number of elements that are divisible by it and have a bitwise AND equal to it\n    for (int i = 1; i < MAX_N; i++) {\n        for (int j = i; j < MAX_N; j += i) {\n            count_and[j] += count_divisible[i];\n        }\n    }\n\n    // For each number, count the number of elements that have a non-zero bitwise AND with it\n    for (int i = 1; i < MAX_N; i++) {\n        for (int j = 1; i + j < MAX_N; j <<= 1) {\n            if (i & j) {\n                count_non_zero_and[i] += count_divisible[j];\n                count_non_zero_and[i + j] += count_divisible[j];\n            }\n        }\n    }\n\n    // Print the results for each number\n    for (int i = 0; i < n; i++) {\n        std::cout << count_divisible[numbers[i]] << \" \" << count_and[numbers[i]] << \" \" << count_non_zero_and[numbers[i]] << \"\\n\";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.25310516357421875,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bit Strings",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n;\n    cin >> n;\n\n    long long result = 1;\n    for (int i = 0; i < n; i++) {\n        result = (result * 2) % MOD;\n    }\n\n    cout << result << endl;\n    return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.08188547690709432,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Bit Substrings",
            "category": "Additional Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Book Shop",
            "category": "Dynamic Programming",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Book Shop II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_BOOKS = 101;\nconst int MAX_PRICE = 100001;\n\nint dp[MAX_BOOKS][MAX_PRICE]; // Dynamic programming array to store the maximum number of pages that can be bought with a given price\nint prices[MAX_BOOKS]; // Array to store the price of each book\nint pages[MAX_BOOKS]; // Array to store the number of pages of each book\nint copies[MAX_BOOKS]; // Array to store the number of copies of each book\n\nint main() {\n    int num_books, max_price;\n    cin >> num_books >> max_price;\n\n    for (int i = 1; i <= num_books; i++) {\n        cin >> prices[i];\n    }\n\n    for (int i = 1; i <= num_books; i++) {\n        cin >> pages[i];\n    }\n\n    for (int i = 1; i <= num_books; i++) {\n        cin >> copies[i];\n    }\n\n    for (int i = 1; i <= num_books; i++) {\n        for (int j = 1; j <= max_price; j++) {\n            dp[i][j] = dp[i - 1][j]; // Initialize the current cell with the value of the previous cell\n\n            for (int k = 1; k <= copies[i]; k++) {\n                if (k * prices[i] > j) {\n                    break; // If the price of k copies of the current book is greater than the current price limit, break the loop\n                }\n\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - k * prices[i]] + k * pages[i]); // Update the current cell with the maximum value obtained by either taking the previous cell or taking k copies of the current book\n            }\n        }\n    }\n\n    cout << dp[num_books][max_price] << endl; // Print the maximum number of pages that can be bought within the given price limit\n\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 10,
            "mean_time_taken": 0.5661855936050415,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bracket Sequences I",
            "category": "Mathematics",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Bracket Sequences II",
            "category": "Mathematics",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Building Roads",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N = 100005;\n\nint parent[MAX_N];\nint rank[MAX_N];\n\nvoid make_set(int v) {\n    parent[v] = v;\n    rank[v] = 0;\n}\n\nint find_set(int v) {\n    if (v == parent[v])\n        return v;\n    return parent[v] = find_set(parent[v]);\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b) {\n        if (rank[a] < rank[b])\n            swap(a, b);\n        parent[b] = a;\n        if (rank[a] == rank[b])\n            rank[a]++;\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 1; i <= n; i++)\n        make_set(i);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        union_sets(a, b);\n    }\n\n    int connected_components = 0;\n    vector<pair<int, int>> new_roads;\n\n    for (int i = 1; i <= n; i++) {\n        if (parent[i] == i)\n            connected_components++;\n        else if (i < parent[i])\n            new_roads.push_back(make_pair(i, parent[i]));\n    }\n\n    cout << connected_components - 1 << endl;\n\n    for (auto road : new_roads)\n        cout << road.first << \" \" << road.second << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Building Teams",
            "category": "Graph Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Candy Lottery",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n\nint main() {\n    int n, k;\n    std::cin >> n >> k;\n\n    double probability = std::pow(1.0 / k, n);\n    double expectedValue = k * n * probability;\n\n    std::cout << std::fixed << std::setprecision(6) << expectedValue << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 14,
            "mean_time_taken": 0.08057567051478795,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Chess Tournament",
            "category": "Additional Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Chessboard and Queens",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 8;\nvector<vector<bool>> board(N, vector<bool>(N));\nvector<bool> col(N, false);\nvector<bool> diag1(2 * N - 1, false);\nvector<bool> diag2(2 * N - 1, false);\nint count = 0;\n\nbool is_safe(int row, int col) {\n    return !diag1[row + col] && !diag2[row - col + N - 1];\n}\n\nvoid place_queens(int row) {\n    if (row == N) {\n        count++;\n        return;\n    }\n    for (int i = 0; i < N; i++) {\n        if (board[row][i] && !col[i] && is_safe(row, i)) {\n            col[i] = true;\n            diag1[row + i] = true;\n            diag2[row - i + N - 1] = true;\n            place_queens(row + 1);\n            col[i] = false;\n            diag1[row + i] = false;\n            diag2[row - i + N - 1] = false;\n        }\n    }\n}\n\nint main() {\n    char c;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> c;\n            board[i][j] = (c == '.');\n        }\n    }\n    place_queens(0);\n    cout << count << endl;\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.08233761787414551,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Christmas Party",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\n// Function to calculate factorial of a number\nlong long factorial(int n) {\n    long long result = 1;\n    for (int i = 2; i <= n; i++) {\n        result = (result * i) % MOD;\n    }\n    return result;\n}\n\n// Function to calculate the number of ways to distribute gifts\nlong long distributeGifts(int n) {\n    // Base case: if there's only one child, there's no way to distribute gifts\n    if (n == 1) {\n        return 0;\n    }\n    // Calculate the number of ways to arrange gifts for the first n-1 children\n    long long waysToArrangeFirstNMinus1 = factorial(n - 1);\n    // Calculate the number of ways to arrange the last gift\n    long long waysToArrangeLastGift = n - 1;\n    // Return the product of the two values, modulo 10^9+7\n    return (waysToArrangeFirstNMinus1 * waysToArrangeLastGift) % MOD;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    cout << distributeGifts(n) << endl;\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 15,
            "mean_time_taken": 0.08188289006551107,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coding Company",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdint>\n\nconst int MAX_SIZE = 105;\nconst int MOD = 1000000007;\n\nint main() {\n    int num_elements, max_diff;\n    std::cin >> num_elements >> max_diff;\n\n    std::vector<int> elements(num_elements);\n    for (int i = 0; i < num_elements; i++) {\n        std::cin >> elements[i];\n    }\n\n    std::sort(elements.begin(), elements.end());\n\n    std::vector<std::vector<std::vector<int64_t>>> dp(MAX_SIZE, std::vector<std::vector<int64_t>>(MAX_SIZE, std::vector<int64_t>(MAX_SIZE, 0)));\n    dp[0][0][0] = 1;\n\n    for (int i = 0; i < num_elements; i++) {\n        for (int j = 0; j <= i; j++) {\n            for (int k = 0; k <= max_diff; k++) {\n                dp[i + 1][j][k] = (dp[i + 1][j][k] + dp[i][j][k]) % MOD;\n                if (j < i) {\n                    dp[i + 1][j + 1][k + elements[i] - elements[j]] = (dp[i + 1][j + 1][k + elements[i] - elements[j]] + dp[i][j][k]) % MOD;\n                }\n            }\n        }\n    }\n\n    int64_t result = 0;\n    for (int i = 1; i <= num_elements; i++) {\n        for (int j = 0; j <= max_diff; j++) {\n            result = (result + dp[num_elements][i][j]) % MOD;\n        }\n    }\n\n    std::cout << result << std::endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.1435384750366211,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Arrangement",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<vector<int>> grid(2, vector<int>(n));\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    int moves = 0;\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] > 1) {\n                int extraCoins = grid[i][j] - 1;\n                moves += extraCoins;\n                grid[i][j] = 1;\n\n                if (j < n - 1) {\n                    grid[i][j + 1] += extraCoins;\n                } else {\n                    grid[1 - i][j] += extraCoins;\n                }\n            }\n        }\n    }\n\n    cout << moves << endl;\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 10,
            "mean_time_taken": 0.0935084342956543,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Collector",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_NODES = 100005;\nvector<int> graph[MAX_NODES];\nlong long dp1[MAX_NODES], dp2[MAX_NODES], coins[MAX_NODES];\n\nvoid dfs(int node, int parent) {\n    dp1[node] = 0;\n    dp2[node] = coins[node];\n    for (int child : graph[node]) {\n        if (child == parent) continue;\n        dfs(child, node);\n        dp1[node] = max(dp1[node], max(dp1[child], dp2[child]));\n        dp2[node] = max(dp2[node], dp1[child] + coins[node]);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) {\n        cin >> coins[i];\n    }\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n    }\n    dfs(1, 0);\n    cout << max(dp1[1], dp2[1]) << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 14,
            "mean_time_taken": 0.13044580391475133,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Combinations I",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n\nconst int MOD = 1000000007;\n\nint main() {\n    int n, x;\n    std::cin >> n >> x;\n\n    std::vector<int> coins(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> coins[i];\n    }\n\n    std::vector<int> dp(x + 1, 0);\n    dp[0] = 1;\n\n    for (int c : coins) {\n        for (int i = c; i <= x; i++) {\n            dp[i] = (dp[i] + dp[i - c]) % MOD;\n        }\n    }\n\n    std::cout << dp[x] << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 13,
            "mean_time_taken": 0.18853114201472357,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                4,
                6,
                7,
                8,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Combinations II",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> coins(n);\n    for (int i = 0; i < n; i++) {\n        cin >> coins[i];\n    }\n\n    vector<int> dp(x + 1, 0);\n    dp[0] = 1;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = coins[i]; j <= x; j++) {\n            dp[j] = (dp[j] + dp[j - coins[i]]) % MOD;\n        }\n    }\n\n    cout << dp[x] << endl;\n\n    return 0;\n}",
            "passed_test_cases": 15,
            "total_test_cases": 15,
            "mean_time_taken": 0.31317392985026044,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 5,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Coin Grid",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <utility>\n\nconst int MAX_SIZE = 105;\nchar grid[MAX_SIZE][MAX_SIZE];\n\nint main() {\n    int size;\n    std::cin >> size;\n\n    for (int i = 0; i < size; i++) {\n        for (int j = 0; j < size; j++) {\n            std::cin >> grid[i][j];\n        }\n    }\n\n    std::vector<std::pair<int, int>> moves;\n\n    for (int i = 0; i < size; i++) {\n        for (int j = 0; j < size; j++) {\n            if (grid[i][j] == 'o') {\n                moves.push_back(std::make_pair(1, i + 1));\n                moves.push_back(std::make_pair(2, j + 1));\n\n                for (int k = 0; k < size; k++) {\n                    grid[i][k] = '.';\n                    grid[k][j] = '.';\n                }\n            }\n        }\n    }\n\n    std::cout << moves.size() << std::endl;\n\n    for (const auto& move : moves) {\n        std::cout << move.first << \" \" << move.second << std::endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 10,
            "mean_time_taken": 0.08296544551849365,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 5,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Piles",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int a, b;\n        cin >> a >> b;\n        if (a == 0 && b == 0) {\n            cout << \"YES\" << endl;\n        } else if (a == 0 || b == 0) {\n            cout << \"NO\" << endl;\n        } else if ((a + b) % 3 != 0) {\n            cout << \"NO\" << endl;\n        } else if (a <= 2 * b && b <= 2 * a) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 3,
            "mean_time_taken": 0.1354200839996338,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Collecting Numbers",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, count = 0, rounds = 0;\n    cin >> n;\n    int arr[n];\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    for (int i = 0; i < n; i++) {\n        if (arr[i] == i + 1) {\n            count++;\n        }\n        if (count == i + 1) {\n            rounds++;\n            count = 0;\n        }\n    }\n    cout << rounds << endl;\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 4,
            "mean_time_taken": 0.10707759857177734,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Collecting Numbers II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> arr(n), pos(n), right(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n        arr[i]--;\n        pos[arr[i]] = i;\n        right[i] = i;\n    }\n\n    for (int i = 1; i < n; i++) {\n        right[i] = max(right[i], right[i - 1]);\n        if (pos[i - 1] > pos[i]) {\n            right[i] = max(right[i], pos[i - 1]);\n        }\n    }\n\n    int rounds = 1;\n    for (int i = 0; i < n - 1; i++) {\n        if (right[i] == i) {\n            rounds++;\n        }\n    }\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        swap(arr[a], arr[b]);\n        swap(pos[arr[a]], pos[arr[b]]);\n        right[0] = pos[0];\n        for (int j = 1; j < n; j++) {\n            right[j] = max(right[j - 1], pos[j]);\n        }\n        rounds = 1;\n        for (int j = 0; j < n - 1; j++) {\n            if (right[j] == j) {\n                rounds++;\n            }\n        }\n        cout << rounds << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.641187310218811,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Common Divisors",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    // Create a frequency array to store the frequency of each element in the input array\n    vector<int> freq(1000001, 0);\n\n    // Read the elements of the array from the input and update their frequency in the frequency array\n    for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        freq[x]++;\n    }\n\n    // Iterate through the frequency array from the maximum possible element (10^6) to 1\n    for (int i = 1000000; i >= 1; i--) {\n        // Check if the frequency of the current element is greater than 1\n        if (freq[i] > 1) {\n            // If it is, then that element is a common divisor for at least two numbers in the array, and it is the maximum possible GCD\n            cout << i << endl;\n            return 0;\n        }\n    }\n\n    // If no common divisor is found, then the maximum possible GCD is 1\n    cout << 1 << endl;\n    return 0;\n}",
            "passed_test_cases": 8,
            "total_test_cases": 17,
            "mean_time_taken": 0.09824888846453499,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                9,
                10,
                11,
                12,
                13,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Company Queries I",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nconst int MAX_LOG = 20;\n\nint n, q;\nvector<int> adj[MAX_N];\nint depth[MAX_N];\nint parent[MAX_N][MAX_LOG];\n\nvoid dfs(int u, int p, int d) {\n    depth[u] = d;\n    parent[u][0] = p;\n    for (int i = 1; i < MAX_LOG; i++) {\n        parent[u][i] = parent[parent[u][i - 1]][i - 1];\n    }\n    for (int v : adj[u]) {\n        if (v != p) {\n            dfs(v, u, d + 1);\n        }\n    }\n}\n\nint query(int x, int k) {\n    for (int i = MAX_LOG - 1; i >= 0; i--) {\n        if (k & (1 << i)) {\n            x = parent[x][i];\n        }\n    }\n    return x;\n}\n\nint main() {\n    cin >> n >> q;\n    for (int i = 2; i <= n; i++) {\n        int p;\n        cin >> p;\n        adj[i].push_back(p);\n        adj[p].push_back(i);\n    }\n    dfs(1, 0, 0);\n    for (int i = 0; i < q; i++) {\n        int x, k;\n        cin >> x >> k;\n        if (depth[x] < k) {\n            cout << -1 << endl;\n        } else {\n            cout << query(x, k) << endl;\n        }\n    }\n    return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 13,
            "mean_time_taken": 0.18689645253694975,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Company Queries II",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nconst int MAX_LOG = 20;\n\nint n, q;\nvector<int> adj[MAX_N];\nint depth[MAX_N];\nint ancestor[MAX_N][MAX_LOG];\n\nvoid dfs(int node, int parent) {\n    depth[node] = depth[parent] + 1;\n    ancestor[node][0] = parent;\n    for (int i = 1; i < MAX_LOG; i++) {\n        ancestor[node][i] = ancestor[ancestor[node][i - 1]][i - 1];\n    }\n    for (int child : adj[node]) {\n        if (child != parent) {\n            dfs(child, node);\n        }\n    }\n}\n\nint lca(int u, int v) {\n    if (depth[u] < depth[v]) {\n        swap(u, v);\n    }\n    int diff = depth[u] - depth[v];\n    for (int i = 0; i < MAX_LOG; i++) {\n        if ((diff >> i) & 1) {\n            u = ancestor[u][i];\n        }\n    }\n    if (u == v) {\n        return u;\n    }\n    for (int i = MAX_LOG - 1; i >= 0; i--) {\n        if (ancestor[u][i] != ancestor[v][i]) {\n            u = ancestor[u][i];\n            v = ancestor[v][i];\n        }\n    }\n    return ancestor[u][0];\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n >> q;\n    for (int i = 2; i <= n; i++) {\n        int parent;\n        cin >> parent;\n        adj[parent].push_back(i);\n        adj[i].push_back(parent);\n    }\n    dfs(1, 0);\n    while (q--) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca(u, v) << endl;\n    }\n    return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 12,
            "mean_time_taken": 0.17004368702570596,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                ""
            ],
            "failed_test_cases": [
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Concert Tickets",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> tickets(n);\n    for (int i = 0; i < n; i++) {\n        cin >> tickets[i];\n    }\n\n    sort(tickets.begin(), tickets.end());\n\n    for (int i = 0; i < m; i++) {\n        int maxPrice;\n        cin >> maxPrice;\n\n        auto it = upper_bound(tickets.begin(), tickets.end(), maxPrice);\n\n        if (it == tickets.begin()) {\n            cout << -1 << endl;\n        } else {\n            cout << *(--it) << endl;\n            tickets.erase(it);\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.3455945578488437,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Convex Hull",
            "category": "Geometry",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Point {\n    int x, y;\n};\n\nint crossProduct(Point o, Point a, Point b) {\n    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);\n}\n\nbool comparePoints(Point a, Point b) {\n    if (a.y != b.y) return a.y < b.y;\n    return a.x < b.x;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> points(n);\n    for (int i = 0; i < n; i++) {\n        cin >> points[i].x >> points[i].y;\n    }\n    sort(points.begin(), points.end(), comparePoints);\n    vector<Point> hull;\n    for (int i = 0; i < n; i++) {\n        while (hull.size() >= 2 && crossProduct(hull[hull.size() - 2], hull.back(), points[i]) <= 0) {\n            hull.pop_back();\n        }\n        hull.push_back(points[i]);\n    }\n    for (int i = n - 2, t = hull.size() + 1; i >= 0; i--) {\n        while (hull.size() >= t && crossProduct(hull[hull.size() - 2], hull.back(), points[i]) <= 0) {\n            hull.pop_back();\n        }\n        hull.push_back(points[i]);\n    }\n    hull.pop_back();\n    cout << hull.size() << endl;\n    for (Point p : hull) {\n        cout << p.x << \" \" << p.y << endl;\n    }\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 9,
            "mean_time_taken": 0.13380413585238987,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Bishops",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int MAX_N = 505;\n\nlong long dp[MAX_N][MAX_N][MAX_N];\n\nlong long power(long long base, long long exponent) {\n    long long result = 1;\n    while (exponent > 0) {\n        if (exponent % 2 == 1) {\n            result = (result * base) % MOD;\n        }\n        base = (base * base) % MOD;\n        exponent /= 2;\n    }\n    return result;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    dp[0][0][0] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= i; j++) {\n            for (int k = 0; k <= i; k++) {\n                dp[i][j][k] = (dp[i-1][j-1][k-1] + dp[i-1][j][k-1] + dp[i-1][j-1][k] + dp[i-1][j][k]) % MOD;\n            }\n        }\n    }\n\n    long long result = 0;\n    for (int i = 0; i <= k; i++) {\n        for (int j = 0; j <= i; j++) {\n            result = (result + dp[n][i][j] * dp[n][k-i][j] % MOD * power(2, n-j) % MOD) % MOD;\n        }\n    }\n\n    cout << result << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 13,
            "mean_time_taken": 0.08071303367614746,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Bits",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nlong long countBits(long long num, int bit, long long count) {\n    if (num == 0) return count;\n    long long currentBit = num & (1LL << bit);\n    if (currentBit != 0) count += (1LL << bit);\n    return countBits(num, bit + 1, count);\n}\n\nint main() {\n    long long n;\n    cin >> n;\n    long long result = 0;\n    result = countBits(n, 0, result);\n    cout << result << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 21,
            "mean_time_taken": 0.13318076587858654,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Coprime Pairs",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nconst int MAX_SIZE = 1000005;\n\nint main() {\n    int numberOfElements;\n    std::cin >> numberOfElements;\n\n    std::vector<int> elements(numberOfElements);\n    std::vector<int> count(MAX_SIZE, 0);\n\n    for (int i = 0; i < numberOfElements; i++) {\n        std::cin >> elements[i];\n        count[elements[i]]++;\n    }\n\n    long long result = 0;\n    for (int i = 1; i < MAX_SIZE; i++) {\n        result += static_cast<long long>(count[i]) * (count[i] - 1) / 2;\n    }\n\n    std::cout << result << std::endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.09919217228889465,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Divisors",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nconst int MAX_VALUE = 1000000;\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> divisor_count(MAX_VALUE + 1, 0);\n\n    for (int i = 1; i <= MAX_VALUE; i++) {\n        for (int j = i; j <= MAX_VALUE; j += i) {\n            divisor_count[j]++;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        int x;\n        std::cin >> x;\n        std::cout << divisor_count[x] << std::endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 16,
            "mean_time_taken": 0.14601077139377594,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                4,
                7,
                13,
                14,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Grids",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<vector<int>> f(n + 1, vector<int>(n + 1));\n    f[1][1] = 1;\n    for (int i = 1; i <= n; i++) {\n        f[i][0] = f[i][i] = 1;\n    }\n\n    for (int i = 2; i <= n; i++) {\n        for (int j = 1; j <= i; j++) {\n            f[i][j] = (f[i - 1][j] + 1LL * f[i - 1][j - 1] * (i - j) % MOD) % MOD;\n        }\n    }\n\n    int ans = 0;\n    for (int i = 0; i <= n; i++) {\n        ans = (ans + f[n][i]) % MOD;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 12,
            "mean_time_taken": 0.11435387531916301,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Necklaces",
            "category": "Mathematics",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Counting Numbers",
            "category": "Dynamic Programming",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Counting Paths",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nvector<int> adj[MAX_N];\nint n, m, cnt[MAX_N];\n\nvoid dfs(int u, int p) {\n    for (int v : adj[u]) {\n        if (v != p) {\n            dfs(v, u);\n        }\n    }\n}\n\nint lca(int u, int v) {\n    static bool vis[MAX_N];\n    while (true) {\n        if (u) {\n            if (vis[u]) return u;\n            vis[u] = true;\n            u = adj[u][0];\n        }\n        if (v) {\n            if (vis[v]) return v;\n            vis[v] = true;\n            v = adj[v][0];\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n >> m;\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    dfs(1, 0);\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        int x = lca(u, v);\n        cnt[u]++;\n        cnt[v]++;\n        cnt[x]--;\n        cnt[adj[x][0]]--;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        cout << cnt[i] << \" \";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 13,
            "mean_time_taken": 0.14939394363990197,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Patterns",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstruct TrieNode {\n    TrieNode* children[26];\n    bool isEndOfWord;\n    int count;\n\n    TrieNode() {\n        for (int i = 0; i < 26; i++)\n            children[i] = nullptr;\n        isEndOfWord = false;\n        count = 0;\n    }\n};\n\nvoid insert(TrieNode* root, string key) {\n    TrieNode* node = root;\n    for (int i = 0; i < key.length(); i++) {\n        int index = key[i] - 'a';\n        if (!node->children[index])\n            node->children[index] = new TrieNode();\n        node = node->children[index];\n    }\n    node->isEndOfWord = true;\n}\n\nvoid search(TrieNode* root, string text) {\n    TrieNode* node = root;\n    for (int i = 0; i < text.length(); i++) {\n        int index = text[i] - 'a';\n        if (!node->children[index])\n            return;\n        node = node->children[index];\n        if (node->isEndOfWord)\n            node->count++;\n    }\n}\n\nint main() {\n    string text;\n    cin >> text;\n\n    int k;\n    cin >> k;\n\n    TrieNode* root = new TrieNode();\n    vector<string> patterns(k);\n\n    for (int i = 0; i < k; i++) {\n        cin >> patterns[i];\n        insert(root, patterns[i]);\n    }\n\n    search(root, text);\n\n    for (int i = 0; i < k; i++) {\n        TrieNode* node = root;\n        for (int j = 0; j < patterns[i].length(); j++) {\n            int index = patterns[i][j] - 'a';\n            node = node->children[index];\n        }\n        cout << node->count << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 11,
            "mean_time_taken": 0.13663627884604715,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Reorders",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N = 5005;\nconst int MAX_CHAR = 26;\nconst long long MOD = 1e9 + 7;\n\nint main() {\n    string inputString;\n    cin >> inputString;\n\n    int length = inputString.size();\n    vector<vector<long long>> dp(MAX_N, vector<long long>(MAX_CHAR));\n    vector<long long> count(MAX_CHAR);\n\n    // Step 3: Initialize count array\n    for (int i = 0; i < length; i++) {\n        count[inputString[i] - 'a']++;\n    }\n\n    // Step 5: Initialize dp array\n    for (int j = 0; j < MAX_CHAR; j++) {\n        dp[0][j] = 1;\n    }\n\n    // Step 6: Calculate dp array using dynamic programming\n    for (int i = 1; i < length; i++) {\n        for (int j = 0; j < MAX_CHAR; j++) {\n            for (int k = 0; k < MAX_CHAR; k++) {\n                dp[i][j] = (dp[i][j] + (dp[i - 1][k] * (count[j] - (k == j))) % MOD) % MOD;\n            }\n        }\n    }\n\n    // Step 7: Calculate result\n    long long result = 0;\n    for (int j = 0; j < MAX_CHAR; j++) {\n        result = (result + dp[length - 1][j]) % MOD;\n    }\n\n    // Step 8: Print result\n    cout << result << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 9,
            "mean_time_taken": 0.10155698988172743,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Rooms",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_SIZE = 1000;\nchar grid[MAX_SIZE][MAX_SIZE];\nbool visited[MAX_SIZE][MAX_SIZE];\nint row_direction[] = {-1, 0, 1, 0};\nint col_direction[] = {0, 1, 0, -1};\nint num_rows, num_cols;\n\nvoid depth_first_search(int row, int col) {\n    visited[row][col] = true;\n    for (int i = 0; i < 4; i++) {\n        int new_row = row + row_direction[i];\n        int new_col = col + col_direction[i];\n        if (new_row >= 0 && new_row < num_rows && new_col >= 0 && new_col < num_cols && grid[new_row][new_col] == '.' && !visited[new_row][new_col]) {\n            depth_first_search(new_row, new_col);\n        }\n    }\n}\n\nint main() {\n    cin >> num_rows >> num_cols;\n    for (int i = 0; i < num_rows; i++) {\n        cin >> grid[i];\n    }\n\n    int room_count = 0;\n    for (int i = 0; i < num_rows; i++) {\n        for (int j = 0; j < num_cols; j++) {\n            if (grid[i][j] == '.' && !visited[i][j]) {\n                room_count++;\n                depth_first_search(i, j);\n            }\n        }\n    }\n\n    cout << room_count << endl;\n    return 0;\n}",
            "passed_test_cases": 15,
            "total_test_cases": 19,
            "mean_time_taken": 0.09581508134540759,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                4,
                7,
                8,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Sequences",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\n// Function to calculate (base^exponent) % MOD\nlong long power(long long base, long long exponent) {\n    long long result = 1;\n    while (exponent > 0) {\n        if (exponent % 2 == 1)\n            result = (result * base) % MOD;\n        base = (base * base) % MOD;\n        exponent /= 2;\n    }\n    return result;\n}\n\n// Function to calculate factorial of n\nlong long factorial(long long n) {\n    long long result = 1;\n    for (long long i = 2; i <= n; i++)\n        result = (result * i) % MOD;\n    return result;\n}\n\n// Function to calculate combination (n choose k)\nlong long combination(long long n, long long k) {\n    long long num = factorial(n);\n    long long den = (factorial(k) * factorial(n - k)) % MOD;\n    return (num * power(den, MOD - 2)) % MOD;\n}\n\nint main() {\n    long long n, k;\n    cin >> n >> k;\n\n    // Calculate the number of sequences\n    long long result = combination(n, k) * factorial(k) % MOD;\n    result = result * power(k, n - k) % MOD;\n\n    cout << result << endl;\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 10,
            "mean_time_taken": 0.08280832767486572,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                4,
                5,
                6,
                7,
                8,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Tilings",
            "category": "Dynamic Programming",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int MAX_N = 10;\nconst int MAX_M = 1000;\n\nint n, m;\nint dp[MAX_M + 1][1 << MAX_N];\nint trans[1 << MAX_N][1 << MAX_N];\n\nvoid add(int& x, int y) {\n    x += y;\n    if (x >= MOD) x -= MOD;\n}\n\nint main() {\n    cin >> n >> m;\n    dp[0][0] = 1;\n    for (int i = 0; i < (1 << n); i++) {\n        for (int j = 0; j < (1 << n); j++) {\n            if ((i & j) == 0 && (i & (j << 1)) == 0) {\n                trans[i][j] = 1;\n            }\n        }\n    }\n    for (int i = 1; i <= m; i++) {\n        for (int j = 0; j < (1 << n); j++) {\n            for (int k = 0; k < (1 << n); k++) {\n                add(dp[i][j], dp[i - 1][k] * trans[k][j]);\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < (1 << n); i++) {\n        add(ans, dp[m][i]);\n    }\n    cout << ans << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.3914277235666911,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Towers",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n\nconst int MAX_SIZE = 1000001;\nconst long long MODULO = 1000000007;\n\nint main() {\n    // Initialize an array to store the number of towers for each height\n    std::vector<long long> towers(MAX_SIZE);\n\n    // Initialize the base cases for the array\n    towers[0] = 1;\n    towers[1] = 2;\n\n    // Use a loop to calculate the number of towers for each height\n    for (int i = 2; i < MAX_SIZE; i++) {\n        towers[i] = (towers[i - 1] * 2 + towers[i - 2]) % MODULO;\n    }\n\n    // Read the number of test cases from the input\n    int num_test_cases;\n    std::cin >> num_test_cases;\n\n    // For each test case, read the height of the tower from the input and print the corresponding number of towers from the array\n    while (num_test_cases--) {\n        int height;\n        std::cin >> height;\n        std::cout << towers[height] << std::endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.09302937984466553,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Course Schedule",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> graph(n + 1);\n    vector<int> in_degree(n + 1, 0);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        in_degree[b]++;\n    }\n\n    queue<int> q;\n    for (int i = 1; i <= n; i++) {\n        if (in_degree[i] == 0) {\n            q.push(i);\n        }\n    }\n\n    vector<int> result;\n    while (!q.empty()) {\n        int course = q.front();\n        q.pop();\n        result.push_back(course);\n\n        for (int adjacent_course : graph[course]) {\n            in_degree[adjacent_course]--;\n            if (in_degree[adjacent_course] == 0) {\n                q.push(adjacent_course);\n            }\n        }\n    }\n\n    if (result.size() == n) {\n        for (int course : result) {\n            cout << course << \" \";\n        }\n    } else {\n        cout << \"IMPOSSIBLE\";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 16,
            "total_test_cases": 16,
            "mean_time_taken": 0.11910650134086609,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Course Schedule II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nvector<int> topologicalSort(vector<vector<int>>& graph, vector<int>& inDegree) {\n    int n = graph.size();\n    vector<int> result;\n    queue<int> q;\n\n    // Enqueue all nodes with an in-degree of 0\n    for (int i = 0; i < n; i++) {\n        if (inDegree[i] == 0) {\n            q.push(i);\n        }\n    }\n\n    // Perform topological sort\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        result.push_back(node);\n\n        // Decrease the in-degree of all adjacent nodes\n        for (int neighbor : graph[node]) {\n            inDegree[neighbor]--;\n\n            // If the in-degree of an adjacent node becomes 0, enqueue it\n            if (inDegree[neighbor] == 0) {\n                q.push(neighbor);\n            }\n        }\n    }\n\n    // If there is a cycle in the graph, return an empty vector\n    if (result.size() < n) {\n        return {};\n    }\n\n    return result;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> graph(n);\n    vector<int> inDegree(n, 0);\n\n    // Read input and create graph representation\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        graph[a].push_back(b);\n        inDegree[b]++;\n    }\n\n    vector<int> result = topologicalSort(graph, inDegree);\n\n    // Output the result\n    for (int i = 0; i < n; i++) {\n        cout << result[i] + 1 << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 8,
            "mean_time_taken": 0.11559289693832397,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                5,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Creating Offices",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nvector<int> adj[MAX_N];\nint dp[MAX_N][2];\n\nvoid dfs(int u, int p) {\n    dp[u][0] = 1;\n    dp[u][1] = 0;\n    for (int v : adj[u]) {\n        if (v == p) continue;\n        dfs(v, u);\n        dp[u][0] += max(dp[v][0], dp[v][1]);\n        dp[u][1] += dp[v][0];\n    }\n}\n\nvoid solve(int u, int p, int d, vector<int>& ans) {\n    if (d == 0) {\n        ans.push_back(u);\n        d = 1;\n    }\n    for (int v : adj[u]) {\n        if (v == p) continue;\n        if (dp[v][0] > dp[v][1]) {\n            solve(v, u, d - 1, ans);\n        } else {\n            solve(v, u, 0, ans);\n        }\n    }\n}\n\nint main() {\n    int n, d;\n    cin >> n >> d;\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(1, 0);\n    vector<int> ans;\n    solve(1, 0, d, ans);\n    cout << ans.size() << endl;\n    for (int u : ans) {\n        cout << u << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 22,
            "mean_time_taken": 0.1700045412236994,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Creating Strings",
            "category": "Introductory Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Creating Strings II",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n\nconst int MOD = 1e9 + 7;\nconst int MAX_N = 1e6 + 5;\n\nstd::vector<long long> fact(MAX_N);\nstd::vector<long long> inv(MAX_N);\nstd::vector<int> cnt(26);\n\nlong long power(long long a, long long b) {\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1) res = (res * a) % MOD;\n        a = (a * a) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nvoid precompute() {\n    fact[0] = 1;\n    for (int i = 1; i < MAX_N; i++) {\n        fact[i] = (fact[i - 1] * i) % MOD;\n    }\n    inv[MAX_N - 1] = power(fact[MAX_N - 1], MOD - 2);\n    for (int i = MAX_N - 2; i >= 0; i--) {\n        inv[i] = (inv[i + 1] * (i + 1)) % MOD;\n    }\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    precompute();\n\n    std::string s;\n    std::cin >> s;\n\n    int n = s.length();\n    for (char c : s) {\n        cnt[c - 'a']++;\n    }\n\n    long long ans = fact[n];\n    for (int i = 0; i < 26; i++) {\n        ans = (ans * inv[cnt[i]]) % MOD;\n    }\n\n    std::cout << ans << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.09834225972493489,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Critical Cities",
            "category": "Additional Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Cut and Paste",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <deque>\n#include <string>\n\nint main() {\n    int n, m;\n    std::cin >> n >> m;\n\n    std::string s;\n    std::cin >> s;\n\n    std::deque<char> d(s.begin(), s.end());\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        std::cin >> a >> b;\n\n        std::deque<char> sub(d.begin() + a - 1, d.begin() + b);\n        d.erase(d.begin() + a - 1, d.begin() + b);\n        d.insert(d.end(), sub.begin(), sub.end());\n    }\n\n    for (char c : d) {\n        std::cout << c;\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 7,
            "mean_time_taken": 0.6106713499341693,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Cycle Finding",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_NODES = 2505;\nconst long long INF = 1e18;\n\nint numNodes, numEdges;\nlong long dist[MAX_NODES];\nint parent[MAX_NODES];\nvector<int> cycle;\n\nstruct Edge {\n    int u, v;\n    long long w;\n};\n\nvector<Edge> edges;\n\nvoid bellmanFord(int source) {\n    fill(dist, dist + MAX_NODES, INF);\n    fill(parent, parent + MAX_NODES, -1);\n    dist[source] = 0;\n\n    for (int i = 1; i <= numNodes; i++) {\n        for (Edge& e : edges) {\n            if (dist[e.u] + e.w < dist[e.v]) {\n                dist[e.v] = dist[e.u] + e.w;\n                parent[e.v] = e.u;\n\n                if (i == numNodes) {\n                    cycle.push_back(e.v);\n                    int curr = parent[e.v];\n                    while (curr != e.v) {\n                        cycle.push_back(curr);\n                        curr = parent[curr];\n                    }\n                    cycle.push_back(e.v);\n                    reverse(cycle.begin(), cycle.end());\n                    return;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> numNodes >> numEdges;\n\n    for (int i = 0; i < numEdges; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        edges.push_back({u, v, w});\n    }\n\n    bellmanFord(1);\n\n    if (cycle.empty()) {\n        cout << \"NO\";\n    } else {\n        cout << \"YES\\n\";\n        for (int node : cycle) {\n            cout << node << \" \";\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 16,
            "total_test_cases": 27,
            "mean_time_taken": 0.3277882823237666,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                4,
                5,
                9,
                12,
                14,
                17,
                18,
                21,
                23,
                24,
                26
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Cyclic Array",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    int arr[n];\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    int subarrays = 1;\n    int currentSum = 0;\n\n    for (int i = 0; i < n; i++) {\n        currentSum += arr[i];\n        if (currentSum > k) {\n            subarrays++;\n            currentSum = arr[i];\n        }\n    }\n\n    cout << subarrays << endl;\n    return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 21,
            "mean_time_taken": 0.08504369145347959,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                5,
                7,
                9,
                10,
                13,
                14,
                18,
                19
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "De Bruijn Sequence",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid generateDeBruijnSequence(vector<int>& sequence, int position, int numberOfBits) {\n    if (position > numberOfBits) {\n        position -= numberOfBits;\n        for (int i = 1; i <= numberOfBits; i++) {\n            cout << sequence[i];\n        }\n        if (position <= 1) {\n            cout << endl;\n        }\n    } else {\n        sequence[position] = sequence[position - numberOfBits];\n        generateDeBruijnSequence(sequence, position + 1, numberOfBits);\n        int j = sequence[position - numberOfBits] + 1;\n        while (j < 2) {\n            sequence[position] = j;\n            generateDeBruijnSequence(sequence, position + 1, numberOfBits);\n            j++;\n        }\n    }\n}\n\nint main() {\n    int numberOfBits;\n    cin >> numberOfBits;\n    vector<int> sequence(2 * numberOfBits + 1);\n    for (int i = 1; i <= numberOfBits; i++) {\n        sequence[i] = 0;\n    }\n    generateDeBruijnSequence(sequence, numberOfBits + 1, numberOfBits);\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.07978533109029134,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Dice Combinations",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countWays(int n) {\n    vector<int> dp(n + 1, 0);\n    dp[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= 6 && j <= i; j++) {\n            dp[i] = (dp[i] + dp[i - j]) % MOD;\n        }\n    }\n    return dp[n];\n}\n\nint main() {\n    int n;\n    cin >> n;\n    cout << countWays(n) << endl;\n    return 0;\n}",
            "passed_test_cases": 20,
            "total_test_cases": 20,
            "mean_time_taken": 0.0861403226852417,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Dice Probability",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n\nconst int MAX_N = 105;\nconst int MAX_SUM = 605;\n\ndouble dp[MAX_N][MAX_SUM][MAX_SUM];\n\nint main() {\n    int n, a, b;\n    std::cin >> n >> a >> b;\n\n    memset(dp, 0, sizeof(dp));\n\n    for (int i = 1; i <= 6; i++) {\n        dp[1][i][i] = 1.0;\n    }\n\n    for (int i = 2; i <= n; i++) {\n        for (int j = 1; j <= 6 * i; j++) {\n            for (int k = 1; k <= 6; k++) {\n                if (j - k >= 1) {\n                    dp[i][j][k] += dp[i - 1][j - k][k];\n                }\n            }\n            dp[i][j][j] /= 6.0;\n            for (int k = j + 1; k <= 6 * i; k++) {\n                dp[i][j][k] += dp[i][j][k - 1];\n            }\n        }\n    }\n\n    double result = 0.0;\n    for (int i = a; i <= b; i++) {\n        result += dp[n][i][6 * n];\n    }\n\n    printf(\"%.6lf\\n\", result);\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 17,
            "mean_time_taken": 0.1905670446508071,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Digit Queries",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    long long int queries, position, numberOfDigits, startingNumber, targetNumber, digit;\n    cin >> queries;\n\n    while (queries--) {\n        cin >> position;\n        numberOfDigits = 1;\n        startingNumber = 1;\n\n        // Calculate the number of digits and the starting number\n        while (position > (9 * startingNumber * numberOfDigits)) {\n            position -= (9 * startingNumber * numberOfDigits);\n            startingNumber *= 10;\n            numberOfDigits++;\n        }\n\n        // Calculate the target number and the digit\n        targetNumber = startingNumber + (position - 1) / numberOfDigits;\n        digit = (position - 1) % numberOfDigits;\n\n        // Print the digit\n        while (digit--) {\n            targetNumber /= 10;\n        }\n        cout << targetNumber % 10 << endl;\n    }\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.08644205331802368,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distance Queries",
            "category": "Tree Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Distinct Colors",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nvector<int> adj[MAX_N];\nint color[MAX_N];\nint subtree_size[MAX_N];\nset<int> subtree_colors[MAX_N];\n\nvoid dfs(int node, int parent) {\n    subtree_colors[node].insert(color[node]);\n    subtree_size[node] = subtree_colors[node].size();\n    for (int child : adj[node]) {\n        if (child != parent) {\n            dfs(child, node);\n            for (int color : subtree_colors[child]) {\n                subtree_colors[node].insert(color);\n            }\n            subtree_size[node] = subtree_colors[node].size();\n        }\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> color[i];\n    }\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(1, 0);\n    for (int i = 1; i <= n; i++) {\n        cout << subtree_size[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 15,
            "mean_time_taken": 0.4573589007059733,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                7,
                9,
                11,
                13,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Numbers",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <set>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::set<int> distinct_numbers;\n    for (int i = 0; i < n; i++) {\n        int num;\n        std::cin >> num;\n        distinct_numbers.insert(num);\n    }\n\n    std::cout << distinct_numbers.size() << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 15,
            "total_test_cases": 15,
            "mean_time_taken": 0.13943689664204914,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Distinct Routes",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 505;\nvector<int> adj[MAX_N];\nint dp[MAX_N][MAX_N];\nvector<vector<int>> paths;\n\nvoid dfs(int u, int v, vector<int>& path) {\n    path.push_back(v);\n    if (v == adj.size() - 1) {\n        paths.push_back(path);\n    } else {\n        for (int i = 0; i < adj[v].size(); i++) {\n            int w = adj[v][i];\n            if (dp[u][w] > 0) {\n                dp[u][w]--;\n                dfs(v, w, path);\n                dp[u][w]++;\n            }\n        }\n    }\n    path.pop_back();\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n    }\n    for (int i = 1; i <= n; i++) {\n        vector<int> path;\n        path.push_back(1);\n        dfs(1, i, path);\n    }\n    for (int i = 0; i < paths.size(); i++) {\n        int u = paths[i][0];\n        int v = paths[i][paths[i].size() - 1];\n        dp[u][v]++;\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n        ans = max(ans, dp[1][i]);\n    }\n    cout << ans << endl;\n    for (int i = 0; i < ans; i++) {\n        for (int j = 0; j < paths.size(); j++) {\n            int u = paths[j][0];\n            int v = paths[j][paths[j].size() - 1];\n            if (dp[u][v] > 0) {\n                dp[u][v]--;\n                cout << paths[j].size() << endl;\n                for (int k = 0; k < paths[j].size(); k++) {\n                    cout << paths[j][k] << \" \";\n                }\n                cout << endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Distinct Routes II",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 505;\nconst int MAX_M = 1005;\nconst int MAX_K = 505;\nconst int INF = 1e9;\n\nint n, m, k;\nvector<pair<int, int>> adj[MAX_N];\nint dp[MAX_N][MAX_N][MAX_K];\nint path[MAX_N][MAX_N][MAX_K];\n\nvoid find_min_coins() {\n    for (int i = 1; i <= k; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i == 1) {\n                dp[i][j][1] = INF;\n                for (auto &edge : adj[1]) {\n                    if (edge.first == j) {\n                        dp[i][j][1] = 1;\n                        path[i][j][1] = 1;\n                        break;\n                    }\n                }\n            } else {\n                dp[i][j][i] = INF;\n                for (int l = 1; l < j; l++) {\n                    for (auto &edge : adj[l]) {\n                        if (edge.first == j) {\n                            int cost = edge.second;\n                            if (dp[i-1][l][i-1] != INF && dp[i-1][l][i-1] + cost < dp[i][j][i]) {\n                                dp[i][j][i] = dp[i-1][l][i-1] + cost;\n                                path[i][j][i] = l;\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid print_paths() {\n    if (dp[k][n][k] == INF) {\n        cout << -1 << endl;\n        return;\n    }\n    cout << dp[k][n][k] << endl;\n    int curr_day = k;\n    int curr_room = n;\n    while (curr_day > 0) {\n        vector<int> curr_path;\n        while (curr_room != 1) {\n            curr_path.push_back(curr_room);\n            curr_room = path[curr_day][curr_room][curr_day];\n        }\n        curr_path.push_back(1);\n        reverse(curr_path.begin(), curr_path.end());\n        for (int room : curr_path) {\n            cout << room << \" \";\n        }\n        cout << endl;\n        curr_day--;\n        curr_room = path[curr_day+1][n][curr_day+1];\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> n >> m >> k;\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        adj[u].push_back({v, w});\n    }\n    find_min_coins();\n    print_paths();\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.07600808143615723,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Substrings",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <set>\n#include <string>\n\nint main() {\n    std::string inputString;\n    std::cin >> inputString;\n\n    std::set<std::string> distinctSubstrings;\n\n    for (int i = 0; i < inputString.length(); i++) {\n        std::string currentSubstring = \"\";\n        for (int j = i; j < inputString.length(); j++) {\n            currentSubstring += inputString[j];\n            distinctSubstrings.insert(currentSubstring);\n        }\n    }\n\n    std::cout << distinctSubstrings.size() << std::endl;\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 7,
            "mean_time_taken": 0.4521233354296003,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Values Queries",
            "category": "Range Queries",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Distributing Apples",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <cmath>\n\nconst int MOD = 1e9 + 7;\n\n// Function to calculate (base^exponent)%MOD\nlong long power(long long base, long long exponent) {\n    long long result = 1;\n    while (exponent > 0) {\n        if (exponent % 2 == 1)\n            result = (result * base) % MOD;\n        base = (base * base) % MOD;\n        exponent = exponent / 2;\n    }\n    return result;\n}\n\n// Function to calculate the inverse of a number\nlong long inverse(long long number) {\n    return power(number, MOD - 2);\n}\n\n// Function to calculate the number of ways to distribute m apples to n children\nlong long countWays(int n, int m) {\n    long long numerator = 1;\n    long long denominator = 1;\n\n    // Calculate the numerator (m+n-1)!\n    for (int i = m + n - 1; i >= m + 1; i--) {\n        numerator = (numerator * i) % MOD;\n    }\n\n    // Calculate the denominator (n-1)!\n    for (int i = n - 1; i >= 2; i--) {\n        denominator = (denominator * i) % MOD;\n    }\n\n    // Return the number of ways modulo MOD\n    return (numerator * inverse(denominator)) % MOD;\n}\n\nint main() {\n    int n, m;\n    std::cin >> n >> m;\n\n    // Print the number of ways to distribute the apples\n    std::cout << countWays(n, m) << std::endl;\n    return 0;\n}",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.0823675485757681,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Divisor Analysis",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nconst long long MOD = 1000000007;\n\nint main() {\n    long long numberOfTestCases;\n    cin >> numberOfTestCases;\n\n    long long totalDivisors = 1, sumOfDivisors = 1, productOfDivisors = 1;\n\n    for (long long testCase = 0; testCase < numberOfTestCases; testCase++) {\n        long long prime, power;\n        cin >> prime >> power;\n\n        // Calculate the number of divisors\n        totalDivisors = (totalDivisors * (power + 1)) % MOD;\n\n        // Calculate the sum of divisors\n        long long temp = (pow(prime, power + 1) - 1) % MOD;\n        temp = (temp * (pow(prime - 1, MOD - 2))) % MOD;\n        sumOfDivisors = (sumOfDivisors * temp) % MOD;\n\n        // Calculate the product of divisors\n        temp = (pow(prime, ((power * (power + 1)) / 2))) % MOD;\n        productOfDivisors = (productOfDivisors * temp) % MOD;\n    }\n\n    cout << totalDivisors << \" \" << sumOfDivisors << \" \" << productOfDivisors << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Download Speed",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_NODES = 505;\nconst long long INF = 1e18;\n\nint numNodes, numEdges;\nvector<pair<int, int>> graph[MAX_NODES];\nlong long distance[MAX_NODES];\n\nvoid bellmanFord() {\n    distance[1] = INF;\n    for (int i = 2; i <= numNodes; i++) {\n        distance[i] = -INF;\n    }\n\n    for (int i = 1; i <= numNodes - 1; i++) {\n        for (int j = 1; j <= numNodes; j++) {\n            for (auto edge : graph[j]) {\n                int nextNode = edge.first;\n                int weight = edge.second;\n                distance[nextNode] = max(distance[nextNode], min(distance[j], (long long)weight));\n            }\n        }\n    }\n\n    for (int j = 1; j <= numNodes; j++) {\n        for (auto edge : graph[j]) {\n            int nextNode = edge.first;\n            int weight = edge.second;\n            if (distance[nextNode] < min(distance[j], (long long)weight)) {\n                cout << \"INFINITE\" << endl;\n                exit(0);\n            }\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    cin >> numNodes >> numEdges;\n\n    for (int i = 1; i <= numEdges; i++) {\n        int node1, node2, weight;\n        cin >> node1 >> node2 >> weight;\n        graph[node1].push_back({node2, weight});\n    }\n\n    bellmanFord();\n    cout << distance[numNodes] << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Dynamic Connectivity",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_NODES = 1e5 + 5;\nint parent[MAX_NODES], rank[MAX_NODES], components;\nbool edge_exists[MAX_NODES][MAX_NODES];\n\nint find_parent(int node) {\n    if (parent[node] == node) return node;\n    return parent[node] = find_parent(parent[node]);\n}\n\nvoid union_nodes(int node1, int node2) {\n    int parent1 = find_parent(node1), parent2 = find_parent(node2);\n    if (parent1 == parent2) return;\n    if (rank[parent1] < rank[parent2]) swap(parent1, parent2);\n    parent[parent2] = parent1;\n    if (rank[parent1] == rank[parent2]) rank[parent1]++;\n    components--;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n        rank[i] = 1;\n    }\n\n    components = n;\n\n    for (int i = 0; i < m; i++) {\n        int node1, node2;\n        cin >> node1 >> node2;\n        edge_exists[node1][node2] = edge_exists[node2][node1] = true;\n        union_nodes(node1, node2);\n    }\n\n    cout << components << \" \";\n\n    for (int i = 0; i < k; i++) {\n        int type, node1, node2;\n        cin >> type >> node1 >> node2;\n        if (type == 1) {\n            if (!edge_exists[node1][node2]) {\n                edge_exists[node1][node2] = edge_exists[node2][node1] = true;\n                union_nodes(node1, node2);\n            }\n        } else {\n            if (edge_exists[node1][node2]) {\n                edge_exists[node1][node2] = edge_exists[node2][node1] = false;\n                components++;\n            }\n        }\n        cout << components << \" \";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Dynamic Range Minimum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Define a structure for the segment tree node\nstruct SegmentTreeNode {\n    int minValue;\n    int lazyPropagation;\n};\n\n// Build the segment tree from the input array\nvoid buildSegmentTree(vector<int>& arr, vector<SegmentTreeNode>& tree, int node, int start, int end) {\n    if (start == end) {\n        tree[node].minValue = arr[start];\n        tree[node].lazyPropagation = 0;\n    } else {\n        int mid = (start + end) / 2;\n        buildSegmentTree(arr, tree, 2 * node, start, mid);\n        buildSegmentTree(arr, tree, 2 * node + 1, mid + 1, end);\n        tree[node].minValue = min(tree[2 * node].minValue, tree[2 * node + 1].minValue);\n        tree[node].lazyPropagation = 0;\n    }\n}\n\n// Update the value at a specific position in the array and propagate the changes to the segment tree nodes\nvoid updateSegmentTree(vector<SegmentTreeNode>& tree, int node, int start, int end, int idx, int val) {\n    if (start == end) {\n        tree[node].minValue = val;\n    } else {\n        int mid = (start + end) / 2;\n        if (idx <= mid) {\n            updateSegmentTree(tree, 2 * node, start, mid, idx, val);\n        } else {\n            updateSegmentTree(tree, 2 * node + 1, mid + 1, end, idx, val);\n        }\n        tree[node].minValue = min(tree[2 * node].minValue, tree[2 * node + 1].minValue);\n    }\n}\n\n// Query the minimum value in a given range using the segment tree\nint querySegmentTree(vector<SegmentTreeNode>& tree, int node, int start, int end, int l, int r) {\n    if (r < start || end < l) {\n        return INT_MAX;\n    }\n    if (l <= start && end <= r) {\n        return tree[node].minValue;\n    }\n    int mid = (start + end) / 2;\n    return min(querySegmentTree(tree, 2 * node, start, mid, l, r), querySegmentTree(tree, 2 * node + 1, mid + 1, end, l, r));\n}\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    vector<SegmentTreeNode> tree(4 * n);\n    buildSegmentTree(arr, tree, 1, 0, n - 1);\n    for (int i = 0; i < q; i++) {\n        int type, a, b;\n        cin >> type >> a >> b;\n        if (type == 1) {\n            updateSegmentTree(tree, 1, 0, n - 1, a - 1, b);\n        } else {\n            cout << querySegmentTree(tree, 1, 0, n - 1, a - 1, b - 1) << endl;\n        }\n    }\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Dynamic Range Sum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Define a structure for the segment tree node\nstruct SegmentTreeNode {\n    long long sum;\n    long long min_val;\n    long long max_val;\n};\n\n// Build the segment tree from the input array\nvoid build_segment_tree(vector<long long>& arr, vector<SegmentTreeNode>& tree, int node, int start, int end) {\n    if (start == end) {\n        tree[node].sum = arr[start];\n        tree[node].min_val = arr[start];\n        tree[node].max_val = arr[start];\n    } else {\n        int mid = (start + end) / 2;\n        build_segment_tree(arr, tree, 2 * node, start, mid);\n        build_segment_tree(arr, tree, 2 * node + 1, mid + 1, end);\n        tree[node].sum = tree[2 * node].sum + tree[2 * node + 1].sum;\n        tree[node].min_val = min(tree[2 * node].min_val, tree[2 * node + 1].min_val);\n        tree[node].max_val = max(tree[2 * node].max_val, tree[2 * node + 1].max_val);\n    }\n}\n\n// Update the value at a specific position in the array and update the corresponding segment tree nodes\nvoid update_segment_tree(vector<long long>& arr, vector<SegmentTreeNode>& tree, int node, int start, int end, int idx, long long val) {\n    if (start == end) {\n        arr[idx] = val;\n        tree[node].sum = val;\n        tree[node].min_val = val;\n        tree[node].max_val = val;\n    } else {\n        int mid = (start + end) / 2;\n        if (idx <= mid)\n            update_segment_tree(arr, tree, 2 * node, start, mid, idx, val);\n        else\n            update_segment_tree(arr, tree, 2 * node + 1, mid + 1, end, idx, val);\n        tree[node].sum = tree[2 * node].sum + tree[2 * node + 1].sum;\n        tree[node].min_val = min(tree[2 * node].min_val, tree[2 * node + 1].min_val);\n        tree[node].max_val = max(tree[2 * node].max_val, tree[2 * node + 1].max_val);\n    }\n}\n\n// Query the sum of values in a given range using the segment tree\nlong long query_segment_tree(vector<SegmentTreeNode>& tree, int node, int start, int end, int l, int r) {\n    if (r < start || end < l)\n        return 0;\n    if (l <= start && end <= r)\n        return tree[node].sum;\n    int mid = (start + end) / 2;\n    return query_segment_tree(tree, 2 * node, start, mid, l, r) + query_segment_tree(tree, 2 * node + 1, mid + 1, end, l, r);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n\n    vector<long long> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    vector<SegmentTreeNode> tree(4 * n);\n    build_segment_tree(arr, tree, 1, 0, n - 1);\n\n    for (int i = 0; i < q; i++) {\n        int type, a, b;\n        cin >> type >> a >> b;\n        if (type == 1) {\n            update_segment_tree(arr, tree, 1, 0, n - 1, a - 1, b);\n        } else {\n            cout << query_segment_tree(tree, 1, 0, n - 1, a - 1, b - 1) << endl;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 2,
            "mean_time_taken": 0.1724534034729004,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Edit Distance",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint editDistance(string str1, string str2, int m, int n) {\n    int dp[m + 1][n + 1];\n\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0)\n                dp[i][j] = j;\n            else if (j == 0)\n                dp[i][j] = i;\n            else if (str1[i - 1] == str2[j - 1])\n                dp[i][j] = dp[i - 1][j - 1];\n            else\n                dp[i][j] = 1 + min(dp[i][j - 1], min(dp[i - 1][j], dp[i - 1][j - 1]));\n        }\n    }\n\n    return dp[m][n];\n}\n\nint main() {\n    string str1, str2;\n    cin >> str1 >> str2;\n\n    int m = str1.length();\n    int n = str2.length();\n\n    cout << editDistance(str1, str2, m, n);\n\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 17,
            "mean_time_taken": 0.10132096795474782,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                5,
                6,
                7,
                9,
                11,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Elevator Rides",
            "category": "Dynamic Programming",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 20;\nint n, x, weights[MAX_N], dp[(1 << MAX_N)];\n\nint main() {\n    cin >> n >> x;\n    for (int i = 0; i < n; i++) {\n        cin >> weights[i];\n    }\n    fill_n(dp, (1 << n), INT_MAX);\n    dp[0] = 0;\n    for (int i = 1; i < (1 << n); i++) {\n        int total_weight = 0;\n        for (int j = 0; j < n; j++) {\n            if (i & (1 << j)) {\n                total_weight += weights[j];\n            }\n        }\n        if (total_weight <= x) {\n            dp[i] = 1;\n        }\n        for (int j = i; j > 0; j = (j - 1) & i) {\n            dp[i] = min(dp[i], dp[j] + dp[i ^ j]);\n        }\n    }\n    cout << dp[(1 << n) - 1] << endl;\n    return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 39,
            "mean_time_taken": 0.7662913371355106,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                8,
                10,
                11,
                12,
                13,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                24,
                27,
                28,
                29,
                30,
                32,
                35,
                36,
                37,
                39
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Empty String",
            "category": "Additional Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Eulerian Subgraphs",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n#define MOD 1000000007\nusing namespace std;\n\n// Function to compute the binomial coefficient C(n, k) modulo MOD\nlong long binomial_coefficient(int n, int k) {\n    vector<vector<long long>> dp(n + 1, vector<long long>(k + 1));\n    for (int i = 0; i <= n; i++) {\n        dp[i][0] = 1;\n        for (int j = 1; j <= min(i, k); j++) {\n            dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % MOD;\n        }\n    }\n    return dp[n][k];\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> degree(n + 1);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        degree[a]++;\n        degree[b]++;\n    }\n    int odd_nodes = 0;\n    for (int i = 1; i <= n; i++) {\n        if (degree[i] % 2 == 1) {\n            odd_nodes++;\n        }\n    }\n    if (odd_nodes % 2 == 1) {\n        cout << 0 << endl;\n        return 0;\n    }\n    long long answer = (1LL << m) % MOD;\n    answer = (answer - binomial_coefficient(m, odd_nodes / 2) + MOD) % MOD;\n    cout << answer << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 0.1928715705871582,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Even Outdegree Edges",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<pair<int, int>> result;\nvector<bool> visited;\n\nvoid dfs(int u, int p) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (v == p) continue;\n        if (!visited[v]) {\n            result.push_back({u, v});\n            dfs(v, u);\n        } else {\n            result.push_back({v, u});\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    adj.resize(n);\n    visited.assign(n, false);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(0, -1);\n    for (int u = 0; u < n; u++) {\n        if (adj[u].size() % 2 == 1) {\n            cout << \"IMPOSSIBLE\" << endl;\n            return 0;\n        }\n    }\n    for (auto& p : result) {\n        cout << p.first + 1 << \" \" << p.second + 1 << endl;\n    }\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 8,
            "mean_time_taken": 0.16646182537078857,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Exponentiation",
            "category": "Mathematics",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Exponentiation II",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst long long MOD = 1e9 + 7;\n\nlong long power(long long base, long long exponent) {\n    long long result = 1;\n    while (exponent > 0) {\n        if (exponent % 2 == 1) {\n            result = (result * base) % MOD;\n        }\n        base = (base * base) % MOD;\n        exponent /= 2;\n    }\n    return result;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    while (n--) {\n        long long a, b, c;\n        cin >> a >> b >> c;\n        long long b_c = power(b, c);\n        long long result = power(a, b_c);\n        cout << result << endl;\n    }\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 13,
            "mean_time_taken": 0.13863330620985764,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Factory Machines",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, t;\n    cin >> n >> t;\n\n    vector<int> machines(n);\n    for (int i = 0; i < n; i++) {\n        cin >> machines[i];\n    }\n\n    long long left = 0, right = 1e18;\n    while (left < right) {\n        long long mid = (left + right) / 2;\n        long long total_products = 0;\n        for (int i = 0; i < n; i++) {\n            total_products += mid / machines[i];\n        }\n\n        if (total_products < t) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    cout << left << endl;\n    return 0;\n}",
            "passed_test_cases": 15,
            "total_test_cases": 18,
            "mean_time_taken": 0.09093679322136773,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                8,
                10,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Ferris Wheel",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nint main() {\n    int n, x;\n    std::cin >> n >> x;\n\n    std::vector<int> weights(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> weights[i];\n    }\n\n    std::sort(weights.begin(), weights.end());\n\n    int left = 0, right = n - 1;\n    int gondolas = 0;\n\n    while (left <= right) {\n        if (weights[left] + weights[right] <= x) {\n            left++;\n        }\n        right--;\n        gondolas++;\n    }\n\n    std::cout << gondolas << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.11945761167086087,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Fibonacci Numbers",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\n// Define the modulo value\nconst long long MODULO = 1000000007;\n\n// Define a structure for 2x2 matrices\nstruct Matrix {\n    long long data[2][2];\n\n    // Implement matrix multiplication\n    Matrix operator*(const Matrix& other) const {\n        Matrix result;\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++) {\n                result.data[i][j] = 0;\n                for (int k = 0; k < 2; k++) {\n                    result.data[i][j] = (result.data[i][j] + (data[i][k] * other.data[k][j]) % MODULO) % MODULO;\n                }\n            }\n        }\n        return result;\n    }\n};\n\n// Implement matrix exponentiation\nMatrix matrixPower(Matrix base, long long exponent) {\n    Matrix result = {{1, 0}, {0, 1}};\n    while (exponent > 0) {\n        if (exponent % 2 == 1) {\n            result = result * base;\n        }\n        base = base * base;\n        exponent /= 2;\n    }\n    return result;\n}\n\n// Define a function to calculate the nth Fibonacci number\nlong long fibonacci(long long n) {\n    if (n == 0) {\n        return 0;\n    }\n    Matrix base = {{1, 1}, {1, 0}};\n    Matrix result = matrixPower(base, n - 1);\n    return result.data[0][0];\n}\n\nint main() {\n    long long n;\n    cin >> n;\n\n    // Call the function to calculate the nth Fibonacci number and print the result modulo 10^9 + 7\n    cout << fibonacci(n) % MODULO << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Filling Trominos",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid fill_grid(int n, int m, vector<vector<char>>& grid, char c) {\n    if (n == 2 && m == 2) {\n        grid[0][0] = c;\n        grid[0][1] = c;\n        grid[1][0] = c;\n        grid[1][1] = c;\n        return;\n    }\n    if (n == 3) {\n        grid[0][0] = c;\n        grid[0][1] = c;\n        grid[1][0] = c;\n        grid[1][1] = c;\n        grid[2][0] = c;\n        grid[2][1] = c;\n        grid[2][2] = c;\n        grid[2][3] = c;\n        grid[0][2] = c + 1;\n        grid[1][2] = c + 1;\n        fill_grid(2, m - 3, grid, c + 2);\n        return;\n    }\n    if (m == 3) {\n        grid[0][0] = c;\n        grid[0][1] = c;\n        grid[1][0] = c;\n        grid[1][1] = c;\n        grid[0][2] = c;\n        grid[1][2] = c;\n        grid[2][2] = c;\n        grid[3][2] = c;\n        grid[2][0] = c + 1;\n        grid[2][1] = c + 1;\n        fill_grid(n - 3, 2, grid, c + 2);\n        return;\n    }\n    fill_grid(n / 2, m / 2, grid, c);\n    fill_grid(n / 2, m / 2, grid, c + 1);\n    fill_grid(n / 2, m / 2, grid, c + 2);\n    fill_grid(n / 2, m / 2, grid, c + 2);\n    grid[n / 2][m / 2] = c + 1;\n    grid[n / 2][m / 2 - 1] = c + 1;\n    grid[n / 2 - 1][m / 2 - 1] = c + 1;\n    grid[n / 2 - 1][m / 2] = c;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        if (n % 2 == 1 && m % 2 == 1) {\n            cout << \"NO\" << endl;\n            continue;\n        }\n        if (n % 2 == 1) {\n            swap(n, m);\n        }\n        if (n % 2 == 0 && m % 2 == 0) {\n            cout << \"YES\" << endl;\n            vector<vector<char>> grid(n, vector<char>(m));\n            fill_grid(n, m, grid, 'A');\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    cout << grid[i][j];\n                }\n                cout << endl;\n            }\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.10242128372192383,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding Borders",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<int> z_function(const std::string& s) {\n    int n = s.length();\n    std::vector<int> z(n);\n    int left = 0, right = 0;\n    for (int i = 1; i < n; i++) {\n        if (i <= right) {\n            z[i] = std::min(right - i + 1, z[i - left]);\n        }\n        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n            z[i]++;\n        }\n        if (i + z[i] - 1 > right) {\n            left = i;\n            right = i + z[i] - 1;\n        }\n    }\n    return z;\n}\n\nint main() {\n    std::string s;\n    std::cin >> s;\n    std::vector<int> z = z_function(s);\n    int n = s.length();\n    for (int i = 1; i < n; i++) {\n        if (z[i] == n - i) {\n            std::cout << i << \" \";\n        }\n    }\n    std::cout << n << std::endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 11,
            "mean_time_taken": 0.10200472311540083,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding Patterns",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate the longest prefix suffix array for a pattern\nvoid computeLPSArray(string pat, int M, vector<int>& lps) {\n    int len = 0;\n    lps[0] = 0;\n    int i = 1;\n    while (i < M) {\n        if (pat[i] == pat[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        } else {\n            if (len != 0) {\n                len = lps[len - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n}\n\n// Function to search for a pattern in a string using KMP algorithm\nbool KMPSearch(string pat, string txt) {\n    int M = pat.length();\n    int N = txt.length();\n\n    vector<int> lps(M);\n    computeLPSArray(pat, M, lps);\n\n    int i = 0;\n    int j = 0;\n    while (i < N) {\n        if (pat[j] == txt[i]) {\n            j++;\n            i++;\n        }\n        if (j == M) {\n            return true;\n            j = lps[j - 1];\n        } else if (i < N && pat[j] != txt[i]) {\n            if (j != 0)\n                j = lps[j - 1];\n            else\n                i = i + 1;\n        }\n    }\n    return false;\n}\n\nint main() {\n    string txt;\n    cin >> txt;\n\n    int k;\n    cin >> k;\n\n    for (int i = 0; i < k; i++) {\n        string pat;\n        cin >> pat;\n\n        if (KMPSearch(pat, txt))\n            cout << \"YES\" << endl;\n        else\n            cout << \"NO\" << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 17,
            "mean_time_taken": 0.4623531874488382,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                4,
                8,
                12,
                14,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding Periods",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvoid z_algorithm(string s, vector<int>& z) {\n    int n = s.length();\n    int left = 0, right = 0;\n    for (int i = 1; i < n; i++) {\n        if (i > right) {\n            left = right = i;\n            while (right < n && s[right - left] == s[right]) right++;\n            z[i] = right - left;\n            right--;\n        } else {\n            int k = i - left;\n            if (z[k] < right - i + 1) z[i] = z[k];\n            else {\n                left = i;\n                while (right < n && s[right - left] == s[right]) right++;\n                z[i] = right - left;\n                right--;\n            }\n        }\n    }\n}\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.length();\n    vector<int> z(n, 0);\n    z_algorithm(s, z);\n    for (int i = 1; i < n; i++) {\n        if (n % (i - z[i]) == 0) cout << i << \" \";\n    }\n    cout << n << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 14,
            "mean_time_taken": 0.1209538323538644,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding a Centroid",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 200005;\nvector<int> adj[MAX_N];\nint subtree_size[MAX_N];\nint centroid;\nint n;\n\nvoid dfs1(int u, int p) {\n    subtree_size[u] = 1;\n    for (int v : adj[u]) {\n        if (v != p) {\n            dfs1(v, u);\n            subtree_size[u] += subtree_size[v];\n        }\n    }\n}\n\nvoid dfs2(int u, int p, int largest_subtree) {\n    int max_subtree = max(largest_subtree, n - subtree_size[u]);\n    for (int v : adj[u]) {\n        if (v != p && subtree_size[v] > n / 2) {\n            dfs2(v, u, min(max_subtree, subtree_size[v]));\n        }\n    }\n    if (max_subtree <= n / 2) {\n        centroid = u;\n    }\n}\n\nint main() {\n    cin >> n;\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs1(1, 0);\n    dfs2(1, 0, 0);\n    cout << centroid << endl;\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 16,
            "mean_time_taken": 0.1322706788778305,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Fixed-Length Paths I",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nvector<int> adj[MAX_N];\nint n, k, ans;\n\nvoid dfs(int u, int p, int d, vector<int>& cnt) {\n    if (d > k) return;\n    if (d == k) ans++;\n    for (int v : adj[u]) {\n        if (v == p) continue;\n        dfs(v, u, d + 1, cnt);\n        cnt[u] += cnt[v];\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> n >> k;\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    vector<int> cnt(n + 1, 0);\n    dfs(1, 0, 0, cnt);\n    cout << ans << endl;\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 20,
            "mean_time_taken": 0.1444964289665222,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Fixed-Length Paths II",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nvector<int> adj[MAX_N];\nint subtree_size[MAX_N];\nint depth[MAX_N];\nint parent[MAX_N][20];\n\nvoid dfs(int u, int p) {\n    subtree_size[u] = 1;\n    parent[u][0] = p;\n    depth[u] = depth[p] + 1;\n    for (int i = 1; i < 20; i++) {\n        parent[u][i] = parent[parent[u][i - 1]][i - 1];\n    }\n    for (int v : adj[u]) {\n        if (v != p) {\n            dfs(v, u);\n            subtree_size[u] += subtree_size[v];\n        }\n    }\n}\n\nint lca(int u, int v) {\n    if (depth[u] < depth[v]) {\n        swap(u, v);\n    }\n    for (int i = 19; i >= 0; i--) {\n        if (depth[parent[u][i]] >= depth[v]) {\n            u = parent[u][i];\n        }\n    }\n    if (u == v) {\n        return u;\n    }\n    for (int i = 19; i >= 0; i--) {\n        if (parent[u][i] != parent[v][i]) {\n            u = parent[u][i];\n            v = parent[v][i];\n        }\n    }\n    return parent[u][0];\n}\n\nint main() {\n    int n, k1, k2;\n    cin >> n >> k1 >> k2;\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(1, 0);\n    long long ans = 0;\n    for (int u = 1; u <= n; u++) {\n        for (int v = 1; v <= n; v++) {\n            int d = depth[u] + depth[v] - 2 * depth[lca(u, v)];\n            if (d >= k1 && d <= k2) {\n                ans++;\n            }\n        }\n    }\n    cout << ans / 2 << endl;\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 23,
            "mean_time_taken": 0.649126436399377,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Flight Discount",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_NODES = 100005;\nconst long long INF = 1e18;\n\nint numNodes, numEdges;\nvector<pair<int, int>> graph[MAX_NODES];\nlong long dist[MAX_NODES][2];\n\nvoid dijkstra() {\n    priority_queue<pair<long long, pair<int, int>>, vector<pair<long long, pair<int, int>>>, greater<pair<long long, pair<int, int>>>> pq;\n    pq.push({0, {1, 0}});\n\n    while (!pq.empty()) {\n        long long cost = pq.top().first;\n        int node = pq.top().second.first;\n        int usedCoupon = pq.top().second.second;\n        pq.pop();\n\n        if (dist[node][usedCoupon] < cost) continue;\n\n        for (auto &edge : graph[node]) {\n            int nextNode = edge.first;\n            int edgeCost = edge.second;\n\n            if (dist[nextNode][usedCoupon] > dist[node][usedCoupon] + edgeCost) {\n                dist[nextNode][usedCoupon] = dist[node][usedCoupon] + edgeCost;\n                pq.push({dist[nextNode][usedCoupon], {nextNode, usedCoupon}});\n            }\n\n            if (usedCoupon == 0 && dist[nextNode][1] > dist[node][0] + edgeCost / 2) {\n                dist[nextNode][1] = dist[node][0] + edgeCost / 2;\n                pq.push({dist[nextNode][1], {nextNode, 1}});\n            }\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    cin >> numNodes >> numEdges;\n\n    for (int i = 1; i <= numEdges; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        graph[u].push_back({v, w});\n    }\n\n    for (int i = 1; i <= numNodes; i++) {\n        dist[i][0] = dist[i][1] = INF;\n    }\n\n    dist[1][0] = dist[1][1] = 0;\n    dijkstra();\n\n    cout << min(dist[numNodes][0], dist[numNodes][1]);\n\n    return 0;\n}",
            "passed_test_cases": 24,
            "total_test_cases": 24,
            "mean_time_taken": 0.13373037179311117,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Flight Route Requests",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nstruct Edge {\n    int source;\n    int destination;\n};\n\nstruct DisjointSetUnion {\n    std::vector<int> parent;\n    std::vector<int> rank;\n\n    DisjointSetUnion(int size) {\n        parent.resize(size);\n        rank.resize(size);\n        for (int i = 0; i < size; i++) {\n            parent[i] = i;\n            rank[i] = 1;\n        }\n    }\n\n    int find_set(int i) {\n        if (parent[i] == i) {\n            return i;\n        }\n        return parent[i] = find_set(parent[i]);\n    }\n\n    void union_sets(int i, int j) {\n        int parent_i = find_set(i);\n        int parent_j = find_set(j);\n        if (parent_i != parent_j) {\n            if (rank[parent_i] < rank[parent_j]) {\n                std::swap(parent_i, parent_j);\n            }\n            parent[parent_j] = parent_i;\n            rank[parent_i] += rank[parent_j];\n        }\n    }\n};\n\nint main() {\n    int num_cities, num_requests;\n    std::cin >> num_cities >> num_requests;\n\n    std::vector<Edge> edges(num_requests);\n    for (int i = 0; i < num_requests; i++) {\n        std::cin >> edges[i].source >> edges[i].destination;\n        edges[i].source--;\n        edges[i].destination--;\n    }\n\n    DisjointSetUnion dsu(num_cities);\n    int num_connections = 0;\n\n    for (const Edge& edge : edges) {\n        int parent_source = dsu.find_set(edge.source);\n        int parent_destination = dsu.find_set(edge.destination);\n        if (parent_source != parent_destination) {\n            dsu.union_sets(edge.source, edge.destination);\n            num_connections++;\n        }\n    }\n\n    std::cout << num_connections << std::endl;\n    return 0;\n}",
            "passed_test_cases": 8,
            "total_test_cases": 17,
            "mean_time_taken": 0.0904383659362793,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                9,
                11,
                12,
                15,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Flight Routes",
            "category": "Graph Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Flight Routes Check",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 1e5 + 5;\n\nvector<int> adj[MAX_N];\nbool visited[MAX_N];\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n    }\n\n    for (int i = 1; i <= n; i++) {\n        fill(visited, visited + MAX_N, false);\n        dfs(i);\n        for (int j = 1; j <= n; j++) {\n            if (!visited[j]) {\n                cout << \"NO\" << endl;\n                cout << i << \" \" << j << endl;\n                return 0;\n            }\n        }\n    }\n\n    cout << \"YES\" << endl;\n\n    return 0;\n}",
            "passed_test_cases": 14,
            "total_test_cases": 20,
            "mean_time_taken": 0.3730227589607239,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                4,
                6,
                8,
                14,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Food Division",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> a(n), b(n), diff(n);\n    int total_diff = 0, total_excess = 0;\n\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n\n    for (int i = 0; i < n; i++) {\n        std::cin >> b[i];\n        diff[i] = b[i] - a[i];\n        total_diff += diff[i];\n        if (diff[i] > 0) {\n            total_excess += diff[i];\n        }\n    }\n\n    if (total_diff != 0) {\n        std::cout << -1;\n    } else {\n        std::cout << total_excess;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 5,
            "mean_time_taken": 0.10362796783447266,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Forbidden Cities",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_NODES = 100005;\nvector<int> graph[MAX_NODES];\nint component[MAX_NODES];\n\nvoid dfs(int node, int component_number) {\n    component[node] = component_number;\n    for (int neighbor : graph[node]) {\n        if (component[neighbor] == 0) {\n            dfs(neighbor, component_number);\n        }\n    }\n}\n\nint main() {\n    int num_nodes, num_edges, num_queries;\n    cin >> num_nodes >> num_edges >> num_queries;\n\n    for (int i = 0; i < num_edges; i++) {\n        int node1, node2;\n        cin >> node1 >> node2;\n        graph[node1].push_back(node2);\n        graph[node2].push_back(node1);\n    }\n\n    int component_number = 1;\n    for (int i = 1; i <= num_nodes; i++) {\n        if (component[i] == 0) {\n            dfs(i, component_number);\n            component_number++;\n        }\n    }\n\n    for (int i = 0; i < num_queries; i++) {\n        int node1, node2, node3;\n        cin >> node1 >> node2 >> node3;\n\n        if (component[node1] != component[node2]) {\n            cout << \"YES\" << endl;\n        } else if (component[node1] != component[node3]) {\n            cout << \"YES\" << endl;\n        } else {\n            bool path_exists = false;\n            for (int neighbor : graph[node1]) {\n                if (neighbor != node3 && component[neighbor] == component[node2]) {\n                    path_exists = true;\n                    break;\n                }\n            }\n            cout << (path_exists ? \"NO\" : \"YES\") << endl;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 14,
            "mean_time_taken": 0.1333775860922677,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Forest Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<vector<int>> forest(n + 1, vector<int>(n + 1));\n    vector<vector<int>> prefixSum(n + 1, vector<int>(n + 1));\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            char c;\n            cin >> c;\n            forest[i][j] = (c == '*');\n            prefixSum[i][j] = prefixSum[i - 1][j] + prefixSum[i][j - 1] - prefixSum[i - 1][j - 1] + forest[i][j];\n        }\n    }\n\n    for (int i = 0; i < q; i++) {\n        int y1, x1, y2, x2;\n        cin >> y1 >> x1 >> y2 >> x2;\n        cout << prefixSum[y2][x2] - prefixSum[y1 - 1][x2] - prefixSum[y2][x1 - 1] + prefixSum[y1 - 1][x1 - 1] << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 3,
            "mean_time_taken": 0.21480862299601236,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Forest Queries II",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nconst int MAX_SIZE = 1005;\n\nint grid[MAX_SIZE][MAX_SIZE];\nint prefixSum[MAX_SIZE][MAX_SIZE];\n\nint main() {\n    int gridSize, numQueries;\n    std::cin >> gridSize >> numQueries;\n\n    char cell;\n    // Read input and initialize grid and prefix sum array\n    for (int row = 1; row <= gridSize; row++) {\n        for (int col = 1; col <= gridSize; col++) {\n            std::cin >> cell;\n            if (cell == '*') {\n                grid[row][col] = 1;\n            }\n            prefixSum[row][col] = grid[row][col] + prefixSum[row - 1][col] + prefixSum[row][col - 1] - prefixSum[row - 1][col - 1];\n        }\n    }\n\n    int queryType, row1, col1, row2, col2;\n    // Process queries\n    for (int query = 0; query < numQueries; query++) {\n        std::cin >> queryType;\n        if (queryType == 1) {\n            // Toggle the state of a square\n            std::cin >> row1 >> col1;\n            grid[row1][col1] = 1 - grid[row1][col1];\n            // Update prefix sum array\n            for (int row = row1; row <= gridSize; row++) {\n                for (int col = col1; col <= gridSize; col++) {\n                    prefixSum[row][col] = grid[row][col] + prefixSum[row - 1][col] + prefixSum[row][col - 1] - prefixSum[row - 1][col - 1];\n                }\n            }\n        } else {\n            // Count the number of trees in a rectangle\n            std::cin >> row1 >> col1 >> row2 >> col2;\n            std::cout << prefixSum[row2][col2] - prefixSum[row1 - 1][col2] - prefixSum[row2][col1 - 1] + prefixSum[row1 - 1][col1 - 1] << std::endl;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 5,
            "mean_time_taken": 0.5443236827850342,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Functional Graph Distribution",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nconst int MODULO = 1e9 + 7;\n\nint main() {\n    int numberOfElements;\n    std::cin >> numberOfElements;\n\n    // Initialize an array to store the number of graphs for each value of k\n    std::vector<long long> dynamicProgramming(numberOfElements + 1, 0);\n    dynamicProgramming[1] = 1; // Set the base case for k = 1 to 1\n\n    // Loop through all values of k from 2 to n\n    for (int currentElement = 2; currentElement <= numberOfElements; ++currentElement) {\n        // For each value of k, loop through all values of j from 1 to k - 1\n        for (int previousElement = 1; previousElement < currentElement; ++previousElement) {\n            // Calculate the number of graphs for the current value of k\n            dynamicProgramming[currentElement] = (dynamicProgramming[currentElement] + dynamicProgramming[previousElement] * (numberOfElements - previousElement) % MODULO) % MODULO;\n        }\n    }\n\n    // Print the number of graphs for each value of k\n    for (int elementIndex = 1; elementIndex <= numberOfElements; ++elementIndex) {\n        std::cout << dynamicProgramming[elementIndex] << std::endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.09792765974998474,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Game Routes",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1e5 + 5;\nconst int MOD = 1e9 + 7;\n\nint n, m;\nvector<int> adj[MAX_N];\nint indegree[MAX_N];\nint dp[MAX_N];\n\nvoid topological_sort() {\n    queue<int> q;\n    for (int i = 1; i <= n; i++) {\n        if (indegree[i] == 0) {\n            q.push(i);\n        }\n    }\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : adj[u]) {\n            indegree[v]--;\n            if (indegree[v] == 0) {\n                q.push(v);\n            }\n        }\n    }\n}\n\nint main() {\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        indegree[v]++;\n    }\n    topological_sort();\n    dp[1] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j : adj[i]) {\n            dp[j] = (dp[j] + dp[i]) % MOD;\n        }\n    }\n    cout << dp[n] << endl;\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 15,
            "mean_time_taken": 0.11664900779724122,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                5,
                6,
                8,
                9,
                10,
                11,
                12,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Giant Pizza",
            "category": "Graph Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Graph Girth",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> dist(n, vector<int>(n, INT_MAX));\n    int girth = INT_MAX;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        dist[a - 1][b - 1] = 1;\n        dist[b - 1][a - 1] = 1;\n    }\n\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX) {\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (dist[i][j] < INT_MAX) {\n                for (int k = 0; k < n; k++) {\n                    if (i != k && j != k && dist[i][k] < INT_MAX && dist[k][j] < INT_MAX) {\n                        girth = min(girth, dist[i][k] + dist[k][j]);\n                    }\n                }\n            }\n        }\n    }\n\n    if (girth == INT_MAX) {\n        cout << -1 << endl;\n    } else {\n        cout << girth << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 20,
            "mean_time_taken": 0.4817817211151123,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Graph Paths I",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <cstring>\n\nconst int MAX_N = 105;\nconst int MOD = 1e9 + 7;\n\nint n, m, k;\nstd::vector<int> adj[MAX_N];\nint dp[MAX_N][MAX_N];\n\nint main() {\n    std::cin >> n >> m >> k;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        std::cin >> a >> b;\n        adj[a].push_back(b);\n    }\n\n    dp[1][0] = 1;\n\n    for (int edge = 1; edge <= k; edge++) {\n        for (int node = 1; node <= n; node++) {\n            for (int neighbor : adj[node]) {\n                dp[node][edge] = (dp[node][edge] + dp[neighbor][edge - 1]) % MOD;\n            }\n        }\n    }\n\n    std::cout << dp[n][k] << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 14,
            "mean_time_taken": 0.11558680874960763,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                5,
                6,
                7,
                8,
                9,
                10,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Graph Paths II",
            "category": "Mathematics",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Gray Code",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <bitset>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<std::bitset<16>> grayCode;\n    grayCode.push_back(0);\n\n    for (int i = 1; i < (1 << n); i++) {\n        grayCode.push_back(grayCode[i - 1] ^ (i & -i));\n    }\n\n    for (const auto& code : grayCode) {\n        std::cout << code.to_string().substr(16 - n) << std::endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Grid Completion",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <cstring>\n\nconst int MAX_SIZE = 505;\nconst int MOD = 1000000007;\n\nint gridSize;\nchar grid[MAX_SIZE][MAX_SIZE];\nint dp[MAX_SIZE][MAX_SIZE][2][2];\nint rowCount[MAX_SIZE], colCount[MAX_SIZE];\n\nint main() {\n    std::cin >> gridSize;\n    for (int i = 0; i < gridSize; i++) {\n        std::cin >> grid[i];\n        for (int j = 0; j < gridSize; j++) {\n            if (grid[i][j] == 'A') {\n                rowCount[i] |= 1;\n                colCount[j] |= 1;\n            }\n            if (grid[i][j] == 'B') {\n                rowCount[i] |= 2;\n                colCount[j] |= 2;\n            }\n        }\n    }\n\n    dp[0][0][0][0] = 1;\n    for (int i = 0; i < gridSize; i++) {\n        for (int j = 0; j < gridSize; j++) {\n            for (int k = 0; k < 2; k++) {\n                for (int l = 0; l < 2; l++) {\n                    if (grid[i][j] != '.') {\n                        if (i > 0) dp[i][j][k][l] = dp[i - 1][j][k][l];\n                        if (j > 0) dp[i][j][k][l] = (dp[i][j][k][l] + dp[i][j - 1][k][l]) % MOD;\n                        if (grid[i][j] == 'A') {\n                            if (k == 0) dp[i][j][k][l] = 0;\n                        } else {\n                            if (l == 0) dp[i][j][k][l] = 0;\n                        }\n                    } else {\n                        if (i > 0) dp[i][j][k | rowCount[i]][l] = (dp[i][j][k | rowCount[i]][l] + dp[i - 1][j][k][l]) % MOD;\n                        if (j > 0) dp[i][j][k][l | colCount[j]] = (dp[i][j][k][l | colCount[j]] + dp[i][j - 1][k][l]) % MOD;\n                        if (i > 0 && j > 0)\n                            dp[i][j][k | rowCount[i]][l | colCount[j]] = (dp[i][j][k | rowCount[i]][l | colCount[j]] + dp[i - 1][j - 1][k][l]) % MOD;\n                    }\n                }\n            }\n        }\n    }\n\n    std::cout << dp[gridSize - 1][gridSize - 1][1][1] << std::endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.10082753499348958,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Path Construction",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a path is possible and print the path\nvoid check_and_print_path(int n, int m, int y1, int x1, int y2, int x2) {\n    // If the starting and ending squares are in the same row or column, it's not possible to construct a path\n    if (y1 == y2 || x1 == x2) {\n        cout << \"NO\" << endl;\n        return;\n    }\n\n    // If the grid has only one row or one column, it's not possible to construct a path\n    if (n == 1 || m == 1) {\n        cout << \"NO\" << endl;\n        return;\n    }\n\n    // If the grid has two rows or two columns, it's possible to construct a path only if the starting and ending squares are adjacent\n    if (n == 2 || m == 2) {\n        if (abs(y1 - y2) + abs(x1 - x2) == 1) {\n            cout << \"YES\" << endl;\n            string path = \"\";\n            if (y1 < y2) path += \"D\";\n            if (y1 > y2) path += \"U\";\n            if (x1 < x2) path += \"R\";\n            if (x1 > x2) path += \"L\";\n            cout << path << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n        return;\n    }\n\n    // If the grid has more than two rows and more than two columns, it's possible to construct a path\n    cout << \"YES\" << endl;\n    string path = \"\";\n\n    // Move to the same row as the starting square\n    if (y1 < y2) {\n        path += string(y2 - y1, 'D');\n    } else {\n        path += string(y1 - y2, 'U');\n    }\n\n    // Move to the same column as the ending square\n    if (x1 < x2) {\n        path += string(x2 - x1, 'R');\n    } else {\n        path += string(x1 - x2, 'L');\n    }\n\n    // Move to the last row\n    if (y1 < y2) {\n        path += string(n - y2, 'U');\n        path += string(m - 1, 'L');\n        path += string(n - 1, 'D');\n    } else {\n        path += string(n - y1, 'D');\n        path += string(m - 1, 'L');\n        path += string(n - 1, 'U');\n    }\n\n    // Move to the last column\n    if (x1 < x2) {\n        path += string(m - x2, 'L');\n    } else {\n        path += string(m - x1, 'R');\n    }\n\n    cout << path << endl;\n}\n\nint main() {\n    int t;\n    cin >> t;\n\n    // Loop through all test cases\n    for (int i = 0; i < t; i++) {\n        int n, m, y1, x1, y2, x2;\n        cin >> n >> m >> y1 >> x1 >> y2 >> x2;\n\n        // Check if a path is possible and print the path\n        check_and_print_path(n, m, y1, x1, y2, x2);\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 20,
            "mean_time_taken": 0.08092098236083985,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Paths",
            "category": "Introductory Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int MAX_N = 1e6 + 5;\n\nint n, m;\nvector<pair<int, int>> traps;\nint dp[MAX_N];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n >> m;\n    traps.resize(m);\n    for (int i = 0; i < m; i++) {\n        cin >> traps[i].first >> traps[i].second;\n    }\n    sort(traps.begin(), traps.end());\n\n    dp[1] = 1;\n    int j = 0;\n    for (int i = 1; i <= n; i++) {\n        while (j < m && traps[j].first == i) {\n            dp[traps[j].second] = 0;\n            j++;\n        }\n        for (int k = 1; k <= n; k++) {\n            dp[k] = (dp[k] + dp[k - 1]) % MOD;\n        }\n    }\n\n    cout << dp[n] << endl;\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 20,
            "mean_time_taken": 0.3177094340324402,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Paths",
            "category": "Introductory Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Grid Paths",
            "category": "Introductory Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Grid Puzzle I",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> a(n), b(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> b[i];\n    }\n\n    int total_a = 0, total_b = 0;\n    for (int i = 0; i < n; i++) {\n        total_a += a[i];\n        total_b += b[i];\n    }\n\n    if (total_a != total_b) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    vector<vector<char>> grid(n, vector<char>(n, '.'));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (a[i] > 0 && b[j] > 0) {\n                grid[i][j] = 'X';\n                a[i]--;\n                b[j]--;\n            }\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << grid[i][j];\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 12,
            "mean_time_taken": 0.08135533332824707,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                6,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Puzzle II",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 55;\nconst int INF = 1e9;\n\nint n, a[MAX_N], b[MAX_N], c[MAX_N][MAX_N];\nint u[MAX_N], v[MAX_N], p[MAX_N], way[MAX_N];\nbool used[MAX_N];\n\nbool try_kuhn(int i) {\n    if (used[i]) return false;\n    used[i] = true;\n    for (int j = 1; j <= n; j++) {\n        if (c[i][j] == INF) continue;\n        if (v[j] == -1 || try_kuhn(v[j])) {\n            u[i] = j;\n            v[j] = i;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    for (int i = 1; i <= n; i++) cin >> b[i];\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            cin >> c[i][j];\n            c[i][j] = -c[i][j];\n        }\n    }\n\n    for (int k = 1; k <= n; k++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                c[i][j] = min(c[i][j], c[i][k] + c[k][j]);\n            }\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (a[i] > 0 && b[j] > 0) {\n                p[i] = j;\n                a[i]--;\n                b[j]--;\n                break;\n            }\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        fill(u + 1, u + n + 1, -1);\n        fill(v + 1, v + n + 1, -1);\n        while (true) {\n            fill(used + 1, used + n + 1, false);\n            if (try_kuhn(i)) break;\n            int delta = INF;\n            for (int i = 1; i <= n; i++) {\n                if (!used[i]) continue;\n                for (int j = 1; j <= n; j++) {\n                    if (used[j]) continue;\n                    delta = min(delta, c[i][j] - p[i] - p[j]);\n                }\n            }\n            for (int i = 1; i <= n; i++) {\n                if (used[i]) p[i] += delta;\n                if (!used[i]) p[j] -= delta;\n            }\n        }\n    }\n\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n        if (u[i] != -1) {\n            ans += -c[i][u[i]];\n            way[u[i]] = i;\n        }\n    }\n\n    cout << ans << \"\\n\";\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (way[j] == i) cout << \"X\";\n            else cout << \".\";\n        }\n        cout << \"\\n\";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Grundy's Game",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        // Check if n is a power of 2\n        if (n & (n - 1)) {\n            cout << \"first\\n\";\n        } else {\n            cout << \"second\\n\";\n        }\n    }\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 3,
            "mean_time_taken": 0.12527704238891602,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Hamiltonian Flights",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nint n, m, adj[21][21], dp[21][1 << 21][21];\n\nint main() {\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u - 1][v - 1] = 1;\n    }\n    dp[0][1][0] = 1;\n    for (int i = 1; i < n; i++) {\n        for (int mask = 1; mask < (1 << n); mask++) {\n            for (int j = 0; j < n; j++) {\n                if (!(mask & (1 << j))) {\n                    for (int k = 0; k < n; k++) {\n                        if (adj[k][j] && (mask & (1 << k))) {\n                            dp[j][mask | (1 << j)][i] = (dp[j][mask | (1 << j)][i] + dp[k][mask][i]) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for (int mask = 1; mask < (1 << n); mask++) {\n        if (mask & (1 << (n - 1))) {\n            for (int i = 0; i < n; i++) {\n                if (adj[i][n - 1]) {\n                    ans = (ans + dp[n - 1][mask][i]) % MOD;\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Hamming Distance",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    int n, k;\n    std::cin >> n >> k;\n\n    std::vector<std::string> bitStrings(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> bitStrings[i];\n    }\n\n    int minHammingDistance = k;\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int hammingDistance = 0;\n            for (int l = 0; l < k; l++) {\n                if (bitStrings[i][l] != bitStrings[j][l]) {\n                    hammingDistance++;\n                }\n            }\n            minHammingDistance = std::min(minHammingDistance, hammingDistance);\n        }\n    }\n\n    std::cout << minHammingDistance << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 15,
            "mean_time_taken": 0.6621227423350017,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                4,
                5,
                6,
                7,
                8,
                9,
                12,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "High Score",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2505;\nconst int MAX_M = 5005;\nconst long long INF = 1e18;\n\nint n, m;\nlong long dist[MAX_N];\nvector<pair<int, int>> adj[MAX_N];\n\nvoid bellman_ford() {\n    fill(dist, dist + n + 1, -INF);\n    dist[1] = 0;\n\n    for (int i = 1; i <= n - 1; i++) {\n        for (int j = 1; j <= n; j++) {\n            for (auto &edge : adj[j]) {\n                int u = j;\n                int v = edge.first;\n                int w = edge.second;\n                dist[v] = max(dist[v], dist[u] + w);\n            }\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (auto &edge : adj[i]) {\n            int u = i;\n            int v = edge.first;\n            int w = edge.second;\n            if (dist[u] + w > dist[v]) {\n                cout << -1 << endl;\n                return;\n            }\n        }\n    }\n\n    cout << dist[n] << endl;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n >> m;\n\n    for (int i = 1; i <= m; i++) {\n        int a, b, x;\n        cin >> a >> b >> x;\n        adj[a].push_back({b, x});\n    }\n\n    bellman_ford();\n\n    return 0;\n}",
            "passed_test_cases": 34,
            "total_test_cases": 43,
            "mean_time_taken": 0.09644949158956838,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                6,
                10,
                13,
                14,
                19,
                25,
                34,
                36,
                42
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Hotel Queries",
            "category": "Range Queries",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nint n, m, h[MAX_N], r[MAX_N], seg[4 * MAX_N];\n\nvoid update(int p, int v) {\n    for (seg[p += n] -= v, p >>= 1; p; p >>= 1)\n        seg[p] = max(seg[2 * p], seg[2 * p + 1]);\n}\n\nint query(int l, int r) {\n    int res = 0;\n    for (l += n - 1, r += n + 1; l ^ r ^ 1; l >>= 1, r >>= 1) {\n        if (~l & 1) res = max(res, seg[l ^ 1]);\n        if ( r & 1) res = max(res, seg[r ^ 1]);\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n >> m;\n    for (int i = 0; i < n; i++) cin >> h[i];\n    for (int i = 0; i < m; i++) cin >> r[i];\n\n    copy(h, h + n, seg + n);\n    for (int i = n - 1; i > 0; i--) seg[i] = max(seg[2 * i], seg[2 * i + 1]);\n\n    for (int i = 0; i < m; i++) {\n        int p = query(0, r[i]);\n        if (p >= r[i]) {\n            cout << lower_bound(h, h + n, r[i]) - h + 1 << \" \";\n            update(lower_bound(h, h + n, r[i]) - h, r[i]);\n        } else {\n            cout << \"0 \";\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 11,
            "mean_time_taken": 0.09838201782920143,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                7,
                8,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Houses and Schools",
            "category": "Advanced Techniques",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Increasing Array",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, prev, curr, moves = 0;\n    cin >> n >> prev;\n    for (int i = 1; i < n; i++) {\n        cin >> curr;\n        if (curr < prev) {\n            moves += prev - curr;\n            curr = prev;\n        }\n        prev = curr;\n    }\n    cout << moves << endl;\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 7,
            "mean_time_taken": 0.09369533402579171,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                4,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Increasing Array II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    priority_queue<int, vector<int>, greater<int>> pq;\n    long long moves = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (!pq.empty() && arr[i] < pq.top()) {\n            moves += pq.top() - arr[i];\n            pq.pop();\n        }\n        pq.push(arr[i]);\n    }\n\n    cout << moves << endl;\n\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 7,
            "mean_time_taken": 0.10863631112234932,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                4,
                5,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Increasing Array Queries",
            "category": "Range Queries",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n    long long min_val, sum, lazy;\n};\n\nNode tree[800005];\nlong long arr[200005];\n\nvoid push_down(long long node, long long left, long long right) {\n    long long mid = (left + right) / 2;\n    tree[node * 2].min_val += tree[node].lazy;\n    tree[node * 2].sum += tree[node].lazy * (mid - left + 1);\n    tree[node * 2].lazy += tree[node].lazy;\n    tree[node * 2 + 1].min_val += tree[node].lazy;\n    tree[node * 2 + 1].sum += tree[node].lazy * (right - mid);\n    tree[node * 2 + 1].lazy += tree[node].lazy;\n    tree[node].lazy = 0;\n}\n\nvoid update(long long node, long long left, long long right, long long i, long long j, long long val) {\n    if (left > j || right < i) return;\n    if (left >= i && right <= j) {\n        tree[node].min_val += val;\n        tree[node].sum += val * (right - left + 1);\n        tree[node].lazy += val;\n        return;\n    }\n    push_down(node, left, right);\n    long long mid = (left + right) / 2;\n    update(node * 2, left, mid, i, j, val);\n    update(node * 2 + 1, mid + 1, right, i, j, val);\n    tree[node].min_val = min(tree[node * 2].min_val, tree[node * 2 + 1].min_val);\n    tree[node].sum = tree[node * 2].sum + tree[node * 2 + 1].sum;\n}\n\nNode query(long long node, long long left, long long right, long long i, long long j) {\n    if (left > j || right < i) return {INT_MAX, 0, 0};\n    if (left >= i && right <= j) return tree[node];\n    push_down(node, left, right);\n    long long mid = (left + right) / 2;\n    Node left_query = query(node * 2, left, mid, i, j);\n    Node right_query = query(node * 2 + 1, mid + 1, right, i, j);\n    Node result;\n    result.min_val = min(left_query.min_val, right_query.min_val + left_query.sum - left_query.min_val * (mid - i + 1));\n    result.sum = left_query.sum + right_query.sum;\n    return result;\n}\n\nvoid build(long long node, long long left, long long right) {\n    if (left == right) {\n        tree[node].min_val = arr[left];\n        tree[node].sum = arr[left];\n        return;\n    }\n    long long mid = (left + right) / 2;\n    build(node * 2, left, mid);\n    build(node * 2 + 1, mid + 1, right);\n    tree[node].min_val = min(tree[node * 2].min_val, tree[node * 2 + 1].min_val);\n    tree[node].sum = tree[node * 2].sum + tree[node * 2 + 1].sum;\n}\n\nint main() {\n    long long n, q;\n    cin >> n >> q;\n    for (long long i = 1; i <= n; i++) cin >> arr[i];\n    build(1, 1, n);\n    while (q--) {\n        long long a, b;\n        cin >> a >> b;\n        Node result = query(1, 1, n, a, b);\n        cout << result.sum - result.min_val * (b - a + 1) << endl;\n        update(1, 1, n, a, b, 1);\n    }\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.4769328236579895,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Increasing Subsequence",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> arr[i];\n    }\n\n    std::vector<int> tail;\n    for (int i = 0; i < n; i++) {\n        auto it = std::lower_bound(tail.begin(), tail.end(), arr[i]);\n        if (it == tail.end()) {\n            tail.push_back(arr[i]);\n        } else {\n            *it = arr[i];\n        }\n    }\n\n    std::cout << tail.size() << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 17,
            "total_test_cases": 17,
            "mean_time_taken": 0.09991585507112391,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Increasing Subsequence II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nconst int MOD = 1e9 + 7;\n\n// Segment tree data structure to store cumulative sum of subsequences\nstruct SegmentTree {\n    vector<int> tree;\n    int n;\n\n    SegmentTree(int size) {\n        n = size;\n        tree.assign(4 * n, 0);\n    }\n\n    // Update the value at a given position in the segment tree\n    void update(int pos, int val) {\n        pos += n;\n        tree[pos] = val;\n        for (pos /= 2; pos > 0; pos /= 2) {\n            tree[pos] = (tree[2 * pos] + tree[2 * pos + 1]) % MOD;\n        }\n    }\n\n    // Query the cumulative sum of subsequences ending at a given position\n    int query(int l, int r) {\n        int res = 0;\n        for (l += n, r += n + 1; l < r; l /= 2, r /= 2) {\n            if (l & 1) res = (res + tree[l++]) % MOD;\n            if (r & 1) res = (res + tree[--r]) % MOD;\n        }\n        return res;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    vector<int> sortedArr = arr;\n    sort(sortedArr.begin(), sortedArr.end());\n\n    SegmentTree segTree(sortedArr.size());\n    int total = 0;\n\n    for (int i = 0; i < n; i++) {\n        int pos = lower_bound(sortedArr.begin(), sortedArr.end(), arr[i]) - sortedArr.begin();\n        int count = segTree.query(0, pos - 1) + 1;\n        total = (total + count) % MOD;\n        segTree.update(pos, count);\n    }\n\n    cout << total << endl;\n\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 10,
            "mean_time_taken": 0.1244659185409546,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                5,
                6,
                7,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Intersection Points",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Event {\n    int x, y, type;\n    Event(int x, int y, int type) : x(x), y(y), type(type) {}\n    bool operator<(const Event& other) const {\n        if (y != other.y) return y < other.y;\n        return type > other.type;\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    set<Event> events;\n    for (int i = 0; i < n; i++) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        if (y1 == y2) {\n            events.insert(Event(min(x1, x2), y1, 0));\n            events.insert(Event(max(x1, x2), y1, 1));\n        } else {\n            events.insert(Event(x1, min(y1, y2), 2));\n            events.insert(Event(x1, max(y1, y2), 3));\n            auto it = events.lower_bound(Event(x1, min(y1, y2), -1));\n            while (it != events.end() && it->y <= max(y1, y2)) {\n                if (it->type == 0 && it->x > x1 && it->x < x2) {\n                    events.insert(Event(it->x, min(y1, y2), 4));\n                }\n                it++;\n            }\n        }\n    }\n    int count = 0, active = 0;\n    for (auto it = events.begin(); it != events.end(); it++) {\n        if (it->type == 0 || it->type == 2) {\n            active++;\n        } else if (it->type == 1 || it->type == 3) {\n            active--;\n        } else {\n            count += active - 1;\n        }\n    }\n    cout << count << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 5,
            "mean_time_taken": 0.4591639995574951,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Inverse Inversions",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nint main() {\n    int n, k;\n    std::cin >> n >> k;\n\n    // Create an array of numbers from 1 to n\n    std::vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        arr[i] = i + 1;\n    }\n\n    // Start from the end of the array and swap elements to create inversions\n    for (int i = n - 1; i >= 0 && k > 0; i--) {\n        int swap_index = i - std::min(k, i);\n        std::swap(arr[i], arr[swap_index]);\n        k -= std::min(k, i);\n    }\n\n    // Print the resulting permutation\n    for (int i = 0; i < n; i++) {\n        std::cout << arr[i] << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 10,
            "mean_time_taken": 0.096339750289917,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                8,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Inversion Probability",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <iomanip>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> r(n);\n    for (int i = 0; i < n; i++) {\n        cin >> r[i];\n    }\n\n    double expected_inversions = 0.0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            double prob = 0.0;\n            for (int k = 1; k <= r[i]; k++) {\n                if (k > r[j]) {\n                    prob += 1.0 / r[i];\n                }\n            }\n            expected_inversions += prob;\n        }\n    }\n\n    cout << fixed << setprecision(6) << expected_inversions << endl;\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 20,
            "mean_time_taken": 0.08034095764160157,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Investigation",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_NODES = 100005;\nconst long long MOD = 1e9 + 7;\n\nstruct Edge {\n    int destination;\n    long long weight;\n};\n\nvector<Edge> graph[MAX_NODES];\nlong long distances[MAX_NODES];\nlong long ways[MAX_NODES];\nint min_steps[MAX_NODES];\nint max_steps[MAX_NODES];\n\nvoid dijkstra(int start_node, int end_node) {\n    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\n    pq.push({0, start_node});\n    fill(distances, distances + MAX_NODES, LONG_LONG_MAX);\n    distances[start_node] = 0;\n    ways[start_node] = 1;\n    min_steps[start_node] = 0;\n    max_steps[start_node] = 0;\n\n    while (!pq.empty()) {\n        long long distance = pq.top().first;\n        int node = pq.top().second;\n        pq.pop();\n\n        if (distance != distances[node]) continue;\n\n        for (Edge edge : graph[node]) {\n            if (distances[edge.destination] > distances[node] + edge.weight) {\n                distances[edge.destination] = distances[node] + edge.weight;\n                ways[edge.destination] = ways[node];\n                min_steps[edge.destination] = min_steps[node] + 1;\n                max_steps[edge.destination] = max_steps[node] + 1;\n                pq.push({distances[edge.destination], edge.destination});\n            } else if (distances[edge.destination] == distances[node] + edge.weight) {\n                ways[edge.destination] = (ways[edge.destination] + ways[node]) % MOD;\n                min_steps[edge.destination] = min(min_steps[edge.destination], min_steps[node] + 1);\n                max_steps[edge.destination] = max(max_steps[edge.destination], max_steps[node] + 1);\n            }\n        }\n    }\n}\n\nint main() {\n    int num_nodes, num_edges;\n    cin >> num_nodes >> num_edges;\n\n    for (int i = 0; i < num_edges; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        graph[u].push_back({v, w});\n    }\n\n    dijkstra(1, num_nodes);\n\n    cout << distances[num_nodes] << \" \" << ways[num_nodes] << \" \" << min_steps[num_nodes] << \" \" << max_steps[num_nodes] << endl;\n\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.15239646434783935,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Josephus Problem I",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <deque>\n#include <vector>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> removal_order;\n    std::deque<int> children;\n\n    for (int i = 1; i <= n; i++) {\n        children.push_back(i);\n    }\n\n    while (!children.empty()) {\n        removal_order.push_back(children.front());\n        children.pop_front();\n\n        if (!children.empty()) {\n            children.push_back(children.front());\n            children.pop_front();\n        }\n    }\n\n    for (int i = 0; i < removal_order.size(); i++) {\n        std::cout << removal_order[i] << \" \";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 13,
            "mean_time_taken": 0.08133382063645583,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Josephus Problem II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n\nint main() {\n    int n, k;\n    std::cin >> n >> k;\n\n    std::vector<int> removal_order;\n    int current_position = 0;\n\n    for (int i = 0; i < n; i++) {\n        current_position = (current_position + k) % (n - i);\n        removal_order.push_back(current_position + 1);\n        current_position = current_position % (n - i - 1);\n    }\n\n    for (int i = 0; i < n; i++) {\n        std::cout << removal_order[i] << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 17,
            "mean_time_taken": 0.1307509927188649,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Josephus Queries",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n// Function to find the position of the kth person in the circle of n people\nlong long josephus(long long n, long long k) {\n    // Base case: if there is only one person, return 1\n    if (n == 1) return 1;\n    // Otherwise, recursively find the position of the (k-1)th person in the circle of (n-1) people\n    // and add k to it, then take the modulo of n to adjust for the removed people\n    else return (josephus(n - 1, k) + k - 1) % n + 1;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    // Read the number of queries\n    long long queries;\n    cin >> queries;\n\n    // Process each query\n    while (queries--) {\n        long long n, k;\n        cin >> n >> k;\n\n        // If k is less than or equal to n/2, use the recursive function to find the answer\n        if (k <= n / 2) {\n            cout << josephus(n, 2 * k) << endl;\n        }\n        // Otherwise, use the formula to find the answer\n        else {\n            cout << (2 * k - n - 1 + josephus(n - (n - k), 2)) % n + 1 << endl;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.20172905921936035,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Knight's Tour",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <cstring>\n\nconst int BOARD_SIZE = 8;\nint board[BOARD_SIZE][BOARD_SIZE];\nint moveX[8] = {2, 1, -1, -2, -2, -1, 1, 2};\nint moveY[8] = {1, 2, 2, 1, -1, -2, -2, -1};\n\nbool tryMove(int x, int y, int moveNumber) {\n    if (moveNumber > BOARD_SIZE * BOARD_SIZE) return true;\n    for (int i = 0; i < 8; i++) {\n        int newX = x + moveX[i];\n        int newY = y + moveY[i];\n        if (newX >= 0 && newX < BOARD_SIZE && newY >= 0 && newY < BOARD_SIZE && board[newX][newY] == 0) {\n            board[newX][newY] = moveNumber;\n            if (tryMove(newX, newY, moveNumber + 1)) return true;\n            board[newX][newY] = 0;\n        }\n    }\n    return false;\n}\n\nint main() {\n    int startX, startY;\n    std::cin >> startX >> startY;\n    startX--;\n    startY--;\n    memset(board, 0, sizeof(board));\n    board[startX][startY] = 1;\n    tryMove(startX, startY, 2);\n    for (int i = 0; i < BOARD_SIZE; i++) {\n        for (int j = 0; j < BOARD_SIZE; j++) {\n            std::cout << board[i][j] << \" \";\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 23,
            "mean_time_taken": 0.9049422740936279,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Knuth Division",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    priority_queue<long long> pq;\n    for (int i = 0; i < n; i++) {\n        long long x;\n        cin >> x;\n        pq.push(x);\n    }\n\n    long long total_cost = 0;\n    while (pq.size() > 1) {\n        long long a = pq.top();\n        pq.pop();\n        long long b = pq.top();\n        pq.pop();\n\n        total_cost += a + b;\n        pq.push(a + b);\n    }\n\n    cout << total_cost << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 0.08880813916524251,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Labyrinth",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_SIZE = 1005;\n\nint row_direction[] = {-1, 0, 1, 0};\nint col_direction[] = {0, 1, 0, -1};\nchar direction_char[] = {'U', 'R', 'D', 'L'};\n\nchar maze[MAX_SIZE][MAX_SIZE];\nint parent[MAX_SIZE][MAX_SIZE];\nbool visited[MAX_SIZE][MAX_SIZE];\n\nint rows, cols;\nint start_row, start_col, end_row, end_col;\n\nbool is_valid_move(int row, int col) {\n    return (row >= 0 && row < rows && col >= 0 && col < cols && maze[row][col] != '#' && !visited[row][col]);\n}\n\nvoid breadth_first_search() {\n    queue<pair<int, int>> q;\n    q.push({start_row, start_col});\n    visited[start_row][start_col] = true;\n\n    while (!q.empty()) {\n        int current_row = q.front().first;\n        int current_col = q.front().second;\n        q.pop();\n\n        if (current_row == end_row && current_col == end_col) {\n            return;\n        }\n\n        for (int i = 0; i < 4; i++) {\n            int new_row = current_row + row_direction[i];\n            int new_col = current_col + col_direction[i];\n\n            if (is_valid_move(new_row, new_col)) {\n                visited[new_row][new_col] = true;\n                parent[new_row][new_col] = i;\n                q.push({new_row, new_col});\n            }\n        }\n    }\n}\n\nvoid print_path() {\n    int current_row = end_row;\n    int current_col = end_col;\n    string path = \"\";\n\n    while (current_row != start_row || current_col != start_col) {\n        int dir = parent[current_row][current_col];\n        path += direction_char[dir];\n        current_row -= row_direction[dir];\n        current_col -= col_direction[dir];\n    }\n\n    reverse(path.begin(), path.end());\n    cout << \"YES\" << endl;\n    cout << path.size() << endl;\n    cout << path << endl;\n}\n\nint main() {\n    cin >> rows >> cols;\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            cin >> maze[i][j];\n\n            if (maze[i][j] == 'A') {\n                start_row = i;\n                start_col = j;\n            } else if (maze[i][j] == 'B') {\n                end_row = i;\n                end_col = j;\n            }\n        }\n    }\n\n    memset(parent, -1, sizeof(parent));\n    breadth_first_search();\n\n    if (parent[end_row][end_col] == -1) {\n        cout << \"NO\" << endl;\n    } else {\n        print_path();\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Letter Pair Move Game",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    int n, count = 0;\n    string s;\n    cin >> n >> s;\n    for (int i = 0; i < 2 * n; i++) {\n        if (s[i] == 'B') {\n            for (int j = i + 1; j < 2 * n; j++) {\n                if (s[j] == 'A') {\n                    count++;\n                    swap(s[i], s[j]);\n                    swap(s[i + 1], s[j + 1]);\n                    cout << s << endl;\n                    i += 2;\n                    break;\n                }\n            }\n        }\n    }\n    if (count > 10 * n) {\n        cout << \"-1\" << endl;\n    } else {\n        cout << count << endl;\n    }\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 24,
            "mean_time_taken": 0.0791813333829244,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                15,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Line Segment Intersection",
            "category": "Geometry",
            "solution": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// Function to calculate the orientation of an ordered triple of points (p, q, r)\n// Returns 0 if the points are collinear, 1 if the points are clockwise, and 2 if the points are counterclockwise\nint orientation(pair<int, int> p, pair<int, int> q, pair<int, int> r) {\n    int val = (q.second - p.second) * (r.first - q.first) - (q.first - p.first) * (r.second - q.second);\n    if (val == 0) return 0;\n    return (val > 0) ? 1 : 2;\n}\n\n// Function to check if two line segments intersect\n// Returns true if the line segments intersect and false otherwise\nbool doIntersect(pair<int, int> p1, pair<int, int> q1, pair<int, int> p2, pair<int, int> q2) {\n    int o1 = orientation(p1, q1, p2);\n    int o2 = orientation(p1, q1, q2);\n    int o3 = orientation(p2, q2, p1);\n    int o4 = orientation(p2, q2, q1);\n\n    if (o1 != o2 && o3 != o4) return true;\n\n    if (o1 == 0 && onSegment(p1, p2, q1)) return true;\n    if (o2 == 0 && onSegment(p1, q2, q1)) return true;\n    if (o3 == 0 && onSegment(p2, p1, q2)) return true;\n    if (o4 == 0 && onSegment(p2, q1, q2)) return true;\n\n    return false;\n}\n\n// Function to check if a point lies on a line segment\nbool onSegment(pair<int, int> p, pair<int, int> q, pair<int, int> r) {\n    if (q.first <= max(p.first, r.first) && q.first >= min(p.first, r.first) &&\n        q.second <= max(p.second, r.second) && q.second >= min(p.second, r.second))\n        return true;\n    return false;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        pair<int, int> p1, q1, p2, q2;\n        cin >> p1.first >> p1.second >> q1.first >> q1.second >> p2.first >> p2.second >> q2.first >> q2.second;\n        if (doIntersect(p1, q1, p2, q2))\n            cout << \"YES\" << endl;\n        else\n            cout << \"NO\" << endl;\n    }\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shot": 1
        },
        {
            "title": "List Removals",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <list>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::list<int> lst;\n    for (int i = 0; i < n; i++) {\n        int x;\n        std::cin >> x;\n        lst.push_back(x);\n    }\n\n    for (int i = 0; i < n; i++) {\n        int p;\n        std::cin >> p;\n\n        auto it = lst.begin();\n        std::advance(it, p - 1);\n\n        int removed_element = *it;\n        lst.erase(it);\n\n        std::cout << removed_element << \" \";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 9,
            "mean_time_taken": 0.31500302420722115,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                5,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "List of Sums",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> B(n * (n - 1) / 2);\n    for (int i = 0; i < n * (n - 1) / 2; i++) {\n        cin >> B[i];\n    }\n\n    sort(B.begin(), B.end());\n\n    vector<int> A(n);\n    A[0] = B[0] - B[1];\n    A[1] = B[1];\n\n    vector<int> diff(n * (n - 1) / 2 - 1);\n    for (int i = 2; i < n * (n - 1) / 2; i++) {\n        diff[i - 2] = B[i] - B[1];\n    }\n\n    for (int i = 2; i < n; i++) {\n        int min_diff = *min_element(diff.begin(), diff.end());\n        A[i] = min_diff;\n        for (int j = 0; j < n * (n - 1) / 2 - 1; j++) {\n            if (diff[j] == min_diff) {\n                diff[j] = INT_MAX;\n                break;\n            }\n        }\n        for (int j = 0; j < n * (n - 1) / 2 - 1; j++) {\n            if (diff[j] != INT_MAX) {\n                diff[j] -= min_diff;\n            }\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        cout << A[i] << \" \";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Longest Flight Route",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_NODES = 100005;\n\nint numNodes, numEdges;\nvector<int> graph[MAX_NODES];\nint inDegree[MAX_NODES];\nint outDegree[MAX_NODES];\nint distance[MAX_NODES];\nint parent[MAX_NODES];\n\nvoid topologicalSort() {\n    queue<int> q;\n    for (int i = 1; i <= numNodes; i++) {\n        if (inDegree[i] == 0) {\n            q.push(i);\n            distance[i] = 1;\n        }\n    }\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n\n        for (int neighbor : graph[node]) {\n            inDegree[neighbor]--;\n            if (inDegree[neighbor] == 0) {\n                q.push(neighbor);\n                distance[neighbor] = distance[node] + 1;\n            }\n            if (distance[neighbor] < distance[node] + 1) {\n                distance[neighbor] = distance[node] + 1;\n                parent[neighbor] = node;\n            }\n        }\n    }\n}\n\nint main() {\n    cin >> numNodes >> numEdges;\n\n    for (int i = 0; i < numEdges; i++) {\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        inDegree[v]++;\n        outDegree[u]++;\n    }\n\n    topologicalSort();\n\n    if (distance[numNodes] == 0) {\n        cout << \"IMPOSSIBLE\" << endl;\n        return 0;\n    }\n\n    cout << distance[numNodes] << endl;\n\n    vector<int> path;\n    int node = numNodes;\n    while (node != 0) {\n        path.push_back(node);\n        node = parent[node];\n    }\n\n    reverse(path.begin(), path.end());\n\n    for (int node : path) {\n        cout << node << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Longest Palindrome",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nstd::string preprocess(const std::string& s) {\n    std::string t = \"#\";\n    for (char c : s) {\n        t += c;\n        t += '#';\n    }\n    return t;\n}\n\nstd::string longest_palindrome(const std::string& s) {\n    std::string t = preprocess(s);\n    int n = t.length();\n    std::vector<int> p(n, 0);\n    int center = 0, right = 0;\n    int max_length = 0, center_index = 0;\n\n    for (int i = 1; i < n - 1; i++) {\n        int mirror = 2 * center - i;\n        if (right > i) {\n            p[i] = std::min(right - i, p[mirror]);\n        }\n\n        while (t[i + 1 + p[i]] == t[i - 1 - p[i]]) {\n            p[i]++;\n        }\n\n        if (i + p[i] > right) {\n            center = i;\n            right = i + p[i];\n        }\n\n        if (p[i] > max_length) {\n            max_length = p[i];\n            center_index = i;\n        }\n    }\n\n    int start = (center_index - max_length) / 2;\n    return s.substr(start, max_length);\n}\n\nint main() {\n    std::string s;\n    std::cin >> s;\n    std::cout << longest_palindrome(s) << std::endl;\n    return 0;\n}",
            "passed_test_cases": 13,
            "total_test_cases": 19,
            "mean_time_taken": 0.11817651045949835,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                6,
                7,
                9,
                14,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Mail Delivery",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<int> path;\n\nvoid dfs(int u) {\n    while (!adj[u].empty()) {\n        int v = adj[u].back();\n        adj[u].pop_back();\n        adj[v].erase(find(adj[v].begin(), adj[v].end(), u));\n        dfs(v);\n    }\n    path.push_back(u);\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    adj.resize(n + 1);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    int odd_degree_count = 0;\n    for (int i = 1; i <= n; i++) {\n        if (adj[i].size() % 2 == 1) {\n            odd_degree_count++;\n        }\n    }\n\n    if (odd_degree_count != 0 && odd_degree_count != 2) {\n        cout << \"IMPOSSIBLE\" << endl;\n        return 0;\n    }\n\n    dfs(1);\n\n    if (path.size() != m + 1) {\n        cout << \"IMPOSSIBLE\" << endl;\n        return 0;\n    }\n\n    for (int i = path.size() - 1; i >= 0; i--) {\n        cout << path[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Maximum Building I",
            "category": "Additional Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Maximum Building II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<string> forest(n);\n    for (int i = 0; i < n; i++) {\n        cin >> forest[i];\n    }\n\n    vector<vector<int>> dp(n, vector<int>(m));\n    vector<vector<int>> prefix_sum(n, vector<int>(m));\n\n    // Calculate prefix sum\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (forest[i][j] == '.') {\n                prefix_sum[i][j] = (j > 0 ? prefix_sum[i][j - 1] : 0) + 1;\n            }\n        }\n    }\n\n    // Calculate number of ways to place a building\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (forest[i][j] == '.') {\n                dp[i][j] = prefix_sum[i][j];\n                for (int k = i - 1; k >= 0; k--) {\n                    if (forest[k][j] == '*') {\n                        break;\n                    }\n                    dp[i][j] = min(dp[i][j], prefix_sum[k][j]);\n                }\n                for (int k = j - 1; k >= 0; k--) {\n                    if (forest[i][k] == '*') {\n                        break;\n                    }\n                    dp[i][j] = min(dp[i][j], dp[i][k]);\n                }\n            }\n        }\n    }\n\n    // Print number of ways to place a building\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cout << dp[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 13,
            "mean_time_taken": 0.5602329694307767,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Maximum Subarray Sum",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint max_subarray_sum(const std::vector<int>& nums) {\n    int max_sum = nums[0];\n    int current_sum = nums[0];\n\n    for (int i = 1; i < nums.size(); i++) {\n        current_sum = std::max(nums[i], current_sum + nums[i]);\n        max_sum = std::max(max_sum, current_sum);\n    }\n\n    return max_sum;\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> nums(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> nums[i];\n    }\n\n    int result = max_subarray_sum(nums);\n    std::cout << result << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 15,
            "mean_time_taken": 0.09135158856709798,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                6,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Maximum Subarray Sum II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int n, a, b;\n    cin >> n >> a >> b;\n\n    vector<int> arr(n), prefixSum(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n        prefixSum[i] = (i == 0) ? arr[i] : prefixSum[i - 1] + arr[i];\n    }\n\n    vector<int> dp(n, INT_MIN);\n    for (int i = a - 1; i < n; i++) {\n        dp[i] = max(dp[i - 1], prefixSum[i] - ((i - a) >= 0 ? prefixSum[i - a] : 0));\n        if (i >= b) {\n            dp[i] = max(dp[i], dp[i - b] + prefixSum[i] - prefixSum[i - b]);\n        }\n    }\n\n    cout << *max_element(dp.begin(), dp.end()) << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Maximum Xor Subarray",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> arr[i];\n    }\n\n    int max_xor_sum = 0;\n    int curr_xor = 0;\n\n    for (int i = 0; i < n; i++) {\n        curr_xor = std::max(curr_xor ^ arr[i], arr[i]);\n        max_xor_sum = std::max(max_xor_sum, curr_xor);\n    }\n\n    std::cout << max_xor_sum << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 9,
            "total_test_cases": 14,
            "mean_time_taken": 0.09386512211390904,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                4,
                6,
                12,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Meet in the Middle",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_SIZE = 45;\n\nint arraySize, targetSum;\nint inputArray[MAX_SIZE];\nvector<long long> sums;\nlong long result;\n\n// Generate all possible sums for a given half of the array using recursion\nvoid generateSums(int index, int end, long long currentSum) {\n    if (index == end) {\n        sums.push_back(currentSum);\n        return;\n    }\n    generateSums(index + 1, end, currentSum);\n    generateSums(index + 1, end, currentSum + inputArray[index]);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    // Read the input array size and target value\n    cin >> arraySize >> targetSum;\n\n    // Read the input array\n    for (int i = 0; i < arraySize; i++) {\n        cin >> inputArray[i];\n    }\n\n    // Generate all possible sums for the first half of the array\n    generateSums(0, arraySize / 2, 0);\n\n    // Sort the sums for the first half of the array\n    sort(sums.begin(), sums.end());\n\n    // Generate all possible sums for the second half of the array and count the number of pairs that sum up to the target value\n    generateSums(arraySize / 2, arraySize, 0);\n\n    // Use binary search to count the number of pairs of sums from the two halves that sum up to the target value\n    for (int i = 0; i < sums.size(); i++) {\n        result += upper_bound(sums.begin(), sums.end(), targetSum - sums[i]) - lower_bound(sums.begin(), sums.end(), targetSum - sums[i]);\n    }\n\n    // Print the result\n    cout << result << endl;\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 40,
            "mean_time_taken": 0.8359892308712006,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                40
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Message Route",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_NODES = 100005;\nvector<int> adj[MAX_NODES];\nint parent[MAX_NODES];\nbool visited[MAX_NODES];\n\nvoid bfs(int start) {\n    queue<int> q;\n    q.push(start);\n    visited[start] = true;\n    parent[start] = -1;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                parent[v] = u;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid print_path(int end) {\n    vector<int> path;\n    for (int at = end; at != -1; at = parent[at])\n        path.push_back(at);\n    reverse(path.begin(), path.end());\n\n    cout << path.size() << \"\\n\";\n    for (int node : path)\n        cout << node << \" \";\n    cout << \"\\n\";\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    bfs(1);\n\n    if (!visited[n])\n        cout << \"IMPOSSIBLE\\n\";\n    else\n        print_path(n);\n\n    return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.12842454512914023,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Minimal Rotation",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n\nint main() {\n    std::string inputString;\n    std::cin >> inputString;\n\n    // Concatenate the input string with itself\n    std::string concatenatedString = inputString + inputString;\n\n    int smallestIndex = 0;\n    int currentIndex = 1;\n\n    // Iterate through the concatenated string using a sliding window approach\n    while (currentIndex < inputString.size()) {\n        int firstStringIndex = smallestIndex;\n        int secondStringIndex = currentIndex;\n\n        // Compare the characters at the current indices\n        while (firstStringIndex < currentIndex + smallestIndex &&\n               concatenatedString[firstStringIndex] == concatenatedString[secondStringIndex]) {\n            firstStringIndex++;\n            secondStringIndex++;\n        }\n\n        // Update the index of the smallest character found so far\n        if (firstStringIndex < currentIndex + smallestIndex &&\n            concatenatedString[firstStringIndex] > concatenatedString[secondStringIndex]) {\n            currentIndex = currentIndex + smallestIndex - firstStringIndex + 1;\n            smallestIndex = firstStringIndex + 1;\n        } else {\n            currentIndex++;\n        }\n    }\n\n    // Extract the lexicographically minimal rotation of the original string\n    std::string result = concatenatedString.substr(smallestIndex, inputString.size());\n    std::cout << result << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 20,
            "mean_time_taken": 0.32176886796951293,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                4,
                6,
                11,
                12,
                14,
                15,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Minimizing Coins",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nconst int INF = 1e9;\n\nint main() {\n    int n, x;\n    std::cin >> n >> x;\n\n    std::vector<int> coins(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> coins[i];\n    }\n\n    std::vector<int> dp(x + 1, INF);\n    dp[0] = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = coins[i]; j <= x; j++) {\n            dp[j] = std::min(dp[j], dp[j - coins[i]] + 1);\n        }\n    }\n\n    if (dp[x] == INF) {\n        std::cout << -1 << std::endl;\n    } else {\n        std::cout << dp[x] << std::endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 16,
            "total_test_cases": 16,
            "mean_time_taken": 0.20456118881702423,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Minimum Euclidean Distance",
            "category": "Geometry",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n};\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<Point> points(n);\n    for (int i = 0; i < n; i++) {\n        cin >> points[i].x >> points[i].y;\n    }\n\n    sort(points.begin(), points.end(), [](const Point& a, const Point& b) {\n        return a.x < b.x;\n    });\n\n    long long min_distance_squared = LLONG_MAX;\n    for (int i = 1; i < n; i++) {\n        long long distance_squared = (long long)(points[i].x - points[i - 1].x) * (points[i].x - points[i - 1].x) +\n                                     (long long)(points[i].y - points[i - 1].y) * (points[i].y - points[i - 1].y);\n        min_distance_squared = min(min_distance_squared, distance_squared);\n    }\n\n    cout << min_distance_squared << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Missing Coin Sum",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> coins(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> coins[i];\n    }\n\n    std::sort(coins.begin(), coins.end());\n\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        if (sum + 1 < coins[i]) {\n            break;\n        }\n        sum += coins[i];\n    }\n\n    std::cout << sum + 1 << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 9,
            "mean_time_taken": 0.10786467128329807,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                5,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Missing Coin Sum Queries",
            "category": "Additional Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Missing Number",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int xor1 = 0;\n    for (int i = 1; i <= n; i++) {\n        xor1 ^= i;\n    }\n\n    int xor2 = 0;\n    for (int i = 0; i < n - 1; i++) {\n        int num;\n        cin >> num;\n        xor2 ^= num;\n    }\n\n    cout << (xor1 ^ xor2) << endl;\n    return 0;\n}",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.08820906707218715,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Money Sums",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> coins(n);\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        cin >> coins[i];\n        sum += coins[i];\n    }\n\n    vector<bool> dp(sum + 1, false);\n    dp[0] = true;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = sum; j >= coins[i]; j--) {\n            dp[j] = dp[j] || dp[j - coins[i]];\n        }\n    }\n\n    int count = 0;\n    for (int i = 1; i <= sum; i++) {\n        if (dp[i]) {\n            count++;\n        }\n    }\n\n    cout << count << endl;\n\n    for (int i = 1; i <= sum; i++) {\n        if (dp[i]) {\n            cout << i << \" \";\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.2113021337068998,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Monotone Subsequences",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n\n        if (k == 1 || k == n) {\n            for (int i = 1; i <= n; i++) {\n                cout << i << \" \";\n            }\n            cout << endl;\n        } else if (k > n / 2) {\n            cout << \"IMPOSSIBLE\" << endl;\n        } else {\n            for (int i = n - k + 1; i <= n; i++) {\n                cout << i << \" \";\n            }\n            for (int i = 1; i <= n - k; i++) {\n                cout << i << \" \";\n            }\n            cout << endl;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.08792722225189209,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Monster Game I",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n    vector<int> s(n), f(n);\n    for (int i = 0; i < n; i++) {\n        cin >> s[i];\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> f[i];\n    }\n    priority_queue<pair<int, int>> pq;\n    long long min_time = 0;\n    for (int i = 0; i < n; i++) {\n        long long kill_time = (long long)s[i] * x;\n        if (!pq.empty() && kill_time > pq.top().first) {\n            min_time += pq.top().first;\n            x = pq.top().second;\n            pq.pop();\n            pq.push({(long long)s[i] * x, f[i]});\n        } else {\n            min_time += kill_time;\n            x = f[i];\n        }\n    }\n    cout << min_time << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 5,
            "mean_time_taken": 0.12481675148010254,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Monster Game II",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<int> s(n), f(n), dp(n, 0);\n    for (int i = 0; i < n; i++) {\n        cin >> s[i];\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> f[i];\n    }\n\n    dp[0] = s[0] * x;\n    for (int i = 1; i < n; i++) {\n        dp[i] = min(dp[i - 1] + s[i] * x, dp[i - 1] + s[i] * f[i - 1]);\n        x = min(x, f[i - 1]);\n    }\n\n    cout << dp[n - 1] << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.12295922636985779,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Monsters",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_SIZE = 1005;\nint distance[MAX_SIZE][MAX_SIZE];\npair<int, int> parent[MAX_SIZE][MAX_SIZE];\nint row_direction[] = {-1, 0, 0, 1};\nint col_direction[] = {0, -1, 1, 0};\nchar direction_char[] = {'U', 'L', 'R', 'D'};\nchar grid[MAX_SIZE][MAX_SIZE];\n\nint main() {\n    int rows, cols;\n    scanf(\"%d %d\", &rows, &cols);\n\n    queue<pair<int, int>> queue;\n    for (int i = 0; i < rows; i++) {\n        scanf(\"%s\", grid[i]);\n        for (int j = 0; j < cols; j++) {\n            if (grid[i][j] == 'A') {\n                queue.push(make_pair(i, j));\n                distance[i][j] = 0;\n            } else {\n                distance[i][j] = INT_MAX;\n            }\n        }\n    }\n\n    bool found_exit = false;\n    while (!queue.empty()) {\n        pair<int, int> current_cell = queue.front();\n        queue.pop();\n\n        for (int k = 0; k < 4; k++) {\n            int new_row = current_cell.first + row_direction[k];\n            int new_col = current_cell.second + col_direction[k];\n\n            if (new_row >= 0 && new_row < rows && new_col >= 0 && new_col < cols && grid[new_row][new_col] != '#' && distance[new_row][new_col] > distance[current_cell.first][current_cell.second] + 1) {\n                distance[new_row][new_col] = distance[current_cell.first][current_cell.second] + 1;\n                parent[new_row][new_col] = make_pair(current_cell.first, current_cell.second);\n                queue.push(make_pair(new_row, new_col));\n\n                if (new_row == 0 || new_row == rows - 1 || new_col == 0 || new_col == cols - 1) {\n                    found_exit = true;\n                    break;\n                }\n            }\n        }\n\n        if (found_exit) {\n            break;\n        }\n    }\n\n    if (!found_exit) {\n        printf(\"NO\\n\");\n        return 0;\n    }\n\n    pair<int, int> current_cell;\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (i == 0 || i == rows - 1 || j == 0 || j == cols - 1) {\n                if (grid[i][j] != '#' && distance[i][j] != INT_MAX) {\n                    current_cell = make_pair(i, j);\n                    break;\n                }\n            }\n        }\n    }\n\n    vector<pair<int, int>> path;\n    while (true) {\n        path.push_back(current_cell);\n        if (grid[current_cell.first][current_cell.second] == 'A') {\n            break;\n        }\n        current_cell = parent[current_cell.first][current_cell.second];\n    }\n\n    printf(\"YES\\n\");\n    printf(\"%d\\n\", path.size());\n    for (int i = path.size() - 1; i > 0; i--) {\n        for (int k = 0; k < 4; k++) {\n            if (path[i].first + row_direction[k] == path[i - 1].first && path[i].second + col_direction[k] == path[i - 1].second) {\n                printf(\"%c\", direction_char[k]);\n                break;\n            }\n        }\n    }\n    printf(\"\\n\");\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Movie Festival",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<int, int>> movies(n);\n    for (int i = 0; i < n; i++) {\n        cin >> movies[i].first >> movies[i].second;\n    }\n\n    sort(movies.begin(), movies.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        return a.second < b.second;\n    });\n\n    int count = 1;\n    int lastEnd = movies[0].second;\n    for (int i = 1; i < n; i++) {\n        if (movies[i].first >= lastEnd) {\n            count++;\n            lastEnd = movies[i].second;\n        }\n    }\n\n    cout << count << endl;\n\n    return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.11962088671597568,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Movie Festival II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<pair<int, int>> movies(n);\n    for (int i = 0; i < n; i++) {\n        cin >> movies[i].first >> movies[i].second;\n    }\n\n    sort(movies.begin(), movies.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        return a.second < b.second;\n    });\n\n    priority_queue<int, vector<int>, greater<int>> minHeap;\n    int count = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (minHeap.size() < k) {\n            minHeap.push(movies[i].second);\n            count++;\n        } else if (movies[i].first > minHeap.top()) {\n            minHeap.pop();\n            minHeap.push(movies[i].second);\n        }\n    }\n\n    cout << count << endl;\n\n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 13,
            "mean_time_taken": 0.128006806740394,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Movie Festival Queries",
            "category": "Additional Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Moving Robots",
            "category": "Mathematics",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Multiplication Table",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int middle = (n + 1) / 2;\n    cout << middle * middle << endl;\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 8,
            "mean_time_taken": 0.08437865972518921,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Nearest Smaller Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <stack>\n#include <vector>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> arr[i];\n    }\n\n    std::stack<int> s;\n    std::vector<int> result(n);\n\n    for (int i = 0; i < n; i++) {\n        while (!s.empty() && arr[s.top()] >= arr[i]) {\n            s.pop();\n        }\n\n        if (!s.empty()) {\n            result[i] = s.top() + 1;\n        } else {\n            result[i] = 0;\n        }\n\n        s.push(i);\n    }\n\n    for (int i = 0; i < n; i++) {\n        std::cout << result[i] << \" \";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.10362372031578651,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Necessary Cities",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_NODES = 100005;\nvector<int> graph[MAX_NODES];\nint discovery_time[MAX_NODES];\nbool is_bridge[MAX_NODES];\nint timer;\n\nvoid dfs(int node, int parent) {\n    discovery_time[node] = timer++;\n    for (int neighbor : graph[node]) {\n        if (neighbor == parent) continue;\n        if (discovery_time[neighbor] == -1) {\n            dfs(neighbor, node);\n            if (discovery_time[node] < discovery_time[neighbor]) {\n                is_bridge[node] = true;\n            }\n        } else if (discovery_time[node] > discovery_time[neighbor]) {\n            is_bridge[node] = true;\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    memset(discovery_time, -1, sizeof(discovery_time));\n    timer = 0;\n    dfs(1, -1);\n    vector<int> bridges;\n    for (int i = 1; i <= n; i++) {\n        if (is_bridge[i]) {\n            bridges.push_back(i);\n        }\n    }\n    cout << bridges.size() << endl;\n    for (int bridge : bridges) {\n        cout << bridge << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.10116106271743774,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Necessary Roads",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 100005;\n\nint n, m;\nvector<int> adj[MAX_N];\nint disc[MAX_N], low[MAX_N];\nbool visited[MAX_N];\nvector<pair<int, int>> bridges;\n\nvoid dfs(int u, int p, int& time) {\n    visited[u] = true;\n    disc[u] = low[u] = time++;\n    for (int v : adj[u]) {\n        if (v == p) continue;\n        if (!visited[v]) {\n            dfs(v, u, time);\n            low[u] = min(low[u], low[v]);\n            if (low[v] > disc[u]) {\n                bridges.push_back({min(u, v), max(u, v)});\n            }\n        } else {\n            low[u] = min(low[u], disc[v]);\n        }\n    }\n}\n\nvoid find_bridges() {\n    int time = 0;\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            dfs(i, -1, time);\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    find_bridges();\n    sort(bridges.begin(), bridges.end());\n    cout << bridges.size() << endl;\n    for (auto bridge : bridges) {\n        cout << bridge.first << \" \" << bridge.second << endl;\n    }\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 5,
            "mean_time_taken": 0.12053933143615722,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Nested Ranges Check",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stack>\n\nusing namespace std;\n\nint main() {\n    int numberOfRanges;\n    cin >> numberOfRanges;\n\n    // Create a vector of pairs to store the ranges\n    vector<pair<int, int>> ranges(numberOfRanges);\n    // Create a vector of pairs to store the sorted ranges based on their start points and their original indices\n    vector<pair<int, int>> sortedRangesByStart(numberOfRanges);\n    // Create a vector of pairs to store the sorted ranges based on their end points and their original indices\n    vector<pair<int, int>> sortedRangesByEnd(numberOfRanges);\n    // Create a vector of pairs to store the sorted ranges based on their start points and end points\n    vector<pair<pair<int, int>, int>> sortedRanges(numberOfRanges);\n    // Create a vector of integers to store the result of whether each range contains another range\n    vector<int> containsAnotherRange(numberOfRanges);\n    // Create a stack of pairs to keep track of the ranges that can contain other ranges\n    stack<pair<int, int>> rangeStack;\n\n    // Read the ranges and store them in the vectors\n    for (int i = 0; i < numberOfRanges; i++) {\n        cin >> ranges[i].first >> ranges[i].second;\n        sortedRangesByStart[i] = make_pair(ranges[i].first, i);\n        sortedRangesByEnd[i] = make_pair(ranges[i].second, i);\n        sortedRanges[i] = make_pair(make_pair(ranges[i].first, ranges[i].second), i);\n    }\n\n    // Sort the ranges based on their start points and end points\n    sort(sortedRangesByStart.begin(), sortedRangesByStart.end());\n    sort(sortedRangesByEnd.begin(), sortedRangesByEnd.end());\n    sort(sortedRanges.begin(), sortedRanges.end());\n\n    // Iterate through the sorted ranges and perform a binary search to find the position of each range in the sorted ranges based on their end points\n    for (int i = 0; i < numberOfRanges; i++) {\n        int position = lower_bound(sortedRangesByEnd.begin(), sortedRangesByEnd.end(), make_pair(sortedRanges[i].first.first, 0)) - sortedRangesByEnd.begin();\n\n        // If the stack is empty or the top range can contain the current range, push the current range onto the stack\n        if (rangeStack.empty() || rangeStack.top().first >= sortedRanges[i].first.second) {\n            rangeStack.push(make_pair(sortedRanges[i].first.second, position));\n        }\n\n        // If the top range of the stack is the same as the current range, pop the top range from the stack\n        if (rangeStack.top().first == sortedRanges[i].first.second) {\n            rangeStack.pop();\n        }\n\n        // If the top range of the stack can be contained by the current range, set the result for the top range to 1\n        if (!rangeStack.empty() && rangeStack.top().second < position) {\n            containsAnotherRange[sortedRanges[i].second] = 1;\n        }\n\n        // If the position of the current range in the sorted ranges based on their end points is the same as the current index, set the result for the current range to 1\n        if (position == i) {\n            containsAnotherRange[sortedRanges[i].second] = 1;\n        }\n    }\n\n    // Print the results for whether each range contains another range\n    for (int i = 0; i < numberOfRanges; i++) {\n        cout << containsAnotherRange[i] << \" \";\n    }\n    cout << endl;\n\n    // Reset the stack and the result vector\n    while (!rangeStack.empty()) {\n        rangeStack.pop();\n    }\n    fill(containsAnotherRange.begin(), containsAnotherRange.end(), 0);\n\n    // Iterate through the sorted ranges in reverse order and perform a binary search to find the position of each range in the sorted ranges based on their start points\n    for (int i = numberOfRanges - 1; i >= 0; i--) {\n        int position = lower_bound(sortedRangesByStart.begin(), sortedRangesByStart.end(), make_pair(sortedRanges[i].first.second, 0)) - sortedRangesByStart.begin();\n\n        // If the stack is empty or the top range can contain the current range, push the current range onto the stack\n        if (rangeStack.empty() || rangeStack.top().first <= sortedRanges[i].first.first) {\n            rangeStack.push(make_pair(sortedRanges[i].first.first, position));\n        }\n\n        // If the top range of the stack is the same as the current range, pop the top range from the stack\n        if (rangeStack.top().first == sortedRanges[i].first.first) {\n            rangeStack.pop();\n        }\n\n        // If the top range of the stack can be contained by the current range, set the result for the top range to 1\n        if (!rangeStack.empty() && rangeStack.top().second > position) {\n            containsAnotherRange[sortedRanges[i].second] = 1;\n        }\n\n        // If the position of the current range in the sorted ranges based on their start points is the same as the current index, set the result for the current range to 1\n        if (position == i) {\n            containsAnotherRange[sortedRanges[i].second] = 1;\n        }\n    }\n\n    // Print the results for whether each range is contained by another range\n    for (int i = 0; i < numberOfRanges; i++) {\n        cout << containsAnotherRange[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.2936363418896993,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Nested Ranges Count",
            "category": "Sorting and Searching",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nint n, x[MAX_N], y[MAX_N], ans1[MAX_N], ans2[MAX_N];\npair<int, int> ranges[MAX_N];\nvector<int> idx;\n\nstruct SegmentTree {\n    int t[4 * MAX_N];\n    void update(int v, int tl, int tr, int pos, int val) {\n        if (tl == tr) {\n            t[v] = val;\n        } else {\n            int tm = (tl + tr) / 2;\n            if (pos <= tm)\n                update(v * 2, tl, tm, pos, val);\n            else\n                update(v * 2 + 1, tm + 1, tr, pos, val);\n            t[v] = max(t[v * 2], t[v * 2 + 1]);\n        }\n    }\n    int query(int v, int tl, int tr, int l, int r) {\n        if (l > r || l > tr || r < tl)\n            return 0;\n        if (l <= tl && tr <= r)\n            return t[v];\n        int tm = (tl + tr) / 2;\n        return max(query(v * 2, tl, tm, l, r), query(v * 2 + 1, tm + 1, tr, l, r));\n    }\n} st;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i];\n        ranges[i] = {x[i], y[i]};\n        idx.push_back(i);\n    }\n    sort(idx.begin(), idx.end(), [&](int i, int j) {\n        if (ranges[i].first == ranges[j].first)\n            return ranges[i].second > ranges[j].second;\n        return ranges[i].first < ranges[j].first;\n    });\n    for (int i = 0; i < n; i++) {\n        int j = idx[i];\n        ans1[j] = st.query(1, 0, n - 1, 0, lower_bound(x, x + n, y[j]) - x - 1);\n        st.update(1, 0, n - 1, lower_bound(x, x + n, y[j]) - x, y[j]);\n    }\n    st = SegmentTree();\n    sort(idx.begin(), idx.end(), [&](int i, int j) {\n        if (ranges[i].second == ranges[j].second)\n            return ranges[i].first < ranges[j].first;\n        return ranges[i].second > ranges[j].second;\n    });\n    for (int i = 0; i < n; i++) {\n        int j = idx[i];\n        ans2[j] = st.query(1, 0, n - 1, 0, lower_bound(y, y + n, x[j]) - y - 1);\n        st.update(1, 0, n - 1, lower_bound(y, y + n, x[j]) - y, x[j]);\n    }\n    for (int i = 0; i < n; i++)\n        cout << ans1[i] << \" \";\n    cout << \"\\n\";\n    for (int i = 0; i < n; i++)\n        cout << ans2[i] << \" \";\n    cout << \"\\n\";\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.248201052347819,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Network Breakdown",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_NODES = 100005;\n\nint parent[MAX_NODES];\nint rank[MAX_NODES];\nbool is_connected[MAX_NODES];\n\n// Find the parent of a node using path compression\nint find_parent(int node) {\n    if (parent[node] == node) return node;\n    return parent[node] = find_parent(parent[node]);\n}\n\n// Union two nodes using union by rank\nvoid union_nodes(int node1, int node2) {\n    int parent1 = find_parent(node1);\n    int parent2 = find_parent(node2);\n\n    if (parent1 == parent2) return;\n\n    if (rank[parent1] < rank[parent2]) {\n        parent[parent1] = parent2;\n    } else if (rank[parent1] > rank[parent2]) {\n        parent[parent2] = parent1;\n    } else {\n        parent[parent2] = parent1;\n        rank[parent1]++;\n    }\n}\n\nint main() {\n    int num_nodes, num_edges, num_queries;\n    cin >> num_nodes >> num_edges >> num_queries;\n\n    // Initialize parent and rank arrays\n    for (int i = 1; i <= num_nodes; i++) {\n        parent[i] = i;\n        rank[i] = 1;\n    }\n\n    // Read edges and connect nodes\n    for (int i = 0; i < num_edges; i++) {\n        int node1, node2;\n        cin >> node1 >> node2;\n        union_nodes(node1, node2);\n        is_connected[i] = true;\n    }\n\n    // Read queries and disconnect nodes\n    for (int i = 0; i < num_queries; i++) {\n        int node1, node2;\n        cin >> node1 >> node2;\n        is_connected[num_edges - i - 1] = false;\n    }\n\n    // Calculate the number of components after each query\n    int num_components = num_nodes;\n    for (int i = num_edges - 1; i >= 0; i--) {\n        if (!is_connected[i]) {\n            int parent1 = find_parent(node1);\n            int parent2 = find_parent(node2);\n\n            if (parent1 != parent2) {\n                num_components--;\n            }\n        }\n\n        if (i > 0 && is_connected[i] && is_connected[i - 1]) {\n            cout << num_components << \" \";\n        } else {\n            cout << num_components << endl;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Network Renovation",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_NODES = 100005;\n\nvector<int> adjacencyList[MAX_NODES];\nint subtreeSize[MAX_NODES];\nint totalNodes;\nint centroid;\n\nvoid calculateSubtreeSize(int node, int parent) {\n    subtreeSize[node] = 1;\n    for (int child : adjacencyList[node]) {\n        if (child != parent) {\n            calculateSubtreeSize(child, node);\n            subtreeSize[node] += subtreeSize[child];\n        }\n    }\n}\n\nvoid findCentroid(int node, int parent) {\n    for (int child : adjacencyList[node]) {\n        if (child != parent && subtreeSize[child] > totalNodes / 2) {\n            findCentroid(child, node);\n            return;\n        }\n    }\n    centroid = node;\n}\n\nvoid printConnections(int node, int parent, vector<pair<int, int>>& connections) {\n    for (int child : adjacencyList[node]) {\n        if (child != parent && subtreeSize[child] > totalNodes / 2) {\n            connections.push_back({node, child});\n            printConnections(child, node, connections);\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int node1, node2;\n    cin >> totalNodes;\n\n    for (int i = 1; i < totalNodes; i++) {\n        cin >> node1 >> node2;\n        adjacencyList[node1].push_back(node2);\n        adjacencyList[node2].push_back(node1);\n    }\n\n    calculateSubtreeSize(1, 0);\n    findCentroid(1, 0);\n\n    vector<pair<int, int>> connections;\n    printConnections(centroid, 0, connections);\n\n    cout << connections.size() << \"\\n\";\n    for (auto connection : connections) {\n        cout << connection.first << \" \" << connection.second << \"\\n\";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 21,
            "mean_time_taken": 0.09019628025236584,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "New Flight Routes",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\nconst int MAX_NODES = 100005;\n\nvector<int> adjacencyList[MAX_NODES];\nbool visited[MAX_NODES];\n\nvoid depthFirstSearch(int node) {\n    visited[node] = true;\n    for (int neighbor : adjacencyList[node]) {\n        if (!visited[neighbor]) {\n            depthFirstSearch(neighbor);\n        }\n    }\n}\n\nint main() {\n    int numNodes, numEdges;\n    cin >> numNodes >> numEdges;\n\n    for (int i = 0; i < numEdges; i++) {\n        int node1, node2;\n        cin >> node1 >> node2;\n        adjacencyList[node1].push_back(node2);\n    }\n\n    int connectedComponents = 0;\n    vector<pair<int, int>> newFlights;\n\n    for (int i = 1; i <= numNodes; i++) {\n        if (!visited[i]) {\n            connectedComponents++;\n            if (connectedComponents > 1) {\n                newFlights.push_back({i, newFlights[0].first});\n            }\n            depthFirstSearch(i);\n        }\n    }\n\n    cout << newFlights.size() << endl;\n    for (auto flight : newFlights) {\n        cout << flight.first << \" \" << flight.second << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 26,
            "mean_time_taken": 0.14067952449505144,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "New Roads Queries",
            "category": "Advanced Techniques",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Nim Game I",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int numberOfTestCases;\n    cin >> numberOfTestCases;\n\n    // Loop through each test case\n    while (numberOfTestCases--) {\n        int numberOfElements;\n        cin >> numberOfElements;\n\n        int xorResult = 0;\n        // Loop through each heap of sticks\n        for (int i = 0; i < numberOfElements; i++) {\n            int currentElement;\n            cin >> currentElement;\n\n            // XOR the number of sticks in each heap\n            xorResult ^= currentElement;\n        }\n\n        // If the XOR result is 0, the second player wins\n        // Otherwise, the first player wins\n        if (xorResult == 0)\n            cout << \"second\" << endl;\n        else\n            cout << \"first\" << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 4,
            "mean_time_taken": 0.10625344514846802,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Nim Game II",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int numberOfTestCases;\n    cin >> numberOfTestCases;\n\n    // Loop through each test case\n    while (numberOfTestCases--) {\n        int sizeOfArray;\n        cin >> sizeOfArray;\n\n        int array[sizeOfArray];\n        int xorResult = 0;\n\n        // Read the number of sticks in each heap and calculate the XOR of the remainders\n        for (int i = 0; i < sizeOfArray; i++) {\n            cin >> array[i];\n            xorResult ^= (array[i] % 4);\n        }\n\n        // Determine the winner based on the XOR result\n        if (xorResult != 0)\n            cout << \"first\\n\";\n        else\n            cout << \"second\\n\";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 4,
            "mean_time_taken": 0.09291702508926392,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Number Grid",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <algorithm>\n\nint main() {\n    // Read the row index and column index from the input\n    long long rowIndex, columnIndex;\n    std::cin >> rowIndex >> columnIndex;\n\n    // Calculate the minimum value between the row index and the column index\n    long long minValue = std::min(rowIndex, columnIndex);\n\n    // Calculate the difference between the row index and the column index\n    long long difference = std::abs(rowIndex - columnIndex);\n\n    // Calculate the result by adding the difference to the minimum value minus one\n    long long result = minValue - 1 + difference;\n\n    // Print the result\n    std::cout << result << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 20,
            "mean_time_taken": 0.0788619041442871,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                12,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Number Spiral",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    // Read the number of test cases\n    long long numberOfTestCases;\n    cin >> numberOfTestCases;\n\n    // Loop through each test case\n    while (numberOfTestCases--) {\n        long long row, column;\n        cin >> row >> column;\n\n        // Determine the maximum value between the row and column numbers\n        long long maxValue = max(row, column);\n\n        // Calculate the starting number of the layer\n        long long layerStart = (maxValue - 1) * (maxValue - 1);\n\n        // Calculate the number in the given row and column based on the layer and the starting number\n        long long result;\n        if (maxValue % 2 == 0) {\n            result = layerStart + row;\n            result = result + (maxValue - column);\n        } else {\n            result = layerStart + column;\n            result = result + (maxValue - row);\n        }\n\n        // Print the number in the given row and column\n        cout << result << \"\\n\";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 2,
            "mean_time_taken": 0.09979069232940674,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "One Bit Positions",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nint main() {\n    std::string binaryString;\n    std::cin >> binaryString;\n\n    int n = binaryString.length();\n    std::vector<int> ones(n, 0);\n    std::vector<int> result(n, 0);\n\n    // Count the number of 1-bits in the binary string\n    for (int i = 0; i < n; i++) {\n        if (binaryString[i] == '1') {\n            ones[i] = 1;\n        }\n    }\n\n    // Calculate the number of ways to choose two 1-bits at a distance k\n    for (int k = 1; k < n; k++) {\n        for (int i = k; i < n; i++) {\n            if (ones[i] == 1 && i - k >= 0 && ones[i - k] == 1) {\n                result[k]++;\n            }\n        }\n    }\n\n    // Print the results\n    for (int k = 1; k < n; k++) {\n        std::cout << result[k] << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 5,
            "mean_time_taken": 0.8441994190216064,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Palindrome Queries",
            "category": "String Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nconst long long MOD = 1e9 + 7;\nconst long long BASE = 31;\n\nlong long power[MAX_N];\nlong long hash_value[MAX_N];\nchar input_string[MAX_N];\n\nvoid calculate_hash(int string_length) {\n  power[0] = 1;\n  for (int i = 1; i <= string_length; i++) {\n    power[i] = (power[i - 1] * BASE) % MOD;\n    hash_value[i] = (hash_value[i - 1] * BASE + input_string[i]) % MOD;\n  }\n}\n\nlong long get_hash(int left, int right) {\n  return ((hash_value[right] - hash_value[left - 1] * power[right - left + 1]) % MOD + MOD) % MOD;\n}\n\nint main() {\n  int string_length, num_queries;\n  scanf(\"%d%d\", &string_length, &num_queries);\n  scanf(\"%s\", input_string + 1);\n  calculate_hash(string_length);\n  while (num_queries--) {\n    int query_type;\n    scanf(\"%d\", &query_type);\n    if (query_type == 1) {\n      int position;\n      char new_char;\n      scanf(\" %d %c\", &position, &new_char);\n      input_string[position] = new_char;\n      calculate_hash(string_length);\n    } else {\n      int left, right;\n      scanf(\"%d%d\", &left, &right);\n      long long hash1 = get_hash(left, right);\n      long long hash2 = get_hash(right, left);\n      if (hash1 == hash2)\n        printf(\"YES\\n\");\n      else\n        printf(\"NO\\n\");\n    }\n  }\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 14,
            "mean_time_taken": 0.1095226492200579,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Palindrome Reorder",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <map>\n\nint main() {\n    std::string input;\n    std::cin >> input;\n\n    std::map<char, int> charCount;\n    for (char c : input) {\n        charCount[c]++;\n    }\n\n    int oddCount = 0;\n    char oddChar;\n    for (auto const& pair : charCount) {\n        if (pair.second % 2 == 1) {\n            oddCount++;\n            oddChar = pair.first;\n        }\n    }\n\n    if (oddCount > 1) {\n        std::cout << \"NO SOLUTION\";\n        return 0;\n    }\n\n    std::string firstHalf = \"\";\n    for (auto const& pair : charCount) {\n        firstHalf += std::string(pair.second / 2, pair.first);\n    }\n\n    std::string secondHalf = firstHalf;\n    std::reverse(secondHalf.begin(), secondHalf.end());\n\n    std::string result = firstHalf;\n    if (oddCount == 1) {\n        result += oddChar;\n    }\n    result += secondHalf;\n\n    std::cout << result;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Parcel Delivery",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 505;\nconst int INF = 1e9;\n\nint n, m, k;\nint cost[MAX_N][MAX_N];\nint capacity[MAX_N][MAX_N];\nint dp[MAX_N][MAX_N];\n\nvoid floyd_warshall() {\n    for (int k = 1; k <= n; k++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n            }\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n >> m >> k;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            cost[i][j] = INF;\n        }\n        cost[i][i] = 0;\n    }\n\n    for (int i = 0; i < m; i++) {\n        int a, b, r, c;\n        cin >> a >> b >> r >> c;\n        cost[a][b] = min(cost[a][b], c);\n        capacity[a][b] = r;\n    }\n\n    floyd_warshall();\n\n    if (cost[1][n] == INF) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= k; j++) {\n            dp[i][j] = INF;\n        }\n    }\n\n    dp[1][0] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= k; j++) {\n            for (int u = 1; u <= n; u++) {\n                if (cost[u][i] != INF) {\n                    for (int v = 1; v <= min(j, capacity[u][i]); v++) {\n                        dp[i][j] = min(dp[i][j], dp[u][j - v] + cost[u][i] * v);\n                    }\n                }\n            }\n        }\n    }\n\n    cout << dp[n][k] << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 13,
            "mean_time_taken": 0.25365934005150426,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Path Queries",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 200005;\n\nvector<int> tree[MAX_N];\nint values[MAX_N];\nint trie[MAX_N];\n\nvoid update(int index, int value) {\n    for (; index < MAX_N; index += index & -index) {\n        trie[index] += value;\n    }\n}\n\nint query(int index) {\n    int sum = 0;\n    for (; index > 0; index -= index & -index) {\n        sum += trie[index];\n    }\n    return sum;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n\n    for (int i = 1; i <= n; i++) {\n        cin >> values[i];\n        update(i, values[i]);\n    }\n\n    for (int i = 1; i < n; i++) {\n        int a, b;\n        cin >> a >> b;\n        tree[a].push_back(b);\n        tree[b].push_back(a);\n    }\n\n    for (int i = 1; i <= q; i++) {\n        int type, s, x;\n        cin >> type >> s;\n        if (type == 1) {\n            cin >> x;\n            update(s, x - values[s]);\n            values[s] = x;\n        } else {\n            cout << query(s) << \"\\n\";\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.1400150775909424,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Path Queries II",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Constants and global variables\nconst int MAX_N = 2e5 + 5;\nconst int MAX_LOG = 18;\nint n, q;\nvector<int> adj[MAX_N];\nint val[MAX_N];\nint depth[MAX_N];\nint parent[MAX_N][MAX_LOG];\nint euler_tour[2 * MAX_N];\nint euler_tour_idx = 0;\nint first_occurrence[MAX_N];\nint sparse_table[2 * MAX_N][MAX_LOG];\n\n// DFS function to calculate depth and parent of each node\nvoid dfs(int u, int p, int d) {\n    depth[u] = d;\n    parent[u][0] = p;\n    first_occurrence[u] = euler_tour_idx;\n    euler_tour[euler_tour_idx++] = u;\n    for (int i = 1; i < MAX_LOG; i++) {\n        parent[u][i] = parent[parent[u][i - 1]][i - 1];\n    }\n    for (int v : adj[u]) {\n        if (v != p) {\n            dfs(v, u, d + 1);\n            euler_tour[euler_tour_idx++] = u;\n        }\n    }\n}\n\n// Function to build sparse table for range maximum queries\nvoid build_sparse_table() {\n    for (int i = 0; i < euler_tour_idx; i++) {\n        sparse_table[i][0] = val[euler_tour[i]];\n    }\n    for (int j = 1; (1 << j) <= euler_tour_idx; j++) {\n        for (int i = 0; i + (1 << j) - 1 < euler_tour_idx; i++) {\n            sparse_table[i][j] = max(sparse_table[i][j - 1], sparse_table[i + (1 << (j - 1))][j - 1]);\n        }\n    }\n}\n\n// Function to find LCA of two nodes using binary lifting\nint find_lca(int u, int v) {\n    if (depth[u] < depth[v]) {\n        swap(u, v);\n    }\n    int diff = depth[u] - depth[v];\n    for (int i = 0; i < MAX_LOG; i++) {\n        if ((diff >> i) & 1) {\n            u = parent[u][i];\n        }\n    }\n    if (u == v) {\n        return u;\n    }\n    for (int i = MAX_LOG - 1; i >= 0; i--) {\n        if (parent[u][i] != parent[v][i]) {\n            u = parent[u][i];\n            v = parent[v][i];\n        }\n    }\n    return parent[u][0];\n}\n\n// Function to find maximum value on path between two nodes using sparse table and DFS information\nint find_max_on_path(int u, int v) {\n    int lca = find_lca(u, v);\n    int left = first_occurrence[u];\n    int right = first_occurrence[v];\n    if (left > right) {\n        swap(left, right);\n    }\n    int k = 32 - __builtin_clz(right - left + 1) - 1;\n    return max(sparse_table[left][k], sparse_table[right - (1 << k) + 1][k]);\n}\n\n// Function to process queries\nvoid process_queries() {\n    cin >> n >> q;\n    for (int i = 1; i <= n; i++) {\n        cin >> val[i];\n    }\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(1, 0, 0);\n    build_sparse_table();\n    for (int i = 0; i < q; i++) {\n        int type, u, v;\n        cin >> type >> u >> v;\n        if (type == 1) {\n            int idx = first_occurrence[u];\n            val[u] = v;\n            sparse_table[idx][0] = v;\n            for (int j = 1; (1 << j) <= euler_tour_idx; j++) {\n                if (idx + (1 << j) - 1 < euler_tour_idx) {\n                    sparse_table[idx][j] = max(sparse_table[idx][j - 1], sparse_table[idx + (1 << (j - 1))][j - 1]);\n                }\n            }\n        } else {\n            cout << find_max_on_path(u, v) << endl;\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    process_queries();\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.2523993253707886,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Pattern Positions",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\n// Function to preprocess the pattern and create a partial match table\nstd::vector<int> computePrefixFunction(const std::string& pattern) {\n    int n = pattern.size();\n    std::vector<int> pi(n, 0);\n    int k = 0;\n    for (int i = 1; i < n; i++) {\n        while (k > 0 && pattern[k] != pattern[i]) {\n            k = pi[k - 1];\n        }\n        if (pattern[k] == pattern[i]) {\n            k++;\n        }\n        pi[i] = k;\n    }\n    return pi;\n}\n\n// Function to search for a pattern in a string using the KMP algorithm and the partial match table\nint kmpSearch(const std::string& text, const std::string& pattern, const std::vector<int>& pi) {\n    int n = text.size();\n    int m = pattern.size();\n    int q = 0;\n    for (int i = 0; i < n; i++) {\n        while (q > 0 && pattern[q] != text[i]) {\n            q = pi[q - 1];\n        }\n        if (pattern[q] == text[i]) {\n            q++;\n        }\n        if (q == m) {\n            return i - m + 1; // 1-indexed position\n        }\n    }\n    return -1;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    std::string text;\n    std::cin >> text;\n\n    int k;\n    std::cin >> k;\n\n    for (int i = 0; i < k; i++) {\n        std::string pattern;\n        std::cin >> pattern;\n\n        std::vector<int> pi = computePrefixFunction(pattern);\n        int position = kmpSearch(text, pattern, pi);\n\n        std::cout << position << std::endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.45941810607910155,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Permutation Inversions",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1));\n    dp[0][0] = 1;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= k; j++) {\n            for (int l = 0; l <= min(j, i - 1); l++) {\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - l]) % MOD;\n            }\n        }\n    }\n\n    cout << dp[n][k] << endl;\n    return 0;\n}",
            "passed_test_cases": 13,
            "total_test_cases": 16,
            "mean_time_taken": 0.2632056027650833,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                7,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Permutations",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    if (n == 1) {\n        std::cout << \"1\\n\";\n    } else if (n == 2) {\n        std::cout << \"NO SOLUTION\\n\";\n    } else {\n        std::vector<int> permutation;\n        int smallest = 1, largest = n;\n\n        while (smallest <= largest) {\n            permutation.push_back(smallest);\n            smallest++;\n\n            if (smallest <= largest) {\n                permutation.push_back(largest);\n                largest--;\n            }\n        }\n\n        for (int i = 0; i < permutation.size(); i++) {\n            std::cout << permutation[i] << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 21,
            "mean_time_taken": 0.09616704214186896,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Permutations II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countBeautifulPermutations(int n) {\n    vector<int> dp(n + 1);\n    dp[1] = 1;\n    dp[2] = 2;\n    for (int i = 3; i <= n; i++) {\n        dp[i] = (1LL * (i - 1) * (dp[i - 1] + dp[i - 2])) % MOD;\n    }\n    return dp[n];\n}\n\nint main() {\n    int n;\n    cin >> n;\n    cout << countBeautifulPermutations(n) << endl;\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 23,
            "mean_time_taken": 0.07957314408343771,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Pizzeria Queries",
            "category": "Range Queries",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nint n, q, a[MAX_N], tree[4 * MAX_N], lazy[4 * MAX_N];\n\nvoid build(int node, int start, int end) {\n    if (start == end) {\n        tree[node] = a[start];\n    } else {\n        int mid = (start + end) / 2;\n        build(2 * node, start, mid);\n        build(2 * node + 1, mid + 1, end);\n        tree[node] = min(tree[2 * node], tree[2 * node + 1] + mid - start);\n    }\n}\n\nvoid update(int node, int start, int end, int idx, int val) {\n    if (start == end) {\n        a[idx] = val;\n        tree[node] = val;\n    } else {\n        int mid = (start + end) / 2;\n        if (idx <= mid) {\n            update(2 * node, start, mid, idx, val);\n        } else {\n            update(2 * node + 1, mid + 1, end, idx, val);\n        }\n        tree[node] = min(tree[2 * node], tree[2 * node + 1] + mid - start);\n    }\n}\n\nint query(int node, int start, int end, int l, int r) {\n    if (r < start || end < l) {\n        return INT_MAX;\n    }\n    if (l <= start && end <= r) {\n        return tree[node];\n    }\n    int mid = (start + end) / 2;\n    int p1 = query(2 * node, start, mid, l, r);\n    int p2 = query(2 * node + 1, mid + 1, end, l, r);\n    return min(p1, p2 + mid - l + 1);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> n >> q;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    build(1, 1, n);\n    while (q--) {\n        int type, x, y;\n        cin >> type >> x;\n        if (type == 1) {\n            cin >> y;\n            update(1, 1, n, x, y);\n        } else {\n            cout << min(query(1, 1, n, 1, x - 1), query(1, 1, n, x + 1, n) - x + 1) << '\\n';\n        }\n    }\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 4,
            "mean_time_taken": 0.12290233373641968,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Planets Cycles",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nint n, t[MAX_N], visited[MAX_N], cycle_length[MAX_N];\n\nint dfs(int u) {\n    visited[u] = 1;\n    int v = t[u];\n    if (visited[v]) {\n        if (cycle_length[v] == 0) {\n            int curr = u, len = 1;\n            while (curr != v) {\n                curr = t[curr];\n                len++;\n            }\n            cycle_length[v] = len;\n        }\n        return cycle_length[v];\n    } else {\n        int len = dfs(v);\n        cycle_length[u] = len + 1;\n        return cycle_length[u];\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> t[i];\n    }\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            dfs(i);\n        }\n        cout << cycle_length[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 14,
            "mean_time_taken": 0.09523895808628627,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Planets Queries I",
            "category": "Graph Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Planets Queries II",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nconst int MAX_N = 2e5 + 5;\nconst int MAX_LOG = 20;\n\nint n, q;\nint parent[MAX_N][MAX_LOG];\nint depth[MAX_N];\n\nvoid precompute() {\n    for (int i = 1; i <= n; i++) {\n        std::cin >> parent[i][0];\n    }\n\n    for (int j = 1; j < MAX_LOG; j++) {\n        for (int i = 1; i <= n; i++) {\n            parent[i][j] = parent[parent[i][j - 1]][j - 1];\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        depth[i] = depth[parent[i][0]] + 1;\n    }\n}\n\nint query(int x, int y) {\n    if (depth[x] < depth[y]) {\n        std::swap(x, y);\n    }\n\n    int diff = depth[x] - depth[y];\n    int answer = 0;\n\n    for (int i = 0; i < MAX_LOG; i++) {\n        if (diff & (1 << i)) {\n            x = parent[x][i];\n            answer += (1 << i);\n        }\n    }\n\n    if (x == y) {\n        return answer;\n    }\n\n    for (int i = MAX_LOG - 1; i >= 0; i--) {\n        if (parent[x][i] != parent[y][i]) {\n            x = parent[x][i];\n            y = parent[y][i];\n            answer += (2 << i);\n        }\n    }\n\n    answer += 2;\n    return answer;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    std::cin >> n >> q;\n\n    precompute();\n\n    while (q--) {\n        int x, y;\n        std::cin >> x >> y;\n        std::cout << query(x, y) << '\\n';\n    }\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 15,
            "mean_time_taken": 0.11353732744852701,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Planets and Kingdoms",
            "category": "Graph Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Playlist",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <set>\n#include <vector>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> songs(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> songs[i];\n    }\n\n    std::set<int> unique_songs;\n    int left = 0, right = 0;\n    int max_length = 0;\n\n    while (right < n) {\n        if (unique_songs.find(songs[right]) == unique_songs.end()) {\n            unique_songs.insert(songs[right]);\n            max_length = std::max(max_length, right - left + 1);\n            right++;\n        } else {\n            unique_songs.erase(songs[left]);\n            left++;\n        }\n    }\n\n    std::cout << max_length << std::endl;\n    return 0;\n}",
            "passed_test_cases": 20,
            "total_test_cases": 20,
            "mean_time_taken": 0.16947001218795776,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 28,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Point Location Test",
            "category": "Geometry",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n\n    while (t--) {\n        long long x1, y1, x2, y2, x3, y3;\n        cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\n        long long cross_product = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);\n\n        if (cross_product > 0)\n            cout << \"LEFT\\n\";\n        else if (cross_product < 0)\n            cout << \"RIGHT\\n\";\n        else\n            cout << \"TOUCH\\n\";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 6,
            "mean_time_taken": 0.10087740421295166,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 29,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Point in Polygon",
            "category": "Geometry",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Point {\n    long long x, y;\n};\n\nbool onSegment(Point p, Point q, Point r) {\n    if (q.x <= max(p.x, r.x) && q.x >= min(p.x, r.x) && q.y <= max(p.y, r.y) && q.y >= min(p.y, r.y))\n        return true;\n    return false;\n}\n\nint orientation(Point p, Point q, Point r) {\n    long long val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    if (val == 0) return 0;\n    return (val > 0) ? 1 : 2;\n}\n\nbool doIntersect(Point p1, Point q1, Point p2, Point q2) {\n    int o1 = orientation(p1, q1, p2);\n    int o2 = orientation(p1, q1, q2);\n    int o3 = orientation(p2, q2, p1);\n    int o4 = orientation(p2, q2, q1);\n    if (o1 != o2 && o3 != o4) return true;\n    if (o1 == 0 && onSegment(p1, p2, q1)) return true;\n    if (o2 == 0 && onSegment(p1, q2, q1)) return true;\n    if (o3 == 0 && onSegment(p2, p1, q2)) return true;\n    if (o4 == 0 && onSegment(p2, q1, q2)) return true;\n    return false;\n}\n\nbool isInside(vector<Point> polygon, Point p) {\n    int n = polygon.size();\n    if (n < 3) return false;\n    Point extreme = {INT_MAX, p.y};\n    int count = 0, i = 0;\n    do {\n        int next = (i + 1) % n;\n        if (doIntersect(polygon[i], polygon[next], p, extreme)) {\n            if (orientation(polygon[i], p, polygon[next]) == 0)\n                return onSegment(polygon[i], p, polygon[next]);\n            count++;\n        }\n        i = next;\n    } while (i != 0);\n    return count & 1;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<Point> polygon(n);\n    for (int i = 0; i < n; i++) {\n        cin >> polygon[i].x >> polygon[i].y;\n    }\n    for (int i = 0; i < m; i++) {\n        Point p;\n        cin >> p.x >> p.y;\n        if (isInside(polygon, p))\n            cout << \"INSIDE\\n\";\n        else\n            cout << \"OUTSIDE\\n\";\n    }\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 8,
            "mean_time_taken": 0.08089932799339294,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 29,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Police Chase",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_NODES = 505;\nvector<int> graph[MAX_NODES];\nint parent[MAX_NODES];\nbool visited[MAX_NODES];\n\nbool bfs(int source, int destination) {\n    queue<int> q;\n    q.push(source);\n    visited[source] = true;\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        for (int neighbor : graph[node]) {\n            if (neighbor == destination) {\n                parent[destination] = node;\n                return true;\n            }\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                parent[neighbor] = node;\n                q.push(neighbor);\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int numNodes, numEdges;\n    cin >> numNodes >> numEdges;\n    for (int i = 0; i < numEdges; i++) {\n        int node1, node2;\n        cin >> node1 >> node2;\n        graph[node1].push_back(node2);\n        graph[node2].push_back(node1);\n    }\n    vector<pair<int, int>> result;\n    while (bfs(1, numNodes)) {\n        int node = numNodes;\n        while (node != 1) {\n            int parentNode = parent[node];\n            result.push_back({parentNode, node});\n            graph[parentNode].erase(find(graph[parentNode].begin(), graph[parentNode].end(), node));\n            graph[node].erase(find(graph[node].begin(), graph[node].end(), parentNode));\n            node = parentNode;\n        }\n        memset(visited, false, sizeof(visited));\n    }\n    cout << result.size() << endl;\n    for (auto edge : result) {\n        cout << edge.first << \" \" << edge.second << endl;\n    }\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 15,
            "mean_time_taken": 0.076937468846639,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                6,
                7,
                9,
                10,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 29,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Polygon Area",
            "category": "Geometry",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<int, int>> vertices(n);\n    for (int i = 0; i < n; i++) {\n        cin >> vertices[i].first >> vertices[i].second;\n    }\n\n    long long area = 0;\n    for (int i = 0; i < n; i++) {\n        int j = (i + 1) % n;\n        area += (long long)vertices[i].first * vertices[j].second;\n        area -= (long long)vertices[j].first * vertices[i].second;\n    }\n\n    cout << abs(area) << endl;\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 5,
            "mean_time_taken": 0.0861086368560791,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 30,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Polygon Lattice Points",
            "category": "Geometry",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Point;\n\nll gcd(ll a, ll b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n\nll shoelaceFormula(vector<Point>& points) {\n    ll area = 0;\n    int n = points.size();\n    for (int i = 0; i < n; i++) {\n        area += points[i].first * points[(i + 1) % n].second - points[i].second * points[(i + 1) % n].first;\n    }\n    return abs(area) / 2;\n}\n\nll boundaryPoints(vector<Point>& points) {\n    ll count = 0;\n    int n = points.size();\n    for (int i = 0; i < n; i++) {\n        count += gcd(abs(points[i].first - points[(i + 1) % n].first), abs(points[i].second - points[(i + 1) % n].second));\n    }\n    return count;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> points(n);\n    for (int i = 0; i < n; i++) {\n        cin >> points[i].first >> points[i].second;\n    }\n    ll area = shoelaceFormula(points);\n    ll boundary = boundaryPoints(points);\n    ll interior = area - boundary / 2 + 1;\n    cout << interior << \" \" << boundary << endl;\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 5,
            "mean_time_taken": 0.08619766235351563,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 31,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Polynomial Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Define a structure for the segment tree nodes\nstruct SegmentTreeNode {\n    long long sum;\n    long long evenLazy;\n    long long oddLazy;\n};\n\n// Define a vector for the segment tree\nvector<SegmentTreeNode> segmentTree;\n\n// Define a vector for the input array\nvector<long long> inputArray;\n\n// Define a function to build the segment tree from the input array\nvoid buildSegmentTree(int node, int start, int end) {\n    if (start == end) {\n        segmentTree[node].sum = inputArray[start];\n        return;\n    }\n    int mid = (start + end) / 2;\n    buildSegmentTree(2 * node, start, mid);\n    buildSegmentTree(2 * node + 1, mid + 1, end);\n    segmentTree[node].sum = segmentTree[2 * node].sum + segmentTree[2 * node + 1].sum;\n}\n\n// Define a function to update the segment tree nodes with a certain value\nvoid updateSegmentTree(int node, int start, int end, int left, int right, long long value) {\n    if (segmentTree[node].oddLazy != 0) {\n        long long size = end - start + 1;\n        segmentTree[node].sum += (size * (size + 1) / 2) * segmentTree[node].oddLazy;\n        if (start != end) {\n            segmentTree[2 * node].oddLazy += segmentTree[node].oddLazy;\n            segmentTree[2 * node + 1].oddLazy += segmentTree[node].oddLazy;\n        }\n        segmentTree[node].oddLazy = 0;\n    }\n    if (segmentTree[node].evenLazy != 0) {\n        long long size = end - start + 1;\n        segmentTree[node].sum += (size + 1) * segmentTree[node].evenLazy;\n        if (start != end) {\n            segmentTree[2 * node].evenLazy += segmentTree[node].evenLazy;\n            segmentTree[2 * node + 1].evenLazy += segmentTree[node].evenLazy;\n        }\n        segmentTree[node].evenLazy = 0;\n    }\n    if (start > right || end < left) return;\n    if (start >= left && end <= right) {\n        long long size = end - start + 1;\n        segmentTree[node].sum += (size * (size + 1) / 2) * value;\n        if (start != end) {\n            segmentTree[2 * node].oddLazy += value;\n            segmentTree[2 * node + 1].oddLazy += value;\n        }\n        return;\n    }\n    int mid = (start + end) / 2;\n    updateSegmentTree(2 * node, start, mid, left, right, value);\n    updateSegmentTree(2 * node + 1, mid + 1, end, left, right, value);\n    segmentTree[node].sum = segmentTree[2 * node].sum + segmentTree[2 * node + 1].sum;\n}\n\n// Define a function to query the sum of values in a range\nlong long querySegmentTree(int node, int start, int end, int left, int right) {\n    if (segmentTree[node].oddLazy != 0) {\n        long long size = end - start + 1;\n        segmentTree[node].sum += (size * (size + 1) / 2) * segmentTree[node].oddLazy;\n        if (start != end) {\n            segmentTree[2 * node].oddLazy += segmentTree[node].oddLazy;\n            segmentTree[2 * node + 1].oddLazy += segmentTree[node].oddLazy;\n        }\n        segmentTree[node].oddLazy = 0;\n    }\n    if (segmentTree[node].evenLazy != 0) {\n        long long size = end - start + 1;\n        segmentTree[node].sum += (size + 1) * segmentTree[node].evenLazy;\n        if (start != end) {\n            segmentTree[2 * node].evenLazy += segmentTree[node].evenLazy;\n            segmentTree[2 * node + 1].evenLazy += segmentTree[node].evenLazy;\n        }\n        segmentTree[node].evenLazy = 0;\n    }\n    if (start > right || end < left) return 0;\n    if (start >= left && end <= right) return segmentTree[node].sum;\n    int mid = (start + end) / 2;\n    long long leftQuery = querySegmentTree(2 * node, start, mid, left, right);\n    long long rightQuery = querySegmentTree(2 * node + 1, mid + 1, end, left, right);\n    return leftQuery + rightQuery;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int numberOfElements, numberOfQueries;\n    cin >> numberOfElements >> numberOfQueries;\n    inputArray.resize(numberOfElements);\n    segmentTree.resize(4 * numberOfElements);\n    for (int i = 0; i < numberOfElements; i++) cin >> inputArray[i];\n    buildSegmentTree(1, 0, numberOfElements - 1);\n    for (int i = 0; i < numberOfQueries; i++) {\n        int queryType, leftIndex, rightIndex;\n        cin >> queryType >> leftIndex >> rightIndex;\n        if (queryType == 1) {\n            updateSegmentTree(1, 0, numberOfElements - 1, leftIndex - 1, rightIndex - 1, 1);\n        } else {\n            cout << querySegmentTree(1, 0, numberOfElements - 1, leftIndex - 1, rightIndex - 1) << \"\\n\";\n        }\n    }\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 3,
            "mean_time_taken": 0.18278725941975912,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 31,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Prefix Sum Queries",
            "category": "Range Queries",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Define a structure for the segment tree nodes\nstruct SegmentTreeNode {\n    long long maxPrefixSum, totalSum;\n};\n\n// Build the segment tree from the input array\nSegmentTreeNode buildSegmentTree(vector<long long>& arr, int left, int right, vector<SegmentTreeNode>& tree) {\n    if (left == right) {\n        tree[left] = {max(0LL, arr[left]), arr[left]};\n        return tree[left];\n    }\n    int mid = (left + right) / 2;\n    SegmentTreeNode leftNode = buildSegmentTree(arr, left, mid, tree);\n    SegmentTreeNode rightNode = buildSegmentTree(arr, mid + 1, right, tree);\n    tree[left] = {max(leftNode.maxPrefixSum, leftNode.totalSum + rightNode.maxPrefixSum), leftNode.totalSum + rightNode.totalSum};\n    return tree[left];\n}\n\n// Update the value at a specific position in the array and the segment tree\nvoid updateSegmentTree(int position, long long value, int left, int right, vector<SegmentTreeNode>& tree) {\n    if (left == right) {\n        tree[position] = {max(0LL, value), value};\n        return;\n    }\n    int mid = (left + right) / 2;\n    if (position <= mid)\n        updateSegmentTree(position, value, left, mid, tree);\n    else\n        updateSegmentTree(position, value, mid + 1, right, tree);\n    tree[left] = {max(tree[left * 2].maxPrefixSum, tree[left * 2].totalSum + tree[left * 2 + 1].maxPrefixSum), tree[left * 2].totalSum + tree[left * 2 + 1].totalSum};\n}\n\n// Find the maximum prefix sum in a given range using the segment tree\nSegmentTreeNode querySegmentTree(int queryLeft, int queryRight, int left, int right, vector<SegmentTreeNode>& tree) {\n    if (queryLeft == left && queryRight == right)\n        return tree[left];\n    int mid = (left + right) / 2;\n    if (queryRight <= mid)\n        return querySegmentTree(queryLeft, queryRight, left, mid, tree);\n    if (queryLeft > mid)\n        return querySegmentTree(queryLeft, queryRight, mid + 1, right, tree);\n    SegmentTreeNode leftNode = querySegmentTree(queryLeft, mid, left, mid, tree);\n    SegmentTreeNode rightNode = querySegmentTree(mid + 1, queryRight, mid + 1, right, tree);\n    return {max(leftNode.maxPrefixSum, leftNode.totalSum + rightNode.maxPrefixSum), leftNode.totalSum + rightNode.totalSum};\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    int numElements, numQueries;\n    cin >> numElements >> numQueries;\n\n    vector<long long> arr(numElements);\n    for (int i = 0; i < numElements; i++)\n        cin >> arr[i];\n\n    vector<SegmentTreeNode> tree(4 * numElements);\n    buildSegmentTree(arr, 0, numElements - 1, tree);\n\n    while (numQueries--) {\n        int queryType, position, value;\n        cin >> queryType >> position >> value;\n        if (queryType == 1)\n            updateSegmentTree(position - 1, value, 0, numElements - 1, tree);\n        else\n            cout << querySegmentTree(position - 1, value - 1, 0, numElements - 1, tree).maxPrefixSum << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 6,
            "mean_time_taken": 0.13082305590311685,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 31,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Prime Multiples",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nlong long n, k;\nvector<long long> primes;\n\nlong long countDivisible(long long x) {\n    return n / x;\n}\n\nlong long countIntersection(long long x, long long y) {\n    return n / (x * y);\n}\n\nint main() {\n    cin >> n >> k;\n    primes.resize(k);\n    for (int i = 0; i < k; i++) {\n        cin >> primes[i];\n    }\n\n    long long result = 0;\n    for (int i = 1; i < (1 << k); i++) {\n        long long lcm = 1;\n        int count = 0;\n        for (int j = 0; j < k; j++) {\n            if (i & (1 << j)) {\n                lcm *= primes[j];\n                count++;\n            }\n        }\n        if (count % 2 == 1) {\n            result += countDivisible(lcm);\n        } else {\n            result -= countDivisible(lcm);\n        }\n    }\n\n    cout << result << endl;\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 5,
            "mean_time_taken": 0.11405744552612304,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 31,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Programmers and Artists",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int a, b, n;\n    cin >> a >> b >> n;\n\n    priority_queue<int, vector<int>, greater<int>> minProgrammers;\n    priority_queue<int, vector<int>, greater<int>> minArtists;\n\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n\n        if (i < a) {\n            minProgrammers.push(x);\n        } else if (x > minProgrammers.top()) {\n            minProgrammers.pop();\n            minProgrammers.push(x);\n        }\n\n        if (i < b) {\n            minArtists.push(y);\n        } else if (y > minArtists.top()) {\n            minArtists.pop();\n            minArtists.push(y);\n        }\n    }\n\n    long long sum = 0;\n    while (!minProgrammers.empty()) {\n        sum += minProgrammers.top();\n        minProgrammers.pop();\n    }\n\n    while (!minArtists.empty()) {\n        sum += minArtists.top();\n        minArtists.pop();\n    }\n\n    cout << sum << endl;\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 11,
            "mean_time_taken": 0.1473698399283669,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 31,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Projects",
            "category": "Dynamic Programming",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nconst int MAX_M = 4 * MAX_N;\n\nint n;\nlong long tree[MAX_M];\n\nstruct Project {\n    int start, end, reward;\n};\n\nbool compareProjects(Project a, Project b) {\n    return a.end < b.end;\n}\n\nvoid update(int node, int start, int end, int idx, long long val) {\n    if (start == end) {\n        tree[node] = val;\n    } else {\n        int mid = (start + end) / 2;\n        if (idx <= mid) {\n            update(2 * node, start, mid, idx, val);\n        } else {\n            update(2 * node + 1, mid + 1, end, idx, val);\n        }\n        tree[node] = max(tree[2 * node], tree[2 * node + 1]);\n    }\n}\n\nlong long query(int node, int start, int end, int l, int r) {\n    if (r < start || end < l) {\n        return LLONG_MIN;\n    }\n    if (l <= start && end <= r) {\n        return tree[node];\n    }\n    int mid = (start + end) / 2;\n    return max(query(2 * node, start, mid, l, r), query(2 * node + 1, mid + 1, end, l, r));\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n;\n    Project projects[n];\n    for (int i = 0; i < n; i++) {\n        cin >> projects[i].start >> projects[i].end >> projects[i].reward;\n    }\n\n    sort(projects, projects + n, compareProjects);\n\n    long long maxReward = 0;\n    for (int i = 0; i < n; i++) {\n        long long prevReward = query(1, 1, MAX_N, 1, projects[i].start - 1);\n        long long newReward = max(prevReward, (long long)projects[i].reward);\n        maxReward = max(maxReward, newReward);\n        update(1, 1, MAX_N, projects[i].end, newReward);\n    }\n\n    cout << maxReward << endl;\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 14,
            "mean_time_taken": 0.11197129317692348,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 31,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Pr\u00fcfer Code",
            "category": "Additional Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 31,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Pyramid Array",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> a(n), b(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n        b[i] = a[i];\n    }\n\n    std::sort(b.begin(), b.end());\n\n    int left = 0, right = n - 1;\n    for (int i = 0; i < n; i++) {\n        if (a[i] == b[left]) {\n            left++;\n        } else if (a[i] == b[right]) {\n            right--;\n        }\n    }\n\n    std::cout << n - (right - left + 1) << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.1047756274541219,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 31,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Range Queries and Copies",
            "category": "Range Queries",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 31,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Range Update Queries",
            "category": "Range Queries",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 31,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Range Updates and Sums",
            "category": "Range Queries",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nint n, q;\nlong long arr[MAX_N], tree[4 * MAX_N], lazy[4 * MAX_N];\n\nvoid build(int node, int start, int end) {\n    if (start == end) {\n        tree[node] = arr[start];\n    } else {\n        int mid = (start + end) / 2;\n        build(2 * node, start, mid);\n        build(2 * node + 1, mid + 1, end);\n        tree[node] = tree[2 * node] + tree[2 * node + 1];\n    }\n}\n\nvoid update_range(int node, int start, int end, int l, int r, long long val, int type) {\n    if (lazy[node] != 0) {\n        tree[node] = (end - start + 1) * lazy[node];\n        if (start != end) {\n            lazy[2 * node] = lazy[node];\n            lazy[2 * node + 1] = lazy[node];\n        }\n        lazy[node] = 0;\n    }\n    if (start > r || end < l) {\n        return;\n    }\n    if (start >= l && end <= r) {\n        if (type == 1) {\n            tree[node] += (end - start + 1) * val;\n            if (start != end) {\n                lazy[2 * node] += val;\n                lazy[2 * node + 1] += val;\n            }\n        } else {\n            tree[node] = (end - start + 1) * val;\n            if (start != end) {\n                lazy[2 * node] = val;\n                lazy[2 * node + 1] = val;\n            }\n        }\n        return;\n    }\n    int mid = (start + end) / 2;\n    update_range(2 * node, start, mid, l, r, val, type);\n    update_range(2 * node + 1, mid + 1, end, l, r, val, type);\n    tree[node] = tree[2 * node] + tree[2 * node + 1];\n}\n\nlong long query_range(int node, int start, int end, int l, int r) {\n    if (lazy[node] != 0) {\n        tree[node] = (end - start + 1) * lazy[node];\n        if (start != end) {\n            lazy[2 * node] = lazy[node];\n            lazy[2 * node + 1] = lazy[node];\n        }\n        lazy[node] = 0;\n    }\n    if (start > r || end < l) {\n        return 0;\n    }\n    if (start >= l && end <= r) {\n        return tree[node];\n    }\n    int mid = (start + end) / 2;\n    long long p1 = query_range(2 * node, start, mid, l, r);\n    long long p2 = query_range(2 * node + 1, mid + 1, end, l, r);\n    return p1 + p2;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> n >> q;\n    for (int i = 1; i <= n; i++) {\n        cin >> arr[i];\n    }\n    build(1, 1, n);\n    while (q--) {\n        int type, l, r;\n        long long val;\n        cin >> type >> l >> r;\n        if (type == 3) {\n            cout << query_range(1, 1, n, l, r) << endl;\n        } else {\n            cin >> val;\n            update_range(1, 1, n, l, r, val, type);\n        }\n    }\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 4,
            "mean_time_taken": 0.1477373242378235,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 31,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Range Xor Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    int arr[n];\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    int prefixXOR[n + 1];\n    prefixXOR[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        prefixXOR[i] = prefixXOR[i - 1] ^ arr[i - 1];\n    }\n\n    for (int i = 0; i < q; i++) {\n        int a, b;\n        cin >> a >> b;\n        cout << (prefixXOR[b] ^ prefixXOR[a - 1]) << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 2,
            "mean_time_taken": 0.17063558101654053,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Reachability Queries",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <cstring>\n\nconst int MAX_NODES = 50005;\n\nstd::vector<int> graph[MAX_NODES];\nbool visited[MAX_NODES];\n\n// Perform DFS starting from the source node\nvoid depthFirstSearch(int source) {\n    visited[source] = true;\n    for (int neighbor : graph[source]) {\n        if (!visited[neighbor]) {\n            depthFirstSearch(neighbor);\n        }\n    }\n}\n\nint main() {\n    int numNodes, numEdges, numQueries;\n    std::cin >> numNodes >> numEdges >> numQueries;\n\n    // Create an adjacency list to represent the directed graph\n    for (int i = 0; i < numEdges; i++) {\n        int nodeA, nodeB;\n        std::cin >> nodeA >> nodeB;\n        graph[nodeA].push_back(nodeB);\n    }\n\n    // Answer each query\n    for (int i = 0; i < numQueries; i++) {\n        int nodeA, nodeB;\n        std::cin >> nodeA >> nodeB;\n\n        // Perform DFS starting from node A\n        memset(visited, false, sizeof(visited));\n        depthFirstSearch(nodeA);\n\n        // Output \"YES\" if node B is visited, and \"NO\" otherwise\n        if (visited[nodeB]) {\n            std::cout << \"YES\" << std::endl;\n        } else {\n            std::cout << \"NO\" << std::endl;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 7,
            "mean_time_taken": 0.76268812588283,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Reachable Nodes",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX_NODES = 50005;\nvector<int> graph[MAX_NODES];\nint reachable[MAX_NODES];\nbool visited[MAX_NODES];\n\nint dfs(int node) {\n    if (visited[node]) return 0;\n    visited[node] = true;\n    int count = 1;\n    for (int neighbor : graph[node]) {\n        count += dfs(neighbor);\n    }\n    return count;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n    }\n    for (int i = 1; i <= n; i++) {\n        reachable[i] = dfs(i);\n        fill(visited, visited + MAX_NODES, false);\n    }\n    for (int i = 1; i <= n; i++) {\n        cout << reachable[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 4,
            "mean_time_taken": 0.7973287105560303,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Reading Books",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> readingTimes(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> readingTimes[i];\n    }\n\n    std::sort(readingTimes.begin(), readingTimes.end());\n\n    int totalTime = 0;\n    int left = 0, right = n - 1;\n    while (left <= right) {\n        totalTime += readingTimes[right];\n        if (left < right) {\n            totalTime = std::max(totalTime, readingTimes[left] + readingTimes[right]);\n        }\n        left++;\n        right--;\n    }\n\n    std::cout << totalTime << std::endl;\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 13,
            "mean_time_taken": 0.09731602668762207,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Rectangle Cutting",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n\nint main() {\n    int a, b;\n    std::cin >> a >> b;\n    std::cout << a * b - 1 << std::endl;\n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 26,
            "mean_time_taken": 0.07918215714968167,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                22,
                23,
                24,
                25,
                26
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Removal Game",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    vector<vector<int>> dp(n, vector<int>(n));\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = a[i];\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 0; i <= n - len; i++) {\n            int j = i + len - 1;\n            dp[i][j] = max(a[i] - dp[i + 1][j], a[j] - dp[i][j - 1]);\n        }\n    }\n    cout << (dp[0][n - 1] + accumulate(a.begin(), a.end(), 0)) / 2 << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Removing Digits",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, steps = 0;\n    cin >> n;\n\n    while (n > 0) {\n        int max_digit = 0;\n        int temp = n;\n\n        // Find the largest digit in the number\n        while (temp > 0) {\n            max_digit = max(max_digit, temp % 10);\n            temp /= 10;\n        }\n\n        // Subtract the largest digit from the number\n        n -= max_digit;\n\n        // Increment the number of steps\n        steps++;\n    }\n\n    cout << steps << endl;\n    return 0;\n}",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.08193520137241908,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 33,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Removing Digits II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    long long n;\n    cin >> n;\n\n    int steps = 0;\n    while (n > 0) {\n        int max_digit = 0;\n        long long temp = n;\n        while (temp > 0) {\n            max_digit = max(max_digit, temp % 10);\n            temp /= 10;\n        }\n        n -= max_digit;\n        steps++;\n    }\n\n    cout << steps << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 33,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Repeating Substring",
            "category": "String Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to build suffix array\nvoid buildSuffixArray(string txt, int *suffixArr) {\n    // Implementation of suffix array construction\n}\n\n// Function to print an array\nvoid printArr(int arr[], int n) {\n    // Implementation of array printing\n}\n\n// Function to build longest common prefix array\nvoid kasai(string txt, int *suffixArr, int *lcp) {\n    // Implementation of longest common prefix array construction\n}\n\nint main() {\n    string txt;\n    cin >> txt;\n    int n = txt.length();\n    int *suffixArr = new int[n];\n    int *lcp = new int[n];\n    buildSuffixArray(txt, suffixArr);\n    kasai(txt, suffixArr, lcp);\n    int maxLCP = *max_element(lcp, lcp + n);\n    int maxIndex = distance(lcp, find(lcp, lcp + n, maxLCP));\n    if (maxLCP == 0)\n        cout << \"-1\\n\";\n    else\n        cout << txt.substr(maxIndex, maxLCP) << \"\\n\";\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 8,
            "mean_time_taken": 0.07968708872795105,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 33,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Repetitions",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <string>\n\nint main() {\n    std::string dnaSequence;\n    std::cin >> dnaSequence;\n\n    char currentChar = dnaSequence[0];\n    int currentCount = 1;\n    int maxCount = 1;\n\n    for (int i = 1; i < dnaSequence.length(); i++) {\n        if (dnaSequence[i] == currentChar) {\n            currentCount++;\n        } else {\n            maxCount = std::max(maxCount, currentCount);\n            currentChar = dnaSequence[i];\n            currentCount = 1;\n        }\n    }\n\n    maxCount = std::max(maxCount, currentCount);\n\n    std::cout << maxCount << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.08917748928070068,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 34,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Required Substring",
            "category": "String Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 34,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Restaurant Customers",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<int, int>> events(2 * n);\n    for (int i = 0; i < n; i++) {\n        cin >> events[i].first >> events[i + n].first;\n        events[i].second = 1;\n        events[i + n].second = -1;\n    }\n\n    sort(events.begin(), events.end());\n\n    int max_customers = 0, current_customers = 0;\n    for (auto event : events) {\n        current_customers += event.second;\n        max_customers = max(max_customers, current_customers);\n    }\n\n    cout << max_customers << endl;\n\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.18179020881652833,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Reversal Sorting",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    vector<pair<int, int>> reversals;\n    for (int i = 0; i < n; i++) {\n        int j = max_element(arr.begin() + i, arr.end()) - arr.begin();\n        if (i != j) {\n            reverse(arr.begin() + i, arr.begin() + j + 1);\n            reversals.push_back({i + 1, j + 1});\n        }\n    }\n\n    cout << reversals.size() << endl;\n    for (auto& reversal : reversals) {\n        cout << reversal.first << \" \" << reversal.second << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.39787667989730835,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Reversals and Sums",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Define the segment tree node structure\nstruct Node {\n    int sum;\n    int prefix;\n    int suffix;\n    int maximum;\n    bool reversed;\n};\n\n// Function to build the segment tree\nvoid buildTree(Node* node, int start, int end, int* arr) {\n    if (start == end) {\n        node->sum = arr[start];\n        node->prefix = arr[start];\n        node->suffix = arr[start];\n        node->maximum = arr[start];\n        node->reversed = false;\n        return;\n    }\n    int mid = (start + end) / 2;\n    buildTree(node->left = new Node(), start, mid, arr);\n    buildTree(node->right = new Node(), mid + 1, end, arr);\n    node->sum = node->left->sum + node->right->sum;\n    node->prefix = max(node->left->prefix, node->left->sum + node->right->prefix);\n    node->suffix = max(node->right->suffix, node->right->sum + node->left->suffix);\n    node->maximum = max(max(node->left->maximum, node->right->maximum), node->left->suffix + node->right->prefix);\n    node->reversed = false;\n}\n\n// Function to reverse a subarray in the segment tree\nvoid reverseSubarray(Node* node, int start, int end, int a, int b) {\n    if (start > b || end < a || start > end) return;\n    if (start >= a && end <= b) {\n        swap(node->left, node->right);\n        swap(node->prefix, node->suffix);\n        node->reversed = !node->reversed;\n        return;\n    }\n    int mid = (start + end) / 2;\n    if (node->reversed) {\n        reverseSubarray(node->left, mid + 1, end, a, b);\n        reverseSubarray(node->right, start, mid, a, b);\n        node->reversed = false;\n    } else {\n        reverseSubarray(node->left, start, mid, a, b);\n        reverseSubarray(node->right, mid + 1, end, a, b);\n    }\n    node->sum = node->left->sum + node->right->sum;\n    node->prefix = max(node->left->prefix, node->left->sum + node->right->prefix);\n    node->suffix = max(node->right->suffix, node->right->sum + node->left->suffix);\n    node->maximum = max(max(node->left->maximum, node->right->maximum), node->left->suffix + node->right->prefix);\n}\n\n// Function to calculate the sum of values in a subarray of the segment tree\nint getSum(Node* node, int start, int end, int a, int b) {\n    if (start > b || end < a || start > end) return 0;\n    if (start >= a && end <= b) return node->sum;\n    int mid = (start + end) / 2;\n    if (node->reversed) {\n        int leftSum = getSum(node->right, mid + 1, end, a, b);\n        int rightSum = getSum(node->left, start, mid, a, b);\n        node->reversed = false;\n        return leftSum + rightSum;\n    } else {\n        int leftSum = getSum(node->left, start, mid, a, b);\n        int rightSum = getSum(node->right, mid + 1, end, a, b);\n        return leftSum + rightSum;\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    int arr[n];\n    for (int i = 0; i < n; i++) cin >> arr[i];\n    Node* root = new Node();\n    buildTree(root, 0, n - 1, arr);\n    for (int i = 0; i < m; i++) {\n        int t, a, b;\n        cin >> t >> a >> b;\n        a--;\n        b--;\n        if (t == 1)\n            reverseSubarray(root, 0, n - 1, a, b);\n        else\n            cout << getSum(root, 0, n - 1, a, b) << endl;\n    }\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Road Construction",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 100005;\n\nint parent[MAX_N];\nint size[MAX_N];\nint max_size = 1;\nint num_components;\n\nint find_parent(int x) {\n    if (parent[x] == x) {\n        return x;\n    }\n    return parent[x] = find_parent(parent[x]);\n}\n\nvoid merge_components(int x, int y) {\n    x = find_parent(x);\n    y = find_parent(y);\n    if (x == y) {\n        return;\n    }\n    if (size[x] < size[y]) {\n        swap(x, y);\n    }\n    parent[y] = x;\n    size[x] += size[y];\n    max_size = max(max_size, size[x]);\n    num_components--;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    num_components = n;\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n        size[i] = 1;\n    }\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        merge_components(a, b);\n        cout << num_components << \" \" << max_size << endl;\n    }\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Road Reparation",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n    int u, v, weight;\n};\n\nint parent[100005];\n\nbool compare(Edge e1, Edge e2) {\n    return e1.weight < e2.weight;\n}\n\nint find_parent(int i) {\n    if (parent[i] == i)\n        return i;\n    return parent[i] = find_parent(parent[i]);\n}\n\nvoid union_sets(int i, int j) {\n    parent[i] = j;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<Edge> edges(m);\n    for (int i = 0; i < m; i++) {\n        cin >> edges[i].u >> edges[i].v >> edges[i].weight;\n    }\n\n    sort(edges.begin(), edges.end(), compare);\n\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n    }\n\n    int total_weight = 0;\n    int connected_components = n;\n\n    for (int i = 0; i < m; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        int weight = edges[i].weight;\n\n        int parent_u = find_parent(u);\n        int parent_v = find_parent(v);\n\n        if (parent_u != parent_v) {\n            union_sets(parent_u, parent_v);\n            total_weight += weight;\n            connected_components--;\n        }\n\n        if (connected_components == 1) {\n            break;\n        }\n    }\n\n    if (connected_components > 1) {\n        cout << \"IMPOSSIBLE\" << endl;\n    } else {\n        cout << total_weight << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 9,
            "total_test_cases": 16,
            "mean_time_taken": 0.1308537721633911,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                5,
                6,
                7,
                9,
                11,
                13,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Robot Path",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <set>\n#include <utility>\n\nusing namespace std;\n\nint main() {\n    int n, x, y = 0, total_distance = 0;\n    char d;\n    set<pair<int, int>> visited;\n    visited.insert({0, 0});\n\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> d >> x;\n        if (d == 'U') y += x;\n        else if (d == 'D') y -= x;\n        else if (d == 'L') x = -x;\n        else x = x;\n\n        if (visited.find({x, y}) != visited.end()) break;\n        visited.insert({x, y});\n        total_distance += abs(x) + abs(y);\n    }\n\n    cout << total_distance << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 35,
            "mean_time_taken": 0.09376938683646066,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                33,
                34,
                35
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Room Allocation",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<int, int>> customers(n);\n    for (int i = 0; i < n; i++) {\n        cin >> customers[i].first >> customers[i].second;\n    }\n\n    sort(customers.begin(), customers.end());\n\n    priority_queue<int, vector<int>, greater<int>> min_heap;\n    vector<int> rooms(n);\n    int num_rooms = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (min_heap.empty() || min_heap.top() >= customers[i].first) {\n            num_rooms++;\n            min_heap.push(customers[i].second);\n        } else {\n            int room = min_heap.top();\n            min_heap.pop();\n            min_heap.push(customers[i].second);\n        }\n        rooms[i] = num_rooms;\n    }\n\n    cout << num_rooms << endl;\n    for (int i = 0; i < n; i++) {\n        cout << rooms[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 12,
            "mean_time_taken": 0.18344779809316,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Round Trip",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 100005;\nvector<int> adj[MAX_N];\nbool visited[MAX_N];\nint parent[MAX_N];\nvector<int> cycle;\n\nbool dfs(int u, int p) {\n    visited[u] = true;\n    parent[u] = p;\n    for (int v : adj[u]) {\n        if (v == p) continue;\n        if (visited[v]) {\n            cycle.push_back(v);\n            int cur = u;\n            while (cur != v) {\n                cycle.push_back(cur);\n                cur = parent[cur];\n            }\n            reverse(cycle.begin(), cycle.end());\n            return true;\n        }\n        if (dfs(v, u)) {\n            cycle.push_back(u);\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i] && dfs(i, -1)) {\n            if (cycle.size() > 2) {\n                cout << cycle.size() << endl;\n                for (int j = 0; j < cycle.size(); j++) {\n                    cout << cycle[j] << \" \";\n                }\n                cout << endl;\n                return 0;\n            }\n            cycle.clear();\n        }\n    }\n    cout << \"IMPOSSIBLE\" << endl;\n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 26,
            "mean_time_taken": 0.1100843594624446,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                26
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Round Trip II",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_NODES = 100005;\nvector<int> graph[MAX_NODES];\nint visited[MAX_NODES];\nint path[MAX_NODES];\nint path_length = 0;\n\nvoid dfs(int node) {\n    visited[node] = 1;\n    path[path_length++] = node;\n    for (int neighbor : graph[node]) {\n        if (visited[neighbor] == 1) {\n            // Found a cycle\n            while (path[path_length - 1] != neighbor) {\n                cout << path[path_length - 1] << \" \";\n                path_length--;\n            }\n            cout << neighbor << \" \";\n            exit(0);\n        } else if (visited[neighbor] == 0) {\n            dfs(neighbor);\n        }\n    }\n    visited[node] = 2;\n    path_length--;\n}\n\nint main() {\n    int num_nodes, num_edges;\n    cin >> num_nodes >> num_edges;\n    for (int i = 0; i < num_edges; i++) {\n        int node1, node2;\n        cin >> node1 >> node2;\n        graph[node1].push_back(node2);\n    }\n    for (int i = 1; i <= num_nodes; i++) {\n        if (visited[i] == 0) {\n            dfs(i);\n        }\n    }\n    cout << \"IMPOSSIBLE\" << endl;\n    return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 20,
            "mean_time_taken": 0.10375339984893799,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                6,
                7,
                8,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                18,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Salary Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to get the least significant bit of a number\nint getLeastSignificantBit(int x) {\n    return x & (-x);\n}\n\n// Function to update the value of an index in the Fenwick tree\nvoid updateFenwickTree(vector<int>& fenwickTree, int index, int value) {\n    while (index < fenwickTree.size()) {\n        fenwickTree[index] += value;\n        index += getLeastSignificantBit(index);\n    }\n}\n\n// Function to get the sum of values up to an index in the Fenwick tree\nint getSum(vector<int>& fenwickTree, int index) {\n    int sum = 0;\n    while (index > 0) {\n        sum += fenwickTree[index];\n        index -= getLeastSignificantBit(index);\n    }\n    return sum;\n}\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> salaries(n + 1);\n    vector<int> fenwickTree(1e9 + 1, 0);\n\n    for (int i = 1; i <= n; i++) {\n        cin >> salaries[i];\n        updateFenwickTree(fenwickTree, salaries[i], 1);\n    }\n\n    for (int i = 0; i < q; i++) {\n        char queryType;\n        int a, b;\n        cin >> queryType >> a >> b;\n\n        if (queryType == '!') {\n            updateFenwickTree(fenwickTree, salaries[a], -1);\n            salaries[a] = b;\n            updateFenwickTree(fenwickTree, salaries[a], 1);\n        } else {\n            cout << getSum(fenwickTree, b) - getSum(fenwickTree, a - 1) << endl;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 13,
            "mean_time_taken": 0.1312079796424279,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "School Dance",
            "category": "Graph Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shot": 1
        },
        {
            "title": "School Excursion",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_NODES = 100005;\nint numNodes, numEdges;\nint parent[MAX_NODES], rank[MAX_NODES];\nbool visited[MAX_NODES], possible[MAX_NODES];\nvector<int> graph[MAX_NODES];\n\n// Find the parent of a node using path compression\nint findParent(int node) {\n  if (parent[node] == node) return node;\n  return parent[node] = findParent(parent[node]);\n}\n\n// Union two nodes using union by rank\nvoid unionNodes(int node1, int node2) {\n  node1 = findParent(node1);\n  node2 = findParent(node2);\n  if (node1 == node2) return;\n  if (rank[node1] < rank[node2])\n    parent[node1] = node2;\n  else {\n    parent[node2] = node1;\n    if (rank[node1] == rank[node2]) rank[node1]++;\n  }\n}\n\n// Perform depth-first search to check if it's possible to assign a certain number of nodes to one group\nbool depthFirstSearch(int node, int groupSize, int currentSize) {\n  if (visited[node]) return possible[node] == (groupSize == currentSize);\n  visited[node] = true;\n  possible[node] = (groupSize == currentSize);\n  for (int neighbor : graph[node])\n    if (!depthFirstSearch(neighbor, groupSize, currentSize + possible[node])) return false;\n  return true;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n\n  // Read the number of nodes and edges\n  cin >> numNodes >> numEdges;\n\n  // Initialize parent and rank arrays\n  for (int i = 1; i <= numNodes; i++) {\n    parent[i] = i;\n    rank[i] = 1;\n  }\n\n  // Read the edges and build the graph\n  for (int i = 0; i < numEdges; i++) {\n    int node1, node2;\n    cin >> node1 >> node2;\n    graph[node1].push_back(node2);\n    graph[node2].push_back(node1);\n    unionNodes(node1, node2);\n  }\n\n  // Initialize the possible array\n  for (int i = 1; i <= numNodes; i++) possible[i] = true;\n\n  // Check if it's possible to assign a certain number of nodes to one group\n  for (int i = 1; i <= numNodes; i++) {\n    if (!visited[i]) {\n      memset(visited, 0, sizeof(visited));\n      if (!depthFirstSearch(i, (numNodes + 1) / 2, 0)) {\n        cout << 0;\n        return 0;\n      }\n    }\n  }\n\n  // Print the result\n  for (int i = 1; i <= numNodes; i++) cout << possible[i];\n  cout << \"\\n\";\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Shortest Routes I",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Define a structure to represent an edge in the graph\nstruct Edge {\n    int destination;\n    long long weight;\n};\n\n// Define a structure to represent a node in the graph\nstruct Node {\n    vector<Edge> edges;\n    long long distance = 1e18;\n};\n\n// Define a comparison function for a priority queue that compares nodes based on their distance values\nstruct CompareNodes {\n    bool operator()(Node* a, Node* b) {\n        return a->distance > b->distance;\n    }\n};\n\nint main() {\n    int numNodes, numEdges;\n    cin >> numNodes >> numEdges;\n\n    // Create a graph with n nodes and m edges\n    vector<Node> graph(numNodes);\n    for (int i = 0; i < numEdges; i++) {\n        int nodeA, nodeB, weight;\n        cin >> nodeA >> nodeB >> weight;\n        nodeA--; nodeB--;\n        graph[nodeA].edges.push_back({nodeB, weight});\n    }\n\n    // Initialize the distance value of the starting city (Syrj\u00e4l\u00e4) to 0 and all other distance values to a large number\n    graph[0].distance = 0;\n\n    // Create a priority queue and push the starting city into it\n    priority_queue<Node*, vector<Node*>, CompareNodes> nodeQueue;\n    nodeQueue.push(&graph[0]);\n\n    // While the priority queue is not empty, pop the node with the smallest distance value and update the distance values of its neighboring nodes if a shorter path is found\n    while (!nodeQueue.empty()) {\n        Node* currentNode = nodeQueue.top();\n        nodeQueue.pop();\n        for (Edge edge : currentNode->edges) {\n            if (graph[edge.destination].distance > currentNode->distance + edge.weight) {\n                graph[edge.destination].distance = currentNode->distance + edge.weight;\n                nodeQueue.push(&graph[edge.destination]);\n            }\n        }\n    }\n\n    // Print the distance values of all nodes in the graph\n    for (Node node : graph) {\n        cout << node.distance << \" \";\n    }\n    cout << endl;\n}",
            "passed_test_cases": 22,
            "total_test_cases": 23,
            "mean_time_taken": 0.21773719787597656,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                ""
            ],
            "failed_test_cases": [
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Shortest Routes II",
            "category": "Graph Algorithms",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Shortest Subsequence",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nint main() {\n    std::string inputString;\n    std::cin >> inputString;\n\n    // Initialize an array to store the count of each character\n    int characterCount[4] = {0};\n\n    // Iterate through the input string and count the occurrences of each character\n    for (char c : inputString) {\n        switch (c) {\n            case 'A':\n                characterCount[0]++;\n                break;\n            case 'C':\n                characterCount[1]++;\n                break;\n            case 'G':\n                characterCount[2]++;\n                break;\n            case 'T':\n                characterCount[3]++;\n                break;\n        }\n    }\n\n    // Find the index of the character with the minimum count\n    int minCountIndex = std::min_element(characterCount, characterCount + 4) - characterCount;\n\n    // Construct the output string by appending the character with the minimum count three times\n    std::string outputString;\n    switch (minCountIndex) {\n        case 0:\n            outputString = \"AAA\";\n            break;\n        case 1:\n            outputString = \"CCC\";\n            break;\n        case 2:\n            outputString = \"GGG\";\n            break;\n        case 3:\n            outputString = \"TTT\";\n            break;\n    }\n\n    // Print the output string\n    std::cout << outputString << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.09266018867492676,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Signal Processing",
            "category": "Advanced Techniques",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Sliding Window Cost",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    vector<int> costs(n - k + 1);\n    for (int i = 0; i <= n - k; i++) {\n        vector<int> window(arr.begin() + i, arr.begin() + i + k);\n        sort(window.begin(), window.end());\n\n        int median = window[k / 2];\n        int cost = 0;\n        for (int j = 0; j < k; j++) {\n            cost += abs(window[j] - median);\n        }\n\n        costs[i] = cost;\n    }\n\n    for (int i = 0; i < n - k + 1; i++) {\n        cout << costs[i] << \" \";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 26,
            "total_test_cases": 34,
            "mean_time_taken": 0.2618188086678,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                14,
                15,
                18,
                20,
                25,
                29,
                32
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sliding Window Median",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    multiset<int> window;\n    for (int i = 0; i < n; i++) {\n        window.insert(arr[i]);\n\n        if (i >= k) {\n            window.erase(window.find(arr[i - k]));\n        }\n\n        if (i >= k - 1) {\n            auto it = next(window.begin(), k / 2);\n            cout << *it << \" \";\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 21,
            "total_test_cases": 40,
            "mean_time_taken": 0.2873408436775208,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                6,
                8,
                9,
                15,
                18,
                19,
                20,
                22,
                24,
                25,
                28,
                30,
                31,
                33,
                35,
                38
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sorting Methods",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> perm(n);\n    for (int i = 0; i < n; i++) {\n        cin >> perm[i];\n    }\n\n    // Method 1: Adjacent swaps\n    int inversions = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (perm[i] > perm[j]) {\n                inversions++;\n            }\n        }\n    }\n\n    // Method 2: Any two swaps\n    vector<int> idx(n);\n    for (int i = 0; i < n; i++) {\n        idx[perm[i] - 1] = i;\n    }\n    vector<bool> visited(n);\n    int swaps = 0;\n    for (int i = 0; i < n; i++) {\n        if (visited[i] || idx[i] == i) continue;\n        int cycle_size = 0;\n        int j = i;\n        while (!visited[j]) {\n            visited[j] = true;\n            j = idx[j];\n            cycle_size++;\n        }\n        if (cycle_size > 0) {\n            swaps += cycle_size - 1;\n        }\n    }\n\n    // Method 3: Any element to another position\n    vector<int> lis;\n    for (int i = 0; i < n; i++) {\n        auto it = lower_bound(lis.begin(), lis.end(), perm[i]);\n        if (it == lis.end()) {\n            lis.push_back(perm[i]);\n        } else {\n            *it = perm[i];\n        }\n    }\n    int lis_length = lis.size();\n\n    // Method 4: Any element to the front\n    int front_moves = 0;\n    for (int i = 0; i < n; i++) {\n        if (perm[i] != i + 1) {\n            front_moves++;\n        }\n    }\n\n    cout << inversions << \" \" << swaps << \" \" << n - lis_length << \" \" << front_moves << endl;\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 10,
            "mean_time_taken": 0.5569575071334839,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Special Substrings",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint countSpecialSubstrings(string s) {\n    int n = s.length();\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        vector<int> count(26, 0);\n        int distinct = 0;\n        for (int j = i; j < n; j++) {\n            int idx = s[j] - 'a';\n            count[idx]++;\n            if (count[idx] == 1) {\n                distinct++;\n            }\n            if (distinct > 1) {\n                int freq = count[0];\n                bool special = true;\n                for (int k = 1; k < 26; k++) {\n                    if (count[k] != 0 && count[k] != freq) {\n                        special = false;\n                        break;\n                    }\n                }\n                if (special) {\n                    result++;\n                }\n            } else {\n                result++;\n            }\n        }\n    }\n    return result;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    cout << countSpecialSubstrings(s) << endl;\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 8,
            "mean_time_taken": 0.7949874401092529,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Stack Weights",
            "category": "Additional Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Stair Game",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nint main() {\n    int numberOfTests;\n    std::cin >> numberOfTests;\n\n    while (numberOfTests--) {\n        int arraySize;\n        std::cin >> arraySize;\n\n        std::vector<int> array(arraySize);\n        for (int i = 0; i < arraySize; i++) {\n            std::cin >> array[i];\n        }\n\n        int xorResult = array[0];\n        for (int i = 1; i < arraySize; i++) {\n            xorResult ^= (array[i] - array[i - 1]);\n        }\n\n        if (xorResult == 0) {\n            std::cout << \"second\\n\";\n        } else {\n            std::cout << \"first\\n\";\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 7,
            "mean_time_taken": 0.10310871260506767,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Static Range Minimum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct SegmentTreeNode {\n    int minVal;\n    int left, right;\n};\n\nvector<SegmentTreeNode> segTree;\n\nvoid buildSegmentTree(int node, int start, int end, vector<int>& arr) {\n    if (start == end) {\n        segTree[node].minVal = arr[start];\n        segTree[node].left = segTree[node].right = start;\n    } else {\n        int mid = (start + end) / 2;\n        buildSegmentTree(2 * node, start, mid, arr);\n        buildSegmentTree(2 * node + 1, mid + 1, end, arr);\n        segTree[node].minVal = min(segTree[2 * node].minVal, segTree[2 * node + 1].minVal);\n        segTree[node].left = segTree[2 * node].left;\n        segTree[node].right = segTree[2 * node + 1].right;\n    }\n}\n\nint querySegmentTree(int node, int start, int end) {\n    if (segTree[node].left == start && segTree[node].right == end) {\n        return segTree[node].minVal;\n    }\n    int mid = (segTree[node].left + segTree[node].right) / 2;\n    if (end <= mid) {\n        return querySegmentTree(2 * node, start, end);\n    } else if (start > mid) {\n        return querySegmentTree(2 * node + 1, start, end);\n    } else {\n        return min(querySegmentTree(2 * node, start, mid), querySegmentTree(2 * node + 1, mid + 1, end));\n    }\n}\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    segTree.resize(4 * n);\n    buildSegmentTree(1, 0, n - 1, arr);\n    for (int i = 0; i < q; i++) {\n        int a, b;\n        cin >> a >> b;\n        cout << querySegmentTree(1, a - 1, b - 1) << endl;\n    }\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 4,
            "mean_time_taken": 0.20422548055648804,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 36,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Static Range Sum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nint main() {\n    int n, q;\n    std::cin >> n >> q;\n\n    std::vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> arr[i];\n    }\n\n    std::vector<long long> prefix_sum(n);\n    prefix_sum[0] = arr[0];\n    for (int i = 1; i < n; i++) {\n        prefix_sum[i] = prefix_sum[i - 1] + arr[i];\n    }\n\n    for (int i = 0; i < q; i++) {\n        int a, b;\n        std::cin >> a >> b;\n        a--; b--;\n        if (a == 0) {\n            std::cout << prefix_sum[b] << std::endl;\n        } else {\n            std::cout << prefix_sum[b] - prefix_sum[a - 1] << std::endl;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 2,
            "mean_time_taken": 0.1721562147140503,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 37,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Stick Divisions",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int x, n;\n    cin >> x >> n;\n\n    vector<int> lengths(n);\n    for (int i = 0; i < n; i++) {\n        cin >> lengths[i];\n    }\n\n    priority_queue<int, vector<int>, greater<int>> pq;\n    pq.push(x);\n\n    long long cost = 0;\n    for (int i = 0; i < n; i++) {\n        int curr_length = pq.top();\n        pq.pop();\n\n        cost += curr_length;\n\n        if (curr_length > lengths[i]) {\n            pq.push(curr_length - lengths[i]);\n        }\n    }\n\n    cout << cost << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.10579442977905273,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 37,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Stick Game",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> p(k);\n    for (int i = 0; i < k; i++) {\n        cin >> p[i];\n    }\n\n    vector<bool> dp(n + 1, false);\n    dp[0] = false;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j < k; j++) {\n            if (i >= p[j] && !dp[i - p[j]]) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        cout << (dp[i] ? \"W\" : \"L\");\n    }\n\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 6,
            "mean_time_taken": 0.30517979462941486,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                ""
            ],
            "failed_test_cases": [
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 37,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Stick Lengths",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> sticks(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> sticks[i];\n    }\n\n    std::sort(sticks.begin(), sticks.end());\n\n    int median = sticks[n / 2];\n\n    long long total_cost = 0;\n    for (int i = 0; i < n; i++) {\n        total_cost += std::abs(sticks[i] - median);\n    }\n\n    std::cout << total_cost << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.09731186519969594,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 38,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "String Functions",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Calculate the z-function using the Z-algorithm\nvector<int> z_function(const string& s) {\n    int n = s.length();\n    vector<int> z(n, 0);\n    int l = 0, r = 0;\n    for (int i = 1; i < n; i++) {\n        if (i > r) {\n            l = r = i;\n            while (r < n && s[r - l] == s[r]) r++;\n            z[i] = r - l;\n            r--;\n        } else {\n            int k = i - l;\n            if (z[k] < r - i + 1) {\n                z[i] = z[k];\n            } else {\n                l = i;\n                while (r < n && s[r - l] == s[r]) r++;\n                z[i] = r - l;\n                r--;\n            }\n        }\n    }\n    return z;\n}\n\n// Calculate the \u03c0-function using the KMP algorithm\nvector<int> pi_function(const string& s) {\n    int n = s.length();\n    vector<int> pi(n, 0);\n    for (int i = 1; i < n; i++) {\n        int j = pi[i - 1];\n        while (j > 0 && s[i] != s[j]) j = pi[j - 1];\n        if (s[i] == s[j]) j++;\n        pi[i] = j;\n    }\n    return pi;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    vector<int> z = z_function(s);\n    vector<int> pi = pi_function(s);\n    for (int i = 0; i < s.length(); i++) {\n        cout << z[i] << \" \";\n    }\n    cout << endl;\n    for (int i = 0; i < s.length(); i++) {\n        cout << pi[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 5,
            "mean_time_taken": 0.20436310768127441,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 39,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "String Matching",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<int> computePrefixFunction(const std::string& pattern) {\n    int m = pattern.size();\n    std::vector<int> pi(m, 0);\n    int k = 0;\n    for (int q = 1; q < m; q++) {\n        while (k > 0 && pattern[k] != pattern[q]) {\n            k = pi[k - 1];\n        }\n        if (pattern[k] == pattern[q]) {\n            k++;\n        }\n        pi[q] = k;\n    }\n    return pi;\n}\n\nint stringMatching(const std::string& text, const std::string& pattern) {\n    int n = text.size();\n    int m = pattern.size();\n    std::vector<int> pi = computePrefixFunction(pattern);\n    int q = 0;\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        while (q > 0 && pattern[q] != text[i]) {\n            q = pi[q - 1];\n        }\n        if (pattern[q] == text[i]) {\n            q++;\n        }\n        if (q == m) {\n            count++;\n            q = pi[q - 1];\n        }\n    }\n    return count;\n}\n\nint main() {\n    std::string text, pattern;\n    std::cin >> text >> pattern;\n    int count = stringMatching(text, pattern);\n    std::cout << count << std::endl;\n    return 0;\n}",
            "passed_test_cases": 37,
            "total_test_cases": 37,
            "mean_time_taken": 0.08215269526919804,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "String Removals",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nconst int MAX_N = 500005;\nconst int MOD = 1000000007;\n\nint dp[MAX_N];\nint last_occurrence[26];\n\nint main() {\n    std::string input_string;\n    std::cin >> input_string;\n\n    int string_length = input_string.size();\n    std::fill_n(last_occurrence, 26, -1);\n\n    dp[0] = 1;\n    for (int i = 1; i <= string_length; i++) {\n        int current_char = input_string[i - 1] - 'a';\n        int j = last_occurrence[current_char];\n\n        if (j != -1) {\n            dp[i] = (dp[i - 1] + dp[j]) % MOD;\n            dp[i] = (dp[i] - dp[j - 1] + MOD) % MOD;\n        } else {\n            dp[i] = (dp[i - 1] + 1) % MOD;\n        }\n\n        last_occurrence[current_char] = i;\n    }\n\n    std::cout << dp[string_length] << std::endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 7,
            "mean_time_taken": 0.08671471050807408,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "String Reorder",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    string inputString;\n    cin >> inputString;\n\n    int characterCount[26] = {0};\n    for (char c : inputString) {\n        characterCount[c - 'A']++;\n    }\n\n    vector<pair<int, char>> characterFrequency;\n    for (int i = 0; i < 26; i++) {\n        if (characterCount[i] > 0) {\n            characterFrequency.push_back({characterCount[i], 'A' + i});\n        }\n    }\n\n    sort(characterFrequency.begin(), characterFrequency.end(), greater<pair<int, char>>());\n\n    string result = \"\";\n    int prevCount = 0;\n    char prevChar = '\\0';\n\n    for (auto& [count, character] : characterFrequency) {\n        if (count > (inputString.length() + 1) / 2) {\n            cout << -1 << endl;\n            return 0;\n        }\n\n        if (prevCount > 0) {\n            result += prevChar;\n            count--;\n        }\n\n        while (count > 0) {\n            result += character;\n            count--;\n        }\n\n        prevCount = count;\n        prevChar = character;\n    }\n\n    cout << result << endl;\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 15,
            "mean_time_taken": 0.086141570409139,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                12,
                13,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "String Transform",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nint main() {\n    std::string transformedString;\n    std::cin >> transformedString;\n\n    std::string originalString;\n\n    while (!transformedString.empty()) {\n        char smallestChar = 'z' + 1;\n        std::string currentTransformedString = transformedString;\n\n        for (char c = 'a'; c <= 'z'; c++) {\n            originalString.push_back(c);\n            std::string temp = originalString;\n            temp.push_back('#');\n\n            for (int i = 0; i < originalString.size(); i++) {\n                std::rotate(temp.begin(), temp.begin() + 1, temp.end());\n                if (temp > currentTransformedString) {\n                    smallestChar = c;\n                    break;\n                }\n            }\n\n            originalString.pop_back();\n            if (smallestChar <= 'z') break;\n        }\n\n        originalString.push_back(smallestChar);\n        transformedString.pop_back();\n    }\n\n    std::reverse(originalString.begin(), originalString.end());\n    std::cout << originalString << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.5572370290756226,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Strongly Connected Edges",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 100005;\n\nvector<int> graph[MAX_N], reversed_graph[MAX_N];\nbool visited[MAX_N];\n\nvoid dfs1(int node) {\n    visited[node] = true;\n    for (int neighbor : graph[node]) {\n        if (!visited[neighbor]) {\n            cout << neighbor << \" \" << node << endl;\n            dfs1(neighbor);\n        }\n    }\n}\n\nvoid dfs2(int node) {\n    visited[node] = true;\n    for (int neighbor : reversed_graph[node]) {\n        if (!visited[neighbor]) {\n            dfs2(neighbor);\n        }\n    }\n}\n\nint main() {\n    int n, m, a, b;\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        cin >> a >> b;\n        graph[a].push_back(b);\n        reversed_graph[b].push_back(a);\n    }\n    dfs1(1);\n    fill(visited, visited + MAX_N, false);\n    dfs2(1);\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            cout << \"IMPOSSIBLE\" << endl;\n            return 0;\n        }\n    }\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 11,
            "mean_time_taken": 0.1216798262162642,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Distinct Values",
            "category": "Sorting and Searching",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Subarray Divisibility",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    vector<int> prefixSum(n);\n    prefixSum[0] = a[0];\n    for (int i = 1; i < n; i++) {\n        prefixSum[i] = prefixSum[i - 1] + a[i];\n    }\n\n    vector<int> count(n, 0);\n    for (int i = 0; i < n; i++) {\n        int mod = (prefixSum[i] % n + n) % n;\n        count[mod]++;\n    }\n\n    long long result = 0;\n    for (int i = 0; i < n; i++) {\n        result += (long long)count[i] * (count[i] - 1) / 2;\n    }\n\n    cout << result + count[0] << endl;\n\n    return 0;\n}",
            "passed_test_cases": 9,
            "total_test_cases": 10,
            "mean_time_taken": 0.0924344778060913,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                ""
            ],
            "failed_test_cases": [
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Squares",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst int MAX_N = 3005;\nconst long long INF = 1e18;\n\nlong long dp[MAX_N][MAX_N];\nlong long prefix_sum[MAX_N];\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> arr(n + 1);\n    for (int i = 1; i <= n; i++) {\n        cin >> arr[i];\n        prefix_sum[i] = prefix_sum[i - 1] + arr[i];\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= k; j++) {\n            if (j == 1) {\n                dp[i][j] = (prefix_sum[i] * prefix_sum[i]);\n            } else if (i < j) {\n                dp[i][j] = INF;\n            } else {\n                dp[i][j] = INF;\n                for (int p = j - 1; p < i; p++) {\n                    dp[i][j] = min(dp[i][j], dp[p][j - 1] + (prefix_sum[i] - prefix_sum[p]) * (prefix_sum[i] - prefix_sum[p]));\n                }\n            }\n        }\n    }\n\n    cout << dp[n][k] << endl;\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 11,
            "mean_time_taken": 0.6149793321436102,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Sum Queries",
            "category": "Range Queries",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Define the structure for the segment tree node\nstruct Node {\n    long long prefixSum, suffixSum, totalSum, maxSum;\n};\n\n// Function to merge two segment tree nodes\nNode merge(Node left, Node right) {\n    Node result;\n    result.prefixSum = max(left.prefixSum, left.totalSum + right.prefixSum);\n    result.suffixSum = max(right.suffixSum, right.totalSum + left.suffixSum);\n    result.totalSum = left.totalSum + right.totalSum;\n    result.maxSum = max(max(left.maxSum, right.maxSum), left.suffixSum + right.prefixSum);\n    return result;\n}\n\n// Function to build the segment tree\nvoid buildTree(vector<Node>& tree, vector<long long>& arr, int node, int start, int end) {\n    if (start == end) {\n        tree[node].prefixSum = tree[node].suffixSum = tree[node].totalSum = tree[node].maxSum = arr[start];\n    } else {\n        int mid = (start + end) / 2;\n        buildTree(tree, arr, 2 * node, start, mid);\n        buildTree(tree, arr, 2 * node + 1, mid + 1, end);\n        tree[node] = merge(tree[2 * node], tree[2 * node + 1]);\n    }\n}\n\n// Function to update an element in the segment tree\nvoid updateTree(vector<Node>& tree, int node, int start, int end, int idx, long long val) {\n    if (start == end) {\n        tree[node].prefixSum = tree[node].suffixSum = tree[node].totalSum = tree[node].maxSum = val;\n    } else {\n        int mid = (start + end) / 2;\n        if (idx <= mid)\n            updateTree(tree, 2 * node, start, mid, idx, val);\n        else\n            updateTree(tree, 2 * node + 1, mid + 1, end, idx, val);\n        tree[node] = merge(tree[2 * node], tree[2 * node + 1]);\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n    cin >> n >> m;\n\n    vector<long long> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    vector<Node> tree(4 * n);\n    buildTree(tree, arr, 1, 0, n - 1);\n\n    for (int i = 0; i < m; i++) {\n        int k, x;\n        cin >> k >> x;\n        k--;\n        updateTree(tree, 1, 0, n - 1, k, x);\n        cout << tree[1].maxSum << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 15,
            "mean_time_taken": 0.16680204073588054,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                4,
                7,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Sums I",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n\nint main() {\n    int n, x;\n    std::cin >> n >> x;\n\n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n\n    std::vector<int> prefix_sum(n);\n    prefix_sum[0] = a[0];\n    for (int i = 1; i < n; i++) {\n        prefix_sum[i] = prefix_sum[i - 1] + a[i];\n    }\n\n    std::unordered_map<int, int> freq;\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        if (prefix_sum[i] == x) {\n            result++;\n        }\n        if (freq.find(prefix_sum[i] - x) != freq.end()) {\n            result += freq[prefix_sum[i] - x];\n        }\n        freq[prefix_sum[i]]++;\n    }\n\n    std::cout << result << std::endl;\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 12,
            "mean_time_taken": 0.12529116868972778,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                7,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Sums II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n\nint main() {\n    int arraySize, targetSum;\n    std::cin >> arraySize >> targetSum;\n\n    std::vector<int> array(arraySize);\n    for (int i = 0; i < arraySize; i++) {\n        std::cin >> array[i];\n    }\n\n    // Initialize a hash map to store the frequency of each prefix sum\n    std::unordered_map<int, int> prefixSumCount;\n    int currentPrefixSum = 0;\n    int subarrayCount = 0;\n\n    // Iterate through the array and update the current prefix sum\n    for (int i = 0; i < arraySize; i++) {\n        currentPrefixSum += array[i];\n\n        // If the current prefix sum is equal to x, increment the count of subarrays\n        if (currentPrefixSum == targetSum) {\n            subarrayCount++;\n        }\n\n        // If the difference between the current prefix sum and x exists in the hash map,\n        // add its frequency to the count of subarrays\n        if (prefixSumCount.find(currentPrefixSum - targetSum) != prefixSumCount.end()) {\n            subarrayCount += prefixSumCount[currentPrefixSum - targetSum];\n        }\n\n        // Increment the frequency of the current prefix sum in the hash map\n        prefixSumCount[currentPrefixSum]++;\n    }\n\n    // Return the count of subarrays\n    std::cout << subarrayCount << std::endl;\n    return 0;\n}",
            "passed_test_cases": 24,
            "total_test_cases": 27,
            "mean_time_taken": 0.13018858874285663,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                21,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subordinates",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_NODES = 200005;\n\nvector<int> adjacencyList[MAX_NODES]; // adjacency list to represent the tree\nint subordinates[MAX_NODES]; // array to store the number of subordinates for each employee\n\nvoid dfs(int node) {\n    for (int child : adjacencyList[node]) {\n        dfs(child); // recursively traverse the children of the current node\n        subordinates[node] += subordinates[child] + 1; // add the number of subordinates of the current child to the current node\n    }\n}\n\nint main() {\n    int numNodes;\n    cin >> numNodes;\n\n    for (int i = 2; i <= numNodes; i++) {\n        int parent;\n        cin >> parent;\n        adjacencyList[parent].push_back(i); // add the current node to the adjacency list of its parent\n    }\n\n    dfs(1); // start the DFS traversal from the general director (node 1)\n\n    for (int i = 1; i <= numNodes; i++) {\n        cout << subordinates[i] << \" \"; // print the number of subordinates for each employee\n    }\n\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 12,
            "mean_time_taken": 0.11394431193669637,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Substring Distribution",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    string s;\n    cin >> s;\n\n    int n = s.length();\n    vector<int> freq(26, 0);\n\n    for (int i = 0; i < n; i++) {\n        freq[s[i] - 'a']++;\n    }\n\n    for (int len = 1; len <= n; len++) {\n        int count = 0;\n        for (int i = 0; i < 26; i++) {\n            if (freq[i] >= len) {\n                count++;\n            }\n        }\n        cout << count << \" \";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 9,
            "mean_time_taken": 0.08930047353108723,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Substring Order I",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstruct TrieNode {\n    vector<TrieNode*> children;\n    bool isEndOfWord;\n\n    TrieNode() : children(26, nullptr), isEndOfWord(false) {}\n};\n\nclass Trie {\n    TrieNode* root;\n\npublic:\n    Trie() : root(new TrieNode()) {}\n\n    void insert(string word) {\n        TrieNode* node = root;\n        for (char c : word) {\n            int index = c - 'a';\n            if (!node->children[index]) {\n                node->children[index] = new TrieNode();\n            }\n            node = node->children[index];\n        }\n        node->isEndOfWord = true;\n    }\n\n    string findKthSmallest(int k) {\n        string result;\n        TrieNode* node = root;\n        while (k > 0) {\n            for (int i = 0; i < 26; i++) {\n                if (node->children[i]) {\n                    k--;\n                    if (k == 0) {\n                        result += 'a' + i;\n                        break;\n                    }\n                }\n            }\n            node = node->children[result.back() - 'a'];\n        }\n        return result;\n    }\n};\n\nint main() {\n    string s;\n    int k;\n    cin >> s >> k;\n\n    Trie trie;\n    for (int i = 0; i < s.length(); i++) {\n        string substring = \"\";\n        for (int j = i; j < s.length(); j++) {\n            substring += s[j];\n            trie.insert(substring);\n        }\n    }\n\n    cout << trie.findKthSmallest(k) << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 9,
            "mean_time_taken": 0.8326902919345431,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Substring Order II",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring s;\nint k;\n\n// Calculate the number of substrings that are less than or equal to s[i...j]\nint countSubstrings(int i, int j) {\n    int res = 0;\n    int cnt[26] = {0};\n    for (int l = i; l <= j; l++) {\n        res += cnt[s[l] - 'a']++;\n    }\n    return res;\n}\n\n// Find the kth smallest substring in lexicographical order\nstring kthSubstring(int k) {\n    int n = s.length();\n    int left = 0, right = n - 1;\n    while (left < right) {\n        int mid = (left + right) / 2;\n        int count = 0;\n        for (int i = 0; i <= mid; i++) {\n            count += countSubstrings(i, mid);\n        }\n        if (count < k) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    string res = s.substr(left, 1);\n    k -= countSubstrings(left, left);\n    int cnt[26] = {0};\n    for (int i = left + 1; i < n; i++) {\n        cnt[s[i] - 'a']++;\n        if (k <= cnt[s[i] - 'a']) {\n            res += s[i];\n            break;\n        }\n        k -= cnt[s[i] - 'a'];\n    }\n    return res;\n}\n\nint main() {\n    cin >> s >> k;\n    cout << kthSubstring(k) << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 9,
            "mean_time_taken": 0.8210355440775553,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Substring Reversals",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Define a structure for the segment tree nodes\nstruct Node {\n    int sum; // sum of elements in the range\n    int count; // number of elements in the range\n    bool reversed; // flag to indicate if the range is reversed\n};\n\n// Function to build the segment tree from the input string\nvoid buildTree(vector<Node>& tree, const string& s, int v, int tl, int tr) {\n    if (tl == tr) {\n        tree[v].sum = s[tl] - 'A';\n        tree[v].count = 1;\n        tree[v].reversed = false;\n    } else {\n        int tm = (tl + tr) / 2;\n        buildTree(tree, s, 2 * v, tl, tm);\n        buildTree(tree, s, 2 * v + 1, tm + 1, tr);\n        tree[v].sum = tree[2 * v].sum + tree[2 * v + 1].sum;\n        tree[v].count = tree[2 * v].count + tree[2 * v + 1].count;\n        tree[v].reversed = false;\n    }\n}\n\n// Function to update the segment tree nodes that correspond to the query range\nvoid updateTree(vector<Node>& tree, int v, int tl, int tr, int l, int r) {\n    if (l > r || l > tr || r < tl) {\n        return;\n    }\n    if (l <= tl && tr <= r) {\n        tree[v].sum = (tree[v].count * (tree[v].count + 1) / 2) - tree[v].sum;\n        tree[v].reversed = !tree[v].reversed;\n    } else {\n        int tm = (tl + tr) / 2;\n        updateTree(tree, 2 * v, tl, tm, l, r);\n        updateTree(tree, 2 * v + 1, tm + 1, tr, l, r);\n        tree[v].sum = tree[2 * v].sum + tree[2 * v + 1].sum;\n    }\n}\n\n// Function to traverse the segment tree to construct the final string after all the reversal queries\nvoid traverseTree(vector<Node>& tree, int v, int tl, int tr, string& s) {\n    if (tree[v].reversed) {\n        swap(tree[2 * v], tree[2 * v + 1]);\n        tree[2 * v].reversed = !tree[2 * v].reversed;\n        tree[2 * v + 1].reversed = !tree[2 * v + 1].reversed;\n        tree[v].reversed = false;\n    }\n    if (tl == tr) {\n        s[tl] = tree[v].sum + 'A';\n    } else {\n        int tm = (tl + tr) / 2;\n        traverseTree(tree, 2 * v, tl, tm, s);\n        traverseTree(tree, 2 * v + 1, tm + 1, tr, s);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    vector<Node> tree(4 * n);\n    buildTree(tree, s, 1, 0, n - 1);\n    for (int i = 0; i < m; i++) {\n        int l, r;\n        cin >> l >> r;\n        updateTree(tree, 1, 0, n - 1, l - 1, r - 1);\n    }\n    traverseTree(tree, 1, 0, n - 1, s);\n    cout << s << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.19633257389068604,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subtree Queries",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Define constants and global variables\nconst int MAX_N = 200005;\nint num_nodes, num_queries;\nint node_values[MAX_N];\nvector<int> adj_list[MAX_N];\nint subtree_sizes[MAX_N];\nint parents[MAX_N];\nint chains[MAX_N];\nint chain_heads[MAX_N];\nint chain_indices[MAX_N];\nint chain_count;\n\n// Define segment tree data structure\nstruct SegmentTree {\n  int sum[4 * MAX_N];\n\n  // Update the value of a node in the segment tree\n  void update(int node, int start, int end, int index, int value) {\n    if (start == end) {\n      sum[node] = value;\n      return;\n    }\n    int mid = (start + end) / 2;\n    if (index <= mid)\n      update(2 * node, start, mid, index, value);\n    else\n      update(2 * node + 1, mid + 1, end, index, value);\n    sum[node] = sum[2 * node] + sum[2 * node + 1];\n  }\n\n  // Calculate the sum of values in a range of nodes in the segment tree\n  int query(int node, int start, int end, int left, int right) {\n    if (start > right || end < left)\n      return 0;\n    if (start >= left && end <= right)\n      return sum[node];\n    int mid = (start + end) / 2;\n    return query(2 * node, start, mid, left, right) + query(2 * node + 1, mid + 1, end, left, right);\n  }\n};\n\n// Define segment trees for each chain\nSegmentTree segment_trees[MAX_N];\n\n// Perform depth-first search on the tree to calculate subtree sizes and parents\nvoid dfs1(int node, int parent) {\n  subtree_sizes[node] = 1;\n  parents[node] = parent;\n  for (int i = 0; i < adj_list[node].size(); i++) {\n    int child = adj_list[node][i];\n    if (child != parent) {\n      dfs1(child, node);\n      subtree_sizes[node] += subtree_sizes[child];\n    }\n  }\n}\n\n// Perform heavy-light decomposition on the tree to decompose it into chains\nvoid dfs2(int node, int parent, int chain_head) {\n  chains[node] = chain_head;\n  chain_indices[node] = chain_count;\n  segment_trees[chain_head].update(1, 0, num_nodes - 1, chain_count, node_values[node]);\n  chain_count++;\n  int heavy_child = -1;\n  for (int i = 0; i < adj_list[node].size(); i++) {\n    int child = adj_list[node][i];\n    if (child != parent && (heavy_child == -1 || subtree_sizes[child] > subtree_sizes[heavy_child])) {\n      heavy_child = child;\n    }\n  }\n  if (heavy_child != -1) {\n    dfs2(heavy_child, node, chain_head);\n  }\n  for (int i = 0; i < adj_list[node].size(); i++) {\n    int child = adj_list[node][i];\n    if (child != parent && child != heavy_child) {\n      chain_heads[child] = child;\n      dfs2(child, node, child);\n    }\n  }\n}\n\n// Calculate the sum of values in the subtree of a node using the segment trees\nint subtree_query(int node) {\n  int result = 0;\n  while (node != -1) {\n    int chain_head = chains[node];\n    result += segment_trees[chain_head].query(1, 0, num_nodes - 1, chain_indices[chain_head], chain_indices[node]);\n    node = parents[chain_head];\n  }\n  return result;\n}\n\n// Process each query by updating the value of a node in the segment tree or calculating the sum of values in a subtree using the segment tree\nint main() {\n  cin >> num_nodes >> num_queries;\n  for (int i = 0; i < num_nodes; i++) {\n    cin >> node_values[i];\n  }\n  for (int i = 0; i < num_nodes - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    u--;\n    v--;\n    adj_list[u].push_back(v);\n    adj_list[v].push_back(u);\n  }\n  dfs1(0, -1);\n  chain_count = 0;\n  chain_heads[0] = 0;\n  dfs2(0, -1, 0);\n  for (int i = 0; i < num_queries; i++) {\n    int type, u, v;\n    cin >> type >> u;\n    u--;\n    if (type == 1) {\n      cin >> v;\n      segment_trees[chains[u]].update(1, 0, num_nodes - 1, chain_indices[u], v);\n    } else {\n      cout << subtree_query(u) << endl;\n    }\n  }\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Sum of Divisors",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long sum_of_divisors(long long n) {\n    long long sum = 0;\n    for (long long i = 1; i <= n; i++) {\n        long long sigma = 0;\n        for (long long j = 1; j * j <= i; j++) {\n            if (i % j == 0) {\n                sigma += j;\n                if (j * j != i) {\n                    sigma += i / j;\n                }\n            }\n        }\n        sum += sigma;\n        sum %= MOD;\n    }\n    return sum;\n}\n\nint main() {\n    long long n;\n    cin >> n;\n    cout << sum_of_divisors(n) << endl;\n    return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 18,
            "mean_time_taken": 0.608929369184706,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                4,
                8,
                12,
                14,
                16,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sum of Four Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n\nint main() {\n    int n, x;\n    std::cin >> n >> x;\n\n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n\n    std::unordered_map<int, int> m;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int remaining = x - a[i] - a[j];\n            if (m.find(remaining) != m.end()) {\n                std::cout << i + 1 << \" \" << j + 1 << \" \" << m[remaining] + 1 << \" \" << m.find(a[i] + a[j])->second + 1;\n                return 0;\n            }\n            m[a[j]] = j;\n        }\n        m.clear();\n    }\n\n    std::cout << \"IMPOSSIBLE\";\n    return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 28,
            "mean_time_taken": 0.12350838524954659,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                7,
                9,
                11,
                12,
                15,
                16,
                18,
                19,
                20,
                21,
                22,
                26,
                27,
                28
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sum of Three Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n\nint main() {\n    int n, x;\n    std::cin >> n >> x;\n\n    std::vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> arr[i];\n    }\n\n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            int remaining = x - arr[i] - arr[j];\n            for (int k = j + 1; k < n; k++) {\n                if (arr[k] == remaining) {\n                    std::cout << i + 1 << \" \" << j + 1 << \" \" << k + 1 << std::endl;\n                    return 0;\n                }\n            }\n        }\n    }\n\n    std::cout << \"IMPOSSIBLE\" << std::endl;\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 27,
            "mean_time_taken": 0.678182460643627,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10,
                12,
                13,
                14,
                15,
                16,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sum of Two Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    unordered_map<int, int> nums;\n    for (int i = 0; i < n; i++) {\n        int num;\n        cin >> num;\n        if (nums.find(x - num) != nums.end()) {\n            cout << nums[x - num] + 1 << \" \" << i + 1 << endl;\n            return 0;\n        }\n        nums[num] = i;\n    }\n\n    cout << \"IMPOSSIBLE\" << endl;\n    return 0;\n}",
            "passed_test_cases": 18,
            "total_test_cases": 27,
            "mean_time_taken": 0.1671400335099962,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                4,
                9,
                10,
                11,
                21,
                22,
                24,
                25
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Swap Game",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    vector<vector<int>> grid(3, vector<int>(3));\n    int min_moves = 0;\n\n    // Read input grid\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    // Iterate through each cell in the grid\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            int expected_value = i * 3 + j + 1;\n\n            // If the current value is not equal to the expected value\n            if (grid[i][j] != expected_value) {\n                int x, y;\n\n                // Find the index of the expected value in the grid\n                for (int k = 0; k < 3; k++) {\n                    for (int l = 0; l < 3; l++) {\n                        if (grid[k][l] == expected_value) {\n                            x = k;\n                            y = l;\n                            break;\n                        }\n                    }\n                }\n\n                // Swap the current value with the expected value\n                swap(grid[i][j], grid[x][y]);\n\n                // Increment the minimum number of moves required\n                min_moves++;\n            }\n        }\n    }\n\n    // Print the minimum number of moves required\n    cout << min_moves << endl;\n\n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 19,
            "mean_time_taken": 0.07990384101867676,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Swap Round Sorting",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nint parent[MAX_N], rank[MAX_N], arr[MAX_N];\nvector<pair<int, int>> swaps;\n\nint find_parent(int x) {\n    if (parent[x] != x) {\n        parent[x] = find_parent(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid union_sets(int x, int y) {\n    int px = find_parent(x);\n    int py = find_parent(y);\n    if (px == py) {\n        return;\n    }\n    if (rank[px] < rank[py]) {\n        parent[px] = py;\n    } else if (rank[px] > rank[py]) {\n        parent[py] = px;\n    } else {\n        parent[py] = px;\n        rank[px]++;\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> arr[i];\n        parent[i] = i;\n        rank[i] = 1;\n    }\n    for (int i = 1; i <= n; i++) {\n        if (arr[i] != i) {\n            union_sets(i, arr[i]);\n            swaps.push_back({i, arr[i]});\n            swap(arr[i], arr[arr[i]]);\n        }\n    }\n    int components = 0;\n    for (int i = 1; i <= n; i++) {\n        if (parent[i] == i) {\n            components++;\n        }\n    }\n    cout << components << endl;\n    for (auto s : swaps) {\n        cout << s.first << \" \" << s.second << endl;\n    }\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Task Assignment",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Hungarian algorithm for bipartite matching\n// Adapted from https://github.com/atcoder/ac-library/blob/master/atcoder/maxflow.hpp\ntemplate<class Cap> class Hungarian {\n    // ...\n};\n\nint main() {\n    int num_vertices;\n    cin >> num_vertices;\n\n    // Read in the cost matrix\n    vector<vector<int>> cost_matrix(num_vertices, vector<int>(num_vertices));\n    for (int i = 0; i < num_vertices; i++) {\n        for (int j = 0; j < num_vertices; j++) {\n            cin >> cost_matrix[i][j];\n        }\n    }\n\n    // Create a vector to store the left and right vertices of the minimum cost matching\n    vector<int> left_vertices(num_vertices), right_vertices(num_vertices);\n\n    // Use the Hungarian algorithm to find the minimum cost matching in the graph\n    Hungarian<int> hungarian(num_vertices, num_vertices);\n    for (int i = 0; i < num_vertices; i++) {\n        for (int j = 0; j < num_vertices; j++) {\n            hungarian.add_edge(i, j, -cost_matrix[i][j]);\n        }\n    }\n    int total_cost = -hungarian.solve();\n\n    // Print out the minimum total cost and the assignment of tasks to employees\n    cout << total_cost << endl;\n    for (int i = 0; i < num_vertices; i++) {\n        cout << i + 1 << \" \" << hungarian.get_right_vertex(i) + 1 << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Tasks and Deadlines",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct Task {\n    int duration;\n    int deadline;\n};\n\nbool compareTasks(Task a, Task b) {\n    return a.deadline < b.deadline;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<Task> tasks(n);\n    for (int i = 0; i < n; i++) {\n        cin >> tasks[i].duration >> tasks[i].deadline;\n    }\n\n    sort(tasks.begin(), tasks.end(), compareTasks);\n\n    priority_queue<int> maxHeap;\n    int currentTime = 0;\n    long long totalReward = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (currentTime + tasks[i].duration <= tasks[i].deadline) {\n            maxHeap.push(tasks[i].duration);\n            currentTime += tasks[i].duration;\n        } else if (!maxHeap.empty() && tasks[i].duration < maxHeap.top()) {\n            currentTime -= maxHeap.top();\n            maxHeap.pop();\n            maxHeap.push(tasks[i].duration);\n            currentTime += tasks[i].duration;\n        }\n    }\n\n    while (!maxHeap.empty()) {\n        totalReward += tasks[i].deadline - currentTime;\n        currentTime += maxHeap.top();\n        maxHeap.pop();\n    }\n\n    cout << totalReward << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Teleporters Path",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_NODES = 100005;\n\nvector<pair<int, int>> graph[MAX_NODES];\nint in_degree[MAX_NODES], out_degree[MAX_NODES];\nint path[MAX_NODES * 2];\nint num_nodes, num_edges;\n\nvoid dfs(int node, int& path_index) {\n    while (!graph[node].empty()) {\n        auto& edge = graph[node].back();\n        int next_node = edge.first;\n        int edge_index = edge.second;\n        graph[node].pop_back();\n        dfs(next_node, path_index);\n        path[path_index++] = node;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> num_nodes >> num_edges;\n\n    for (int i = 0; i < num_edges; i++) {\n        int node1, node2;\n        cin >> node1 >> node2;\n        graph[node1].push_back({node2, i});\n        out_degree[node1]++;\n        in_degree[node2]++;\n    }\n\n    for (int i = 1; i <= num_nodes; i++) {\n        if (in_degree[i] != out_degree[i]) {\n            cout << \"IMPOSSIBLE\\n\";\n            return 0;\n        }\n    }\n\n    int path_index = 0;\n    dfs(1, path_index);\n\n    if (path_index != num_edges + 1) {\n        cout << \"IMPOSSIBLE\\n\";\n        return 0;\n    }\n\n    for (int i = num_edges; i >= 0; i--) {\n        cout << path[i] << \" \";\n    }\n    cout << \"\\n\";\n\n    return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 18,
            "mean_time_taken": 0.09946670797136095,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                4,
                5,
                7,
                9,
                10,
                11,
                12,
                13,
                15,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Throwing Dice",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int MAX_N = 100005;\nconst int MAX_K = 6;\n\nint dp[MAX_K];\n\nint main() {\n    long long n;\n    cin >> n;\n\n    // Handle edge cases\n    if (n < 6) {\n        cout << (n >= 1 && n <= 6) << endl;\n        return 0;\n    }\n\n    // Initialize the first row of the array\n    for (int i = 1; i <= 6; i++) {\n        dp[i] = 1;\n    }\n\n    // Calculate the number of ways for each sum n and number of dice k\n    for (int k = 2; k <= MAX_K; k++) {\n        for (int i = k; i <= n; i++) {\n            dp[i % MAX_K] = 0;\n            for (int j = 1; j <= 6; j++) {\n                dp[i % MAX_K] = (dp[i % MAX_K] + dp[(i - j + MAX_K) % MAX_K]) % MOD;\n            }\n        }\n    }\n\n    // Return the number of ways to get a sum n by throwing 6 dice\n    cout << dp[n % MAX_K] << endl;\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 32,
            "mean_time_taken": 0.7336020469665527,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tower of Hanoi",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nvoid hanoi(int n, int src, int dst, int aux) {\n    if (n == 1) {\n        cout << src << \" \" << dst << endl;\n        return;\n    }\n    hanoi(n - 1, src, aux, dst);\n    cout << src << \" \" << dst << endl;\n    hanoi(n - 1, aux, dst, src);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    cout << (1 << n) - 1 << endl;\n    hanoi(n, 1, 3, 2);\n    return 0;\n}",
            "passed_test_cases": 16,
            "total_test_cases": 16,
            "mean_time_taken": 0.08398295938968658,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 41,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Towers",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    int number_of_elements;\n    std::cin >> number_of_elements;\n\n    // Read the sizes of the cubes from the input\n    std::vector<int> elements(number_of_elements);\n    for (int i = 0; i < number_of_elements; i++) {\n        std::cin >> elements[i];\n    }\n\n    // Initialize an empty vector to store the top elements of the towers\n    std::vector<int> top_elements;\n\n    // Iterate through the cubes\n    for (int i = 0; i < number_of_elements; i++) {\n        // If the vector is empty or the top element of the last tower is greater than the current cube\n        if (top_elements.empty() || top_elements.back() > elements[i]) {\n            // Push the current cube onto the vector\n            top_elements.push_back(elements[i]);\n        } else {\n            // Use lower_bound to find the position where the current cube can be inserted in the vector\n            auto it = std::lower_bound(top_elements.begin(), top_elements.end(), elements[i]);\n            // Replace the element at that position with the current cube\n            *it = elements[i];\n        }\n    }\n\n    // The minimum number of towers is equal to the size of the vector\n    std::cout << top_elements.size() << std::endl;\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 12,
            "mean_time_taken": 0.09931035836537679,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 41,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Traffic Lights",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    int x, n;\n    std::cin >> x >> n;\n\n    std::vector<int> positions(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> positions[i];\n    }\n\n    std::sort(positions.begin(), positions.end());\n\n    int max_gap = positions[0];\n    for (int i = 1; i < n; i++) {\n        int gap = positions[i] - positions[i - 1];\n        if (gap > max_gap) {\n            max_gap = gap;\n        }\n        std::cout << max_gap << \" \";\n    }\n    std::cout << x - positions[n - 1] << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.12610524892807007,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 41,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Trailing Zeros",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, count = 0;\n    cin >> n;\n    for (int i = 5; i <= n; i *= 5) {\n        count += n / i;\n    }\n    cout << count << endl;\n    return 0;\n}",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.08074237750126766,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Tree Diameter",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 2e5 + 5;\nvector<int> adj[MAX_N];\nint n, max_dist, farthest_node;\n\nvoid dfs(int u, int p, int dist) {\n    if (dist > max_dist) {\n        max_dist = dist;\n        farthest_node = u;\n    }\n    for (int v : adj[u]) {\n        if (v != p) {\n            dfs(v, u, dist + 1);\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n;\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    max_dist = 0;\n    dfs(1, 0, 0);\n\n    max_dist = 0;\n    dfs(farthest_node, 0, 0);\n\n    cout << max_dist << endl;\n\n    return 0;\n}",
            "passed_test_cases": 16,
            "total_test_cases": 18,
            "mean_time_taken": 0.11615886953141955,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Distances I",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_NODES = 200005;\n\nvector<int> adj[MAX_NODES];\nint dist1[MAX_NODES], dist2[MAX_NODES];\n\nvoid dfs1(int node, int parent) {\n    for (int child : adj[node]) {\n        if (child != parent) {\n            dist1[child] = dist1[node] + 1;\n            dfs1(child, node);\n        }\n    }\n}\n\nvoid dfs2(int node, int parent) {\n    for (int child : adj[node]) {\n        if (child != parent) {\n            dist2[child] = max(dist2[node] + 1, dist1[child]);\n            dfs2(child, node);\n        }\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    dfs1(1, 0);\n\n    int max_dist = 0, max_node = 0;\n    for (int i = 1; i <= n; i++) {\n        if (dist1[i] > max_dist) {\n            max_dist = dist1[i];\n            max_node = i;\n        }\n    }\n\n    dfs2(max_node, 0);\n\n    for (int i = 1; i <= n; i++) {\n        cout << max(dist1[i], dist2[i]) << \" \";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 15,
            "mean_time_taken": 0.1507408618927002,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Distances II",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N = 200005;\n\nvector<int> adj[MAX_N];\nint subtree_size[MAX_N];\nlong long subtree_sum[MAX_N];\nlong long total_sum[MAX_N];\nint n;\n\nvoid dfs1(int node, int parent) {\n    subtree_size[node] = 1;\n    subtree_sum[node] = 0;\n    for (int child : adj[node]) {\n        if (child != parent) {\n            dfs1(child, node);\n            subtree_size[node] += subtree_size[child];\n            subtree_sum[node] += subtree_sum[child] + subtree_size[child];\n        }\n    }\n}\n\nvoid dfs2(int node, int parent, int depth) {\n    total_sum[node] = subtree_sum[node] + (n - subtree_size[node]) * depth;\n    for (int child : adj[node]) {\n        if (child != parent) {\n            long long old_subtree_sum = subtree_sum[child];\n            int old_subtree_size = subtree_size[child];\n            subtree_sum[child] = subtree_sum[node] - subtree_sum[child] - subtree_size[child] + (n - subtree_size[child]) * 2;\n            subtree_size[child] = n - subtree_size[child];\n            dfs2(child, node, depth + 1);\n            subtree_sum[child] = old_subtree_sum;\n            subtree_size[child] = old_subtree_size;\n        }\n    }\n}\n\nint main() {\n    cin >> n;\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs1(1, 0);\n    dfs2(1, 0, 0);\n    for (int i = 1; i <= n; i++) {\n        cout << total_sum[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 14,
            "mean_time_taken": 0.14843497957502091,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Isomorphism I",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_NODES = 100005;\n\nvector<int> adjacencyList1[MAX_NODES];\nvector<int> adjacencyList2[MAX_NODES];\nint degreeSequence1[MAX_NODES];\nint degreeSequence2[MAX_NODES];\n\nvoid depthFirstSearch1(int node, int parent) {\n    degreeSequence1[node] = adjacencyList1[node].size();\n    for (int child : adjacencyList1[node]) {\n        if (child != parent) {\n            depthFirstSearch1(child, node);\n        }\n    }\n}\n\nvoid depthFirstSearch2(int node, int parent) {\n    degreeSequence2[node] = adjacencyList2[node].size();\n    for (int child : adjacencyList2[node]) {\n        if (child != parent) {\n            depthFirstSearch2(child, node);\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int numberOfTests;\n    cin >> numberOfTests;\n\n    while (numberOfTests--) {\n        int numberOfNodes;\n        cin >> numberOfNodes;\n\n        for (int i = 1; i <= numberOfNodes; i++) {\n            adjacencyList1[i].clear();\n            adjacencyList2[i].clear();\n        }\n\n        for (int i = 1; i < numberOfNodes; i++) {\n            int node1, node2;\n            cin >> node1 >> node2;\n            adjacencyList1[node1].push_back(node2);\n            adjacencyList1[node2].push_back(node1);\n        }\n\n        for (int i = 1; i < numberOfNodes; i++) {\n            int node1, node2;\n            cin >> node1 >> node2;\n            adjacencyList2[node1].push_back(node2);\n            adjacencyList2[node2].push_back(node1);\n        }\n\n        depthFirstSearch1(1, 0);\n        depthFirstSearch2(1, 0);\n\n        sort(degreeSequence1 + 1, degreeSequence1 + numberOfNodes + 1);\n        sort(degreeSequence2 + 1, degreeSequence2 + numberOfNodes + 1);\n\n        bool isIsomorphic = true;\n        for (int i = 1; i <= numberOfNodes; i++) {\n            if (degreeSequence1[i] != degreeSequence2[i]) {\n                isIsomorphic = false;\n                break;\n            }\n        }\n\n        if (isIsomorphic) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 8,
            "total_test_cases": 15,
            "mean_time_taken": 0.1298085371653239,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                10,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Isomorphism II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_NODES = 100005;\n\nvector<int> graph1[MAX_NODES];\nvector<int> graph2[MAX_NODES];\nvector<int> degrees1;\nvector<int> degrees2;\n\nvoid dfs(vector<int> graph[], vector<int>& degrees, int node, int parent) {\n    degrees.push_back(graph[node].size());\n    for (int child : graph[node]) {\n        if (child != parent) {\n            dfs(graph, degrees, child, node);\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    int numTests;\n    cin >> numTests;\n\n    while (numTests--) {\n        int numNodes;\n        cin >> numNodes;\n\n        for (int i = 1; i <= numNodes; i++) {\n            graph1[i].clear();\n            graph2[i].clear();\n        }\n\n        degrees1.clear();\n        degrees2.clear();\n\n        for (int i = 1; i < numNodes; i++) {\n            int node1, node2;\n            cin >> node1 >> node2;\n            graph1[node1].push_back(node2);\n            graph2[node1].push_back(node2);\n        }\n\n        for (int i = 1; i < numNodes; i++) {\n            int node1, node2;\n            cin >> node1 >> node2;\n            graph1[node1].push_back(node2);\n            graph2[node1].push_back(node2);\n        }\n\n        dfs(graph1, degrees1, 1, 0);\n        dfs(graph2, degrees2, 1, 0);\n\n        sort(degrees1.begin(), degrees1.end());\n        sort(degrees2.begin(), degrees2.end());\n\n        if (degrees1 == degrees2) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 14,
            "mean_time_taken": 0.1473235743386405,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Matching",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N = 200005;\n\nvector<int> adj[MAX_N];\nint leaves = 0;\n\nvoid dfs(int node, int parent) {\n    if (adj[node].size() == 1 && node != 1) {\n        leaves++;\n        return;\n    }\n    for (int neighbor : adj[node]) {\n        if (neighbor != parent) {\n            dfs(neighbor, node);\n        }\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    dfs(1, -1);\n    cout << leaves / 2 << endl;\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 13,
            "mean_time_taken": 0.13906251467191255,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Traversals",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;\n};\n\n// Function to build a binary tree from preorder and inorder traversals\nNode* buildTree(vector<int>& preorder, vector<int>& inorder, int start, int end) {\n    static int preIndex = 0;\n\n    if (start > end)\n        return nullptr;\n\n    Node* node = new Node();\n    node->data = preorder[preIndex++];\n\n    if (start == end)\n        return node;\n\n    int inIndex = distance(inorder.begin(), find(inorder.begin(), inorder.end(), node->data));\n\n    node->left = buildTree(preorder, inorder, start, inIndex - 1);\n    node->right = buildTree(preorder, inorder, inIndex + 1, end);\n\n    return node;\n}\n\n// Function to perform a postorder traversal of the tree\nvoid postorderTraversal(Node* node) {\n    if (node == nullptr)\n        return;\n\n    postorderTraversal(node->left);\n    postorderTraversal(node->right);\n    cout << node->data << \" \";\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> preorder(n), inorder(n);\n\n    for (int i = 0; i < n; i++)\n        cin >> preorder[i];\n\n    for (int i = 0; i < n; i++)\n        cin >> inorder[i];\n\n    Node* root = buildTree(preorder, inorder, 0, n - 1);\n\n    postorderTraversal(root);\n\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 12,
            "mean_time_taken": 0.6359502275784811,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                7,
                9,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Two Knights",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    long long int n, totalSquares, safeSquares, result;\n    cin >> n;\n\n    for (long long int k = 1; k <= n; k++) {\n        totalSquares = k * k;\n        safeSquares = totalSquares - (2 * k - 1) * (k - 2) / 2;\n        result = (totalSquares * (totalSquares - 1) / 2) - (2 * safeSquares * (safeSquares - 1));\n        cout << result / 2 << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 3,
            "mean_time_taken": 0.08922346433003743,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Two Sets",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nint main() {\n    long long int n;\n    std::cin >> n;\n\n    long long int total_sum = n * (n + 1) / 2;\n\n    if (total_sum % 2 != 0) {\n        std::cout << \"NO\";\n        return 0;\n    }\n\n    long long int target_sum = total_sum / 2;\n    long long int current_sum = 0;\n    std::vector<long long int> set1, set2;\n\n    for (long long int i = n; i >= 1; i--) {\n        if (current_sum + i <= target_sum) {\n            current_sum += i;\n            set1.push_back(i);\n        } else {\n            set2.push_back(i);\n        }\n    }\n\n    std::cout << \"YES\\n\";\n    std::cout << set1.size() << \"\\n\";\n    for (long long int i = 0; i < set1.size(); i++) {\n        std::cout << set1[i] << \" \";\n    }\n    std::cout << \"\\n\";\n    std::cout << set2.size() << \"\\n\";\n    for (long long int i = 0; i < set2.size(); i++) {\n        std::cout << set2[i] << \" \";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 15,
            "total_test_cases": 23,
            "mean_time_taken": 0.0847024917602539,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                7,
                9,
                14,
                16,
                17,
                21,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Two Sets II",
            "category": "Dynamic Programming",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Two Stacks Sorting",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <stack>\n#include <vector>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> input(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> input[i];\n    }\n\n    std::stack<int> stack1, stack2;\n    std::vector<int> output;\n\n    for (int num : input) {\n        if (stack1.empty() || num <= stack1.top()) {\n            stack1.push(num);\n        } else {\n            stack2.push(num);\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (!stack1.empty() && (stack2.empty() || stack1.top() <= stack2.top())) {\n            output.push_back(stack1.top());\n            stack1.pop();\n        } else {\n            output.push_back(stack2.top());\n            stack2.pop();\n        }\n    }\n\n    for (int num : output) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 14,
            "mean_time_taken": 0.11308496338980538,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Visiting Cities",
            "category": "Additional Problems",
            "solution": "No solution generated",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Solution generation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Weird Algorithm",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n\nint main() {\n    long long int n;\n    std::cin >> n;\n\n    std::cout << n << \" \";\n\n    while (n != 1) {\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = n * 3 + 1;\n        }\n        std::cout << n << \" \";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.08139206681932722,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Word Combinations",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_set>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countWays(string s, vector<string>& words) {\n    int n = s.length();\n    vector<bool> dp(n + 1, false);\n    unordered_set<string> wordSet(words.begin(), words.end());\n\n    dp[0] = true;\n\n    for (int i = 1; i <= n; i++) {\n        for (string word : words) {\n            int len = word.length();\n            if (i >= len && s.substr(i - len, len) == word && dp[i - len]) {\n                dp[i] = true;\n            }\n        }\n    }\n\n    int count = 0;\n    for (bool val : dp) {\n        if (val) {\n            count = (count + 1) % MOD;\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    string s;\n    int k;\n    cin >> s >> k;\n\n    vector<string> words(k);\n    for (int i = 0; i < k; i++) {\n        cin >> words[i];\n    }\n\n    cout << countWays(s, words) << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.7016629775365194,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Writing Numbers",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <cmath>\n\n// Function to calculate the total number of digits that can be written with n presses of each key\nlong long calculateTotalDigits(long long n) {\n    long long totalDigits = 0;\n    for (long long i = 1; i <= n; i++) {\n        totalDigits += i * 9 * pow(10, i - 1);\n    }\n    return totalDigits;\n}\n\n// Function to calculate the last number that can be written using a given total number of digits\nlong long calculateLastNumber(long long totalDigits) {\n    long long lastNumber = 0;\n    long long currentDigits = 0;\n    long long power = 0;\n    while (currentDigits < totalDigits) {\n        lastNumber++;\n        currentDigits += (long long)log10(lastNumber) + 1;\n        power = (long long)log10(lastNumber);\n    }\n    if (currentDigits > totalDigits) {\n        lastNumber--;\n        power = (long long)log10(lastNumber);\n    }\n    long long remainingDigits = totalDigits - (currentDigits - (power + 1));\n    lastNumber += remainingDigits * pow(10, power);\n    return lastNumber;\n}\n\nint main() {\n    long long n;\n    std::cin >> n;\n\n    // Calculate the total number of digits that can be written with n presses of each key\n    long long totalDigits = calculateTotalDigits(n);\n\n    // Calculate the last number that can be written using the total number of digits calculated above\n    long long lastNumber = calculateLastNumber(totalDigits);\n\n    // Print the last number that can be written\n    std::cout << lastNumber << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 21,
            "mean_time_taken": 0.7201220194498698,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Xor Pyramid",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int result = 0;\n    int count[1000000001] = {0};\n\n    for (int i = 0; i < n; i++) {\n        int num;\n        cin >> num;\n        count[num]++;\n    }\n\n    for (int i = 0; i < 1000000001; i++) {\n        if (count[i] % 2 != 0) {\n            result ^= i;\n        }\n    }\n\n    cout << result << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.13553735613822937,
            "mean_memory_used": 7741624.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        }
    ],
    "total_passed_problems": 43,
    "initial_config": {
        "ignore_time_limits": false,
        "model": "codestral-latest",
        "provider": "mistral",
        "categories": [],
        "shots": 1
    }
}