{
    "problems": [
        {
            "title": "Acyclic Graph Edges",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nvoid dfs(int node, vector<vector<int>>& adj, vector<int>& visited, vector<pair<int, int>>& result) {\n    stack<int> s;\n    s.push(node);\n    visited[node] = 1;\n\n    while (!s.empty()) {\n        int u = s.top();\n        s.pop();\n\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = 1;\n                s.push(v);\n                result.push_back({u, v});\n            } else if (visited[v] == 1) {\n                result.push_back({u, v});\n            }\n        }\n        visited[u] = 2;\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> adj(n + 1);\n    vector<pair<int, int>> edges(m);\n\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n        edges[i] = {a, b};\n    }\n\n    vector<int> visited(n + 1, 0);\n    vector<pair<int, int>> result;\n\n    for (int i = 1; i <= n; ++i) {\n        if (!visited[i]) {\n            dfs(i, adj, visited, result);\n        }\n    }\n\n    for (auto& edge : result) {\n        cout << edge.first << \" \" << edge.second << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 4,
            "mean_time_taken": 0.14707869291305542,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Advertisement",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> heights(n);\n\n    for (int i = 0; i < n; i++) {\n        cin >> heights[i];\n    }\n\n    stack<int> s;\n    int maxArea = 0;\n    int i = 0;\n\n    while (i < n) {\n        if (s.empty() || heights[s.top()] <= heights[i]) {\n            s.push(i++);\n        } else {\n            int tp = s.top();\n            s.pop();\n            int area = heights[tp] * (s.empty() ? i : i - s.top() - 1);\n            maxArea = max(maxArea, area);\n        }\n    }\n\n    while (!s.empty()) {\n        int tp = s.top();\n        s.pop();\n        int area = heights[tp] * (s.empty() ? i : i - s.top() - 1);\n        maxArea = max(maxArea, area);\n    }\n\n    cout << maxArea << endl;\n    return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 11,
            "mean_time_taken": 0.10915613174438477,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                4,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Another Game",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> heaps(n);\n        long long total_coins = 0;\n        for (int i = 0; i < n; ++i) {\n            cin >> heaps[i];\n            total_coins += heaps[i];\n        }\n        if (total_coins % 2 == 1) {\n            cout << \"first\\n\";\n        } else {\n            cout << \"second\\n\";\n        }\n    }\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 3,
            "mean_time_taken": 0.09909979502360027,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Apartments",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    int n, m, k;\n    std::cin >> n >> m >> k;\n    \n    std::vector<int> applicants(n);\n    std::vector<int> apartments(m);\n    \n    for (int i = 0; i < n; ++i) {\n        std::cin >> applicants[i];\n    }\n    \n    for (int i = 0; i < m; ++i) {\n        std::cin >> apartments[i];\n    }\n    \n    std::sort(applicants.begin(), applicants.end());\n    std::sort(apartments.begin(), apartments.end());\n    \n    int i = 0, j = 0;\n    int matches = 0;\n    \n    while (i < n && j < m) {\n        if (apartments[j] < applicants[i] - k) {\n            ++j; // apartment is too small\n        } else if (apartments[j] > applicants[i] + k) {\n            ++i; // apartment is too large\n        } else {\n            ++matches; // apartment is suitable\n            ++i;\n            ++j;\n        }\n    }\n    \n    std::cout << matches << std::endl;\n    \n    return 0;\n}",
            "passed_test_cases": 19,
            "total_test_cases": 19,
            "mean_time_taken": 0.14485175986039012,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 1,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Apple Division",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nint main() {\n    int n;\n    std::cin >> n;\n    std::vector<int> weights(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> weights[i];\n    }\n\n    long long totalWeight = 0;\n    for (int i = 0; i < n; ++i) {\n        totalWeight += weights[i];\n    }\n\n    long long minDifference = totalWeight; // Initialize with a large value\n    \n    // Iterate over all subsets\n    for (int mask = 0; mask < (1 << n); ++mask) {\n        long long subsetWeight = 0;\n        for (int i = 0; i < n; ++i) {\n            if (mask & (1 << i)) {\n                subsetWeight += weights[i];\n            }\n        }\n        long long otherWeight = totalWeight - subsetWeight;\n        long long currentDifference = std::abs(subsetWeight - otherWeight);\n        minDifference = std::min(minDifference, currentDifference);\n    }\n\n    std::cout << minDifference << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 18,
            "total_test_cases": 18,
            "mean_time_taken": 0.11224525504642063,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Apples and Bananas",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int k, n, m;\n    cin >> k >> n >> m;\n\n    vector<int> apple_weights(n);\n    vector<int> banana_weights(m);\n\n    for (int i = 0; i < n; i++) {\n        cin >> apple_weights[i];\n    }\n\n    for (int i = 0; i < m; i++) {\n        cin >> banana_weights[i];\n    }\n\n    // Frequency arrays for apples and bananas\n    vector<int> apple_freq(k + 1, 0);\n    vector<int> banana_freq(k + 1, 0);\n\n    for (int i = 0; i < n; i++) {\n        apple_freq[apple_weights[i]]++;\n    }\n\n    for (int i = 0; i < m; i++) {\n        banana_freq[banana_weights[i]]++;\n    }\n\n    // Calculate results for each weight w from 2 to 2k\n    vector<int> result(2 * k + 1, 0);\n\n    for (int w = 2; w <= 2 * k; w++) {\n        for (int i = 1; i < w; i++) {\n            if (i <= k && (w - i) <= k) {\n                result[w] += apple_freq[i] * banana_freq[w - i];\n            }\n        }\n    }\n\n    // Print the results\n    for (int w = 2; w <= 2 * k; w++) {\n        cout << result[w] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 6,
            "mean_time_taken": 0.7223476568857828,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Area of Rectangles",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nstruct Event {\n    int x, y1, y2, type;\n    bool operator<(const Event& other) const {\n        return x < other.x || (x == other.x && type < other.type);\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Event> events;\n\n    for (int i = 0; i < n; ++i) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        events.push_back({x1, y1, y2, 1});  // Starting edge\n        events.push_back({x2, y1, y2, -1}); // Ending edge\n    }\n\n    sort(events.begin(), events.end());\n\n    multiset<pair<int, int>> activeIntervals;\n    int prevX = events[0].x;\n    long long totalArea = 0;\n\n    for (const auto& event : events) {\n        int curX = event.x;\n\n        // Calculate the total length of active intervals\n        int curY = 0, lastY = -1e6;\n        for (const auto& interval : activeIntervals) {\n            curY += max(0, interval.second - max(lastY, interval.first));\n            lastY = max(lastY, interval.second);\n        }\n\n        totalArea += (long long)curY * (curX - prevX);\n\n        // Update the active intervals\n        if (event.type == 1) {\n            activeIntervals.insert({event.y1, event.y2});\n        } else {\n            activeIntervals.erase(activeIntervals.find({event.y1, event.y2}));\n        }\n\n        prevX = curX;\n    }\n\n    cout << totalArea << endl;\n\n    return 0;\n}",
            "passed_test_cases": 13,
            "total_test_cases": 15,
            "mean_time_taken": 0.31131502787272136,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Array Description",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> x(n);\n    for(int i = 0; i < n; ++i) {\n        cin >> x[i];\n    }\n\n    // dp array\n    vector<vector<int>> dp(n, vector<int>(m + 1, 0));\n\n    // Initializing the dp array for the first position\n    if(x[0] != 0) {\n        dp[0][x[0]] = 1;\n    } else {\n        for(int j = 1; j <= m; ++j) {\n            dp[0][j] = 1;\n        }\n    }\n\n    // Fill the dp table\n    for(int i = 1; i < n; ++i) {\n        if(x[i] != 0) {\n            for(int j = max(1, x[i] - 1); j <= min(m, x[i] + 1); ++j) {\n                dp[i][x[i]] = (dp[i][x[i]] + dp[i-1][j]) % MOD;\n            }\n        } else {\n            for(int j = 1; j <= m; ++j) {\n                for(int k = max(1, j - 1); k <= min(m, j + 1); ++k) {\n                    dp[i][j] = (dp[i][j] + dp[i-1][k]) % MOD;\n                }\n            }\n        }\n    }\n\n    // Summing up the results\n    int result = 0;\n    for(int j = 1; j <= m; ++j) {\n        result = (result + dp[n-1][j]) % MOD;\n    }\n\n    cout << result << endl;\n    return 0;\n}",
            "passed_test_cases": 29,
            "total_test_cases": 29,
            "mean_time_taken": 0.13843181215483566,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Array Division",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nbool canDivide(const vector<int>& arr, int n, int k, long long maxSum) {\n    long long currentSum = 0;\n    int subarrays = 1; // Start with one subarray\n\n    for (int i = 0; i < n; ++i) {\n        if (currentSum + arr[i] > maxSum) {\n            // If adding arr[i] exceeds maxSum, create a new subarray\n            ++subarrays;\n            currentSum = arr[i];\n            if (subarrays > k) {\n                return false; // More subarrays than allowed\n            }\n        } else {\n            currentSum += arr[i];\n        }\n    }\n    return true;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> arr(n);\n    \n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i];\n    }\n\n    long long low = *max_element(arr.begin(), arr.end());\n    long long high = accumulate(arr.begin(), arr.end(), 0LL);\n    long long result = high;\n\n    while (low <= high) {\n        long long mid = (low + high) / 2;\n        if (canDivide(arr, n, k, mid)) {\n            result = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n\n    cout << result << endl;\n    return 0;\n}",
            "passed_test_cases": 18,
            "total_test_cases": 18,
            "mean_time_taken": 0.1193897459242079,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Beautiful Subgrids",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> grid(n, vector<int>(n));\n    \n    for (int i = 0; i < n; ++i) {\n        string row;\n        cin >> row;\n        for (int j = 0; j < n; ++j) {\n            grid[i][j] = row[j] - '0';\n        }\n    }\n\n    long long beautiful_subgrids = 0;\n    \n    // For each pair of columns, count rows with black cells.\n    for (int col1 = 0; col1 < n; ++col1) {\n        for (int col2 = col1 + 1; col2 < n; ++col2) {\n            int count = 0;\n            for (int row = 0; row < n; ++row) {\n                if (grid[row][col1] == 1 && grid[row][col2] == 1) {\n                    ++count;\n                }\n            }\n            if (count >= 2) {\n                beautiful_subgrids += count * (count - 1) / 2;\n            }\n        }\n    }\n\n    cout << beautiful_subgrids << endl;\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 8,
            "mean_time_taken": 0.8060687482357025,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Binary Subsequences",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <cmath>\n#include <string>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    // Calculate the minimum L such that 2^L >= n + 1\n    int L = ceil(log2(n + 1));\n    \n    // Generate a bit string of length L\n    string bitString;\n    for (int i = 0; i < L; ++i) {\n        bitString += (i % 2 == 0) ? '1' : '0';\n    }\n    \n    // Output the result\n    cout << bitString << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 12,
            "mean_time_taken": 0.09143628676732381,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Binomial Coefficients",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#define MOD 1000000007\n\nusing namespace std;\n\n// Function to compute x^y % p using modular exponentiation\nlong long mod_exp(long long x, long long y, long long p) {\n    long long res = 1;\n    x = x % p;\n    while (y > 0) {\n        if (y & 1)\n            res = (res * x) % p;\n        y = y >> 1;\n        x = (x * x) % p;\n    }\n    return res;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<pair<int, int>> queries(n);\n    int max_a = 0;\n\n    for (int i = 0; i < n; ++i) {\n        cin >> queries[i].first >> queries[i].second;\n        max_a = max(max_a, queries[i].first);\n    }\n\n    // Precompute factorials and inverse factorials\n    vector<long long> fact(max_a + 1), inv_fact(max_a + 1);\n    fact[0] = 1;\n    for (int i = 1; i <= max_a; ++i) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n\n    // Compute inverse factorials using Fermat's Little Theorem\n    inv_fact[max_a] = mod_exp(fact[max_a], MOD - 2, MOD);\n    for (int i = max_a - 1; i >= 0; --i) {\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;\n    }\n\n    // Process each query and output the result\n    for (const auto &query : queries) {\n        int a = query.first, b = query.second;\n        long long result = fact[a] * inv_fact[b] % MOD * inv_fact[a - b] % MOD;\n        cout << result << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.12790764461864124,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 5,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Bit Inversions",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nclass SegmentTree {\npublic:\n    SegmentTree(const string &s) {\n        n = s.size();\n        tree.resize(4 * n);\n        build(s, 0, 0, n - 1);\n    }\n\n    void update(int idx, char new_value) {\n        update(0, 0, n - 1, idx, new_value);\n    }\n\n    int query() const {\n        return tree[0].max_len;\n    }\n\nprivate:\n    struct Node {\n        int max_len;\n        int left_len;\n        char left_char;\n        int right_len;\n        char right_char;\n    };\n\n    int n;\n    vector<Node> tree;\n\n    void build(const string &s, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = {1, 1, s[start], 1, s[start]};\n        } else {\n            int mid = (start + end) / 2;\n            build(s, 2 * node + 1, start, mid);\n            build(s, 2 * node + 2, mid + 1, end);\n            merge(node, start, end);\n        }\n    }\n\n    void update(int node, int start, int end, int idx, char new_value) {\n        if (start == end) {\n            tree[node] = {1, 1, new_value, 1, new_value};\n        } else {\n            int mid = (start + end) / 2;\n            if (idx <= mid) {\n                update(2 * node + 1, start, mid, idx, new_value);\n            } else {\n                update(2 * node + 2, mid + 1, end, idx, new_value);\n            }\n            merge(node, start, end);\n        }\n    }\n\n    void merge(int node, int start, int end) {\n        int mid = (start + end) / 2;\n        Node left = tree[2 * node + 1];\n        Node right = tree[2 * node + 2];\n\n        tree[node].left_char = left.left_char;\n        tree[node].right_char = right.right_char;\n\n        if (left.left_char == right.left_char) {\n            tree[node].left_len = left.left_len + right.left_len;\n        } else {\n            tree[node].left_len = left.left_len;\n        }\n\n        if (right.right_char == left.right_char) {\n            tree[node].right_len = right.right_len + left.right_len;\n        } else {\n            tree[node].right_len = right.right_len;\n        }\n\n        tree[node].max_len = max(left.max_len, right.max_len);\n        if (left.right_char == right.left_char) {\n            tree[node].max_len = max(tree[node].max_len, left.right_len + right.left_len);\n        }\n    }\n};\n\nint main() {\n    string s;\n    cin >> s;\n    int m;\n    cin >> m;\n    vector<int> changes(m);\n    for (int i = 0; i < m; ++i) {\n        cin >> changes[i];\n        --changes[i];\n    }\n\n    SegmentTree segTree(s);\n\n    for (int change : changes) {\n        s[change] = (s[change] == '0') ? '1' : '0';\n        segTree.update(change, s[change]);\n        cout << segTree.query() << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.22513558467229208,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 5,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bit Problem",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <bitset>\n\nusing namespace std;\n\nconst int MAX_VAL = 1e6 + 1;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    vector<int> freq(MAX_VAL, 0);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n        freq[a[i]]++;\n    }\n\n    vector<int> countDivisible(MAX_VAL, 0);\n    vector<int> countAndEqual(MAX_VAL, 0);\n    vector<int> countAndNonZero(MAX_VAL, 0);\n\n    // Precompute countDivisible and countAndEqual\n    for (int x = 1; x < MAX_VAL; ++x) {\n        for (int multiple = x; multiple < MAX_VAL; multiple += x) {\n            countDivisible[x] += freq[multiple];\n        }\n        countAndEqual[x] = freq[x];\n    }\n\n    // Precompute countAndNonZero\n    for (int x = 1; x < MAX_VAL; ++x) {\n        for (int y = x; y < MAX_VAL; y += x) {\n            countAndNonZero[x] += freq[y];\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        int x = a[i];\n        int resDivisible = countDivisible[x];\n        int resAndEqual = countAndEqual[x];\n        int resAndNonZero = 0;\n\n        for (int j = 0; j < 20; ++j) {\n            if (x & (1 << j)) {\n                for (int k = 0; k < (1 << 20); k += (1 << (j + 1))) {\n                    resAndNonZero += freq[k + (x & ((1 << j) - 1))];\n                }\n            }\n        }\n\n        cout << resDivisible << \" \" << resAndEqual << \" \" << resAndNonZero << \"\\n\";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.2680736780166626,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 5,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bit Strings",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\n// Function to perform modular exponentiation\nlong long mod_exp(long long base, long long exp, int mod) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) { // If exp is odd, multiply the base with result\n            result = (result * base) % mod;\n        }\n        base = (base * base) % mod; // Square the base\n        exp = exp / 2; // Divide the exponent by 2\n    }\n    return result;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    // Calculate 2^n % (10^9 + 7)\n    long long result = mod_exp(2, n, MOD);\n    \n    cout << result << endl;\n    return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.09302767117818196,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Bit Substrings",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.length();\n    \n    vector<long long> result(n + 1, 0);\n    unordered_map<int, long long> prefixCount;\n    \n    // Initialize prefixCount for prefix sum 0 (empty prefix)\n    prefixCount[0] = 1;\n    \n    int prefixSum = 0;\n    \n    for (int i = 0; i < n; ++i) {\n        // Update the prefix sum\n        prefixSum += (s[i] == '1' ? 1 : 0);\n        \n        // If we have seen this prefix sum before, it means there are substrings\n        // ending at the current index i which have a certain number of ones.\n        for (int k = 0; k <= prefixSum; ++k) {\n            result[k] += prefixCount[prefixSum - k];\n        }\n        \n        // Update the count of the current prefix sum\n        prefixCount[prefixSum]++;\n    }\n    \n    // Print the result\n    for (int k = 0; k <= n; ++k) {\n        cout << result[k] << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 8,
            "mean_time_taken": 0.453350692987442,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Book Shop",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n    vector<int> h(n), s(n);\n    \n    for (int i = 0; i < n; ++i) {\n        cin >> h[i];\n    }\n    \n    for (int i = 0; i < n; ++i) {\n        cin >> s[i];\n    }\n    \n    vector<int> dp(x + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = x; j >= h[i]; --j) {\n            dp[j] = max(dp[j], dp[j - h[i]] + s[i]);\n        }\n    }\n    \n    cout << dp[x] << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 8,
            "total_test_cases": 15,
            "mean_time_taken": 0.5892682711283366,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                9,
                11,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Book Shop II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n    \n    vector<int> h(n), s(n), k(n);\n    for (int i = 0; i < n; ++i) cin >> h[i];\n    for (int i = 0; i < n; ++i) cin >> s[i];\n    for (int i = 0; i < n; ++i) cin >> k[i];\n    \n    vector<int> dp(x + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = x; j >= 0; --j) {\n            for (int c = 1; c <= k[i] && c * h[i] <= j; ++c) {\n                dp[j] = max(dp[j], dp[j - c * h[i]] + c * s[i]);\n            }\n        }\n    }\n    \n    int max_pages = 0;\n    for (int j = 0; j <= x; ++j) {\n        max_pages = max(max_pages, dp[j]);\n    }\n    \n    cout << max_pages << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 10,
            "mean_time_taken": 0.5864845275878906,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bracket Sequences I",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int MAXN = 1e6 + 5;\n\nvector<long long> fact(MAXN), invfact(MAXN);\n\nlong long modpow(long long base, long long exp, long long mod) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return result;\n}\n\nvoid precompute_factorials_and_inverses(int max_n, int mod) {\n    fact[0] = 1;\n    for (int i = 1; i <= max_n; ++i) {\n        fact[i] = fact[i-1] * i % mod;\n    }\n    invfact[max_n] = modpow(fact[max_n], mod - 2, mod);\n    for (int i = max_n - 1; i >= 0; --i) {\n        invfact[i] = invfact[i + 1] * (i + 1) % mod;\n    }\n}\n\nlong long binomial_coefficient(int n, int k, int mod) {\n    if (k > n || k < 0) return 0;\n    return fact[n] * invfact[k] % mod * invfact[n - k] % mod;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    if (n % 2 != 0) {\n        cout << 0 << endl;\n        return 0;\n    }\n    \n    int half_n = n / 2;\n    precompute_factorials_and_inverses(2 * half_n, MOD);\n    \n    long long catalan_number = binomial_coefficient(2 * half_n, half_n, MOD) * modpow(half_n + 1, MOD - 2, MOD) % MOD;\n    \n    cout << catalan_number << endl;\n    return 0;\n}",
            "passed_test_cases": 17,
            "total_test_cases": 17,
            "mean_time_taken": 0.09437276335323558,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Bracket Sequences II",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n;\n    string prefix;\n    cin >> n >> prefix;\n\n    int k = prefix.size();\n    int open = 0, close = 0;\n\n    for (char ch : prefix) {\n        if (ch == '(') open++;\n        else close++;\n    }\n\n    if (open > n / 2 || close > n / 2 || open < close) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n    dp[prefix.size()][open - close] = 1;\n\n    for (int i = k; i < n; ++i) {\n        for (int j = 0; j <= n; ++j) {\n            if (dp[i][j] > 0) {\n                if (j + 1 <= n) {\n                    dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % MOD;\n                }\n                if (j - 1 >= 0) {\n                    dp[i + 1][j - 1] = (dp[i + 1][j - 1] + dp[i][j]) % MOD;\n                }\n            }\n        }\n    }\n\n    cout << dp[n][0] << endl;\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 11,
            "mean_time_taken": 0.1983248320492831,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                4,
                6,
                7,
                8,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Building Roads",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid dfs(int v, vector<vector<int>>& adj, vector<bool>& visited) {\n    visited[v] = true;\n    for (int u : adj[v]) {\n        if (!visited[u]) {\n            dfs(u, adj, visited);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<vector<int>> adj(n + 1);\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    \n    vector<bool> visited(n + 1, false);\n    vector<int> representatives;\n\n    for (int i = 1; i <= n; ++i) {\n        if (!visited[i]) {\n            representatives.push_back(i);\n            dfs(i, adj, visited);\n        }\n    }\n    \n    int k = representatives.size() - 1;\n    cout << k << endl;\n    for (int i = 1; i < representatives.size(); ++i) {\n        cout << representatives[i-1] << \" \" << representatives[i] << endl;\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.14151402314503989,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Building Teams",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nbool bfs(int start, vector<vector<int>>& adj, vector<int>& team) {\n    queue<int> q;\n    q.push(start);\n    team[start] = 1; // Start with team 1\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        for (int neighbor : adj[node]) {\n            if (team[neighbor] == 0) {\n                // Assign opposite team\n                team[neighbor] = 3 - team[node];\n                q.push(neighbor);\n            } else if (team[neighbor] == team[node]) {\n                // If the neighbor is in the same team, it's not bipartite\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> adj(n + 1);\n    vector<int> team(n + 1, 0); // team[i] will be 0 if unvisited, 1 or 2 otherwise\n\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        if (team[i] == 0) {\n            if (!bfs(i, adj, team)) {\n                cout << \"IMPOSSIBLE\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        cout << team[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.14179344177246095,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Candy Lottery",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    \n    double expected_max = 0.0;\n\n    for (int x = 1; x <= k; ++x) {\n        double prob_x = pow((double)x / k, n) - pow((double)(x - 1) / k, n);\n        expected_max += x * prob_x;\n    }\n\n    cout << fixed << setprecision(6) << expected_max << endl;\n\n    return 0;\n}",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.0884033100945609,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Chess Tournament",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> x(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> x[i];\n    }\n\n    // Check if the total number of requested games is even\n    int total_games = 0;\n    for (int games : x) {\n        total_games += games;\n    }\n    if (total_games % 2 != 0) {\n        cout << \"IMPOSSIBLE\" << endl;\n        return 0;\n    }\n\n    // Priority queue to store players based on remaining games they want to play\n    priority_queue<pair<int, int>> pq;\n    for (int i = 0; i < n; ++i) {\n        if (x[i] > 0) {\n            pq.push({x[i], i + 1});\n        }\n    }\n\n    vector<pair<int, int>> result;\n    while (pq.size() >= 2) {\n        auto player1 = pq.top(); pq.pop();\n        auto player2 = pq.top(); pq.pop();\n\n        result.push_back({player1.second, player2.second});\n        \n        if (--player1.first > 0) {\n            pq.push(player1);\n        }\n        if (--player2.first > 0) {\n            pq.push(player2);\n        }\n    }\n\n    // If there are any players left who still want to play more games, it's impossible\n    if (!pq.empty()) {\n        cout << \"IMPOSSIBLE\" << endl;\n    } else {\n        cout << result.size() << endl;\n        for (auto& game : result) {\n            cout << game.first << \" \" << game.second << endl;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 21,
            "mean_time_taken": 0.12992270787556967,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                9,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Chessboard and Queens",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 8;\nvector<string> board(N);\nvector<bool> col(N, false), diag1(2 * N - 1, false), diag2(2 * N - 1, false);\nint count = 0;\n\nvoid solve(int row) {\n    if (row == N) {\n        count++;\n        return;\n    }\n    for (int c = 0; c < N; ++c) {\n        if (board[row][c] == '.' && !col[c] && !diag1[row - c + N - 1] && !diag2[row + c]) {\n            col[c] = diag1[row - c + N - 1] = diag2[row + c] = true;\n            solve(row + 1);\n            col[c] = diag1[row - c + N - 1] = diag2[row + c] = false;\n        }\n    }\n}\n\nint main() {\n    for (int i = 0; i < N; ++i) {\n        cin >> board[i];\n    }\n    solve(0);\n    cout << count << endl;\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.08923144340515136,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Christmas Party",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#define MOD 1000000007\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    // Base cases\n    if (n == 0) {\n        cout << 1 << endl;\n        return 0;\n    } else if (n == 1) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    // DP array to store the number of derangements\n    vector<long long> derangements(n + 1);\n    derangements[0] = 1;\n    derangements[1] = 0;\n\n    // Fill the DP array using the recurrence relation\n    for (int i = 2; i <= n; ++i) {\n        derangements[i] = (i - 1) * (derangements[i - 1] + derangements[i - 2]) % MOD;\n    }\n\n    // Output the result for the given n\n    cout << derangements[n] << endl;\n\n    return 0;\n}",
            "passed_test_cases": 15,
            "total_test_cases": 15,
            "mean_time_taken": 0.09112788836161295,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Coding Company",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n    vector<int> t(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> t[i];\n    }\n\n    // Sort the skill levels\n    sort(t.begin(), t.end());\n\n    // DP array\n    vector<int> dp(x + 1, 0);\n    dp[0] = 1; // There's one way to split zero coders (empty split)\n\n    // Iterate over each coder\n    for (int i = 0; i < n; ++i) {\n        // Temporary array to store new dp values\n        vector<int> new_dp(x + 1, 0);\n        // Iterate over all current penalties\n        for (int current_penalty = 0; current_penalty <= x; ++current_penalty) {\n            if (dp[current_penalty] == 0) continue;\n            // Try to form teams ending at coder i\n            for (int j = i; j < n; ++j) {\n                int penalty = t[j] - t[i];\n                if (current_penalty + penalty <= x) {\n                    new_dp[current_penalty + penalty] = (new_dp[current_penalty + penalty] + dp[current_penalty]) % MOD;\n                } else {\n                    break; // No need to check further since the array is sorted\n                }\n            }\n        }\n        // Update dp with new values\n        for (int j = 0; j <= x; ++j) {\n            dp[j] = (dp[j] + new_dp[j]) % MOD;\n        }\n    }\n\n    // Sum up all valid partition counts\n    int result = 0;\n    for (int i = 0; i <= x; ++i) {\n        result = (result + dp[i]) % MOD;\n    }\n\n    cout << result << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.09680670102437337,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Arrangement",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> grid(2 * n);\n    \n    // Read the grid values\n    for (int i = 0; i < 2 * n; ++i) {\n        cin >> grid[i];\n    }\n    \n    long long prefix_sum = 0;\n    long long moves = 0;\n    \n    // Iterate through each cell in the grid\n    for (int i = 0; i < 2 * n; ++i) {\n        // Calculate the imbalance at current cell\n        int imbalance = grid[i] - 1;\n        // Update the prefix sum with the current imbalance\n        prefix_sum += imbalance;\n        // The number of moves required is the absolute value of the prefix sum\n        moves += abs(prefix_sum);\n    }\n    \n    // Output the result\n    cout << moves << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 10,
            "mean_time_taken": 0.10032408237457276,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Collector",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nvoid topologicalSortUtil(int v, vector<bool>& visited, stack<int>& Stack, const vector<vector<int>>& adj) {\n    visited[v] = true;\n    for (int i : adj[v]) {\n        if (!visited[i]) {\n            topologicalSortUtil(i, visited, Stack, adj);\n        }\n    }\n    Stack.push(v);\n}\n\nvector<int> topologicalSort(int n, const vector<vector<int>>& adj) {\n    stack<int> Stack;\n    vector<bool> visited(n, false);\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            topologicalSortUtil(i, visited, Stack, adj);\n        }\n    }\n    vector<int> order;\n    while (!Stack.empty()) {\n        order.push_back(Stack.top());\n        Stack.pop();\n    }\n    return order;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> coins(n);\n    for (int i = 0; i < n; i++) {\n        cin >> coins[i];\n    }\n    vector<vector<int>> adj(n);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a-1].push_back(b-1);\n    }\n    \n    vector<int> topoOrder = topologicalSort(n, adj);\n    vector<long long> dp(n, 0);\n    \n    for (int i : topoOrder) {\n        dp[i] += coins[i];\n        for (int neighbor : adj[i]) {\n            dp[neighbor] = max(dp[neighbor], dp[i]);\n        }\n    }\n    \n    long long maxCoins = *max_element(dp.begin(), dp.end());\n    cout << maxCoins << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 14,
            "mean_time_taken": 0.13445438657488143,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Combinations I",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nconst int MOD = 1000000007;\n\nint main() {\n    int n, x;\n    std::cin >> n >> x;\n    \n    std::vector<int> coins(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> coins[i];\n    }\n    \n    std::vector<int> dp(x + 1, 0);\n    dp[0] = 1; // There's one way to make sum 0, by using no coins\n    \n    for (int coin : coins) {\n        for (int j = coin; j <= x; ++j) {\n            dp[j] = (dp[j] + dp[j - coin]) % MOD;\n        }\n    }\n    \n    std::cout << dp[x] << std::endl;\n    \n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 13,
            "mean_time_taken": 0.19853443365830642,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                4,
                6,
                7,
                8,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Combinations II",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n\nconst int MOD = 1000000007;\n\nint main() {\n    int n, x;\n    std::cin >> n >> x;\n    \n    std::vector<int> coins(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> coins[i];\n    }\n    \n    std::vector<int> dp(x + 1, 0);\n    dp[0] = 1; // There's one way to form the sum 0, which is using no coins.\n    \n    for (int coin : coins) {\n        for (int j = coin; j <= x; ++j) {\n            dp[j] = (dp[j] + dp[j - coin]) % MOD;\n        }\n    }\n    \n    std::cout << dp[x] << std::endl;\n    \n    return 0;\n}",
            "passed_test_cases": 15,
            "total_test_cases": 15,
            "mean_time_taken": 0.25618977546691896,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Coin Grid",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<string> grid(n);\n    \n    for (int i = 0; i < n; ++i) {\n        cin >> grid[i];\n    }\n    \n    vector<int> rows, cols;\n    vector<bool> rowHasCoin(n, false), colHasCoin(n, false);\n    \n    // Identify rows and columns with coins\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] == 'o') {\n                rowHasCoin[i] = true;\n                colHasCoin[j] = true;\n            }\n        }\n    }\n    \n    // Collect rows and columns that need to be cleared\n    for (int i = 0; i < n; ++i) {\n        if (rowHasCoin[i]) {\n            rows.push_back(i + 1); // +1 to match the 1-based indexing\n        }\n    }\n    \n    for (int j = 0; j < n; ++j) {\n        if (colHasCoin[j]) {\n            cols.push_back(j + 1); // +1 to match the 1-based indexing\n        }\n    }\n    \n    // Print the number of moves\n    cout << rows.size() + cols.size() << endl;\n    \n    // Print the moves\n    for (int row : rows) {\n        cout << \"1 \" << row << endl;\n    }\n    \n    for (int col : cols) {\n        cout << \"2 \" << col << endl;\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 10,
            "mean_time_taken": 0.09123578071594238,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Piles",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        long long a, b;\n        cin >> a >> b;\n        if ((a + b) % 3 == 0 && 2 * a >= b && 2 * b >= a) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 3,
            "mean_time_taken": 0.14372714360555014,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Collecting Numbers",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    vector<int> pos(n+1); // position array to store positions of numbers 1 to n\n\n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i];\n        pos[arr[i]] = i; // store the position of each number\n    }\n\n    int rounds = 1; // at least one round is needed\n    for (int i = 2; i <= n; ++i) {\n        if (pos[i] < pos[i-1]) {\n            ++rounds; // new round needed\n        }\n    }\n\n    cout << rounds << endl;\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 4,
            "mean_time_taken": 0.11819708347320557,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Collecting Numbers II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<int> array(n);\n    vector<int> pos(n + 1);\n    \n    for (int i = 0; i < n; i++) {\n        cin >> array[i];\n        pos[array[i]] = i;\n    }\n    \n    auto rounds_needed = [&]() {\n        int rounds = 1;\n        for (int i = 2; i <= n; i++) {\n            if (pos[i] < pos[i - 1]) {\n                rounds++;\n            }\n        }\n        return rounds;\n    };\n    \n    int rounds = rounds_needed();\n    \n    while (m--) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--; // Convert to zero-based index\n        \n        // Elements to be swapped\n        int val_a = array[a], val_b = array[b];\n        \n        // Positions affected by the swap\n        vector<int> affected = {val_a, val_b};\n        for (int dx : {-1, 1}) {\n            if (val_a + dx >= 1 && val_a + dx <= n) affected.push_back(val_a + dx);\n            if (val_b + dx >= 1 && val_b + dx <= n) affected.push_back(val_b + dx);\n        }\n        \n        // Remove duplicates\n        sort(affected.begin(), affected.end());\n        affected.erase(unique(affected.begin(), affected.end()), affected.end());\n        \n        // Subtract the round count changes before the swap\n        for (int val : affected) {\n            if (val > 1 && pos[val] < pos[val - 1]) rounds--;\n        }\n        \n        // Perform the swap\n        swap(array[a], array[b]);\n        swap(pos[val_a], pos[val_b]);\n        \n        // Add the round count changes after the swap\n        for (int val : affected) {\n            if (val > 1 && pos[val] < pos[val - 1]) rounds++;\n        }\n        \n        cout << rounds << endl;\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 2,
            "mean_time_taken": 0.4682866334915161,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Common Divisors",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<int> arr(n);\n    vector<int> freq(1000001, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i];\n        freq[arr[i]]++;\n    }\n    \n    for (int gcd = 1000000; gcd > 0; --gcd) {\n        int count = 0;\n        for (int multiple = gcd; multiple <= 1000000; multiple += gcd) {\n            count += freq[multiple];\n        }\n        if (count >= 2) {\n            cout << gcd << endl;\n            return 0;\n        }\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 17,
            "total_test_cases": 17,
            "mean_time_taken": 0.1190941333770752,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Company Queries I",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> boss(n + 1);\n    for (int i = 2; i <= n; ++i) {\n        cin >> boss[i];\n    }\n\n    int LOG = log2(n) + 1;\n    vector<vector<int>> up(n + 1, vector<int>(LOG));\n\n    for (int i = 1; i <= n; ++i) {\n        up[i][0] = boss[i];\n    }\n\n    for (int j = 1; j < LOG; ++j) {\n        for (int i = 1; i <= n; ++i) {\n            if (up[i][j - 1] != 0) {\n                up[i][j] = up[up[i][j - 1]][j - 1];\n            }\n        }\n    }\n\n    while (q--) {\n        int x, k;\n        cin >> x >> k;\n\n        for (int j = 0; j < LOG; ++j) {\n            if (x == 0) break;\n            if (k & (1 << j)) {\n                x = up[x][j];\n            }\n        }\n\n        if (x == 0) {\n            cout << -1 << '\\n';\n        } else {\n            cout << x << '\\n';\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.1441190242767334,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Company Queries II",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 200005;\nconst int LOG = 18; // ceil(log2(200000)) is about 18\n\nvector<int> adj[MAXN];\nint up[MAXN][LOG]; // up[i][j] is the 2^j-th ancestor of node i\nint depth[MAXN];\n\nvoid dfs(int v, int parent) {\n    up[v][0] = parent;\n    for (int j = 1; j < LOG; ++j) {\n        if (up[v][j - 1] != -1)\n            up[v][j] = up[up[v][j - 1]][j - 1];\n        else\n            up[v][j] = -1;\n    }\n    for (int u : adj[v]) {\n        if (u != parent) {\n            depth[u] = depth[v] + 1;\n            dfs(u, v);\n        }\n    }\n}\n\nint lca(int a, int b) {\n    if (depth[a] < depth[b])\n        swap(a, b);\n    // Lift a up to the same level as b\n    int diff = depth[a] - depth[b];\n    for (int j = LOG - 1; j >= 0; --j) {\n        if ((diff >> j) & 1)\n            a = up[a][j];\n    }\n    if (a == b)\n        return a;\n    // Lift both a and b up until their LCA is found\n    for (int j = LOG - 1; j >= 0; --j) {\n        if (up[a][j] != up[b][j]) {\n            a = up[a][j];\n            b = up[b][j];\n        }\n    }\n    return up[a][0];\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, q;\n    cin >> n >> q;\n    \n    for (int i = 2; i <= n; ++i) {\n        int boss;\n        cin >> boss;\n        adj[boss].push_back(i);\n        adj[i].push_back(boss);\n    }\n    \n    // Initialize the up table and depth array\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < LOG; ++j) {\n            up[i][j] = -1;\n        }\n    }\n    depth[1] = 0;\n    dfs(1, -1);\n    \n    while (q--) {\n        int a, b;\n        cin >> a >> b;\n        cout << lca(a, b) << \"\\n\";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 12,
            "mean_time_taken": 0.15784168243408203,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                ""
            ],
            "failed_test_cases": [
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Concert Tickets",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    multiset<int> tickets;\n    vector<int> customers(m);\n    \n    // Reading the ticket prices\n    for (int i = 0; i < n; ++i) {\n        int price;\n        cin >> price;\n        tickets.insert(price);\n    }\n    \n    // Reading the maximum prices customers are willing to pay\n    for (int i = 0; i < m; ++i) {\n        cin >> customers[i];\n    }\n    \n    // Processing each customer\n    for (int i = 0; i < m; ++i) {\n        int max_price = customers[i];\n        auto it = tickets.upper_bound(max_price);\n        \n        if (it == tickets.begin()) {\n            // No ticket is affordable for the current customer\n            cout << \"-1\\n\";\n        } else {\n            // Move iterator to the largest price that is <= max_price\n            --it;\n            cout << *it << \"\\n\";\n            tickets.erase(it);\n        }\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.19322612068869852,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Convex Hull",
            "category": "Geometry",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Point {\n    long long x, y;\n    \n    bool operator<(const Point& other) const {\n        return x < other.x || (x == other.x && y < other.y);\n    }\n};\n\nlong long cross(const Point& O, const Point& A, const Point& B) {\n    return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);\n}\n\nvector<Point> convexHull(vector<Point>& points) {\n    int n = points.size();\n    if (n <= 1) return points;\n    \n    sort(points.begin(), points.end());\n    \n    vector<Point> lower, upper;\n    \n    for (const auto& p : points) {\n        while (lower.size() >= 2 && cross(lower[lower.size() - 2], lower.back(), p) <= 0)\n            lower.pop_back();\n        lower.push_back(p);\n    }\n    \n    for (int i = n - 1; i >= 0; --i) {\n        Point p = points[i];\n        while (upper.size() >= 2 && cross(upper[upper.size() - 2], upper.back(), p) <= 0)\n            upper.pop_back();\n        upper.push_back(p);\n    }\n    \n    lower.pop_back();\n    upper.pop_back();\n    \n    lower.insert(lower.end(), upper.begin(), upper.end());\n    return lower;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<Point> points(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> points[i].x >> points[i].y;\n    }\n    \n    vector<Point> hull = convexHull(points);\n    \n    cout << hull.size() << endl;\n    for (const auto& p : hull) {\n        cout << p.x << \" \" << p.y << endl;\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 9,
            "mean_time_taken": 0.14050250583224827,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Bishops",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    \n    if (k > 2 * n - 1) {\n        cout << 0 << endl;\n        return 0;\n    }\n    \n    vector<vector<long long>> dp(2 * n, vector<long long>(k + 1, 0));\n    dp[0][0] = 1;\n    \n    for (int d = 1; d <= 2 * n - 1; ++d) {\n        int maxBishops = min(d, 2 * n - d);\n        for (int b = 0; b <= k; ++b) {\n            dp[d][b] = dp[d - 1][b];\n            if (b > 0) {\n                dp[d][b] += dp[d - 1][b - 1] * maxBishops;\n                dp[d][b] %= MOD;\n            }\n        }\n    }\n    \n    cout << dp[2 * n - 1][k] << endl;\n\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 13,
            "mean_time_taken": 0.09249567985534668,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                5,
                6,
                7,
                10,
                11,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Bits",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\ntypedef long long ll;\n\nll countBits(ll n) {\n    ll count = 0;\n    for (ll i = 0; (1LL << i) <= n; ++i) {\n        ll totalPairs = (n + 1) / (1LL << (i + 1));\n        ll remaining = (n + 1) % (1LL << (i + 1));\n        count += totalPairs * (1LL << i);\n        if (remaining > (1LL << i)) {\n            count += remaining - (1LL << i);\n        }\n    }\n    return count;\n}\n\nint main() {\n    ll n;\n    cin >> n;\n    cout << countBits(n) << endl;\n    return 0;\n}",
            "passed_test_cases": 21,
            "total_test_cases": 21,
            "mean_time_taken": 0.08785892668224517,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Counting Coprime Pairs",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\n// Function to calculate GCD of two numbers\nint gcd(int a, int b) {\n    while (b) {\n        a %= b;\n        swap(a, b);\n    }\n    return a;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    vector<int> freq(1000001, 0);\n\n    // Read the input array and populate frequency array\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n        freq[arr[i]]++;\n    }\n\n    // Total number of pairs\n    long long totalPairs = (long long)n * (n - 1) / 2;\n\n    // Count non-coprime pairs using a modified sieve approach\n    vector<int> nonCoprime(1000001, 0);\n    for (int i = 2; i <= 1000000; i++) {\n        if (nonCoprime[i] == 0) {\n            // This is a prime number\n            long long count = 0;\n            for (int j = i; j <= 1000000; j += i) {\n                nonCoprime[j] = 1;\n                count += freq[j];\n            }\n            if (count > 1) {\n                totalPairs -= count * (count - 1) / 2;\n            }\n        }\n    }\n\n    cout << totalPairs << endl;\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 8,
            "mean_time_taken": 0.11914536356925964,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Divisors",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nint main() {\n    const int MAX_X = 1000000;\n    std::vector<int> divisors(MAX_X + 1, 0);\n\n    // Precompute the number of divisors for every number up to MAX_X\n    for (int i = 1; i <= MAX_X; ++i) {\n        for (int j = i; j <= MAX_X; j += i) {\n            divisors[j]++;\n        }\n    }\n\n    // Read the number of integers\n    int n;\n    std::cin >> n;\n\n    // Read each integer and print the number of its divisors\n    for (int i = 0; i < n; ++i) {\n        int x;\n        std::cin >> x;\n        std::cout << divisors[x] << std::endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 16,
            "mean_time_taken": 0.1567918211221695,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                4,
                7,
                13,
                14,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Grids",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n#define MOD 1000000007\n\ntypedef long long ll;\n\n// Function to perform modular exponentiation\nll mod_pow(ll base, ll exp, ll mod) {\n    ll result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return result;\n}\n\nint main() {\n    ll n;\n    cin >> n;\n\n    ll n2 = n * n;\n    ll term0 = mod_pow(2, n2, MOD);            // 0 degrees rotation\n    ll term90 = mod_pow(2, n2 / 4, MOD);       // 90 degrees rotation\n    ll term180 = mod_pow(2, n2 / 2, MOD);      // 180 degrees rotation\n    ll term270 = mod_pow(2, n2 / 4, MOD);      // 270 degrees rotation\n\n    // According to Burnside's lemma\n    ll result = (term0 + term90 + term180 + term270) % MOD;\n    result = (result * mod_pow(4, MOD - 2, MOD)) % MOD;  // Multiplying by modular inverse of 4\n\n    cout << result << endl;\n    return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 12,
            "mean_time_taken": 0.09101438522338867,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Necklaces",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <cmath>\n\nconst int MOD = 1000000007;\n\n// Function to perform modular exponentiation\nlong long mod_exp(long long base, long long exp, long long mod) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return result;\n}\n\nint main() {\n    int n, m;\n    std::cin >> n >> m;\n    \n    long long result = 0;\n    \n    // Iterate over each possible rotation\n    for (int k = 0; k < n; ++k) {\n        int g = std::gcd(n, k);\n        result = (result + mod_exp(m, g, MOD)) % MOD;\n    }\n    \n    // Divide by n and take modulo\n    result = (result * mod_exp(n, MOD-2, MOD)) % MOD;\n    \n    std::cout << result << std::endl;\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.1051363229751587,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Counting Numbers",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\n// Memoization table\nll dp[20][10][2];\n\n// Convert number to its digits\nvector<int> getDigits(ll x) {\n    vector<int> digits;\n    while (x > 0) {\n        digits.push_back(x % 10);\n        x /= 10;\n    }\n    reverse(digits.begin(), digits.end());\n    return digits;\n}\n\n// Digit DP function\nll countNumbers(int pos, int prevDigit, bool tight, const vector<int>& digits) {\n    if (pos == digits.size()) return 1;\n    \n    if (dp[pos][prevDigit][tight] != -1) return dp[pos][prevDigit][tight];\n    \n    ll result = 0;\n    int limit = tight ? digits[pos] : 9;\n    \n    for (int digit = 0; digit <= limit; ++digit) {\n        if (digit == prevDigit) continue; // Skip the same digit as the previous one\n        result += countNumbers(pos + 1, digit, tight && (digit == limit), digits);\n    }\n    \n    return dp[pos][prevDigit][tight] = result;\n}\n\n// Function to compute the count of valid numbers up to x\nll countValidNumbersUpTo(ll x) {\n    if (x < 0) return 0;\n    vector<int> digits = getDigits(x);\n    memset(dp, -1, sizeof(dp));\n    return countNumbers(0, -1, true, digits);\n}\n\nint main() {\n    ll a, b;\n    cin >> a >> b;\n    \n    ll result = countValidNumbersUpTo(b) - countValidNumbersUpTo(a - 1);\n    cout << result << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Counting Paths",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 200005;\nvector<int> adj[MAXN];\nint cnt[MAXN];\nint subtree[MAXN];\nint n, m;\n\nvoid dfs(int v, int p) {\n    subtree[v] = cnt[v];\n    for (int u : adj[v]) {\n        if (u != p) {\n            dfs(u, v);\n            subtree[v] += subtree[u];\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    cin >> n >> m;\n    \n    for (int i = 1; i < n; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    \n    while (m--) {\n        int a, b;\n        cin >> a >> b;\n        cnt[a]++;\n        cnt[b]++;\n    }\n    \n    dfs(1, -1);\n    \n    for (int i = 1; i <= n; ++i) {\n        cout << subtree[i] << \" \";\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 13,
            "mean_time_taken": 0.15169053811293381,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Patterns",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to preprocess the pattern and create the lps array\nvector<int> computeLPSArray(const string& pat) {\n    int m = pat.length();\n    vector<int> lps(m);\n    int j = 0;  // length of the previous longest prefix suffix\n    lps[0] = 0; // lps[0] is always 0\n\n    int i = 1;\n    while (i < m) {\n        if (pat[i] == pat[j]) {\n            j++;\n            lps[i] = j;\n            i++;\n        } else {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    return lps;\n}\n\n// Function to count occurrences of pat in txt using KMP algorithm\nint KMPSearch(const string& pat, const string& txt) {\n    int m = pat.length();\n    int n = txt.length();\n\n    vector<int> lps = computeLPSArray(pat);\n\n    int i = 0; // index for txt[]\n    int j = 0; // index for pat[]\n    int count = 0;\n\n    while (i < n) {\n        if (pat[j] == txt[i]) {\n            j++;\n            i++;\n        }\n\n        if (j == m) {\n            count++;\n            j = lps[j - 1];\n        } else if (i < n && pat[j] != txt[i]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    string txt;\n    cin >> txt;\n\n    int k;\n    cin >> k;\n\n    vector<string> patterns(k);\n    for (int i = 0; i < k; i++) {\n        cin >> patterns[i];\n    }\n\n    for (const string& pat : patterns) {\n        cout << KMPSearch(pat, txt) << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 11,
            "mean_time_taken": 0.7445776029066606,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                7,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Reorders",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\n#define MOD 1000000007\n\nusing namespace std;\n\n// Function to calculate factorial modulo MOD\nlong long factorial(int n, vector<long long>& fact) {\n    if (fact[n] != -1) return fact[n];\n    if (n == 0 || n == 1) return fact[n] = 1;\n    return fact[n] = (n * factorial(n - 1, fact)) % MOD;\n}\n\n// Function to calculate the modular inverse using Fermat's Little Theorem\nlong long modInverse(long long a, long long m) {\n    long long res = 1, exponent = m - 2;\n    while (exponent > 0) {\n        if (exponent % 2 == 1) res = (res * a) % m;\n        a = (a * a) % m;\n        exponent /= 2;\n    }\n    return res;\n}\n\n// Function to calculate the number of valid permutations\nint countReorders(string s) {\n    int n = s.length();\n    unordered_map<char, int> freq;\n    for (char c : s) {\n        freq[c]++;\n    }\n    \n    // Check feasibility\n    for (auto entry : freq) {\n        if (entry.second > (n + 1) / 2) return 0;\n    }\n    \n    // Precompute factorials and their inverses\n    vector<long long> fact(n + 1, -1);\n    factorial(n, fact);\n    vector<long long> invFact(n + 1);\n    for (int i = 0; i <= n; i++) {\n        invFact[i] = modInverse(fact[i], MOD);\n    }\n    \n    // Compute the total number of permutations\n    long long totalPermutations = fact[n];\n    for (auto entry : freq) {\n        totalPermutations = (totalPermutations * invFact[entry.second]) % MOD;\n    }\n\n    return totalPermutations;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    cout << countReorders(s) << endl;\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 9,
            "mean_time_taken": 0.09111155403984918,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Rooms",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\n// Directions for moving up, down, left, right\nconst int dx[] = {0, 0, -1, 1};\nconst int dy[] = {-1, 1, 0, 0};\n\nvoid dfs(int x, int y, vector<vector<bool>> &visited, const vector<string> &map, int n, int m) {\n    stack<pair<int, int>> s;\n    s.push({x, y});\n    visited[x][y] = true;\n\n    while (!s.empty()) {\n        int cx = s.top().first;\n        int cy = s.top().second;\n        s.pop();\n\n        for (int i = 0; i < 4; ++i) {\n            int nx = cx + dx[i];\n            int ny = cy + dy[i];\n\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && !visited[nx][ny] && map[nx][ny] == '.') {\n                visited[nx][ny] = true;\n                s.push({nx, ny});\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<string> map(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> map[i];\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    int roomCount = 0;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (map[i][j] == '.' && !visited[i][j]) {\n                dfs(i, j, visited, map, n, m);\n                ++roomCount;\n            }\n        }\n    }\n\n    cout << roomCount << endl;\n\n    return 0;\n}",
            "passed_test_cases": 19,
            "total_test_cases": 19,
            "mean_time_taken": 0.1557086894386693,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Counting Sequences",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long modExp(long long base, long long exp, long long mod) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return result;\n}\n\nvector<long long> factorial;\nvector<long long> invFactorial;\n\nvoid precomputeFactorials(int maxN, int mod) {\n    factorial.resize(maxN + 1);\n    invFactorial.resize(maxN + 1);\n    factorial[0] = 1;\n    for (int i = 1; i <= maxN; ++i) {\n        factorial[i] = (factorial[i-1] * i) % mod;\n    }\n    invFactorial[maxN] = modExp(factorial[maxN], mod - 2, mod);\n    for (int i = maxN - 1; i >= 0; --i) {\n        invFactorial[i] = (invFactorial[i+1] * (i+1)) % mod;\n    }\n}\n\nlong long binomialCoefficient(int n, int k, int mod) {\n    if (k > n || k < 0) return 0;\n    return factorial[n] * invFactorial[k] % mod * invFactorial[n - k] % mod;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    precomputeFactorials(k, MOD);\n\n    long long result = 0;\n    for (int i = 0; i <= k; ++i) {\n        long long term = binomialCoefficient(k, i, MOD) * modExp(k - i, n, MOD) % MOD;\n        if (i % 2 == 0) {\n            result = (result + term) % MOD;\n        } else {\n            result = (result - term + MOD) % MOD;\n        }\n    }\n\n    cout << result << endl;\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.09977085590362549,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Counting Tilings",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n\nconst int MOD = 1e9 + 7;\n\nint countTilings(int n, int m) {\n    int max_mask = 1 << n;\n    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(max_mask, 0));\n    dp[0][0] = 1;\n\n    for (int col = 0; col < m; ++col) {\n        for (int mask = 0; mask < max_mask; ++mask) {\n            if (dp[col][mask] == 0) continue;\n\n            // Trying to place tiles in the next column\n            std::function<void(int, int, int)> dfs = [&](int row, int curr_mask, int next_mask) {\n                if (row == n) {\n                    dp[col + 1][next_mask] = (dp[col + 1][next_mask] + dp[col][mask]) % MOD;\n                    return;\n                }\n                // If this cell is already filled in the current mask, move to the next cell\n                if (mask & (1 << row)) {\n                    dfs(row + 1, curr_mask, next_mask);\n                } else {\n                    // Place a vertical tile\n                    dfs(row + 1, curr_mask | (1 << row), next_mask);\n                    // Place a horizontal tile if the next cell is within bounds and not filled\n                    if (row + 1 < n && !(mask & (1 << (row + 1)))) {\n                        dfs(row + 2, curr_mask | (1 << row) | (1 << (row + 1)), next_mask);\n                    }\n                }\n            };\n\n            dfs(0, 0, mask);\n        }\n    }\n\n    return dp[m][0];\n}\n\nint main() {\n    int n, m;\n    std::cin >> n >> m;\n    std::cout << countTilings(n, m) << std::endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Counting Towers",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#define MOD 1000000007\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    vector<int> queries(t);\n    int max_n = 0;\n    for (int i = 0; i < t; i++) {\n        cin >> queries[i];\n        if (queries[i] > max_n) {\n            max_n = queries[i];\n        }\n    }\n\n    // DP arrays to store number of ways to build towers\n    vector<long long> dp0(max_n + 1, 0), dp1(max_n + 1, 0);\n    \n    // Initial conditions\n    dp0[1] = 1; // One way to build height 1 with two vertical blocks\n    dp1[1] = 1; // One way to build height 1 with one horizontal block\n\n    // Fill the DP tables\n    for (int i = 2; i <= max_n; i++) {\n        dp0[i] = (dp0[i-1] + dp1[i-1] * 2) % MOD;\n        dp1[i] = (dp1[i-1] + dp0[i-1]) % MOD;\n    }\n\n    // Answer each query\n    for (int i = 0; i < t; i++) {\n        int n = queries[i];\n        long long result = (dp0[n] + dp1[n]) % MOD;\n        cout << result << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.10013657808303833,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Course Schedule",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nvector<int> findOrder(int n, vector<pair<int, int>>& prerequisites) {\n    vector<vector<int>> graph(n + 1);\n    vector<int> inDegree(n + 1, 0);\n    \n    // Build the graph and compute in-degrees\n    for (auto& pre : prerequisites) {\n        graph[pre.first].push_back(pre.second);\n        inDegree[pre.second]++;\n    }\n    \n    // Queue for nodes with zero in-degree\n    queue<int> zeroInDegree;\n    for (int i = 1; i <= n; ++i) {\n        if (inDegree[i] == 0) {\n            zeroInDegree.push(i);\n        }\n    }\n    \n    vector<int> order;\n    while (!zeroInDegree.empty()) {\n        int node = zeroInDegree.front();\n        zeroInDegree.pop();\n        order.push_back(node);\n        \n        for (int neighbor : graph[node]) {\n            inDegree[neighbor]--;\n            if (inDegree[neighbor] == 0) {\n                zeroInDegree.push(neighbor);\n            }\n        }\n    }\n    \n    // If we have ordered all courses, return the order\n    if (order.size() == n) {\n        return order;\n    } else {\n        return {}; // Return an empty list to indicate it's impossible\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<pair<int, int>> prerequisites(m);\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        prerequisites[i] = {a, b};\n    }\n\n    vector<int> result = findOrder(n, prerequisites);\n\n    if (result.empty()) {\n        cout << \"IMPOSSIBLE\" << endl;\n    } else {\n        for (int course : result) {\n            cout << course << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 16,
            "total_test_cases": 16,
            "mean_time_taken": 0.13326646387577057,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Course Schedule II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> findCourseOrder(int n, vector<pair<int, int>>& prerequisites) {\n    vector<vector<int>> adj(n + 1); // Adjacency list\n    vector<int> in_degree(n + 1, 0); // In-degree of nodes\n\n    // Build the graph\n    for (auto& pre : prerequisites) {\n        adj[pre.first].push_back(pre.second);\n        in_degree[pre.second]++;\n    }\n\n    // Priority queue to get the smallest node first\n    priority_queue<int, vector<int>, greater<int>> zero_degree_nodes;\n    \n    // Initialize the queue with all nodes having zero in-degree\n    for (int i = 1; i <= n; ++i) {\n        if (in_degree[i] == 0) {\n            zero_degree_nodes.push(i);\n        }\n    }\n\n    vector<int> order;\n    \n    // Process the graph\n    while (!zero_degree_nodes.empty()) {\n        int node = zero_degree_nodes.top();\n        zero_degree_nodes.pop();\n        order.push_back(node);\n        \n        // Reduce the in-degree of neighbors\n        for (int neighbor : adj[node]) {\n            in_degree[neighbor]--;\n            if (in_degree[neighbor] == 0) {\n                zero_degree_nodes.push(neighbor);\n            }\n        }\n    }\n\n    return order;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<pair<int, int>> prerequisites(m);\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        prerequisites[i] = {a, b};\n    }\n\n    vector<int> order = findCourseOrder(n, prerequisites);\n    for (int course : order) {\n        cout << course << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 8,
            "mean_time_taken": 0.14284732937812805,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Creating Offices",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 200000;\nvector<int> adj[MAXN + 1];\nint depth[MAXN + 1];\nbool chosen[MAXN + 1];\n\nvoid dfs(int v, int parent, int d) {\n    depth[v] = (parent == -1 ? 0 : depth[parent] + 1);\n    for (int u : adj[v]) {\n        if (u != parent) {\n            dfs(u, v, d);\n        }\n    }\n}\n\nint main() {\n    int n, d;\n    cin >> n >> d;\n    \n    for (int i = 1; i < n; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    dfs(1, -1, d);\n    \n    vector<pair<int, int>> nodes;\n    for (int i = 1; i <= n; ++i) {\n        nodes.push_back({depth[i], i});\n    }\n    \n    sort(nodes.rbegin(), nodes.rend());\n    \n    vector<int> offices;\n    for (auto [dep, v] : nodes) {\n        if (!chosen[v]) {\n            offices.push_back(v);\n            queue<int> q;\n            q.push(v);\n            chosen[v] = true;\n            int current_depth = 0;\n\n            while (!q.empty()) {\n                int size = q.size();\n                if (++current_depth > d) break;\n\n                while (size--) {\n                    int u = q.front();\n                    q.pop();\n                    for (int neighbour : adj[u]) {\n                        if (!chosen[neighbour]) {\n                            chosen[neighbour] = true;\n                            q.push(neighbour);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    cout << offices.size() << endl;\n    for (int city : offices) {\n        cout << city << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 22,
            "mean_time_taken": 0.2375046665018255,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                16,
                17,
                18,
                19,
                20,
                21,
                22
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Creating Strings",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <set>\n#include <algorithm>\n\nint main() {\n    std::string s;\n    std::cin >> s;\n    \n    // A set to store the permutations (automatically sorted and unique)\n    std::set<std::string> permutations;\n    \n    // Sort the string to start with the smallest lexicographical permutation\n    std::sort(s.begin(), s.end());\n    \n    // Generate all permutations and insert into the set\n    do {\n        permutations.insert(s);\n    } while (std::next_permutation(s.begin(), s.end()));\n    \n    // Output the number of unique permutations\n    std::cout << permutations.size() << std::endl;\n    \n    // Output all unique permutations in sorted order\n    for (const std::string& perm : permutations) {\n        std::cout << perm << std::endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 6,
            "mean_time_taken": 0.09943791230519612,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Creating Strings II",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nconst int MOD = 1'000'000'007;\nconst int MAX_N = 1'000'000;\n\nstd::vector<long long> factorial(MAX_N + 1);\nstd::vector<long long> inv_factorial(MAX_N + 1);\n\n// Function to perform modular exponentiation\nlong long mod_exp(long long base, long long exp, long long mod) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return result;\n}\n\n// Precompute factorials and inverse factorials\nvoid precompute_factorials() {\n    factorial[0] = 1;\n    for (int i = 1; i <= MAX_N; ++i) {\n        factorial[i] = (factorial[i] * i) % MOD;\n    }\n    inv_factorial[MAX_N] = mod_exp(factorial[MAX_N], MOD - 2, MOD);\n    for (int i = MAX_N - 1; i >= 0; --i) {\n        inv_factorial[i] = (inv_factorial[i + 1] * (i + 1)) % MOD;\n    }\n}\n\nint main() {\n    precompute_factorials();\n    \n    std::string s;\n    std::cin >> s;\n    \n    std::vector<int> freq(26, 0);\n    for (char c : s) {\n        freq[c - 'a']++;\n    }\n    \n    long long result = factorial[s.size()];\n    for (int count : freq) {\n        if (count > 0) {\n            result = (result * inv_factorial[count]) % MOD;\n        }\n    }\n    \n    std::cout << result << std::endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.10950740178426106,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Critical Cities",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> adj[100005], rev_adj[100005];\nbool visited[100005], rev_visited[100005];\n\nvoid dfs(int node, vector<int> adj[], bool visited[]) {\n    visited[node] = true;\n    for (int neighbor : adj[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, adj, visited);\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n    \n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        rev_adj[b].push_back(a);\n    }\n\n    // Step 1: Find all nodes reachable from Syrj\u00e4l\u00e4 (city 1)\n    dfs(1, adj, visited);\n\n    // Step 2: Find all nodes that can reach Lehm\u00e4l\u00e4 (city n)\n    dfs(n, rev_adj, rev_visited);\n\n    // Step 3: Determine the critical cities\n    vector<int> critical_cities;\n    for (int i = 1; i <= n; i++) {\n        if (visited[i] && rev_visited[i]) {\n            critical_cities.push_back(i);\n        }\n    }\n\n    // Output the result\n    cout << critical_cities.size() << \"\\n\";\n    for (int city : critical_cities) {\n        cout << city << \" \";\n    }\n    cout << \"\\n\";\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 14,
            "mean_time_taken": 0.12820988042013987,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Cut and Paste",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <string>\n\nint main() {\n    // Read the length of the string and the number of operations\n    int n, m;\n    std::cin >> n >> m;\n    \n    // Read the initial string\n    std::string s;\n    std::cin >> s;\n    \n    // Process each operation\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        std::cin >> a >> b;\n        \n        // Convert from 1-based index to 0-based index\n        a--; b--;\n        \n        // Extract the substring and append it to the end of the string\n        s += s.substr(a, b - a + 1);\n    }\n    \n    // Print the final string\n    std::cout << s << std::endl;\n    \n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 7,
            "mean_time_taken": 0.17867050852094377,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Cycle Finding",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <limits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Edge {\n    int u, v;\n    long long weight;\n};\n\nconst long long INF = numeric_limits<long long>::max();\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<Edge> edges(m);\n    for (int i = 0; i < m; i++) {\n        cin >> edges[i].u >> edges[i].v >> edges[i].weight;\n    }\n    \n    vector<long long> dist(n + 1, INF);\n    vector<int> parent(n + 1, -1);\n    \n    dist[1] = 0;\n    int lastUpdated = -1;\n    \n    for (int i = 1; i <= n; i++) {\n        lastUpdated = -1;\n        for (const auto& edge : edges) {\n            if (dist[edge.u] < INF && dist[edge.u] + edge.weight < dist[edge.v]) {\n                dist[edge.v] = dist[edge.u] + edge.weight;\n                parent[edge.v] = edge.u;\n                lastUpdated = edge.v;\n            }\n        }\n    }\n    \n    if (lastUpdated == -1) {\n        cout << \"NO\" << endl;\n    } else {\n        cout << \"YES\" << endl;\n        int y = lastUpdated;\n        for (int i = 0; i < n; i++) {\n            y = parent[y];\n        }\n        \n        vector<int> cycle;\n        for (int cur = y;; cur = parent[cur]) {\n            cycle.push_back(cur);\n            if (cur == y && cycle.size() > 1) break;\n        }\n        \n        reverse(cycle.begin(), cycle.end());\n        \n        for (int node : cycle) {\n            cout << node << \" \";\n        }\n        cout << endl;\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 27,
            "mean_time_taken": 0.1197663148244222,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                4,
                5,
                6,
                7,
                9,
                11,
                12,
                13,
                14,
                17,
                18,
                21,
                23,
                24,
                25,
                26
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Cyclic Array",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    long long k;\n    cin >> n >> k;\n    vector<long long> x(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i];\n    }\n\n    long long current_sum = 0;\n    int subarray_count = 1; // Start with one subarray\n\n    for (int i = 0; i < n; i++) {\n        if (current_sum + x[i] > k) {\n            subarray_count++;\n            current_sum = x[i];\n        } else {\n            current_sum += x[i];\n        }\n    }\n\n    cout << subarray_count << endl;\n\n    return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 21,
            "mean_time_taken": 0.09585086504618327,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                5,
                7,
                9,
                10,
                13,
                14,
                18,
                19
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "De Bruijn Sequence",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <cassert>\n\nvoid generateDeBruijn(int n, std::string &current, std::unordered_set<std::string> &visited, std::string &result) {\n    if (visited.size() == (1 << n)) return;\n\n    std::string last_n_minus_1 = current.substr(current.size() - (n - 1));\n    for (char c : {'0', '1'}) {\n        std::string next = last_n_minus_1 + c;\n        if (visited.find(next) == visited.end()) {\n            visited.insert(next);\n            current.push_back(c);\n            generateDeBruijn(n, current, visited, result);\n            if (visited.size() == (1 << n)) break;\n            current.pop_back(); // backtrack\n            visited.erase(next);\n        }\n    }\n    result = current;\n}\n\nstd::string deBruijnSequence(int n) {\n    std::unordered_set<std::string> visited;\n    std::string result, current(n - 1, '0');\n    generateDeBruijn(n, current, visited, result);\n    result += current.substr(0, n - 1);\n    return result;\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    assert(1 <= n && n <= 15);\n    \n    std::string deBruijnSeq = deBruijnSequence(n);\n    std::cout << deBruijnSeq << std::endl;\n    \n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.09275113741556804,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Dice Combinations",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#define MOD 1000000007\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<long long> dp(n + 1, 0);\n    dp[0] = 1; // There's one way to make sum 0: use no dice at all\n    \n    // Fill the dp array\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= 6; ++j) {\n            if (i - j >= 0) {\n                dp[i] = (dp[i] + dp[i - j]) % MOD;\n            }\n        }\n    }\n    \n    cout << dp[n] << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 20,
            "total_test_cases": 20,
            "mean_time_taken": 0.09607478380203247,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Dice Probability",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n, a, b;\n    cin >> n >> a >> b;\n\n    // Create a DP table initialized to 0\n    vector<vector<long long>> dp(n + 1, vector<long long>(6 * n + 1, 0));\n    \n    // Base case: one way to get sum 0 with 0 dice\n    dp[0][0] = 1;\n\n    // Fill the DP table\n    for (int i = 1; i <= n; ++i) {\n        for (int j = i; j <= 6 * i; ++j) {\n            dp[i][j] = 0;\n            for (int k = 1; k <= 6; ++k) {\n                if (j >= k) {\n                    dp[i][j] += dp[i - 1][j - k];\n                }\n            }\n        }\n    }\n\n    // Calculate the number of favorable outcomes\n    long long favorable_outcomes = 0;\n    for (int sum = a; sum <= b; ++sum) {\n        favorable_outcomes += dp[n][sum];\n    }\n\n    // Calculate the total number of possible outcomes\n    long long total_outcomes = pow(6, n);\n\n    // Calculate the probability\n    double probability = (double)favorable_outcomes / total_outcomes;\n\n    // Print the result with six decimal places\n    cout << fixed << setprecision(6) << probability << endl;\n\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 17,
            "mean_time_taken": 0.08815263299381032,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                4,
                5,
                6,
                9,
                11,
                15,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Digit Queries",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nvoid solve() {\n    int q;\n    cin >> q;\n    vector<long long> queries(q);\n    for (int i = 0; i < q; ++i) {\n        cin >> queries[i];\n    }\n\n    for (long long k : queries) {\n        long long currentPos = 1;\n        long long digitCount = 1;\n        long long rangeStart = 1;\n\n        while (true) {\n            long long rangeEnd = rangeStart * 10 - 1;\n            long long numbersInRange = rangeEnd - rangeStart + 1;\n            long long digitsInRange = numbersInRange * digitCount;\n\n            if (k <= digitsInRange) {\n                long long numberIndex = (k - 1) / digitCount;\n                long long digitIndex = (k - 1) % digitCount;\n\n                long long number = rangeStart + numberIndex;\n                string numberStr = to_string(number);\n                cout << numberStr[digitIndex] << endl;\n                break;\n            }\n\n            k -= digitsInRange;\n            rangeStart *= 10;\n            digitCount++;\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    solve();\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 4,
            "mean_time_taken": 0.09388905763626099,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Distance Queries",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 200000;\nconst int LOG = 20;\n\nvector<int> adj[MAXN + 1];\nint depth[MAXN + 1];\nint up[MAXN + 1][LOG];\n\n// DFS to compute depth and initialize 1st parent pointers\nvoid dfs(int v, int p) {\n    up[v][0] = p;\n    for (int i = 1; i < LOG; ++i) {\n        if (up[v][i - 1] != -1)\n            up[v][i] = up[up[v][i - 1]][i - 1];\n        else\n            up[v][i] = -1;\n    }\n    for (int u : adj[v]) {\n        if (u != p) {\n            depth[u] = depth[v] + 1;\n            dfs(u, v);\n        }\n    }\n}\n\n// Function to get LCA\nint lca(int a, int b) {\n    if (depth[a] < depth[b]) swap(a, b);\n\n    int diff = depth[a] - depth[b];\n    for (int i = LOG - 1; i >= 0; --i) {\n        if ((diff >> i) & 1) {\n            a = up[a][i];\n        }\n    }\n\n    if (a == b) return a;\n\n    for (int i = LOG - 1; i >= 0; --i) {\n        if (up[a][i] != up[b][i]) {\n            a = up[a][i];\n            b = up[b][i];\n        }\n    }\n\n    return up[a][0];\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, q;\n    cin >> n >> q;\n\n    for (int i = 1; i < n; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    // Initialize depth and up arrays\n    depth[1] = 0;\n    dfs(1, -1);\n\n    while (q--) {\n        int a, b;\n        cin >> a >> b;\n        int ancestor = lca(a, b);\n        int distance = depth[a] + depth[b] - 2 * depth[ancestor];\n        cout << distance << '\\n';\n    }\n\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 11,
            "mean_time_taken": 0.16431513699618253,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                ""
            ],
            "failed_test_cases": [
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Colors",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n\nconst int MAXN = 200005;\nvector<int> tree[MAXN];\nint color[MAXN];\nset<int> *color_sets[MAXN];\nint result[MAXN];\n\nvoid dfs(int node, int parent) {\n    // Start by creating a set for the current node and add its color\n    color_sets[node] = new set<int>();\n    color_sets[node]->insert(color[node]);\n\n    // Process all children\n    for (int child : tree[node]) {\n        if (child != parent) {\n            dfs(child, node);\n\n            // Always merge the smaller set into the larger set\n            if (color_sets[child]->size() > color_sets[node]->size()) {\n                swap(color_sets[child], color_sets[node]);\n            }\n\n            // Merge child's set into current node's set\n            for (int col : *color_sets[child]) {\n                color_sets[node]->insert(col);\n            }\n        }\n    }\n\n    // The result for the current node is the size of its color set\n    result[node] = color_sets[node]->size();\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n;\n\n    // Read colors\n    for (int i = 1; i <= n; ++i) {\n        cin >> color[i];\n    }\n\n    // Read edges\n    for (int i = 0; i < n - 1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        tree[a].push_back(b);\n        tree[b].push_back(a);\n    }\n\n    // Run DFS from the root (node 1)\n    dfs(1, -1);\n\n    // Output results\n    for (int i = 1; i <= n; ++i) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 15,
            "mean_time_taken": 0.23356413841247559,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                4,
                5,
                13,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Numbers",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <unordered_set>\n\nint main() {\n    int n;\n    std::cin >> n;\n    \n    std::unordered_set<int> distinct_numbers;\n    \n    for (int i = 0; i < n; ++i) {\n        int x;\n        std::cin >> x;\n        distinct_numbers.insert(x);\n    }\n    \n    std::cout << distinct_numbers.size() << std::endl;\n    \n    return 0;\n}",
            "passed_test_cases": 14,
            "total_test_cases": 15,
            "mean_time_taken": 0.19030261039733887,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                ""
            ],
            "failed_test_cases": [
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Routes",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 500;\nvector<int> adj[MAXN + 1];\nvector<int> paths[MAXN + 1];\nvector<vector<int>> result;\nbool visited[MAXN + 1];\nbool used[MAXN + 1][MAXN + 1];\n\nbool dfs(int node, int dest, vector<int>& path) {\n    if (node == dest) {\n        path.push_back(node);\n        return true;\n    }\n    \n    visited[node] = true;\n    for (int neighbor : adj[node]) {\n        if (!visited[neighbor] && !used[node][neighbor]) {\n            if (dfs(neighbor, dest, path)) {\n                path.push_back(node);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n    \n    int max_days = 0;\n    while (true) {\n        fill(visited, visited + MAXN + 1, false);\n        vector<int> path;\n        if (!dfs(1, n, path)) break;\n        \n        reverse(path.begin(), path.end());\n        for (int i = 0; i < path.size() - 1; i++) {\n            used[path[i]][path[i + 1]] = true;\n        }\n        \n        result.push_back(path);\n        max_days++;\n    }\n    \n    cout << max_days << \"\\n\";\n    for (const auto& path : result) {\n        cout << path.size() << \"\\n\";\n        for (int node : path) {\n            cout << node << \" \";\n        }\n        cout << \"\\n\";\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 18,
            "mean_time_taken": 0.08744343121846516,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                4,
                5,
                6,
                8,
                10,
                12,
                14,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Routes II",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 500;\nvector<int> adj[MAXN+1];\nvector<vector<int>> paths;\nbool visited[MAXN+1];\nint n, m, k;\n\nvoid findPaths(int u, vector<int>& path) {\n    if (u == n) {\n        paths.push_back(path);\n        return;\n    }\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            visited[v] = true;\n            path.push_back(v);\n            findPaths(v, path);\n            path.pop_back();\n            visited[v] = false;\n        }\n        if (paths.size() >= k) return;\n    }\n}\n\nint main() {\n    cin >> n >> m >> k;\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n\n    vector<int> path;\n    path.push_back(1);\n    visited[1] = true;\n    findPaths(1, path);\n\n    if (paths.size() < k) {\n        cout << \"-1\\n\";\n    } else {\n        int total_coins = 0;\n        for (const auto& p : paths) {\n            total_coins += p.size() - 1; // number of edges in the path\n        }\n        cout << total_coins << \"\\n\";\n        for (const auto& p : paths) {\n            cout << p.size() << \"\\n\";\n            for (int v : p) {\n                cout << v << \" \";\n            }\n            cout << \"\\n\";\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.08627529144287109,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Substrings",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to build the suffix array\nvector<int> build_suffix_array(const string &s) {\n    int n = s.size();\n    vector<int> suffix_array(n), rank(n), temp(n), count(max(256, n), 0);\n\n    for (int i = 0; i < n; ++i) {\n        rank[i] = s[i];\n        suffix_array[i] = i;\n    }\n\n    for (int step = 1; step < n; step *= 2) {\n        auto cmp = [&](int a, int b) {\n            if (rank[a] != rank[b]) return rank[a] < rank[b];\n            int ra = (a + step < n) ? rank[a + step] : -1;\n            int rb = (b + step < n) ? rank[b + step] : -1;\n            return ra < rb;\n        };\n        \n        sort(suffix_array.begin(), suffix_array.end(), cmp);\n\n        temp[suffix_array[0]] = 0;\n        for (int i = 1; i < n; ++i) {\n            temp[suffix_array[i]] = temp[suffix_array[i - 1]] + cmp(suffix_array[i - 1], suffix_array[i]);\n        }\n        rank = temp;\n    }\n    return suffix_array;\n}\n\n// Function to build the LCP array\nvector<int> build_lcp_array(const string &s, const vector<int> &suffix_array) {\n    int n = s.size();\n    vector<int> rank(n), lcp(n);\n\n    for (int i = 0; i < n; ++i) {\n        rank[suffix_array[i]] = i;\n    }\n\n    int h = 0;\n    for (int i = 0; i < n; ++i) {\n        if (rank[i] > 0) {\n            int j = suffix_array[rank[i] - 1];\n            while (i + h < n && j + h < n && s[i + h] == s[j + h]) {\n                ++h;\n            }\n            lcp[rank[i]] = h;\n            if (h > 0) {\n                --h;\n            }\n        }\n    }\n    return lcp;\n}\n\n// Function to count distinct substrings\nint count_distinct_substrings(const string &s) {\n    int n = s.size();\n    vector<int> suffix_array = build_suffix_array(s);\n    vector<int> lcp = build_lcp_array(s, suffix_array);\n\n    int total_substrings = n * (n + 1) / 2; // Total substrings in a string of length n\n    int lcp_sum = 0;\n\n    for (int i = 1; i < n; ++i) {\n        lcp_sum += lcp[i];\n    }\n\n    return total_substrings - lcp_sum;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    cout << count_distinct_substrings(s) << endl;\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 7,
            "mean_time_taken": 0.5118963037218366,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Values Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <unordered_map>\n\nusing namespace std;\n\nstruct Query {\n    int l, r, idx;\n};\n\nint BLOCK_SIZE;\n\nbool compare(const Query& a, const Query& b) {\n    if (a.l / BLOCK_SIZE != b.l / BLOCK_SIZE)\n        return a.l / BLOCK_SIZE < b.l / BLOCK_SIZE;\n    return a.r < b.r;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; ++i)\n        cin >> arr[i];\n\n    vector<Query> queries(q);\n    for (int i = 0; i < q; ++i) {\n        cin >> queries[i].l >> queries[i].r;\n        queries[i].l--; // 0-based indexing\n        queries[i].r--; // 0-based indexing\n        queries[i].idx = i;\n    }\n\n    BLOCK_SIZE = static_cast<int>(sqrt(n));\n    sort(queries.begin(), queries.end(), compare);\n\n    vector<int> result(q);\n    unordered_map<int, int> freq;\n    int current_l = 0, current_r = -1, distinct_count = 0;\n\n    auto add = [&](int pos) {\n        freq[arr[pos]]++;\n        if (freq[arr[pos]] == 1) {\n            distinct_count++;\n        }\n    };\n\n    auto remove = [&](int pos) {\n        freq[arr[pos]]--;\n        if (freq[arr[pos]] == 0) {\n            distinct_count--;\n        }\n    };\n\n    for (auto& query : queries) {\n        while (current_l > query.l) {\n            current_l--;\n            add(current_l);\n        }\n        while (current_r < query.r) {\n            current_r++;\n            add(current_r);\n        }\n        while (current_l < query.l) {\n            remove(current_l);\n            current_l++;\n        }\n        while (current_r > query.r) {\n            remove(current_r);\n            current_r--;\n        }\n        result[query.idx] = distinct_count;\n    }\n\n    for (int i = 0; i < q; ++i) {\n        cout << result[i] << '\\n';\n    }\n\n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 14,
            "mean_time_taken": 0.8392668792179653,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 27,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distributing Apples",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\n// Function to compute x^y under modulo m\nlong long mod_exp(long long x, long long y, long long m) {\n    long long result = 1;\n    while (y > 0) {\n        if (y % 2 == 1) {\n            result = (result * x) % m;\n        }\n        y = y >> 1;\n        x = (x * x) % m;\n    }\n    return result;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    int max_factorial = n + m - 1;\n    vector<long long> fact(max_factorial + 1, 1);\n    vector<long long> inv_fact(max_factorial + 1, 1);\n    \n    // Compute all factorials % MOD\n    for (int i = 2; i <= max_factorial; ++i) {\n        fact[i] = (fact[i - 1] * i) % MOD;\n    }\n    \n    // Compute the inverses of all factorials % MOD using Fermat's Little Theorem\n    inv_fact[max_factorial] = mod_exp(fact[max_factorial], MOD - 2, MOD);\n    for (int i = max_factorial - 1; i >= 2; --i) {\n        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD;\n    }\n    \n    // Calculate the binomial coefficient C(n + m - 1, m) % MOD\n    long long result = (fact[n + m - 1] * inv_fact[m]) % MOD;\n    result = (result * inv_fact[n - 1]) % MOD;\n    \n    cout << result << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.09740438828101525,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 28,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Divisor Analysis",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#define MOD 1000000007\n\nusing namespace std;\n\ntypedef long long ll;\n\n// Function to perform modular exponentiation\nll mod_exp(ll base, ll exp, ll mod) {\n    ll result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return result;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<pair<ll, ll>> factors(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> factors[i].first >> factors[i].second;\n    }\n    \n    ll number_of_divisors = 1;\n    ll sum_of_divisors = 1;\n    ll product_of_divisors = 1;\n    ll total_divisors = 1;\n\n    for (const auto& factor : factors) {\n        ll p = factor.first;\n        ll k = factor.second;\n\n        // Number of divisors\n        number_of_divisors = number_of_divisors * (k + 1) % MOD;\n\n        // Sum of divisors\n        ll sum_term = (mod_exp(p, k + 1, MOD) - 1 + MOD) % MOD;\n        sum_term = sum_term * mod_exp(p - 1, MOD - 2, MOD) % MOD;\n        sum_of_divisors = sum_of_divisors * sum_term % MOD;\n\n        // Product of divisors\n        ll exponent = k * (k + 1) / 2 % (MOD - 1); // Using properties of modulo arithmetic\n        product_of_divisors = mod_exp(product_of_divisors, k + 1, MOD) * mod_exp(mod_exp(p, exponent, MOD), total_divisors, MOD) % MOD;\n        total_divisors = total_divisors * (k + 1) % (MOD - 1);\n    }\n\n    cout << number_of_divisors << \" \" << sum_of_divisors << \" \" << product_of_divisors << endl;\n    return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 7,
            "mean_time_taken": 0.11451700755528041,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 29,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Download Speed",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 1e9+5;\n\nstruct Edge {\n    int to, speed;\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<Edge>> graph(n + 1);\n\n    for (int i = 0; i < m; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        graph[a].push_back({b, c});\n        graph[b].push_back({a, c});\n    }\n\n    vector<int> max_bandwidth(n + 1, 0);\n    priority_queue<pair<int, int>> pq;\n\n    max_bandwidth[1] = INF;\n    pq.push({INF, 1});\n\n    while (!pq.empty()) {\n        int current_bandwidth = pq.top().first;\n        int current_node = pq.top().second;\n        pq.pop();\n\n        if (current_bandwidth < max_bandwidth[current_node]) continue;\n\n        for (const auto& edge : graph[current_node]) {\n            int next_node = edge.to;\n            int next_bandwidth = min(current_bandwidth, edge.speed);\n\n            if (next_bandwidth > max_bandwidth[next_node]) {\n                max_bandwidth[next_node] = next_bandwidth;\n                pq.push({next_bandwidth, next_node});\n            }\n        }\n    }\n\n    cout << max_bandwidth[n] << endl;\n\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 21,
            "mean_time_taken": 0.08786414918445405,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                10,
                11,
                13,
                15,
                16,
                17,
                18,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 29,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Dynamic Connectivity",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass UnionFind {\npublic:\n    UnionFind(int n) : parent(n), rank(n, 0), components(n) {\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    bool unionSets(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n\n        if (rootX != rootY) {\n            if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n            components--;\n            return true;\n        }\n        return false;\n    }\n\n    int getComponents() {\n        return components;\n    }\n\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n    int components;\n};\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    UnionFind uf(n);\n\n    unordered_map<int, unordered_map<int, bool>> edges;\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        uf.unionSets(a, b);\n        edges[a][b] = true;\n        edges[b][a] = true;\n    }\n\n    vector<pair<int, pair<int, int>>> events(k);\n    for (int i = 0; i < k; ++i) {\n        int t, a, b;\n        cin >> t >> a >> b;\n        a--; b--;\n        events[i] = {t, {a, b}};\n    }\n\n    vector<int> results;\n    results.push_back(uf.getComponents());\n\n    for (const auto& event : events) {\n        int t = event.first;\n        int a = event.second.first;\n        int b = event.second.second;\n\n        if (t == 1) {\n            if (uf.unionSets(a, b)) {\n                edges[a][b] = true;\n                edges[b][a] = true;\n            }\n        } else if (t == 2) {\n            if (edges[a][b]) {\n                edges[a][b] = false;\n                edges[b][a] = false;\n                uf = UnionFind(n); // Reset and reprocess all edges\n                for (const auto& edgeList : edges) {\n                    for (const auto& edge : edgeList.second) {\n                        if (edge.second) {\n                            uf.unionSets(edgeList.first, edge.first);\n                        }\n                    }\n                }\n            }\n        }\n        results.push_back(uf.getComponents());\n    }\n\n    for (const int& result : results) {\n        cout << result << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 7,
            "mean_time_taken": 0.7751691000802177,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 29,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Dynamic Range Minimum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nclass SegmentTree {\nprivate:\n    vector<int> tree;\n    int n;\n\n    void build(const vector<int>& arr, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = arr[start];\n        } else {\n            int mid = (start + end) / 2;\n            build(arr, 2 * node + 1, start, mid);\n            build(arr, 2 * node + 2, mid + 1, end);\n            tree[node] = min(tree[2 * node + 1], tree[2 * node + 2]);\n        }\n    }\n\n    void update(int node, int start, int end, int idx, int value) {\n        if (start == end) {\n            tree[node] = value;\n        } else {\n            int mid = (start + end) / 2;\n            if (start <= idx && idx <= mid) {\n                update(2 * node + 1, start, mid, idx, value);\n            } else {\n                update(2 * node + 2, mid + 1, end, idx, value);\n            }\n            tree[node] = min(tree[2 * node + 1], tree[2 * node + 2]);\n        }\n    }\n\n    int query(int node, int start, int end, int L, int R) {\n        if (R < start || end < L) {\n            return INT_MAX;\n        }\n        if (L <= start && end <= R) {\n            return tree[node];\n        }\n        int mid = (start + end) / 2;\n        int leftQuery = query(2 * node + 1, start, mid, L, R);\n        int rightQuery = query(2 * node + 2, mid + 1, end, L, R);\n        return min(leftQuery, rightQuery);\n    }\n\npublic:\n    SegmentTree(const vector<int>& arr) {\n        n = arr.size();\n        tree.resize(4 * n);\n        build(arr, 0, 0, n - 1);\n    }\n\n    void update(int idx, int value) {\n        update(0, 0, n - 1, idx, value);\n    }\n\n    int query(int L, int R) {\n        return query(0, 0, n - 1, L, R);\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, q;\n    cin >> n >> q;\n    vector<int> arr(n);\n    \n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i];\n    }\n\n    SegmentTree segTree(arr);\n\n    for (int i = 0; i < q; ++i) {\n        int type;\n        cin >> type;\n        if (type == 1) {\n            int k, u;\n            cin >> k >> u;\n            segTree.update(k - 1, u);\n        } else if (type == 2) {\n            int a, b;\n            cin >> a >> b;\n            cout << segTree.query(a - 1, b - 1) << \"\\n\";\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 2,
            "mean_time_taken": 0.14159512519836426,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 30,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Dynamic Range Sum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass FenwickTree {\npublic:\n    FenwickTree(int n) : n(n), bit(n+1, 0) {}\n\n    void update(int idx, int delta) {\n        for (; idx <= n; idx += idx & -idx)\n            bit[idx] += delta;\n    }\n\n    int sum(int idx) {\n        int ret = 0;\n        for (; idx > 0; idx -= idx & -idx)\n            ret += bit[idx];\n        return ret;\n    }\n\n    int rangeSum(int l, int r) {\n        return sum(r) - sum(l-1);\n    }\n\nprivate:\n    int n;\n    vector<int> bit;\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, q;\n    cin >> n >> q;\n    \n    vector<int> arr(n+1);\n    FenwickTree fenwickTree(n);\n\n    for (int i = 1; i <= n; ++i) {\n        cin >> arr[i];\n        fenwickTree.update(i, arr[i]);\n    }\n\n    while (q--) {\n        int type;\n        cin >> type;\n        if (type == 1) {\n            // Update query\n            int k, u;\n            cin >> k >> u;\n            fenwickTree.update(k, u - arr[k]);\n            arr[k] = u;\n        } else if (type == 2) {\n            // Sum query\n            int a, b;\n            cin >> a >> b;\n            cout << fenwickTree.rangeSum(a, b) << \"\\n\";\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 2,
            "mean_time_taken": 0.11807680130004883,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                ""
            ],
            "failed_test_cases": [
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 30,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Edit Distance",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint editDistance(const string &s1, const string &s2) {\n    int n = s1.size();\n    int m = s2.size();\n    \n    // Create a 2D vector to store the edit distances\n    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\n    \n    // Initialize the base cases\n    for (int i = 0; i <= n; ++i) {\n        dp[i][0] = i; // Deleting all characters from s1 to match an empty s2\n    }\n    for (int j = 0; j <= m; ++j) {\n        dp[0][j] = j; // Inserting all characters to s1 to match s2\n    }\n    \n    // Fill the DP table\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            if (s1[i - 1] == s2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1]; // Characters match, no new operation needed\n            } else {\n                dp[i][j] = min({dp[i - 1][j] + 1,    // Delete\n                                dp[i][j - 1] + 1,    // Insert\n                                dp[i - 1][j - 1] + 1 // Replace\n                               });\n            }\n        }\n    }\n    \n    // The answer is in dp[n][m]\n    return dp[n][m];\n}\n\nint main() {\n    string s1, s2;\n    cin >> s1 >> s2;\n    cout << editDistance(s1, s2) << endl;\n    return 0;\n}",
            "passed_test_cases": 17,
            "total_test_cases": 17,
            "mean_time_taken": 0.296948418897741,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 31,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Elevator Rides",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n    \n    vector<int> weights(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> weights[i];\n    }\n    \n    vector<int> dp(1 << n, INT_MAX);\n    vector<int> minLastWeight(1 << n, x + 1);\n    \n    dp[0] = 1;\n    minLastWeight[0] = 0;\n    \n    for (int mask = 0; mask < (1 << n); ++mask) {\n        for (int i = 0; i < n; ++i) {\n            if (!(mask & (1 << i))) {\n                int newMask = mask | (1 << i);\n                if (minLastWeight[mask] + weights[i] <= x) {\n                    if (dp[newMask] > dp[mask]) {\n                        dp[newMask] = dp[mask];\n                        minLastWeight[newMask] = minLastWeight[mask] + weights[i];\n                    } else if (dp[newMask] == dp[mask]) {\n                        minLastWeight[newMask] = min(minLastWeight[newMask], minLastWeight[mask] + weights[i]);\n                    }\n                } else {\n                    if (dp[newMask] > dp[mask] + 1) {\n                        dp[newMask] = dp[mask] + 1;\n                        minLastWeight[newMask] = weights[i];\n                    } else if (dp[newMask] == dp[mask] + 1) {\n                        minLastWeight[newMask] = min(minLastWeight[newMask], weights[i]);\n                    }\n                }\n            }\n        }\n    }\n    \n    cout << dp[(1 << n) - 1] << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 39,
            "total_test_cases": 39,
            "mean_time_taken": 0.2615657219519982,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Empty String",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9+7;\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.size();\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n\n    // Initialize the base cases\n    for (int i = 0; i < n; ++i) {\n        dp[i][i] = 0; // Single character can't be removed\n    }\n    for (int len = 2; len <= n; ++len) {\n        for (int i = 0; i <= n - len; ++i) {\n            int j = i + len - 1;\n            if (s[i] == s[j]) {\n                dp[i][j] = (dp[i+1][j-1] + 1) % MOD;\n            }\n            for (int k = i; k < j; ++k) {\n                dp[i][j] = (dp[i][j] + (dp[i][k] * dp[k+1][j]) % MOD) % MOD;\n            }\n        }\n    }\n\n    cout << dp[0][n-1] << endl;\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 12,
            "mean_time_taken": 0.16740002234776816,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Eulerian Subgraphs",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nvoid addEdge(vector<vector<int>>& adj, int u, int v) {\n    adj[u][v] ^= 1;\n    adj[v][u] ^= 1;\n}\n\nint determinant(vector<vector<int>>& mat, int n) {\n    int det = 1;\n    for (int i = 0; i < n; ++i) {\n        int pivot = -1;\n        for (int j = i; j < n; ++j) {\n            if (mat[j][i] != 0) {\n                pivot = j;\n                break;\n            }\n        }\n        if (pivot == -1) return 0;\n        if (i != pivot) {\n            swap(mat[i], mat[pivot]);\n            det = MOD - det;\n        }\n        det = (1LL * det * mat[i][i]) % MOD;\n        int inv = 1;\n        for (int j = 1; j < MOD - 2; ++j) inv = (1LL * inv * mat[i][i]) % MOD;\n        for (int j = i + 1; j < n; ++j) {\n            int t = (1LL * mat[j][i] * inv) % MOD;\n            for (int k = i; k < n; ++k) {\n                mat[j][k] = (mat[j][k] - 1LL * t * mat[i][k]) % MOD;\n                if (mat[j][k] < 0) mat[j][k] += MOD;\n            }\n        }\n    }\n    return det;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> adj(n, vector<int>(n, 0));\n    \n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a, --b;\n        addEdge(adj, a, b);\n    }\n    \n    vector<vector<int>> mat(n - 1, vector<int>(n - 1, 0));\n    for (int i = 1; i < n; ++i) {\n        for (int j = 1; j < n; ++j) {\n            mat[i - 1][j - 1] = adj[i][j];\n            if (i == j) {\n                for (int k = 0; k < n; ++k) {\n                    mat[i - 1][j - 1] += adj[i][k];\n                }\n                mat[i - 1][j - 1] %= MOD;\n            }\n        }\n    }\n    \n    int result = determinant(mat, n - 1);\n    cout << result << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 0.8045154412587484,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Even Outdegree Edges",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<pair<int, int>> edges(m);\n    vector<int> degree(n + 1, 0);\n    unordered_map<int, vector<int>> adjList;\n\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        edges[i] = {a, b};\n        degree[a]++;\n        degree[b]++;\n        adjList[a].push_back(b);\n        adjList[b].push_back(a);\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        if (degree[i] % 2 != 0) {\n            cout << \"IMPOSSIBLE\" << endl;\n            return 0;\n        }\n    }\n\n    vector<bool> visitedEdge(m, false);\n    vector<bool> visited(n + 1, false);\n    vector<int> outdegree(n + 1, 0);\n\n    for (int i = 0; i < m; ++i) {\n        if (!visitedEdge[i]) {\n            int u = edges[i].first;\n            int v = edges[i].second;\n            if (outdegree[u] % 2 == 0) {\n                cout << u << \" \" << v << endl;\n                outdegree[u]++;\n            } else {\n                cout << v << \" \" << u << endl;\n                outdegree[v]++;\n            }\n            visitedEdge[i] = true;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 8,
            "mean_time_taken": 0.17311730980873108,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 32,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Exponentiation",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nconst int MOD = 1e9 + 7;\n\n// Function to perform modular exponentiation\nlong long mod_exp(long long base, long long exp, long long mod) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return result;\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    std::vector<std::pair<long long, long long>> queries(n);\n    \n    for (int i = 0; i < n; ++i) {\n        std::cin >> queries[i].first >> queries[i].second;\n    }\n    \n    for (const auto& query : queries) {\n        long long a = query.first;\n        long long b = query.second;\n        std::cout << mod_exp(a, b, MOD) << std::endl;\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 3,
            "mean_time_taken": 0.2109827995300293,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 33,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Exponentiation II",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n#define MOD 1000000007\n#define PHI_MOD 1000000006 // PHI(MOD) = MOD-1\nusing namespace std;\n\n// Modular exponentiation: base^exp % mod\nlong long mod_exp(long long base, long long exp, long long mod) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) \n            result = (result * base) % mod;\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return result;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<long long> results(n);\n\n    for (int i = 0; i < n; ++i) {\n        long long a, b, c;\n        cin >> a >> b >> c;\n        \n        if (a == 0 && b == 0) {\n            results[i] = 1; // 0^0 is defined as 1\n        } else if (b == 0) {\n            results[i] = 1; // a^0 is 1 for any a\n        } else {\n            // Calculate b^c % PHI_MOD\n            long long exp = mod_exp(b, c, PHI_MOD);\n            // Calculate a^exp % MOD\n            results[i] = mod_exp(a, exp, MOD);\n        }\n    }\n\n    for (const auto& result : results) {\n        cout << result << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 13,
            "mean_time_taken": 0.14392828941345215,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                4,
                9,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 33,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Factory Machines",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool canProduceInTime(const vector<long long>& machines, long long n, long long t, long long time) {\n    long long totalProducts = 0;\n    for (long long i = 0; i < n; ++i) {\n        totalProducts += time / machines[i];\n        if (totalProducts >= t) return true; // No need to check further if we already meet the requirement\n    }\n    return totalProducts >= t;\n}\n\nlong long minimumTime(long long n, long long t, vector<long long>& machines) {\n    long long left = 1;\n    long long right = *max_element(machines.begin(), machines.end()) * t;\n    long long result = right;\n    \n    while (left <= right) {\n        long long mid = left + (right - left) / 2;\n        if (canProduceInTime(machines, n, t, mid)) {\n            result = mid; // mid is a valid solution, try to find a smaller valid time\n            right = mid - 1;\n        } else {\n            left = mid + 1; // mid is not enough time, try a larger time\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    long long n, t;\n    cin >> n >> t;\n    vector<long long> machines(n);\n    for (long long i = 0; i < n; ++i) {\n        cin >> machines[i];\n    }\n    \n    cout << minimumTime(n, t, machines) << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 18,
            "total_test_cases": 18,
            "mean_time_taken": 0.0991512934366862,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 34,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Ferris Wheel",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    int n, x;\n    std::cin >> n >> x;\n    std::vector<int> weights(n);\n\n    for (int i = 0; i < n; ++i) {\n        std::cin >> weights[i];\n    }\n\n    std::sort(weights.begin(), weights.end());\n\n    int i = 0, j = n - 1;\n    int gondolas = 0;\n\n    while (i <= j) {\n        if (weights[i] + weights[j] <= x) {\n            ++i;\n        }\n        --j;\n        ++gondolas;\n    }\n\n    std::cout << gondolas << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.128205079298753,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Fibonacci Numbers",
            "category": "Mathematics",
            "solution": "#include <iostream>\n\n#define MOD 1000000007\n\nusing namespace std;\n\ntypedef long long ll;\n\n// Function to multiply two matrices\nvoid multiplyMatrix(ll F[2][2], ll M[2][2]) {\n    ll x = (F[0][0] * M[0][0] + F[0][1] * M[1[0]]) % MOD;\n    ll y = (F[0][0] * M[0][1] + F[0][1] * M[1][1]) % MOD;\n    ll z = (F[1][0] * M[0][0] + F[1][1] * M[1][0]) % MOD;\n    ll w = (F[1][0] * M[0][1] + F[1][1] * M[1][1]) % MOD;\n\n    F[0][0] = x;\n    F[0][1] = y;\n    F[1][0] = z;\n    F[1][1] = w;\n}\n\n// Function to perform matrix exponentiation\nvoid powerMatrix(ll F[2][2], ll n) {\n    if (n == 0 || n == 1)\n        return;\n\n    ll M[2][2] = {{1, 1}, {1, 0}};\n\n    powerMatrix(F, n / 2);\n    multiplyMatrix(F, F);\n\n    if (n % 2 != 0)\n        multiplyMatrix(F, M);\n}\n\n// Function to get the nth Fibonacci number\nll fibonacci(ll n) {\n    if (n == 0)\n        return 0;\n\n    ll F[2][2] = {{1, 1}, {1, 0}};\n    powerMatrix(F, n - 1);\n\n    return F[0][0];\n}\n\nint main() {\n    ll n;\n    cin >> n;\n    cout << fibonacci(n) << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Filling Trominos",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool isDivisibleBy3(int n, int m) {\n    return (n * m) % 3 == 0;\n}\n\nvoid fillTrominoGrid(int n, int m) {\n    vector<vector<char>> grid(n, vector<char>(m));\n    char currentChar = 'A';\n    for (int i = 0; i < n; i += 2) {\n        for (int j = 0; j < m; j += 3) {\n            if (j + 2 < m) {\n                grid[i][j] = grid[i][j + 1] = grid[i + 1][j] = currentChar;\n                currentChar = currentChar == 'Z' ? 'A' : currentChar + 1;\n                grid[i + 1][j + 1] = grid[i + 1][j + 2] = grid[i][j + 2] = currentChar;\n                currentChar = currentChar == 'Z' ? 'A' : currentChar + 1;\n            }\n        }\n    }\n    for (const auto& row : grid) {\n        for (char cell : row) {\n            cout << cell;\n        }\n        cout << '\\n';\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        if (isDivisibleBy3(n, m)) {\n            cout << \"YES\\n\";\n            fillTrominoGrid(n, m);\n        } else {\n            cout << \"NO\\n\";\n        }\n    }\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.13520348072052002,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding Borders",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> computePrefixFunction(const string& s) {\n    int n = s.size();\n    vector<int> pi(n, 0);\n    for (int i = 1; i < n; ++i) {\n        int j = pi[i - 1];\n        while (j > 0 && s[i] != s[j]) {\n            j = pi[j - 1];\n        }\n        if (s[i] == s[j]) {\n            ++j;\n        }\n        pi[i] = j;\n    }\n    return pi;\n}\n\nvector<int> findBorders(const string& s) {\n    vector<int> borders;\n    vector<int> pi = computePrefixFunction(s);\n    int n = s.size();\n    int k = pi[n - 1];\n    while (k > 0) {\n        borders.push_back(k);\n        k = pi[k - 1];\n    }\n    reverse(borders.begin(), borders.end());\n    return borders;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    \n    vector<int> borders = findBorders(s);\n    for (int length : borders) {\n        cout << length << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Finding Patterns",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <unordered_set>\n#include <vector>\n#include <string>\n\nint main() {\n    std::string mainString;\n    int k;\n    \n    // Read the main string\n    std::cin >> mainString;\n    int n = mainString.size();\n    \n    // Read the number of patterns\n    std::cin >> k;\n    \n    std::vector<std::string> patterns(k);\n    std::unordered_set<std::string> substrings;\n    \n    // Read all patterns\n    for(int i = 0; i < k; ++i) {\n        std::cin >> patterns[i];\n    }\n    \n    // Process for each unique pattern length\n    for(const auto &pattern : patterns) {\n        int len = pattern.size();\n        if(len > n) continue; // Skip patterns longer than the main string\n        \n        // Generate all substrings of the main string of length `len`\n        for(int i = 0; i <= n - len; ++i) {\n            substrings.insert(mainString.substr(i, len));\n        }\n    }\n    \n    // Check each pattern\n    for(const auto &pattern : patterns) {\n        if(substrings.find(pattern) != substrings.end()) {\n            std::cout << \"YES\" << std::endl;\n        } else {\n            std::cout << \"NO\" << std::endl;\n        }\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 17,
            "mean_time_taken": 0.7038501430960262,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                8,
                10,
                12,
                14,
                15,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding Periods",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<int> computePrefixFunction(const std::string &s) {\n    int n = s.size();\n    std::vector<int> pi(n, 0);\n    for (int i = 1; i < n; ++i) {\n        int j = pi[i - 1];\n        while (j > 0 && s[i] != s[j]) {\n            j = pi[j - 1];\n        }\n        if (s[i] == s[j]) {\n            ++j;\n        }\n        pi[i] = j;\n    }\n    return pi;\n}\n\nstd::vector<int> findPeriods(const std::string &s) {\n    int n = s.size();\n    std::vector<int> pi = computePrefixFunction(s);\n    std::vector<int> periods;\n    for (int i = 0; i < n; ++i) {\n        if ((i + 1) % (i + 1 - pi[i]) == 0) {\n            periods.push_back(i + 1);\n        }\n    }\n    return periods;\n}\n\nint main() {\n    std::string s;\n    std::cin >> s;\n    std::vector<int> periods = findPeriods(s);\n    for (int period : periods) {\n        std::cout << period << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 14,
            "mean_time_taken": 0.11658384118761335,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding a Centroid",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> tree;\nvector<int> subtree_size;\nint n;\n\nvoid dfs(int node, int parent) {\n    subtree_size[node] = 1;\n    for (int neighbor : tree[node]) {\n        if (neighbor == parent) continue;\n        dfs(neighbor, node);\n        subtree_size[node] += subtree_size[neighbor];\n    }\n}\n\nint find_centroid(int node, int parent) {\n    for (int neighbor : tree[node]) {\n        if (neighbor == parent) continue;\n        if (subtree_size[neighbor] > n / 2) {\n            return find_centroid(neighbor, node);\n        }\n    }\n    return node;\n}\n\nint main() {\n    cin >> n;\n    tree.resize(n + 1);\n    subtree_size.resize(n + 1);\n\n    for (int i = 0; i < n - 1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        tree[a].push_back(b);\n        tree[b].push_back(a);\n    }\n\n    // Assume the tree is rooted at node 1\n    dfs(1, -1);\n\n    // Find the centroid\n    int centroid = find_centroid(1, -1);\n    cout << centroid << endl;\n\n    return 0;\n}",
            "passed_test_cases": 14,
            "total_test_cases": 16,
            "mean_time_taken": 0.14077560603618622,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                5,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Fixed-Length Paths I",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAXN = 200005;\nvector<int> adj[MAXN];\nint dp[MAXN][10];  // dp[u][i] represents number of paths of length i ending at node u\nint result = 0;\nint n, k;\n\nvoid dfs(int u, int parent) {\n    dp[u][0] = 1;  // There's one path of length 0 ending at u (the node itself)\n\n    for (int v : adj[u]) {\n        if (v == parent) continue;\n        dfs(v, u);\n\n        // Combine paths from u and v to count paths of length exactly k\n        for (int i = 0; i < k; ++i) {\n            result += dp[u][i] * dp[v][k - i - 1];\n        }\n\n        // Update dp[u] for all lengths\n        for (int i = 0; i < k; ++i) {\n            dp[u][i + 1] += dp[v][i];\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n >> k;\n    for (int i = 1; i < n; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    dfs(1, -1);\n\n    cout << result << endl;\n\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 20,
            "mean_time_taken": 0.22960562705993653,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                12,
                13,
                14,
                16,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Fixed-Length Paths II",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 200005;\n\nvector<int> adj[MAXN];\nvector<int> dist(MAXN, 0);\nlong long result = 0;\nint k1, k2;\n\nvoid dfs(int node, int parent, vector<int>& count, int depth = 0) {\n    vector<int> current(MAXN, 0);\n    current[depth] = 1;  // Starting a new path from this node\n\n    for (int neighbor : adj[node]) {\n        if (neighbor == parent) continue;\n        dfs(neighbor, node, current, depth + 1);\n    }\n\n    // Add up valid paths from the current distances\n    for (int i = k1; i <= k2; ++i) {\n        if (i <= depth) {\n            result += count[depth - i];\n        }\n    }\n\n    // Update the counts for the parent\n    for (int i = 1; i < MAXN; ++i) {\n        count[i] += current[i];\n    }\n}\n\nint main() {\n    int n;\n    cin >> n >> k1 >> k2;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    vector<int> count(MAXN, 0);\n    dfs(1, -1, count);\n\n    cout << result << endl;\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 23,
            "mean_time_taken": 0.5888203745302947,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 35,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Flight Discount",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nstruct Edge {\n    int to;\n    long long cost;\n};\n\nstruct State {\n    long long cost;\n    int node;\n    bool used_coupon;\n    bool operator>(const State& other) const {\n        return cost > other.cost;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n    \n    vector<vector<Edge>> adj(n + 1);\n    \n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        long long c;\n        cin >> a >> b >> c;\n        adj[a].push_back({b, c});\n    }\n    \n    vector<vector<long long>> dist(n + 1, vector<long long>(2, LLONG_MAX));\n    priority_queue<State, vector<State>, greater<State>> pq;\n    \n    pq.push({0, 1, false});\n    dist[1][0] = 0;\n    \n    while (!pq.empty()) {\n        State cur = pq.top();\n        pq.pop();\n        \n        if (cur.cost > dist[cur.node][cur.used_coupon])\n            continue;\n        \n        for (auto& edge : adj[cur.node]) {\n            long long new_cost = cur.cost + edge.cost;\n            if (new_cost < dist[edge.to][cur.used_coupon]) {\n                dist[edge.to][cur.used_coupon] = new_cost;\n                pq.push({new_cost, edge.to, cur.used_coupon});\n            }\n            \n            if (!cur.used_coupon) {\n                long long discounted_cost = cur.cost + edge.cost / 2;\n                if (discounted_cost < dist[edge.to][true]) {\n                    dist[edge.to][true] = discounted_cost;\n                    pq.push({discounted_cost, edge.to, true});\n                }\n            }\n        }\n    }\n    \n    cout << min(dist[n][0], dist[n][1]) << \"\\n\";\n    \n    return 0;\n}",
            "passed_test_cases": 24,
            "total_test_cases": 24,
            "mean_time_taken": 0.13950990637143454,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 36,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Flight Route Requests",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#include <unordered_set>\n\nusing namespace std;\n\nvoid dfs1(int v, const vector<vector<int>>& adj, vector<bool>& visited, stack<int>& finishStack) {\n    visited[v] = true;\n    for (int u : adj[v]) {\n        if (!visited[u]) {\n            dfs1(u, adj, visited, finishStack);\n        }\n    }\n    finishStack.push(v);\n}\n\nvoid dfs2(int v, const vector<vector<int>>& adj, vector<bool>& visited, vector<int>& component) {\n    visited[v] = true;\n    component.push_back(v);\n    for (int u : adj[v]) {\n        if (!visited[u]) {\n            dfs2(u, adj, visited, component);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> adj(n);\n    vector<vector<int>> adjRev(n);\n\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a; --b;\n        adj[a].push_back(b);\n        adjRev[b].push_back(a);\n    }\n\n    // Step 1: Perform DFS and fill the stack with finishing order\n    vector<bool> visited(n, false);\n    stack<int> finishStack;\n\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            dfs1(i, adj, visited, finishStack);\n        }\n    }\n\n    // Step 2: Reverse the graph and perform DFS in the order of the stack\n    fill(visited.begin(), visited.end(), false);\n    vector<vector<int>> sccs;\n\n    while (!finishStack.empty()) {\n        int v = finishStack.top();\n        finishStack.pop();\n        if (!visited[v]) {\n            vector<int> component;\n            dfs2(v, adjRev, visited, component);\n            sccs.push_back(component);\n        }\n    }\n\n    // Step 3: Build the condensed graph\n    vector<unordered_set<int>> condensedAdj(sccs.size());\n    vector<int> sccIndex(n);\n\n    for (int i = 0; i < sccs.size(); ++i) {\n        for (int v : sccs[i]) {\n            sccIndex[v] = i;\n        }\n    }\n\n    for (int u = 0; u < n; ++u) {\n        for (int v : adj[u]) {\n            int from = sccIndex[u];\n            int to = sccIndex[v];\n            if (from != to) {\n                condensedAdj[from].insert(to);\n            }\n        }\n    }\n\n    // Step 4: Calculate the number of sources and sinks in the condensed graph\n    vector<int> inDegree(sccs.size(), 0);\n    vector<int> outDegree(sccs.size(), 0);\n\n    for (int u = 0; u < condensedAdj.size(); ++u) {\n        for (int v : condensedAdj[u]) {\n            outDegree[u]++;\n            inDegree[v]++;\n        }\n    }\n\n    int sources = 0, sinks = 0;\n    for (int i = 0; i < sccs.size(); ++i) {\n        if (inDegree[i] == 0) sources++;\n        if (outDegree[i] == 0) sinks++;\n    }\n\n    cout << max(sources, sinks) << endl;\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 17,
            "mean_time_taken": 0.13069506252513213,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 36,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Flight Routes",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> pli;\n\nconst ll INF = 1e18;\n\nstruct Edge {\n    int to;\n    ll cost;\n};\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n    \n    vector<vector<Edge>> graph(n + 1);\n    \n    // Reading the flights and constructing the graph\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        ll c;\n        cin >> a >> b >> c;\n        graph[a].push_back({b, c});\n    }\n    \n    // Min-heap to store the current shortest distances\n    priority_queue<pli, vector<pli>, greater<pli>> pq;\n    vector<vector<ll>> dist(n + 1);\n    \n    pq.push({0, 1}); // Starting from city 1\n    dist[1].push_back(0);\n    \n    while (!pq.empty()) {\n        ll d = pq.top().first;\n        int u = pq.top().second;\n        pq.pop();\n        \n        if (dist[u].size() > k) continue; // We only need k shortest distances\n        \n        for (auto& edge : graph[u]) {\n            int v = edge.to;\n            ll new_d = d + edge.cost;\n            \n            if (dist[v].size() < k || new_d < dist[v].back()) {\n                dist[v].push_back(new_d);\n                sort(dist[v].begin(), dist[v].end());\n                if (dist[v].size() > k) dist[v].pop_back();\n                \n                pq.push({new_d, v});\n            }\n        }\n    }\n    \n    // Output the k shortest routes from city 1 to city n\n    for (auto& d : dist[n]) {\n        cout << d << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 16,
            "total_test_cases": 17,
            "mean_time_taken": 0.4866807320538689,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                ""
            ],
            "failed_test_cases": [
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 36,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Flight Routes Check",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nvoid dfs(int node, vector<vector<int>>& graph, vector<bool>& visited) {\n    stack<int> s;\n    s.push(node);\n    while (!s.empty()) {\n        int v = s.top();\n        s.pop();\n        if (!visited[v]) {\n            visited[v] = true;\n            for (int neighbor : graph[v]) {\n                if (!visited[neighbor]) {\n                    s.push(neighbor);\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> graph(n + 1);\n    vector<vector<int>> transposedGraph(n + 1);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        transposedGraph[b].push_back(a);\n    }\n\n    // Check reachability from node 1 to all other nodes\n    vector<bool> visited(n + 1, false);\n    dfs(1, graph, visited);\n\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            cout << \"NO\" << endl;\n            cout << 1 << \" \" << i << endl;\n            return 0;\n        }\n    }\n\n    // Check reachability from all nodes to node 1 using the transposed graph\n    fill(visited.begin(), visited.end(), false);\n    dfs(1, transposedGraph, visited);\n\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            cout << \"NO\" << endl;\n            cout << i << \" \" << 1 << endl;\n            return 0;\n        }\n    }\n\n    cout << \"YES\" << endl;\n    return 0;\n}",
            "passed_test_cases": 20,
            "total_test_cases": 20,
            "mean_time_taken": 0.1426563262939453,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 37,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Food Division",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<int> a(n), b(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < n; ++i) {\n        cin >> b[i];\n    }\n    \n    vector<int> diff(n);\n    for (int i = 0; i < n; ++i) {\n        diff[i] = a[i] - b[i];\n    }\n    \n    long long total_steps = 0;\n    long long current_balance = 0;\n    \n    for (int i = 0; i < n; ++i) {\n        current_balance += diff[i];\n        total_steps += abs(current_balance);\n    }\n    \n    cout << total_steps << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 5,
            "mean_time_taken": 0.11242880821228027,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 37,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Forbidden Cities",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n\nusing namespace std;\n\nvector<vector<int>> graph;\nvector<bool> visited;\n\nbool bfs(int start, int end, int forbidden) {\n    if (start == forbidden || end == forbidden) return false;  // If starting or ending point is forbidden\n    queue<int> q;\n    q.push(start);\n    visited[start] = true;\n\n    while (!q.empty()) {\n        int curr = q.front();\n        q.pop();\n\n        if (curr == end) return true;\n\n        for (int neighbor : graph[curr]) {\n            if (neighbor != forbidden && !visited[neighbor]) {\n                visited[neighbor] = true;\n                q.push(neighbor);\n            }\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n\n    graph.resize(n + 1);\n\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n\n        visited.assign(n + 1, false);\n        if (bfs(a, b, c)) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 9,
            "total_test_cases": 14,
            "mean_time_taken": 0.43317530836377827,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                5,
                6,
                8,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 37,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Forest Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    \n    vector<vector<int>> forest(n + 1, vector<int>(n + 1, 0));\n    \n    // Read the forest grid and fill the forest array\n    for (int i = 1; i <= n; ++i) {\n        string row;\n        cin >> row;\n        for (int j = 1; j <= n; ++j) {\n            forest[i][j] = (row[j - 1] == '*') ? 1 : 0;\n        }\n    }\n    \n    // Create the prefix sum array\n    vector<vector<int>> prefix(n + 1, vector<int>(n + 1, 0));\n    \n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            prefix[i][j] = forest[i][j] \n                         + prefix[i - 1][j] \n                         + prefix[i][j - 1] \n                         - prefix[i - 1][j - 1];\n        }\n    }\n    \n    // Process each query\n    while (q--) {\n        int y1, x1, y2, x2;\n        cin >> y1 >> x1 >> y2 >> x2;\n        int result = prefix[y2][x2] \n                   - prefix[y1 - 1][x2] \n                   - prefix[y2][x1 - 1] \n                   + prefix[y1 - 1][x1 - 1];\n        cout << result << endl;\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 3,
            "mean_time_taken": 0.2187042236328125,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 38,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Forest Queries II",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass FenwickTree2D {\npublic:\n    FenwickTree2D(int n) : n(n) {\n        tree.assign(n + 1, vector<int>(n + 1, 0));\n    }\n\n    void update(int y, int x, int delta) {\n        for (int i = y; i <= n; i += (i & -i)) {\n            for (int j = x; j <= n; j += (j & -j)) {\n                tree[i][j] += delta;\n            }\n        }\n    }\n\n    int query(int y, int x) {\n        int sum = 0;\n        for (int i = y; i > 0; i -= (i & -i)) {\n            for (int j = x; j > 0; j -= (j & -j)) {\n                sum += tree[i][j];\n            }\n        }\n        return sum;\n    }\n\n    int query(int y1, int x1, int y2, int x2) {\n        return query(y2, x2) - query(y1-1, x2) - query(y2, x1-1) + query(y1-1, x1-1);\n    }\n\nprivate:\n    int n;\n    vector<vector<int>> tree;\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, q;\n    cin >> n >> q;\n\n    vector<string> forest(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> forest[i];\n    }\n\n    FenwickTree2D fenwick(n);\n\n    // Initialize Fenwick Tree with the initial forest map\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            if (forest[i-1][j-1] == '*') {\n                fenwick.update(i, j, 1);\n            }\n        }\n    }\n\n    while (q--) {\n        int type;\n        cin >> type;\n        if (type == 1) {\n            int y, x;\n            cin >> y >> x;\n            if (forest[y-1][x-1] == '*') {\n                fenwick.update(y, x, -1);\n                forest[y-1][x-1] = '.';\n            } else {\n                fenwick.update(y, x, 1);\n                forest[y-1][x-1] = '*';\n            }\n        } else if (type == 2) {\n            int y1, x1, y2, x2;\n            cin >> y1 >> x1 >> y2 >> x2;\n            cout << fenwick.query(y1, x1, y2, x2) << \"\\n\";\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 5,
            "mean_time_taken": 0.22761893272399902,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 39,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Functional Graph Distribution",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nconst int MOD = 1000000007;\n\nusing namespace std;\n\n// Function to compute binomial coefficients modulo MOD\nvector<vector<long long>> computeBinomialCoefficients(int n) {\n    vector<vector<long long>> binom(n + 1, vector<long long>(n + 1, 0));\n    for (int i = 0; i <= n; ++i) {\n        binom[i][0] = binom[i][i] = 1;\n        for (int j = 1; j < i; ++j) {\n            binom[i][j] = (binom[i - 1][j - 1] + binom[i - 1][j]) % MOD;\n        }\n    }\n    return binom;\n}\n\n// Function to compute Stirling numbers of the first kind modulo MOD\nvector<vector<long long>> computeStirlingNumbers(int n) {\n    vector<vector<long long>> stirling(n + 1, vector<long long>(n + 1, 0));\n    stirling[0][0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= i; ++j) {\n            stirling[i][j] = (stirling[i - 1][j - 1] + (i - 1) * stirling[i - 1][j]) % MOD;\n        }\n    }\n    return stirling;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    // Precompute binomial coefficients and Stirling numbers\n    vector<vector<long long>> binom = computeBinomialCoefficients(n);\n    vector<vector<long long>> stirling = computeStirlingNumbers(n);\n\n    // Compute the number of functional graphs with n nodes and k components\n    vector<long long> result(n + 1, 0);\n    for (int k = 1; k <= n; ++k) {\n        result[k] = stirling[n][k];\n        for (int i = 1; i <= k; ++i) {\n            result[k] = (result[k] * i) % MOD;\n        }\n    }\n\n    // Output the result\n    for (int k = 1; k <= n; ++k) {\n        cout << result[k] << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.18970853090286255,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 39,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Game Routes",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nconst int MOD = 1000000007;\n\nvoid dfs(int node, const std::vector<std::vector<int>>& adj, std::vector<bool>& visited, std::stack<int>& st) {\n    visited[node] = true;\n    for (int neighbor : adj[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, adj, visited, st);\n        }\n    }\n    st.push(node);\n}\n\nint main() {\n    int n, m;\n    std::cin >> n >> m;\n    std::vector<std::vector<int>> adj(n + 1);\n    \n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        std::cin >> a >> b;\n        adj[a].push_back(b);\n    }\n    \n    // Topological sorting\n    std::stack<int> st;\n    std::vector<bool> visited(n + 1, false);\n    \n    for (int i = 1; i <= n; ++i) {\n        if (!visited[i]) {\n            dfs(i, adj, visited, st);\n        }\n    }\n    \n    // Dynamic programming\n    std::vector<int> dp(n + 1, 0);\n    dp[1] = 1; // Start at level 1\n    \n    while (!st.empty()) {\n        int node = st.top();\n        st.pop();\n        \n        for (int neighbor : adj[node]) {\n            dp[neighbor] = (dp[neighbor] + dp[node]) % MOD;\n        }\n    }\n    \n    std::cout << dp[n] << std::endl;\n    \n    return 0;\n}",
            "passed_test_cases": 15,
            "total_test_cases": 15,
            "mean_time_taken": 0.13575900395711263,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Giant Pizza",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nint main() {\n    int n, m;\n    std::cin >> n >> m;\n    \n    std::vector<int> toppingStatus(m + 1, 0); // 0: unknown, 1: included, -1: not included\n    std::vector<std::pair<std::string, int>> wishes[n];\n    \n    for (int i = 0; i < n; ++i) {\n        std::string wish1, wish2;\n        int topping1, topping2;\n        std::cin >> wish1 >> topping1 >> wish2 >> topping2;\n        wishes[i].emplace_back(wish1, topping1);\n        wishes[i].emplace_back(wish2, topping2);\n    }\n    \n    for (int i = 0; i < n; ++i) {\n        bool satisfied = false;\n        for (const auto& wish : wishes[i]) {\n            std::string type = wish.first;\n            int topping = wish.second;\n            if (type == \"+\") {\n                if (toppingStatus[topping] == 1 || toppingStatus[topping] == 0) {\n                    toppingStatus[topping] = 1;\n                    satisfied = true;\n                    break;\n                }\n            } else { // type == \"-\"\n                if (toppingStatus[topping] == -1 || toppingStatus[topping] == 0) {\n                    toppingStatus[topping] = -1;\n                    satisfied = true;\n                    break;\n                }\n            }\n        }\n\n        // If no wish is satisfied, we need to forcefully satisfy one wish\n        if (!satisfied) {\n            for (const auto& wish : wishes[i]) {\n                std::string type = wish.first;\n                int topping = wish.second;\n                if (type == \"+\") {\n                    toppingStatus[topping] = 1;\n                    break;\n                } else { // type == \"-\"\n                    toppingStatus[topping] = -1;\n                    break;\n                }\n            }\n        }\n    }\n    \n    for (int i = 1; i <= m; ++i) {\n        if (toppingStatus[i] == 1)\n            std::cout << \"+\";\n        else\n            std::cout << \"-\";\n    }\n    std::cout << std::endl;\n    \n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 22,
            "mean_time_taken": 0.11735676635395396,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 40,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Graph Girth",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nint findGirth(int n, const vector<vector<int>>& adj) {\n    int min_cycle_length = INT_MAX;\n\n    for (int start = 0; start < n; ++start) {\n        vector<int> dist(n, INT_MAX);\n        vector<int> parent(n, -1);\n        queue<int> q;\n\n        dist[start] = 0;\n        q.push(start);\n\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n\n            for (int v : adj[u]) {\n                if (dist[v] == INT_MAX) {\n                    // Node v is not visited\n                    dist[v] = dist[u] + 1;\n                    parent[v] = u;\n                    q.push(v);\n                } else if (parent[u] != v) {\n                    // Found a cycle\n                    int cycle_length = dist[u] + dist[v] + 1;\n                    min_cycle_length = min(min_cycle_length, cycle_length);\n                }\n            }\n        }\n    }\n\n    return (min_cycle_length == INT_MAX) ? -1 : min_cycle_length;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> adj(n);\n\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a; // converting to 0-based index\n        --b; // converting to 0-based index\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    int girth = findGirth(n, adj);\n    cout << girth << endl;\n\n    return 0;\n}",
            "passed_test_cases": 20,
            "total_test_cases": 20,
            "mean_time_taken": 0.20774954557418823,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 41,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Graph Paths I",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nconst int MOD = 1e9 + 7;\nconst int MAXN = 100;\n\nusing namespace std;\n\ntypedef vector<vector<long long>> Matrix;\n\nMatrix multiply(const Matrix &A, const Matrix &B, int n) {\n    Matrix C(n, vector<long long>(n, 0));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            for (int k = 0; k < n; ++k) {\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD;\n            }\n        }\n    }\n    return C;\n}\n\nMatrix matrixExpo(Matrix A, long long k, int n) {\n    Matrix result(n, vector<long long>(n, 0));\n    for (int i = 0; i < n; ++i) {\n        result[i][i] = 1;\n    }\n    while (k > 0) {\n        if (k % 2 == 1) {\n            result = multiply(result, A, n);\n        }\n        A = multiply(A, A, n);\n        k /= 2;\n    }\n    return result;\n}\n\nint main() {\n    int n, m;\n    long long k;\n    cin >> n >> m >> k;\n    \n    Matrix adj(n, vector<long long>(n, 0));\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a; --b;\n        adj[a][b]++;\n    }\n    \n    Matrix result = matrixExpo(adj, k, n);\n    \n    cout << result[0][n - 1] << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.2883742366518293,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Graph Paths II",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nconst long long INF = LLONG_MAX;\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<vector<pair<int, int>>> edges(n + 1);\n    for (int i = 0; i < m; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        edges[a].emplace_back(b, c);\n    }\n\n    vector<vector<long long>> dp(n + 1, vector<long long>(k + 1, INF));\n    dp[1][0] = 0;\n\n    for (int e = 0; e < k; ++e) {\n        for (int u = 1; u <= n; ++u) {\n            if (dp[u][e] == INF) continue;\n            for (auto &edge : edges[u]) {\n                int v = edge.first;\n                int weight = edge.second;\n                if (dp[u][e] != INF) {\n                    dp[v][e + 1] = min(dp[v][e + 1], dp[u][e] + weight);\n                }\n            }\n        }\n    }\n\n    long long answer = dp[n][k];\n    if (answer == INF) {\n        cout << -1 << endl;\n    } else {\n        cout << answer << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 8,
            "total_test_cases": 15,
            "mean_time_taken": 0.1127806822458903,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                9,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 42,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Gray Code",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <bitset>\n\nint main() {\n    int n;\n    std::cin >> n;\n    \n    int num_codes = 1 << n; // 2^n\n    \n    for (int i = 0; i < num_codes; ++i) {\n        int gray_code = i ^ (i >> 1);\n        std::bitset<16> binary(gray_code); // using 16 bits to handle up to n=16\n        std::string binary_str = binary.to_string();\n        \n        // Extract the last n bits to get the n-bit binary representation\n        std::cout << binary_str.substr(16 - n) << std::endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 16,
            "total_test_cases": 16,
            "mean_time_taken": 0.09620478749275208,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Grid Completion",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <functional>\n\nconst int MOD = 1000000007;\n\nint main() {\n    int n;\n    std::cin >> n;\n    std::vector<std::string> grid(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> grid[i];\n    }\n\n    std::vector<bool> rowHasA(n, false), rowHasB(n, false);\n    std::vector<bool> colHasA(n, false), colHasB(n, false);\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] == 'A') {\n                rowHasA[i] = true;\n                colHasA[j] = true;\n            } else if (grid[i][j] == 'B') {\n                rowHasB[i] = true;\n                colHasB[j] = true;\n            }\n        }\n    }\n\n    std::function<int(int)> countWays = [&](int cell) {\n        if (cell == n * n) {\n            return 1;\n        }\n        int row = cell / n;\n        int col = cell % n;\n        if (grid[row][col] != '.') {\n            return countWays(cell + 1);\n        }\n\n        int ways = 0;\n        if (!rowHasA[row] && !colHasA[col]) {\n            grid[row][col] = 'A';\n            rowHasA[row] = true;\n            colHasA[col] = true;\n            ways = (ways + countWays(cell + 1)) % MOD;\n            rowHasA[row] = false;\n            colHasA[col] = false;\n            grid[row][col] = '.';\n        }\n        if (!rowHasB[row] && !colHasB[col]) {\n            grid[row][col] = 'B';\n            rowHasB[row] = true;\n            colHasB[col] = true;\n            ways = (ways + countWays(cell + 1)) % MOD;\n            rowHasB[row] = false;\n            colHasB[col] = false;\n            grid[row][col] = '.';\n        }\n        return ways;\n    };\n\n    std::cout << countWays(0) << std::endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.09560116132100423,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Path Construction",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\nbool is_valid(int x, int y, int n, int m, vector<vector<bool>> &visited) {\n    return x >= 0 && x < n && y >= 0 && y < m && !visited[x][y];\n}\n\nbool dfs(int x, int y, int n, int m, vector<vector<bool>> &visited, vector<pair<int, int>> &path, int target_x, int target_y) {\n    if (path.size() == n * m) {\n        return x == target_x && y == target_y;\n    }\n    \n    vector<pair<int, int>> moves = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    for (auto move : moves) {\n        int nx = x + move.first;\n        int ny = y + move.second;\n        if (is_valid(nx, ny, n, m, visited)) {\n            visited[nx][ny] = true;\n            path.push_back({nx, ny});\n            if (dfs(nx, ny, n, m, visited, path, target_x, target_y)) {\n                return true;\n            }\n            path.pop_back();\n            visited[nx][ny] = false;\n        }\n    }\n    return false;\n}\n\nvoid solve() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m, y1, x1, y2, x2;\n        cin >> n >> m >> y1 >> x1 >> y2 >> x2;\n        y1--; x1--; y2--; x2--;\n\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        vector<pair<int, int>> path;\n        visited[y1][x1] = true;\n        path.push_back({y1, x1});\n        \n        if (dfs(y1, x1, n, m, visited, path, y2, x2)) {\n            cout << \"YES\" << endl;\n            string result;\n            for (int i = 1; i < path.size(); i++) {\n                int dx = path[i].first - path[i - 1].first;\n                int dy = path[i].second - path[i - 1].second;\n                if (dx == 1) result += 'D';\n                else if (dx == -1) result += 'U';\n                else if (dy == 1) result += 'R';\n                else if (dy == -1) result += 'L';\n            }\n            cout << result << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 20,
            "mean_time_taken": 0.7065087199211121,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13,
                15,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Paths",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <utility>\n#include <map>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nstruct pair_hash {\n    template <class T1, class T2>\n    size_t operator()(const pair<T1, T2>& p) const {\n        auto hash1 = hash<T1>{}(p.first);\n        auto hash2 = hash<T2>{}(p.second);\n        return hash1 ^ hash2;\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    unordered_set<pair<int, int>, pair_hash> traps;\n    for (int i = 0; i < m; ++i) {\n        int y, x;\n        cin >> y >> x;\n        traps.insert({y, x});\n    }\n\n    map<pair<int, int>, int> dp;\n    dp[{1, 1}] = 1;\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            if (traps.find({i, j}) != traps.end()) continue;\n            if (i > 1) {\n                dp[{i, j}] = (dp[{i, j}] + dp[{i - 1, j}]) % MOD;\n            }\n            if (j > 1) {\n                dp[{i, j}] = (dp[{i, j}] + dp[{i, j - 1}]) % MOD;\n            }\n        }\n    }\n\n    cout << dp[{n, n}] << endl;\n    return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 20,
            "mean_time_taken": 0.33298269510269163,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                12,
                14,
                16,
                17,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Paths",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 7;\nconst int len = 48;\nstring path;\nint result = 0;\nvector<vector<bool>> visited(N, vector<bool>(N, false));\n\n// Directions: D, U, L, R\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, -1, 1};\nchar dir[4] = {'D', 'U', 'L', 'R'};\n\nvoid dfs(int x, int y, int step) {\n    if (x == N - 1 && y == 0 && step == len) {\n        result++;\n        return;\n    }\n    if (step >= len) return;\n\n    visited[x][y] = true;\n    \n    for (int i = 0; i < 4; ++i) {\n        if (path[step] == '?' || path[step] == dir[i]) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N && !visited[nx][ny]) {\n                dfs(nx, ny, step + 1);\n            }\n        }\n    }\n    \n    visited[x][y] = false;\n}\n\nint main() {\n    cin >> path;\n    dfs(0, 0, 0);\n    cout << result << endl;\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 20,
            "mean_time_taken": 0.9773884177207947,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Paths",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<char>> grid(n, vector<char>(n));\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n    \n    // Input the grid\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> grid[i][j];\n        }\n    }\n    \n    // Initialize the starting point\n    if (grid[0][0] == '.') {\n        dp[0][0] = 1;\n    }\n\n    // Fill the dp table\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] == '*') {\n                dp[i][j] = 0;\n            } else {\n                if (i > 0) {\n                    dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD;\n                }\n                if (j > 0) {\n                    dp[i][j] = (dp[i][j] + dp[j-1][j]) % MOD;\n                }\n            }\n        }\n    }\n    \n    // Output the number of ways to reach the bottom-right corner\n    cout << dp[n-1][n-1] << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 20,
            "mean_time_taken": 0.11658313274383544,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                6,
                7,
                8,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Puzzle I",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n);\n    for(int i = 0; i < n; ++i) cin >> a[i];\n    for(int i = 0; i < n; ++i) cin >> b[i];\n    \n    // Check if the total number of X's required matches\n    int totalA = 0, totalB = 0;\n    for(int i = 0; i < n; ++i) {\n        totalA += a[i];\n        totalB += b[i];\n    }\n    \n    if (totalA != totalB) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    // Initialize the grid with '.'\n    vector<vector<char>> grid(n, vector<char>(n, '.'));\n    \n    // Greedy approach to place 'X' in the grid\n    for(int i = 0; i < n; ++i) {\n        int count = a[i];\n        for(int j = 0; j < n && count > 0; ++j) {\n            if (b[j] > 0) {\n                grid[i][j] = 'X';\n                b[j]--;\n                count--;\n            }\n        }\n    }\n\n    // Output the grid\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < n; ++j) {\n            cout << grid[i][j];\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 12,
            "mean_time_taken": 0.09029889106750488,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                6,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Puzzle II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst int MAXN = 100; // Since n <= 50, we use 100 to account for bipartite graph representation\n\nint n, a[MAXN], b[MAXN], c[MAXN][MAXN];\nint row[MAXN], col[MAXN], lx[MAXN], ly[MAXN];\nint match[MAXN], slack[MAXN];\nbool S[MAXN], T[MAXN];\n\nbool dfs(int x) {\n    S[x] = true;\n    for (int y = 0; y < n; ++y) {\n        if (T[y]) continue;\n        int temp = lx[x] + ly[y] - c[x][y];\n        if (temp == 0) {\n            T[y] = true;\n            if (match[y] == -1 || dfs(match[y])) {\n                match[y] = x;\n                return true;\n            }\n        } else {\n            slack[y] = min(slack[y], temp);\n        }\n    }\n    return false;\n}\n\nvoid update() {\n    int delta = INF;\n    for (int y = 0; y < n; ++y) {\n        if (!T[y]) delta = min(delta, slack[y]);\n    }\n    for (int i = 0; i < n; ++i) {\n        if (S[i]) lx[i] -= delta;\n        if (T[i]) ly[i] += delta;\n        else slack[i] -= delta;\n    }\n}\n\nint km() {\n    fill(match, match + n, -1);\n    fill(ly, ly + n, 0);\n    for (int i = 0; i < n; ++i) {\n        lx[i] = *max_element(c[i], c[i] + n);\n    }\n    for (int x = 0; x < n; ++x) {\n        fill(slack, slack + n, INF);\n        while (true) {\n            fill(S, S + n, false);\n            fill(T, T + n, false);\n            if (dfs(x)) break;\n            else update();\n        }\n    }\n    int result = 0;\n    for (int y = 0; y < n; ++y) {\n        if (match[y] != -1) result += c[match[y]][y];\n    }\n    return result;\n}\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; ++i) cin >> a[i];\n    for (int i = 0; i < n; ++i) cin >> b[i];\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            cin >> c[i][j];\n\n    int result = km();\n\n    cout << result << endl;\n\n    vector<vector<char>> grid(n, vector<char>(n, '.'));\n    for (int y = 0; y < n; ++y) {\n        if (match[y] != -1) grid[match[y]][y] = 'X';\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << grid[i][j];\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.09072130918502808,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grundy's Game",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 1000000;\nvector<string> results(MAX_N + 1);\n\nvoid precompute() {\n    for (int i = 1; i <= MAX_N; ++i) {\n        if ((i & (i - 1)) == 0) { // Check if i is a power of 2\n            results[i] = \"second\";\n        } else {\n            results[i] = \"first\";\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    precompute();\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        cout << results[n] << \"\\n\";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 3,
            "mean_time_taken": 0.12724057833353677,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Hamiltonian Flights",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9+7;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<vector<int>> adj(n + 1);\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n    \n    vector<vector<long long>> dp(1 << n, vector<long long>(n + 1, 0));\n    dp[1][1] = 1; // Start from city 1 with only city 1 visited\n    \n    for (int mask = 1; mask < (1 << n); ++mask) {\n        for (int i = 1; i <= n; ++i) {\n            if (mask & (1 << (i - 1))) { // If city i is in the current mask\n                for (int j : adj[i]) { // Try to extend the path to city j\n                    if (!(mask & (1 << (j - 1)))) { // If city j is not in the current mask\n                        dp[mask | (1 << (j - 1))][j] = (dp[mask | (1 << (j - 1))][j] + dp[mask][i]) % MOD;\n                    }\n                }\n            }\n        }\n    }\n    \n    cout << dp[(1 << n) - 1][n] << endl; // Number of ways to reach city n having visited all cities\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 20,
            "mean_time_taken": 0.5686116576194763,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                4,
                5,
                6,
                8,
                9,
                12,
                14,
                16,
                18,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Hamming Distance",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n#include <climits>\n\nint calculateHammingDistance(const std::string& a, const std::string& b) {\n    int distance = 0;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            ++distance;\n        }\n    }\n    return distance;\n}\n\nint main() {\n    int n, k;\n    std::cin >> n >> k;\n    std::vector<std::string> bitStrings(n);\n\n    for (int i = 0; i < n; ++i) {\n        std::cin >> bitStrings[i];\n    }\n\n    int minHammingDistance = INT_MAX;\n\n    // Compare each pair of strings\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            int distance = calculateHammingDistance(bitStrings[i], bitStrings[j]);\n            if (distance < minHammingDistance) {\n                minHammingDistance = distance;\n            }\n        }\n    }\n\n    std::cout << minHammingDistance << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 15,
            "mean_time_taken": 0.6684800306955974,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                4,
                5,
                6,
                7,
                8,
                9,
                12,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "High Score",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <limits>\n\nusing namespace std;\n\nconst long long INF = numeric_limits<long long>::min();\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<tuple<int, int, int>> edges;\n    for (int i = 0; i < m; ++i) {\n        int a, b, x;\n        cin >> a >> b >> x;\n        edges.emplace_back(a - 1, b - 1, x); // Store edges in 0-indexed format\n    }\n\n    vector<long long> dist(n, INF);\n    dist[0] = 0; // Starting from room 1 (0-indexed as 0)\n\n    // Bellman-Ford algorithm to find the longest path\n    for (int i = 0; i < n - 1; ++i) {\n        for (auto [a, b, x] : edges) {\n            if (dist[a] != INF && dist[a] + x > dist[b]) {\n                dist[b] = dist[a] + x;\n            }\n        }\n    }\n\n    // Check for positive weight cycles\n    vector<bool> reachable(n, false);\n    for (int i = 0; i < n; ++i) {\n        for (auto [a, b, x] : edges) {\n            if (dist[a] != INF && dist[a] + x > dist[b]) {\n                dist[b] = dist[a] + x;\n                reachable[b] = true;\n            }\n        }\n    }\n\n    // Propagate reachability\n    for (int i = 0; i < n; ++i) {\n        for (auto [a, b, x] : edges) {\n            if (reachable[a]) {\n                reachable[b] = true;\n            }\n        }\n    }\n\n    // If room n (0-indexed as n-1) is reachable from a positive cycle\n    if (reachable[n - 1]) {\n        cout << -1 << endl;\n    } else {\n        cout << dist[n - 1] << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 39,
            "total_test_cases": 43,
            "mean_time_taken": 0.21263260619584903,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                9,
                15,
                23,
                35
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Hotel Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nint main() {\n    // Read n and m\n    int n, m;\n    std::cin >> n >> m;\n\n    // Read the number of free rooms in each hotel\n    std::vector<int> hotels(n);\n    for(int i = 0; i < n; ++i) {\n        std::cin >> hotels[i];\n    }\n\n    // Read the number of rooms each group requires\n    std::vector<int> groups(m);\n    for(int i = 0; i < m; ++i) {\n        std::cin >> groups[i];\n    }\n\n    // Process each group\n    for(int i = 0; i < m; ++i) {\n        int needed_rooms = groups[i];\n        bool assigned = false;\n        for(int j = 0; j < n; ++j) {\n            if(hotels[j] >= needed_rooms) {\n                std::cout << (j + 1) << \" \";\n                hotels[j] -= needed_rooms;\n                assigned = true;\n                break;\n            }\n        }\n        if(!assigned) {\n            std::cout << 0 << \" \";\n        }\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 11,
            "mean_time_taken": 0.5230659571560946,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Houses and Schools",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> children(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        cin >> children[i];\n    }\n\n    vector<vector<long long>> dp(n + 1, vector<long long>(k + 1, LLONG_MAX));\n    vector<vector<long long>> cost(n + 1, vector<long long>(n + 1, 0));\n\n    // Precompute the cost\n    for (int i = 1; i <= n; ++i) {\n        for (int j = i; j <= n; ++j) {\n            cost[i][j] = 0;\n            int mid = (i + j) / 2;\n            for (int l = i; l <= j; ++l) {\n                cost[i][j] += children[l] * abs(l - mid);\n            }\n        }\n    }\n\n    dp[0][0] = 0;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= k; ++j) {\n            for (int t = 1; t <= i; ++t) {\n                if (dp[t-1][j-1] != LLONG_MAX) {\n                    dp[i][j] = min(dp[i][j], dp[t-1][j-1] + cost[t][i]);\n                }\n            }\n        }\n    }\n\n    cout << dp[n][k] << endl;\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 6,
            "mean_time_taken": 0.7318149010340372,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 43,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Increasing Array",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    \n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i];\n    }\n    \n    long long moves = 0;\n    \n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            moves += arr[i - 1] - arr[i];\n            arr[i] = arr[i - 1];\n        }\n    }\n    \n    cout << moves << endl;\n    return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 7,
            "mean_time_taken": 0.10194114276341029,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 44,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Increasing Array II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    \n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    \n    long long moves = 0;\n    \n    for (int i = 1; i < n; i++) {\n        if (arr[i] < arr[i-1]) {\n            moves += arr[i-1] - arr[i];\n            arr[i] = arr[i-1];\n        }\n    }\n    \n    cout << moves << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 7,
            "mean_time_taken": 0.10778920991080147,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 44,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Increasing Array Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    vector<int> x(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        cin >> x[i];\n    }\n    \n    // Prefix array to store the number of operations needed to make the array increasing up to each index\n    vector<long long> prefix_operations(n + 1, 0);\n    \n    // Calculate operations needed to make the array increasing\n    for (int i = 2; i <= n; ++i) {\n        if (x[i] < x[i - 1]) {\n            prefix_operations[i] = prefix_operations[i - 1] + (x[i - 1] - x[i]);\n        } else {\n            prefix_operations[i] = prefix_operations[i - 1];\n        }\n    }\n    \n    // Process each query\n    for (int i = 0; i < q; ++i) {\n        int a, b;\n        cin >> a >> b;\n        cout << prefix_operations[b] - prefix_operations[a] << endl;\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 8,
            "mean_time_taken": 0.22914639115333557,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 44,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Increasing Subsequence",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    int n;\n    std::cin >> n;\n    std::vector<int> arr(n);\n    \n    for (int i = 0; i < n; ++i) {\n        std::cin >> arr[i];\n    }\n\n    std::vector<int> lis;\n\n    for (int i = 0; i < n; ++i) {\n        auto it = std::lower_bound(lis.begin(), lis.end(), arr[i]);\n        if (it == lis.end()) {\n            lis.push_back(arr[i]);\n        } else {\n            *it = arr[i];\n        }\n    }\n\n    std::cout << lis.size() << std::endl;\n    return 0;\n}",
            "passed_test_cases": 17,
            "total_test_cases": 17,
            "mean_time_taken": 0.11080056078293744,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 45,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Increasing Subsequence II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nclass FenwickTree {\npublic:\n    FenwickTree(int n) : data(n + 1, 0) {}\n\n    void update(int index, int value) {\n        while (index < data.size()) {\n            data[index] = (data[index] + value) % MOD;\n            index += index & -index;\n        }\n    }\n\n    int query(int index) {\n        int sum = 0;\n        while (index > 0) {\n            sum = (sum + data[index]) % MOD;\n            index -= index & -index;\n        }\n        return sum;\n    }\n\nprivate:\n    vector<int> data;\n};\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i];\n    }\n\n    // Coordinate compression\n    map<int, int> compress;\n    for (int x : arr) {\n        compress[x] = 0;\n    }\n    int index = 0;\n    for (auto &pair : compress) {\n        pair.second = ++index;\n    }\n\n    FenwickTree fenwick(index);\n    int result = 0;\n\n    for (int i = 0; i < n; ++i) {\n        int pos = compress[arr[i]];\n        int count = fenwick.query(pos - 1) + 1;\n        fenwick.update(pos, count);\n        result = (result + count) % MOD;\n    }\n\n    cout << result << endl;\n\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.1557765245437622,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 46,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Intersection Points",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Segment {\n    int fixed, start, end;\n};\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<Segment> horizontalSegments;\n    vector<Segment> verticalSegments;\n    \n    for (int i = 0; i < n; ++i) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        \n        if (y1 == y2) {\n            // horizontal segment\n            if (x1 > x2) swap(x1, x2);\n            horizontalSegments.push_back({y1, x1, x2});\n        } else if (x1 == x2) {\n            // vertical segment\n            if (y1 > y2) swap(y1, y2);\n            verticalSegments.push_back({x1, y1, y2});\n        }\n    }\n    \n    // Use a map to store horizontal segments sorted by their y-coordinate\n    map<int, vector<pair<int, int>>> horizontalMap;\n    for (const auto& segment : horizontalSegments) {\n        horizontalMap[segment.fixed].push_back({segment.start, segment.end});\n    }\n\n    // Count intersections\n    int intersectionCount = 0;\n    for (const auto& vSegment : verticalSegments) {\n        int x = vSegment.fixed;\n        int y_start = vSegment.start;\n        int y_end = vSegment.end;\n\n        for (const auto& [y, hSegments] : horizontalMap) {\n            if (y >= y_start && y <= y_end) {\n                for (const auto& [h_start, h_end] : hSegments) {\n                    if (x >= h_start && x <= h_end) {\n                        intersectionCount++;\n                    }\n                }\n            }\n        }\n    }\n    \n    cout << intersectionCount << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 5,
            "mean_time_taken": 0.4735853672027588,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 46,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Inverse Inversions",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    \n    vector<int> permutation(n);\n    for (int i = 0; i < n; ++i) {\n        permutation[i] = i + 1;\n    }\n    \n    int current_inversions = 0;\n\n    for (int i = n - 1; i >= 0 && current_inversions < k; --i) {\n        int remaining = k - current_inversions;\n        int add_inversions = min(remaining, i);\n        \n        if (add_inversions > 0) {\n            reverse(permutation.begin() + (i - add_inversions), permutation.begin() + i + 1);\n            current_inversions += add_inversions;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        cout << permutation[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 46,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Inversion Probability",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <iomanip>\n#include <vector>\n\nusing namespace std;\n\ndouble calculateProbability(int r_i, int r_j) {\n    double count = 0.0;\n    for (int v_i = 1; v_i <= r_i; ++v_i) {\n        for (int v_j = 1; v_j <= r_j; ++v_j) {\n            if (v_i > v_j) {\n                count += 1.0;\n            }\n        }\n    }\n    return count / (r_i * r_j);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> r(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> r[i];\n    }\n\n    double expectedInversions = 0.0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            expectedInversions += calculateProbability(r[i], r[j]);\n        }\n    }\n\n    cout << fixed << setprecision(6) << expectedInversions << endl;\n    return 0;\n}",
            "passed_test_cases": 19,
            "total_test_cases": 20,
            "mean_time_taken": 0.10113509893417358,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                ""
            ],
            "failed_test_cases": [
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 46,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Investigation",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <climits>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst long long INF = LLONG_MAX;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<vector<pair<int, int>>> adj(n + 1);\n    \n    for (int i = 0; i < m; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        adj[a].emplace_back(b, c);\n    }\n    \n    vector<long long> dist(n + 1, INF);\n    vector<int> count(n + 1, 0);\n    vector<int> minFlights(n + 1, INT_MAX);\n    vector<int> maxFlights(n + 1, 0);\n    \n    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\n    \n    dist[1] = 0;\n    count[1] = 1;\n    minFlights[1] = 0;\n    maxFlights[1] = 0;\n    pq.emplace(0, 1);\n    \n    while (!pq.empty()) {\n        auto [currDist, u] = pq.top();\n        pq.pop();\n        \n        if (currDist > dist[u]) continue;\n        \n        for (auto &[v, weight] : adj[u]) {\n            long long newDist = currDist + weight;\n            if (newDist < dist[v]) {\n                dist[v] = newDist;\n                count[v] = count[u];\n                minFlights[v] = minFlights[u] + 1;\n                maxFlights[v] = maxFlights[u] + 1;\n                pq.emplace(newDist, v);\n            } else if (newDist == dist[v]) {\n                count[v] = (count[v] + count[u]) % MOD;\n                minFlights[v] = min(minFlights[v], minFlights[u] + 1);\n                maxFlights[v] = max(maxFlights[v], maxFlights[u] + 1);\n            }\n        }\n    }\n    \n    cout << dist[n] << \" \" << count[n] << \" \" << minFlights[n] << \" \" << maxFlights[n] << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.17046606540679932,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 47,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Josephus Problem I",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<int> children;\n    for (int i = 1; i <= n; ++i) {\n        children.push_back(i);\n    }\n    \n    vector<int> removalOrder;\n    int currentIndex = 0;\n    \n    while (!children.empty()) {\n        currentIndex = (currentIndex + 1) % children.size();  // Move to the next child to be removed\n        removalOrder.push_back(children[currentIndex]);\n        children.erase(children.begin() + currentIndex);\n    }\n    \n    for (int i = 0; i < removalOrder.size(); ++i) {\n        if (i > 0) cout << \" \";\n        cout << removalOrder[i];\n    }\n    cout << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.1504030961256761,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 48,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Josephus Problem II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <set>\n#include <vector>\n\nint main() {\n    int n, k;\n    std::cin >> n >> k;\n\n    // Use a set to maintain the circle of children\n    std::set<int> children;\n    for (int i = 1; i <= n; ++i) {\n        children.insert(i);\n    }\n\n    auto it = children.begin();\n    std::vector<int> removal_order;\n\n    while (!children.empty()) {\n        // Compute the position of the k-th child to be removed\n        if (k > 0) {\n            int steps = (k - 1) % children.size(); // Number of steps to move\n            for (int i = 0; i < steps; ++i) {\n                if (it == children.end()) it = children.begin(); // Wrap around\n                ++it;\n                if (it == children.end()) it = children.begin(); // Wrap around again\n            }\n        }\n\n        // Record the removal and erase the child from the set\n        removal_order.push_back(*it);\n        it = children.erase(it);\n\n        // Wrap around if iterator goes to the end\n        if (it == children.end()) it = children.begin();\n    }\n\n    // Print the removal order\n    for (int child : removal_order) {\n        std::cout << child << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 17,
            "mean_time_taken": 0.34450366917778463,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                9,
                11,
                14,
                15,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 48,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Josephus Queries",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint findKthRemoved(int n, int k) {\n    // Start with the first position\n    int pos = 0;\n    // We need to remove k-1 children to get the k-th removed\n    for (int i = 2; i <= k; ++i) {\n        pos = (pos + 2) % i;\n    }\n    // Convert 0-based index to 1-based\n    return pos + 1;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int q;\n    cin >> q;\n    vector<int> results(q);\n\n    for (int i = 0; i < q; ++i) {\n        int n, k;\n        cin >> n >> k;\n        results[i] = findKthRemoved(n, k);\n    }\n\n    for (int result : results) {\n        cout << result << \"\\n\";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.5953861474990845,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 48,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Knight's Tour",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 8;\n\n// Possible moves for the knight\nint dx[8] = {1, 1, 2, 2, -1, -1, -2, -2};\nint dy[8] = {2, -2, 1, -1, 2, -2, 1, -1};\n\n// Function to check if the move is valid\nbool isValid(int x, int y, vector<vector<int>>& board) {\n    return (x >= 0 && x < N && y >= 0 && y < N && board[x][y] == -1);\n}\n\n// Function to count the number of valid onward moves from a position\nint countOnwardMoves(int x, int y, vector<vector<int>>& board) {\n    int count = 0;\n    for (int i = 0; i < 8; ++i) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (isValid(nx, ny, board)) {\n            ++count;\n        }\n    }\n    return count;\n}\n\n// Function to perform the Knight's Tour using Warnsdorff's rule\nbool knightsTour(int stepCount, int x, int y, vector<vector<int>>& board) {\n    if (stepCount == N * N) return true;\n\n    vector<pair<int, int>> nextMoves;\n    for (int i = 0; i < 8; ++i) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (isValid(nx, ny, board)) {\n            nextMoves.push_back({countOnwardMoves(nx, ny, board), i});\n        }\n    }\n\n    // Sort the moves based on the number of onward moves\n    sort(nextMoves.begin(), nextMoves.end());\n\n    for (auto move : nextMoves) {\n        int i = move.second;\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        board[nx][ny] = stepCount;\n        if (knightsTour(stepCount + 1, nx, ny, board)) return true;\n        board[nx][ny] = -1; // Backtrack\n    }\n\n    return false;\n}\n\nint main() {\n    int x, y;\n    cin >> x >> y;\n    --x; // Convert to 0-indexed\n    --y;\n\n    vector<vector<int>> board(N, vector<int>(N, -1));\n    board[x][y] = 0;\n\n    if (knightsTour(1, x, y, board)) {\n        for (const auto& row : board) {\n            for (int cell : row) {\n                cout << cell + 1 << \" \";\n            }\n            cout << endl;\n        }\n    } else {\n        cout << \"No solution exists!\" << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 23,
            "mean_time_taken": 0.08982846011286197,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 48,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Knuth Division",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<long long> arr(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i];\n    }\n\n    vector<vector<long long>> dp(n, vector<long long>(n, LLONG_MAX));\n    vector<long long> prefix_sum(n + 1, 0);\n\n    for (int i = 0; i < n; ++i) {\n        prefix_sum[i + 1] = prefix_sum[i] + arr[i];\n    }\n\n    for (int i = 0; i < n; ++i) {\n        dp[i][i] = 0;\n    }\n\n    for (int length = 2; length <= n; ++length) {\n        for (int i = 0; i + length - 1 < n; ++i) {\n            int j = i + length - 1;\n            for (int k = i; k < j; ++k) {\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + prefix_sum[j + 1] - prefix_sum[i]);\n            }\n        }\n    }\n\n    cout << dp[0][n - 1] << endl;\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 3,
            "mean_time_taken": 0.5133999188741049,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                ""
            ],
            "failed_test_cases": [
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 48,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Labyrinth",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct Point {\n    int x, y;\n};\n\nstruct State {\n    int x, y;\n    string path;\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<string> labyrinth(n);\n    Point start, end;\n\n    for (int i = 0; i < n; i++) {\n        cin >> labyrinth[i];\n        for (int j = 0; j < m; j++) {\n            if (labyrinth[i][j] == 'A') {\n                start = {i, j};\n            }\n            if (labyrinth[i][j] == 'B') {\n                end = {i, j};\n            }\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    queue<State> q;\n    q.push({start.x, start.y, \"\"});\n    visited[start.x][start.y] = true;\n\n    vector<Point> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    string dirStr = \"UDLR\"; // Matches with directions\n\n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n\n        if (current.x == end.x && current.y == end.y) {\n            cout << \"YES\" << endl;\n            cout << current.path.length() << endl;\n            cout << current.path << endl;\n            return 0;\n        }\n\n        for (int i = 0; i < 4; i++) {\n            int nx = current.x + directions[i].x;\n            int ny = current.y + directions[i].y;\n\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && !visited[nx][ny] && labyrinth[nx][ny] != '#') {\n                visited[nx][ny] = true;\n                q.push({nx, ny, current.path + dirStr[i]});\n            }\n        }\n    }\n\n    cout << \"NO\" << endl;\n    return 0;\n}",
            "passed_test_cases": 8,
            "total_test_cases": 17,
            "mean_time_taken": 0.23648729043848374,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                4,
                6,
                9,
                11,
                12,
                13,
                14,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 48,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Letter Pair Move Game",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nstruct Move {\n    int from;\n    int to;\n};\n\nint main() {\n    int n;\n    cin >> n;\n    string boxes;\n    cin >> boxes;\n\n    vector<Move> moves;\n    int empty1 = -1, empty2 = -1;\n\n    // Find the positions of the two empty boxes.\n    for (int i = 0; i < 2 * n; ++i) {\n        if (boxes[i] == '.') {\n            if (empty1 == -1) {\n                empty1 = i;\n            } else {\n                empty2 = i;\n                break;\n            }\n        }\n    }\n\n    for (int i = 0; i < 2 * n; ++i) {\n        if (i < empty1 && boxes[i] == 'B') {\n            // Move B to the right\n            for (int j = empty1 - 1; j > i; --j) {\n                boxes[j + 1] = boxes[j];\n                moves.push_back({j, j + 1});\n            }\n            boxes[i] = '.';\n            empty1 = i;\n\n        } else if (i > empty2 && boxes[i] == 'A') {\n            // Move A to the left\n            for (int j = empty2 + 1; j < i; ++j) {\n                boxes[j - 1] = boxes[j];\n                moves.push_back({j, j - 1});\n            }\n            boxes[i] = '.';\n            empty2 = i;\n        }\n    }\n\n    // Verify if the configuration is correct\n    bool valid = true;\n    for (int i = 0; i < 2 * n; ++i) {\n        if (i < n - 1 && boxes[i] != 'A') {\n            valid = false;\n        }\n        if (i >= n - 1 && i < 2 * n - 2 && boxes[i] != 'B') {\n            valid = false;\n        }\n    }\n\n    if (!valid) {\n        cout << -1 << endl;\n    } else {\n        cout << moves.size() << endl;\n        for (auto &move : moves) {\n            cout << move.from << \" \" << move.to << endl;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 24,
            "mean_time_taken": 0.0913721223672231,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                16,
                17,
                18,
                20,
                21,
                22,
                24
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 48,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Line Segment Intersection",
            "category": "Geometry",
            "solution": "#include <iostream>\nusing namespace std;\n\nstruct Point {\n    long long x, y;\n};\n\nint orientation(Point p, Point q, Point r) {\n    long long val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    if (val == 0) return 0; // collinear\n    return (val > 0) ? 1 : 2; // clock or counterclock wise\n}\n\nbool onSegment(Point p, Point q, Point r) {\n    if (q.x <= max(p.x, r.x) && q.x >= min(p.x, r.x) &&\n        q.y <= max(p.y, r.y) && q.y >= min(p.y, r.y))\n        return true;\n    return false;\n}\n\nbool doIntersect(Point p1, Point q1, Point p2, Point q2) {\n    int o1 = orientation(p1, q1, p2);\n    int o2 = orientation(p1, q1, q2);\n    int o3 = orientation(p2, q2, p1);\n    int o4 = orientation(p2, q2, q1);\n\n    // General case\n    if (o1 != o2 && o3 != o4)\n        return true;\n\n    // Special Cases\n    // p1, q1 and p2 are collinear and p2 lies on segment p1q1\n    if (o1 == 0 && onSegment(p1, p2, q1)) return true;\n\n    // p1, q1 and q2 are collinear and q2 lies on segment p1q1\n    if (o2 == 0 && onSegment(p1, q2, q1)) return true;\n\n    // p2, q2 and p1 are collinear and p1 lies on segment p2q2\n    if (o3 == 0 && onSegment(p2, p1, q2)) return true;\n\n    // p2, q2 and q1 are collinear and q1 lies on segment p2q2\n    if (o4 == 0 && onSegment(p2, q1, q2)) return true;\n\n    return false;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        Point p1, q1, p2, q2;\n        cin >> p1.x >> p1.y >> q1.x >> q1.y >> p2.x >> p2.y >> q2.x >> q2.y;\n        \n        if (doIntersect(p1, q1, p2, q2))\n            cout << \"YES\\n\";\n        else\n            cout << \"NO\\n\";\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 6,
            "mean_time_taken": 0.11414833863576253,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 49,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "List Removals",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> elements(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> elements[i];\n    }\n    vector<int> positions(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> positions[i];\n    }\n\n    // Using a set to keep track of the current positions of elements\n    // The set will help us efficiently find and erase elements\n    set<int> current_positions;\n    for (int i = 0; i < n; ++i) {\n        current_positions.insert(i);\n    }\n\n    for (int i = 0; i < n; ++i) {\n        // Find the iterator to the position to be removed\n        auto it = current_positions.begin();\n        advance(it, positions[i] - 1);\n        int pos = *it;\n        cout << elements[pos] << \" \";\n        current_positions.erase(it);\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 9,
            "mean_time_taken": 0.3200988504621718,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                5,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 49,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "List of Sums",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int totalPairs = n * (n - 1) / 2;\n    vector<int> B(totalPairs);\n    for (int i = 0; i < totalPairs; ++i) {\n        cin >> B[i];\n    }\n    \n    sort(B.begin(), B.end());\n    \n    // Finding the first three elements of A\n    int s1 = B[0];\n    int s2 = B[1];\n    int s3 = B[2];\n    \n    // Calculating initial values of A\n    int A0 = (s1 + s2 - s3) / 2;\n    int A1 = (s1 + s3 - s2) / 2;\n    int A2 = (s2 + s3 - s1) / 2;\n    \n    vector<int> A(n);\n    A[0] = A0;\n    A[1] = A1;\n    A[2] = A2;\n    \n    // Using the sums in B to determine the remaining elements\n    int index = 3; // As we have already determined A[0], A[1], A[2]\n    for (int i = 3; i < n; ++i) {\n        int sum = B[index++];\n        for (int j = 0; j < i; ++j) {\n            sum -= A[j];\n        }\n        A[i] = sum;\n    }\n    \n    for (int i = 0; i < n; ++i) {\n        cout << A[i] << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 10,
            "mean_time_taken": 0.09354109764099121,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                7,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 49,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Longest Flight Route",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stack>\n\nusing namespace std;\n\nvoid topologicalSort(int v, vector<bool> &visited, stack<int> &Stack, vector<vector<int>> &adj) {\n    visited[v] = true;\n    for (int i : adj[v]) {\n        if (!visited[i]) {\n            topologicalSort(i, visited, Stack, adj);\n        }\n    }\n    Stack.push(v);\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<vector<int>> adj(n + 1);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n    \n    vector<bool> visited(n + 1, false);\n    stack<int> Stack;\n    \n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            topologicalSort(i, visited, Stack, adj);\n        }\n    }\n    \n    vector<int> dp(n + 1, -1);\n    vector<int> parent(n + 1, -1);\n    dp[1] = 1;\n    \n    while (!Stack.empty()) {\n        int u = Stack.top();\n        Stack.pop();\n        \n        if (dp[u] != -1) {\n            for (int v : adj[u]) {\n                if (dp[u] + 1 > dp[v]) {\n                    dp[v] = dp[u] + 1;\n                    parent[v] = u;\n                }\n            }\n        }\n    }\n    \n    if (dp[n] == -1) {\n        cout << \"IMPOSSIBLE\" << endl;\n    } else {\n        cout << dp[n] << endl;\n        vector<int> path;\n        for (int v = n; v != -1; v = parent[v]) {\n            path.push_back(v);\n        }\n        reverse(path.begin(), path.end());\n        for (int v : path) {\n            cout << v << \" \";\n        }\n        cout << endl;\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 16,
            "total_test_cases": 24,
            "mean_time_taken": 0.1401570737361908,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                5,
                6,
                8,
                11,
                13,
                15,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 49,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Longest Palindrome",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring longestPalindrome(string s) {\n    int n = s.length();\n    if (n == 0) return \"\";\n    \n    int start = 0, end = 0;\n    \n    for (int i = 0; i < n; ++i) {\n        // Odd length palindromes\n        int len1 = expandFromCenter(s, i, i);\n        // Even length palindromes\n        int len2 = expandFromCenter(s, i, i + 1);\n        int len = max(len1, len2);\n        \n        if (len > end - start) {\n            start = i - (len - 1) / 2;\n            end = i + len / 2;\n        }\n    }\n    \n    return s.substr(start, end - start + 1);\n}\n\nint expandFromCenter(const string &s, int left, int right) {\n    while (left >= 0 && right < s.length() && s[left] == s[right]) {\n        --left;\n        ++right;\n    }\n    return right - left - 1;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    cout << longestPalindrome(s) << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 49,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Mail Delivery",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <unordered_map>\n#include <set>\n\nusing namespace std;\n\nvoid findEulerianCircuit(int n, const vector<vector<int>>& graph) {\n    unordered_map<int, multiset<int>> adj;\n    vector<int> degree(n + 1, 0);\n\n    for (const auto& edge : graph) {\n        int u = edge[0];\n        int v = edge[1];\n        adj[u].insert(v);\n        adj[v].insert(u);\n        degree[u]++;\n        degree[v]++;\n    }\n\n    // Check if all vertices have even degree\n    for (int i = 1; i <= n; ++i) {\n        if (degree[i] % 2 != 0) {\n            cout << \"IMPOSSIBLE\" << endl;\n            return;\n        }\n    }\n\n    stack<int> currentPath;\n    vector<int> circuit;\n    currentPath.push(1);\n\n    while (!currentPath.empty()) {\n        int u = currentPath.top();\n\n        if (!adj[u].empty()) {\n            int v = *adj[u].begin();\n            currentPath.push(v);\n            adj[u].erase(adj[u].begin());\n            adj[v].erase(adj[v].find(u));\n        } else {\n            circuit.push_back(u);\n            currentPath.pop();\n        }\n    }\n\n    if (circuit.size() != graph.size() + 1) {\n        cout << \"IMPOSSIBLE\" << endl;\n        return;\n    }\n\n    for (int i = circuit.size() - 1; i >= 0; --i) {\n        cout << circuit[i] << \" \";\n    }\n    cout << endl;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> graph(m, vector<int>(2));\n\n    for (int i = 0; i < m; ++i) {\n        cin >> graph[i][0] >> graph[i][1];\n    }\n\n    findEulerianCircuit(n, graph);\n    return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 16,
            "mean_time_taken": 0.22882063686847687,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                4,
                5,
                7,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 49,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Maximum Building I",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to find the largest rectangle in a histogram\nint largestRectangleArea(vector<int>& heights) {\n    stack<int> s;\n    heights.push_back(0); // Append 0 to handle remaining elements in stack\n    int maxArea = 0;\n    \n    for (int i = 0; i < heights.size(); ++i) {\n        while (!s.empty() && heights[s.top()] > heights[i]) {\n            int height = heights[s.top()];\n            s.pop();\n            int width = s.empty() ? i : i - s.top() - 1;\n            maxArea = max(maxArea, height * width);\n        }\n        s.push(i);\n    }\n    \n    heights.pop_back(); // Remove the appended 0\n    return maxArea;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<string> forest(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> forest[i];\n    }\n    \n    vector<vector<int>> height(n, vector<int>(m, 0));\n    \n    // Build the height histogram for each column\n    for (int j = 0; j < m; ++j) {\n        for (int i = 0; i < n; ++i) {\n            if (forest[i][j] == '.') {\n                height[i][j] = (i == 0) ? 1 : height[i-1][j] + 1;\n            }\n        }\n    }\n    \n    // Find the maximum rectangle area for each row's histogram\n    int maxArea = 0;\n    for (int i = 0; i < n; ++i) {\n        maxArea = max(maxArea, largestRectangleArea(height[i]));\n    }\n    \n    cout << maxArea << endl;\n    return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.1440995136896769,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 50,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Maximum Building II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<char>> forest(n, vector<char>(m));\n    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            cin >> forest[i][j];\n        }\n    }\n    \n    // Preprocess the forest to create a prefix sum array\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            dp[i][j] = (forest[i-1][j-1] == '*') ? 1 : 0;\n            dp[i][j] += dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1];\n        }\n    }\n    \n    // Function to get the sum of a submatrix\n    auto getSum = [&](int x1, int y1, int x2, int y2) {\n        return dp[x2][y2] - dp[x1-1][y2] - dp[x2][y1-1] + dp[x1-1][y1-1];\n    };\n    \n    // Result array\n    vector<vector<int>> results(n, vector<int>(m, 0));\n    \n    // Calculate the number of ways to place each building size\n    for (int height = 1; height <= n; ++height) {\n        for (int width = 1; width <= m; ++width) {\n            int count = 0;\n            for (int i = 1; i + height - 1 <= n; ++i) {\n                for (int j = 1; j + width - 1 <= m; ++j) {\n                    if (getSum(i, j, i + height - 1, j + width - 1) == 0) {\n                        ++count;\n                    }\n                }\n            }\n            results[height - 1][width - 1] = count;\n        }\n    }\n    \n    // Output the results\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            cout << results[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 13,
            "mean_time_taken": 0.74846861912654,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                8,
                10,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 50,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Maximum Subarray Sum",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    int n;\n    std::cin >> n;\n    std::vector<int> array(n);\n\n    for (int i = 0; i < n; ++i) {\n        std::cin >> array[i];\n    }\n\n    long long max_so_far = array[0];\n    long long max_ending_here = array[0];\n\n    for (int i = 1; i < n; ++i) {\n        max_ending_here = std::max((long long)array[i], max_ending_here + array[i]);\n        max_so_far = std::max(max_so_far, max_ending_here);\n    }\n\n    std::cout << max_so_far << std::endl;\n    return 0;\n}",
            "passed_test_cases": 15,
            "total_test_cases": 15,
            "mean_time_taken": 0.10482869148254395,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 51,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Maximum Subarray Sum II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int n, a, b;\n    cin >> n >> a >> b;\n    vector<int> x(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> x[i];\n    }\n\n    // Calculate prefix sums\n    vector<long long> prefix(n + 1, 0);\n    for (int i = 0; i < n; ++i) {\n        prefix[i + 1] = prefix[i] + x[i];\n    }\n\n    // Deque to maintain the minimum prefix sum in the window\n    deque<int> dq;\n    long long max_sum = LLONG_MIN;\n\n    for (int i = a; i <= n; ++i) {\n        if (!dq.empty() && dq.front() < i - b) {\n            dq.pop_front();\n        }\n\n        int window_start = i - a;\n        while (!dq.empty() && prefix[dq.back()] >= prefix[window_start]) {\n            dq.pop_back();\n        }\n\n        dq.push_back(window_start);\n\n        max_sum = max(max_sum, prefix[i] - prefix[dq.front()]);\n    }\n\n    cout << max_sum << endl;\n\n    return 0;\n}",
            "passed_test_cases": 23,
            "total_test_cases": 23,
            "mean_time_taken": 0.10982969532842221,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 52,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Maximum Xor Subarray",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass TrieNode {\npublic:\n    TrieNode* children[2];\n    TrieNode() {\n        children[0] = children[1] = nullptr;\n    }\n};\n\nclass Trie {\npublic:\n    TrieNode* root;\n    Trie() {\n        root = new TrieNode();\n    }\n\n    void insert(int num) {\n        TrieNode* node = root;\n        for (int i = 31; i >= 0; --i) {\n            int bit = (num >> i) & 1;\n            if (!node->children[bit]) {\n                node->children[bit] = new TrieNode();\n            }\n            node = node->children[bit];\n        }\n    }\n\n    int getMaxXor(int num) {\n        TrieNode* node = root;\n        int maxXor = 0;\n        for (int i = 31; i >= 0; --i) {\n            int bit = (num >> i) & 1;\n            if (node->children[1 - bit]) {\n                maxXor |= (1 << i);\n                node = node->children[1 - bit];\n            } else {\n                node = node->children[bit];\n            }\n        }\n        return maxXor;\n    }\n};\n\nint findMaxXorSubarray(vector<int>& arr) {\n    Trie trie;\n    int maxXor = 0, prefixXor = 0;\n\n    trie.insert(0);  // Insert the base case for empty subarray\n\n    for (int num : arr) {\n        prefixXor ^= num;\n        maxXor = max(maxXor, trie.getMaxXor(prefixXor));\n        trie.insert(prefixXor);\n    }\n\n    return maxXor;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i];\n    }\n\n    int result = findMaxXorSubarray(arr);\n    cout << result << endl;\n\n    return 0;\n}",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.13120790890284947,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 53,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Meet in the Middle",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\n// Function to compute all subset sums of a given vector\nvoid computeSubsetSums(const vector<int>& arr, vector<long long>& sums) {\n    int n = arr.size();\n    int totalSubsets = 1 << n;\n    for (int i = 0; i < totalSubsets; i++) {\n        long long sum = 0;\n        for (int j = 0; j < n; j++) {\n            if (i & (1 << j)) {\n                sum += arr[j];\n            }\n        }\n        sums.push_back(sum);\n    }\n}\n\nint main() {\n    int n;\n    long long x;\n    cin >> n >> x;\n    \n    vector<int> t(n);\n    for (int i = 0; i < n; i++) {\n        cin >> t[i];\n    }\n    \n    // Split the array into two halves\n    vector<int> firstHalf(t.begin(), t.begin() + n / 2);\n    vector<int> secondHalf(t.begin() + n / 2, t.end());\n    \n    // Compute all subset sums for both halves\n    vector<long long> firstHalfSums, secondHalfSums;\n    computeSubsetSums(firstHalf, firstHalfSums);\n    computeSubsetSums(secondHalf, secondHalfSums);\n    \n    // Use a hashmap to count occurrences of each sum in the first half\n    unordered_map<long long, int> firstHalfSumCount;\n    for (long long sum : firstHalfSums) {\n        firstHalfSumCount[sum]++;\n    }\n    \n    // Count the number of ways to achieve the sum x\n    long long count = 0;\n    for (long long sum : secondHalfSums) {\n        long long complement = x - sum;\n        if (firstHalfSumCount.find(complement) != firstHalfSumCount.end()) {\n            count += firstHalfSumCount[complement];\n        }\n    }\n    \n    // Output the result\n    cout << count << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 39,
            "total_test_cases": 40,
            "mean_time_taken": 0.4553523242473602,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                ""
            ],
            "failed_test_cases": [
                25
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 53,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Message Route",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> adj(n + 1);\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    vector<int> distance(n + 1, -1);\n    vector<int> parent(n + 1, -1);\n    queue<int> q;\n\n    q.push(1);\n    distance[1] = 0;\n\n    while (!q.empty()) {\n        int current = q.front();\n        q.pop();\n\n        for (int neighbor : adj[current]) {\n            if (distance[neighbor] == -1) {\n                distance[neighbor] = distance[current] + 1;\n                parent[neighbor] = current;\n                q.push(neighbor);\n            }\n        }\n    }\n\n    if (distance[n] == -1) {\n        cout << \"IMPOSSIBLE\" << endl;\n    } else {\n        cout << distance[n] + 1 << endl;\n        stack<int> path;\n        for (int at = n; at != -1; at = parent[at]) {\n            path.push(at);\n        }\n        while (!path.empty()) {\n            cout << path.top() << \" \";\n            path.pop();\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.14130520820617676,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 54,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Minimal Rotation",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint minimal_rotation(const string &s) {\n    int n = s.size();\n    string ss = s + s;\n    vector<int> f(2 * n, -1);\n    int k = 0; // least rotation of string found so far\n    \n    for (int j = 1; j < 2 * n; ++j) {\n        char sj = ss[j];\n        int i = f[j - k - 1];\n        while (i != -1 && sj != ss[k + i + 1]) {\n            if (sj < ss[k + i + 1]) k = j - i - 1;\n            i = f[i];\n        }\n        if (sj != ss[k + i + 1]) {\n            if (sj < ss[k]) k = j;\n            f[j - k] = -1;\n        } else {\n            f[j - k] = i + 1;\n        }\n    }\n    return k;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    int index = minimal_rotation(s);\n    string result = s.substr(index) + s.substr(0, index);\n    cout << result << endl;\n    return 0;\n}",
            "passed_test_cases": 20,
            "total_test_cases": 20,
            "mean_time_taken": 0.10441633462905883,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 55,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Minimizing Coins",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nint main() {\n    int n, x;\n    std::cin >> n >> x;\n    std::vector<int> coins(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> coins[i];\n    }\n\n    std::vector<int> dp(x + 1, INT_MAX);\n    dp[0] = 0;\n\n    for (int coin : coins) {\n        for (int i = coin; i <= x; ++i) {\n            if (dp[i - coin] != INT_MAX) {\n                dp[i] = std::min(dp[i], dp[i - coin] + 1);\n            }\n        }\n    }\n\n    if (dp[x] == INT_MAX) {\n        std::cout << -1 << std::endl;\n    } else {\n        std::cout << dp[x] << std::endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 16,
            "total_test_cases": 16,
            "mean_time_taken": 0.22815625369548798,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 56,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Minimum Euclidean Distance",
            "category": "Geometry",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nll distSquared(const pii &a, const pii &b) {\n    return (ll)(a.first - b.first) * (a.first - b.first) + (ll)(a.second - b.second) * (a.second - b.second);\n}\n\nll closestPair(vector<pii> &points, vector<pii> &temp, int left, int right) {\n    if (right - left <= 3) {\n        ll minDist = LLONG_MAX;\n        for (int i = left; i < right; ++i) {\n            for (int j = i + 1; j < right; ++j) {\n                minDist = min(minDist, distSquared(points[i], points[j]));\n            }\n        }\n        sort(points.begin() + left, points.begin() + right, [](const pii &a, const pii &b) {\n            return a.second < b.second;\n        });\n        return minDist;\n    }\n\n    int mid = (left + right) / 2;\n    int midX = points[mid].first;\n    ll d = min(closestPair(points, temp, left, mid), closestPair(points, temp, mid, right));\n\n    merge(points.begin() + left, points.begin() + mid, points.begin() + mid, points.begin() + right, temp.begin() + left, [](const pii &a, const pii &b) {\n        return a.second < b.second;\n    });\n    copy(temp.begin() + left, temp.begin() + right, points.begin() + left);\n\n    int tSize = 0;\n    for (int i = left; i < right; ++i) {\n        if ((ll)(points[i].first - midX) * (points[i].first - midX) < d) {\n            for (int j = tSize - 1; j >= 0 && (ll)(points[i].second - temp[j].second) * (points[i].second - temp[j].second) < d; --j) {\n                d = min(d, distSquared(points[i], temp[j]));\n            }\n            temp[tSize++] = points[i];\n        }\n    }\n    return d;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin >> n;\n    vector<pii> points(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> points[i].first >> points[i].second;\n    }\n\n    sort(points.begin(), points.end());\n    vector<pii> temp(n);\n    cout << closestPair(points, temp, 0, n) << endl;\n\n    return 0;\n}",
            "passed_test_cases": 27,
            "total_test_cases": 27,
            "mean_time_taken": 0.1380620620868824,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 57,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Missing Coin Sum",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    int n;\n    std::cin >> n;\n    std::vector<long long> coins(n);\n    \n    for (int i = 0; i < n; ++i) {\n        std::cin >> coins[i];\n    }\n    \n    std::sort(coins.begin(), coins.end());\n    \n    long long smallest_missing_sum = 1;\n    \n    for (int i = 0; i < n; ++i) {\n        if (coins[i] > smallest_missing_sum) {\n            break;\n        }\n        smallest_missing_sum += coins[i];\n    }\n    \n    std::cout << smallest_missing_sum << std::endl;\n    \n    return 0;\n}",
            "passed_test_cases": 9,
            "total_test_cases": 9,
            "mean_time_taken": 0.11698540051778157,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 58,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Missing Coin Sum Queries",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> find_min_missing_sum(vector<int>& coins, vector<pair<int, int>>& queries) {\n    vector<int> results;\n    for (auto& query : queries) {\n        int a = query.first;\n        int b = query.second;\n        vector<int> subset(coins.begin() + a - 1, coins.begin() + b);\n        sort(subset.begin(), subset.end());\n        \n        long long current_sum = 0;\n        for (int value : subset) {\n            if (value > current_sum + 1) {\n                break;\n            }\n            current_sum += value;\n        }\n        results.push_back(current_sum + 1);\n    }\n    return results;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, q;\n    cin >> n >> q;\n    vector<int> coins(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> coins[i];\n    }\n    \n    vector<pair<int, int>> queries(q);\n    for (int i = 0; i < q; ++i) {\n        int a, b;\n        cin >> a >> b;\n        queries[i] = {a, b};\n    }\n\n    vector<int> results = find_min_missing_sum(coins, queries);\n    for (int result : results) {\n        cout << result << \"\\n\";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 8,
            "mean_time_taken": 0.6833075881004333,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 58,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Missing Number",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> numbers(n-1);\n    long long sum_given = 0;\n    \n    // Read the n-1 numbers and calculate their sum\n    for(int i = 0; i < n-1; ++i) {\n        cin >> numbers[i];\n        sum_given += numbers[i];\n    }\n    \n    // Calculate the sum of the first n natural numbers\n    long long sum_n = (long long)n * (n + 1) / 2;\n    \n    // The missing number is the difference between the expected sum and the given sum\n    long long missing_number = sum_n - sum_given;\n    \n    // Print the missing number\n    cout << missing_number << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.09896601949419294,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 59,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Money Sums",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<int> coins(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> coins[i];\n    }\n    \n    int max_sum = 100 * 1000; // Maximum sum possible with constraints\n    vector<bool> possible(max_sum + 1, false);\n    possible[0] = true;\n    \n    for (int coin : coins) {\n        for (int sum = max_sum; sum >= coin; --sum) {\n            if (possible[sum - coin]) {\n                possible[sum] = true;\n            }\n        }\n    }\n    \n    set<int> sums;\n    for (int i = 1; i <= max_sum; ++i) {\n        if (possible[i]) {\n            sums.insert(i);\n        }\n    }\n    \n    cout << sums.size() << endl;\n    for (int sum : sums) {\n        cout << sum << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.24803955738361066,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 60,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Monotone Subsequences",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> generatePermutation(int n, int k) {\n    vector<int> permutation(n);\n    for(int i = 0; i < n; ++i) {\n        permutation[i] = i + 1;\n    }\n    \n    if (k == n) {\n        return permutation;\n    }\n    \n    if (k == 1) {\n        return permutation;\n    }\n    \n    int idx = 0;\n    for (int i = 0; i < k - 1; ++i) {\n        swap(permutation[i], permutation[i + 1]);\n    }\n    \n    return permutation;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        \n        if (k > n) {\n            cout << \"IMPOSSIBLE\" << endl;\n            continue;\n        }\n        \n        vector<int> result = generatePermutation(n, k);\n        \n        for (int i = 0; i < result.size(); ++i) {\n            cout << result[i] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.09943294525146484,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 60,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Monster Game I",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits.h>\n\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n    vector<int> s(n), f(n);\n    for (int i = 0; i < n; i++) {\n        cin >> s[i];\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> f[i];\n    }\n    \n    // Initialize the dp array with high values\n    vector<vector<long long>> dp(n, vector<long long>(x + 1, LLONG_MAX));\n    \n    // Set the initial state\n    dp[0][x] = 0;\n    \n    // Fill the dp array\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 1; j <= x; j++) {\n            if (dp[i][j] != LLONG_MAX) {\n                // Case 1: Escape the monster\n                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);\n                \n                // Case 2: Kill the monster and update the skill factor\n                int new_skill_factor = f[i];\n                long long new_time = dp[i][j] + s[i] * j;\n                dp[i + 1][new_skill_factor] = min(dp[i + 1][new_skill_factor], new_time);\n            }\n        }\n    }\n    \n    // Handle the final level where killing the monster is mandatory\n    long long result = LLONG_MAX;\n    for (int j = 1; j <= x; j++) {\n        if (dp[n - 1][j] != LLONG_MAX) {\n            result = min(result, dp[n - 1][j] + s[n - 1] * j);\n        }\n    }\n    \n    cout << result << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 5,
            "mean_time_taken": 0.3333724498748779,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 60,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Monster Game II",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n    \n    vector<int> s(n), f(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> s[i];\n    }\n    for (int i = 0; i < n; ++i) {\n        cin >> f[i];\n    }\n\n    vector<long long> dp(n + 1, LLONG_MAX);\n    dp[0] = 0;\n    \n    for (int i = 0; i < n; ++i) {\n        if (i > 0) {\n            dp[i] = min(dp[i], dp[i-1]);\n        }\n        long long kill_time = s[i] * (i > 0 ? f[i-1] : x);\n        if (i < n - 1) {\n            dp[i+1] = min(dp[i+1], dp[i] + kill_time);\n        } else {\n            dp[i+1] = dp[i] + kill_time;\n        }\n    }\n\n    cout << dp[n] << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.12887313961982727,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 60,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Monsters",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <string>\n#include <tuple>\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, 1, -1};\nconst char dir[] = {'D', 'U', 'R', 'L'};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<string> grid(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> grid[i];\n    }\n    \n    queue<pair<int, int>> q;\n    vector<vector<int>> monster_time(n, vector<int>(m, INF));\n    pair<int, int> start;\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == 'M') {\n                q.push({i, j});\n                monster_time[i][j] = 0;\n            }\n            if (grid[i][j] == 'A') {\n                start = {i, j};\n            }\n        }\n    }\n    \n    // Multi-source BFS for monsters\n    while (!q.empty()) {\n        auto [x, y] = q.front();\n        q.pop();\n        for (int i = 0; i < 4; ++i) {\n            int nx = x + dx[i], ny = y + dy[i];\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && grid[nx][ny] == '.' && monster_time[nx][ny] == INF) {\n                monster_time[nx][ny] = monster_time[x][y] + 1;\n                q.push({nx, ny});\n            }\n        }\n    }\n    \n    queue<tuple<int, int, int>> pq;\n    pq.push({start.first, start.second, 0});\n    vector<vector<int>> player_time(n, vector<int>(m, INF));\n    vector<vector<pair<int, int>>> parent(n, vector<pair<int, int>>(m, {-1, -1}));\n    player_time[start.first][start.second] = 0;\n    \n    // BFS for player\n    while (!pq.empty()) {\n        auto [x, y, t] = pq.front();\n        pq.pop();\n        for (int i = 0; i < 4; ++i) {\n            int nx = x + dx[i], ny = y + dy[i];\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && grid[nx][ny] == '.' && player_time[nx][ny] == INF && t + 1 < monster_time[nx][ny]) {\n                player_time[nx][ny] = t + 1;\n                parent[nx][ny] = {x, y};\n                pq.push({nx, ny, t + 1});\n                if (nx == 0 || ny == 0 || nx == n-1 || ny == m-1) {\n                    // Reconstruct the path\n                    string path;\n                    pair<int, int> cur = {nx, ny};\n                    while (cur != start) {\n                        pair<int, int> pr = parent[cur.first][cur.second];\n                        for (int d = 0; d < 4; ++d) {\n                            if (pr.first + dx[d] == cur.first && pr.second + dy[d] == cur.second) {\n                                path += dir[d];\n                                break;\n                            }\n                        }\n                        cur = pr;\n                    }\n                    reverse(path.begin(), path.end());\n                    cout << \"YES\\n\";\n                    cout << path.size() << \"\\n\";\n                    cout << path << \"\\n\";\n                    return 0;\n                }\n            }\n        }\n    }\n    \n    cout << \"NO\\n\";\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 60,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Movie Festival",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<pair<int, int>> movies(n);\n    \n    // Reading input\n    for (int i = 0; i < n; ++i) {\n        cin >> movies[i].first >> movies[i].second;\n    }\n\n    // Sort movies by their ending time\n    sort(movies.begin(), movies.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        return a.second < b.second;\n    });\n\n    int count = 0;\n    int last_end_time = 0;\n\n    // Greedily select the maximum number of movies\n    for (const auto& movie : movies) {\n        if (movie.first >= last_end_time) {\n            ++count;\n            last_end_time = movie.second;\n        }\n    }\n\n    // Output the result\n    cout << count << endl;\n\n    return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.13284730911254883,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 61,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Movie Festival II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    \n    vector<pair<int, int>> movies(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> movies[i].first >> movies[i].second;\n    }\n    \n    // Sort movies by their ending times\n    sort(movies.begin(), movies.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        return a.second < b.second;\n    });\n    \n    multiset<int> endTimes;\n    for (int i = 0; i < k; ++i) {\n        endTimes.insert(0); // initially all k members are free at time 0\n    }\n    \n    int count = 0;\n    \n    for (const auto& movie : movies) {\n        auto it = endTimes.upper_bound(movie.first);\n        if (it != endTimes.begin()) {\n            --it; // move to the largest ending time that is <= movie.first\n            endTimes.erase(it);\n            endTimes.insert(movie.second); // update the ending time of this member\n            ++count;\n        }\n    }\n    \n    cout << count << endl;\n    return 0;\n}",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.17379091336176947,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 62,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Movie Festival Queries",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Movie {\n    int start, end;\n};\n\nstruct Query {\n    int arrive, leave, index;\n};\n\nbool compareMovies(const Movie &m1, const Movie &m2) {\n    return m1.end < m2.end;\n}\n\nbool compareQueries(const Query &q1, const Query &q2) {\n    return q1.leave < q2.leave;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int n, q;\n    cin >> n >> q;\n    \n    vector<Movie> movies(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> movies[i].start >> movies[i].end;\n    }\n    \n    vector<Query> queries(q);\n    for (int i = 0; i < q; ++i) {\n        cin >> queries[i].arrive >> queries[i].leave;\n        queries[i].index = i;\n    }\n    \n    sort(movies.begin(), movies.end(), compareMovies);\n    sort(queries.begin(), queries.end(), compareQueries);\n    \n    vector<int> dp(n + 1, 0);\n    vector<int> times;\n    \n    for (int i = 0; i < n; ++i) {\n        times.push_back(movies[i].end);\n    }\n    \n    for (int i = 1; i <= n; ++i) {\n        dp[i] = dp[i - 1];\n        int start_time = movies[i - 1].start;\n        auto it = lower_bound(times.begin(), times.end(), start_time);\n        int pos = it - times.begin();\n        dp[i] = max(dp[i], dp[pos] + 1);\n    }\n    \n    vector<int> result(q);\n    int j = 0;\n    \n    for (int i = 0; i < q; ++i) {\n        int arrive = queries[i].arrive;\n        int leave = queries[i].leave;\n        \n        auto it = upper_bound(times.begin(), times.end(), leave);\n        int pos = it - times.begin();\n        \n        if (pos == 0) {\n            result[queries[i].index] = 0;\n        } else {\n            int start_pos = lower_bound(times.begin(), times.end(), arrive) - times.begin();\n            if (start_pos >= pos) {\n                result[queries[i].index] = 0;\n            } else {\n                result[queries[i].index] = dp[pos];\n            }\n        }\n    }\n    \n    for (int i = 0; i < q; ++i) {\n        cout << result[i] << \"\\n\";\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 5,
            "mean_time_taken": 0.24371399879455566,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 62,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Moving Robots",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <iomanip>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 8;\nconst int directions[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\nint main() {\n    int k;\n    cin >> k;\n\n    vector<vector<vector<double>>> dp(k + 1, vector<vector<double>>(N, vector<double>(N, 0.0)));\n\n    // Initialize the DP table for step 0\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dp[0][i][j] = 1.0;\n        }\n    }\n\n    // Fill the DP table for steps 1 to k\n    for (int step = 1; step <= k; ++step) {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                dp[step][i][j] = 0.0;\n                for (int d = 0; d < 4; ++d) {\n                    int ni = i + directions[d][0];\n                    int nj = j + directions[d][1];\n                    if (ni >= 0 && ni < N && nj >= 0 && nj < N) {\n                        dp[step][i][j] += dp[step - 1][ni][nj] / 4.0;\n                    }\n                }\n            }\n        }\n    }\n\n    // Calculate the expected number of empty squares after k steps\n    double expectedEmptySquares = 64.0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            expectedEmptySquares -= dp[k][i][j];\n        }\n    }\n\n    cout << fixed << setprecision(6) << expectedEmptySquares << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 16,
            "mean_time_taken": 0.09294773638248444,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 62,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Multiplication Table",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\n// Function to count the number of elements in the multiplication table <= x\nlong long countLessOrEqual(int n, long long x) {\n    long long count = 0;\n    for (int i = 1; i <= n; ++i) {\n        count += min(x / i, (long long)n);\n    }\n    return count;\n}\n\nint findMedian(int n) {\n    long long low = 1, high = (long long)n * n, median = 0;\n    while (low <= high) {\n        long long mid = low + (high - low) / 2;\n        if (countLessOrEqual(n, mid) >= (n * n + 1) / 2) {\n            median = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return median;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    cout << findMedian(n) << endl;\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 8,
            "mean_time_taken": 0.11198481917381287,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 62,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Nearest Smaller Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n\nint main() {\n    int n;\n    std::cin >> n;\n    std::vector<int> arr(n);\n    std::vector<int> result(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> arr[i];\n    }\n\n    std::stack<int> s; // Stack to store indices\n\n    for (int i = 0; i < n; ++i) {\n        // Maintain the stack such that it holds indices of elements in increasing order\n        while (!s.empty() && arr[s.top()] >= arr[i]) {\n            s.pop();\n        }\n\n        if (s.empty()) {\n            result[i] = 0; // No smaller element to the left\n        } else {\n            result[i] = s.top() + 1; // Convert 0-based index to 1-based index\n        }\n\n        s.push(i); // Push current index onto the stack\n    }\n\n    for (int i = 0; i < n; ++i) {\n        std::cout << result[i] << \" \";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.11472613994891827,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 63,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Necessary Cities",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 100005;\n\nvector<int> adj[MAXN];\nbool visited[MAXN];\nint disc[MAXN], low[MAXN], parent[MAXN];\nbool isArticulationPoint[MAXN];\nint timeCounter;\n\nvoid dfs(int u) {\n    visited[u] = true;\n    disc[u] = low[u] = ++timeCounter;\n    int children = 0;\n\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            children++;\n            parent[v] = u;\n            dfs(v);\n\n            low[u] = min(low[u], low[v]);\n\n            if (parent[u] == -1 && children > 1)\n                isArticulationPoint[u] = true;\n\n            if (parent[u] != -1 && low[v] >= disc[u])\n                isArticulationPoint[u] = true;\n        } else if (v != parent[u]) {\n            low[u] = min(low[u], disc[v]);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    fill(visited, visited + n + 1, false);\n    fill(parent, parent + n + 1, -1);\n    fill(isArticulationPoint, isArticulationPoint + n + 1, false);\n    timeCounter = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (!visited[i]) {\n            dfs(i);\n        }\n    }\n\n    vector<int> articulationPoints;\n    for (int i = 1; i <= n; ++i) {\n        if (isArticulationPoint[i]) {\n            articulationPoints.push_back(i);\n        }\n    }\n\n    cout << articulationPoints.size() << endl;\n    for (int u : articulationPoints) {\n        cout << u << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 8,
            "mean_time_taken": 0.1143302321434021,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 63,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Necessary Roads",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 100000;\n\nvector<int> adj[MAXN];\nvector<pair<int, int>> bridges;\nint disc[MAXN], low[MAXN], parent[MAXN];\nbool visited[MAXN];\nint time_counter;\n\nvoid dfs(int u) {\n    visited[u] = true;\n    disc[u] = low[u] = ++time_counter;\n\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            parent[v] = u;\n            dfs(v);\n            low[u] = min(low[u], low[v]);\n\n            if (low[v] > disc[u]) {\n                bridges.push_back({u, v});\n            }\n        } else if (v != parent[u]) {\n            low[u] = min(low[u], disc[v]);\n        }\n    }\n}\n\nvoid findBridges(int n) {\n    time_counter = 0;\n    fill(disc, disc + n, -1);\n    fill(low, low + n, -1);\n    fill(parent, parent + n, -1);\n    fill(visited, visited + n, false);\n\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            dfs(i);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a; --b; // Convert to 0-based index\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    findBridges(n);\n\n    cout << bridges.size() << \"\\n\";\n    for (auto &bridge : bridges) {\n        cout << bridge.first + 1 << \" \" << bridge.second + 1 << \"\\n\"; // Convert back to 1-based index\n    }\n\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 5,
            "mean_time_taken": 0.12702841758728028,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 64,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Nested Ranges Check",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Range {\n    int start, end, index;\n};\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Range> ranges(n);\n\n    // Read input ranges\n    for (int i = 0; i < n; ++i) {\n        cin >> ranges[i].start >> ranges[i].end;\n        ranges[i].index = i;\n    }\n\n    // Sort ranges by start, and by end descending if starts are equal\n    sort(ranges.begin(), ranges.end(), [](const Range& a, const Range& b) {\n        return (a.start < b.start) || (a.start == b.start && a.end > b.end);\n    });\n\n    vector<int> contains(n, 0), contained(n, 0);\n    int max_end = -1;\n\n    // Determine if a range contains another range\n    for (int i = 0; i < n; ++i) {\n        if (ranges[i].end <= max_end) {\n            contained[ranges[i].index] = 1;\n        }\n        max_end = max(max_end, ranges[i].end);\n    }\n\n    // Sort by end, and by start descending if ends are equal\n    sort(ranges.begin(), ranges.end(), [](const Range& a, const Range& b) {\n        return (a.end < b.end) || (a.end == b.end && a.start > b.start);\n    });\n\n    int min_start = 1e9 + 1;\n\n    // Determine if a range is contained within another range\n    for (int i = n - 1; i >= 0; --i) {\n        if (ranges[i].start >= min_start) {\n            contains[ranges[i].index] = 1;\n        }\n        min_start = min(min_start, ranges[i].start);\n    }\n\n    // Print results\n    for (int i = 0; i < n; ++i) {\n        cout << contains[i] << \" \";\n    }\n    cout << endl;\n    for (int i = 0; i < n; ++i) {\n        cout << contained[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.18008665243784586,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 64,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Nested Ranges Count",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <set>\nusing namespace std;\n\nstruct Range {\n    int start, end, index;\n    bool operator<(const Range &other) const {\n        if (start != other.start)\n            return start < other.start;\n        return end > other.end;\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Range> ranges(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> ranges[i].start >> ranges[i].end;\n        ranges[i].index = i;\n    }\n\n    // Sort ranges by starting point, and by ending point in descending order if starting points are the same\n    sort(ranges.begin(), ranges.end());\n\n    // To count how many ranges each range contains\n    vector<int> contains(n, 0);\n    set<int> activeEnds;\n    \n    for (const auto &range : ranges) {\n        // Count how many active ranges have an end point <= current range's end\n        contains[range.index] = distance(activeEnds.begin(), activeEnds.lower_bound(range.end + 1));\n        activeEnds.insert(range.end);\n    }\n\n    // Sort ranges by ending point, and by starting point in ascending order if ending points are the same\n    sort(ranges.begin(), ranges.end(), [](const Range &a, const Range &b) {\n        if (a.end != b.end)\n            return a.end < b.end;\n        return a.start > b.start;\n    });\n\n    // To count how many ranges contain each range\n    vector<int> containedBy(n, 0);\n    activeEnds.clear();\n\n    for (const auto &range : ranges) {\n        // Count how many active ranges have a start point >= current range's start\n        containedBy[range.index] = activeEnds.size() - distance(activeEnds.begin(), activeEnds.lower_bound(range.start));\n        activeEnds.insert(range.start);\n    }\n\n    for (int i = 0; i < n; ++i) {\n        cout << contains[i] << \" \";\n    }\n    cout << endl;\n\n    for (int i = 0; i < n; ++i) {\n        cout << containedBy[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.5833834012349447,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 64,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Network Breakdown",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass UnionFind {\npublic:\n    vector<int> parent, rank;\n    int components;\n\n    UnionFind(int n) : parent(n), rank(n, 1), components(n) {\n        for (int i = 0; i < n; ++i) parent[i] = i;\n    }\n\n    int find(int a) {\n        if (parent[a] != a) {\n            parent[a] = find(parent[a]);\n        }\n        return parent[a];\n    }\n\n    bool unionSets(int a, int b) {\n        int rootA = find(a);\n        int rootB = find(b);\n        if (rootA != rootB) {\n            if (rank[rootA] > rank[rootB]) {\n                parent[rootB] = rootA;\n            } else if (rank[rootA] < rank[rootB]) {\n                parent[rootA] = rootB;\n            } else {\n                parent[rootB] = rootA;\n                rank[rootA]++;\n            }\n            components--;\n            return true;\n        }\n        return false;\n    }\n};\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<pair<int, int>> connections(m);\n    vector<pair<int, int>> breakdowns(k);\n\n    for (int i = 0; i < m; ++i) {\n        cin >> connections[i].first >> connections[i].second;\n        connections[i].first--;\n        connections[i].second--;\n    }\n\n    vector<bool> willBreak(m, false);\n    for (int i = 0; i < k; ++i) {\n        cin >> breakdowns[i].first >> breakdowns[i].second;\n        breakdowns[i].first--;\n        breakdowns[i].second--;\n    }\n\n    // Mark the connections that will break\n    for (auto b : breakdowns) {\n        for (int i = 0; i < m; ++i) {\n            if (connections[i] == b) {\n                willBreak[i] = true;\n                break;\n            }\n        }\n    }\n\n    UnionFind uf(n);\n\n    // Union all connections that are not breaking down\n    for (int i = 0; i < m; ++i) {\n        if (!willBreak[i]) {\n            uf.unionSets(connections[i].first, connections[i].second);\n        }\n    }\n\n    vector<int> result(k);\n    for (int i = k - 1; i >= 0; --i) {\n        result[i] = uf.components;\n        uf.unionSets(breakdowns[i].first, breakdowns[i].second);\n    }\n\n    for (int i = 0; i < k; ++i) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 13,
            "mean_time_taken": 0.46042299270629883,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                5,
                6,
                8,
                10,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 64,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Network Renovation",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nconst int MAXN = 100005;\nvector<int> graph[MAXN];\nvector<pair<int, int>> addEdges;\nint discovery[MAXN], low[MAXN], parent[MAXN];\nbool visited[MAXN];\nint timer = 0;\n\nvoid dfs(int u) {\n    visited[u] = true;\n    discovery[u] = low[u] = ++timer;\n    int children = 0;\n\n    for (int v : graph[u]) {\n        if (!visited[v]) {\n            children++;\n            parent[v] = u;\n            dfs(v);\n\n            low[u] = min(low[u], low[v]);\n\n            if (low[v] > discovery[u]) {\n                // This is a bridge, so we need to add an edge here\n                addEdges.push_back({u, v});\n            }\n        } else if (v != parent[u]) {\n            low[u] = min(low[u], discovery[v]);\n        }\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    for (int i = 1; i < n; ++i) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n\n    fill(visited, visited + n + 1, false);\n    fill(parent, parent + n + 1, -1);\n\n    // Perform DFS from node 1 (or any arbitrary node)\n    dfs(1);\n\n    // Output the required edges\n    cout << addEdges.size() << endl;\n    for (auto &edge : addEdges) {\n        cout << edge.first << \" \" << edge.second << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 21,
            "mean_time_taken": 0.1213672501700265,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 64,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "New Flight Routes",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 100000;\n\nvector<int> adj[MAXN], adj_rev[MAXN], scc_adj[MAXN];\nvector<int> order, component;\nbool visited[MAXN];\nint component_id[MAXN];\nint n, m;\n\nvoid dfs1(int v) {\n    visited[v] = true;\n    for (int u : adj[v]) {\n        if (!visited[u]) {\n            dfs1(u);\n        }\n    }\n    order.push_back(v);\n}\n\nvoid dfs2(int v, int id) {\n    visited[v] = true;\n    component_id[v] = id;\n    for (int u : adj_rev[v]) {\n        if (!visited[u]) {\n            dfs2(u, id);\n        }\n    }\n}\n\nint main() {\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a - 1].push_back(b - 1);\n        adj_rev[b - 1].push_back(a - 1);\n    }\n\n    fill(visited, visited + n, false);\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs1(i);\n        }\n    }\n\n    fill(visited, visited + n, false);\n    reverse(order.begin(), order.end());\n\n    int id = 0;\n    for (int v : order) {\n        if (!visited[v]) {\n            dfs2(v, id++);\n        }\n    }\n\n    vector<int> in_deg(id, 0), out_deg(id, 0);\n\n    for (int v = 0; v < n; v++) {\n        for (int u : adj[v]) {\n            if (component_id[v] != component_id[u]) {\n                scc_adj[component_id[v]].push_back(component_id[u]);\n                out_deg[component_id[v]]++;\n                in_deg[component_id[u]]++;\n            }\n        }\n    }\n\n    int sources = 0, sinks = 0;\n    for (int i = 0; i < id; i++) {\n        if (in_deg[i] == 0) sources++;\n        if (out_deg[i] == 0) sinks++;\n    }\n\n    cout << max(sources, sinks) << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 26,
            "mean_time_taken": 0.13344163161057693,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 64,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "New Roads Queries",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass UnionFind {\npublic:\n    vector<int> parent, rank;\n\n    UnionFind(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]); // Path compression\n        }\n        return parent[x];\n    }\n\n    bool unionSets(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n            return true;\n        }\n        return false;\n    }\n};\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n\n    vector<pair<int, int>> roads(m);\n    for (int i = 0; i < m; ++i) {\n        cin >> roads[i].first >> roads[i].second;\n        roads[i].first--;\n        roads[i].second--;\n    }\n\n    vector<pair<pair<int, int>, int>> queries(q);\n    for (int i = 0; i < q; ++i) {\n        cin >> queries[i].first.first >> queries[i].first.second;\n        queries[i].first.first--;\n        queries[i].first.second--;\n        queries[i].second = i;\n    }\n\n    vector<int> answer(q, -1);\n    UnionFind uf(n);\n\n    for (int day = 0; day < m; ++day) {\n        uf.unionSets(roads[day].first, roads[day].second);\n        for (auto& query : queries) {\n            int a = query.first.first;\n            int b = query.first.second;\n            int idx = query.second;\n            if (answer[idx] == -1 && uf.find(a) == uf.find(b)) {\n                answer[idx] = day + 1;\n            }\n        }\n    }\n\n    for (int i = 0; i < q; ++i) {\n        cout << answer[i] << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 7,
            "mean_time_taken": 0.9063186986105782,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 64,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Nim Game I",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n;\n        cin >> n;\n        \n        int nim_sum = 0;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            cin >> x;\n            nim_sum ^= x;\n        }\n        \n        if (nim_sum == 0) {\n            cout << \"second\" << '\\n';\n        } else {\n            cout << \"first\" << '\\n';\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 4,
            "mean_time_taken": 0.0977446436882019,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 65,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Nim Game II",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n;\n        cin >> n;\n        \n        int nim_sum = 0;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            cin >> x;\n            nim_sum ^= x;\n        }\n        \n        if (nim_sum == 0) {\n            cout << \"second\" << endl;\n        } else {\n            cout << \"first\" << endl;\n        }\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.10027498006820679,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 65,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Number Grid",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    long long y, x;\n    cin >> y >> x;\n    cout << (y + x - 2) << endl;\n    return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 20,
            "mean_time_taken": 0.0896766185760498,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                7,
                8,
                9,
                10,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 65,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Number Spiral",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        long long y, x;\n        cin >> y >> x;\n\n        long long layer = max(y, x);\n        long long layerMax = layer * layer;\n        \n        long long result;\n        if (layer % 2 == 0) {\n            if (x == layer) {\n                result = layerMax - (y - 1);\n            } else {\n                result = layerMax - (2 * layer - 1) + (x - 1);\n            }\n        } else {\n            if (y == layer) {\n                result = layerMax - (x - 1);\n            } else {\n                result = layerMax - (2 * layer - 1) + (y - 1);\n            }\n        }\n\n        cout << result << \"\\n\";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 2,
            "mean_time_taken": 0.11155831813812256,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                ""
            ],
            "failed_test_cases": [
                1
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 65,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "One Bit Positions",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.length();\n    \n    // List to store positions of '1's\n    vector<int> ones_positions;\n    \n    // Fill the positions of '1's\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '1') {\n            ones_positions.push_back(i);\n        }\n    }\n    \n    // Vector to store the result for each k\n    vector<int> result(n - 1, 0);\n    \n    // Count pairs for each distance k\n    for (int i = 0; i < ones_positions.size(); ++i) {\n        for (int j = i + 1; j < ones_positions.size(); ++j) {\n            int distance = ones_positions[j] - ones_positions[i];\n            if (distance < n) {\n                result[distance - 1]++;\n            }\n        }\n    }\n    \n    // Print the results\n    for (int k = 0; k < n - 1; ++k) {\n        if (k > 0) cout << \" \";\n        cout << result[k];\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 5,
            "mean_time_taken": 0.8521579742431641,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 65,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Palindrome Queries",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int n, m;\n    cin >> n >> m;\n    \n    string s;\n    cin >> s;\n    \n    while (m--) {\n        int type;\n        cin >> type;\n        \n        if (type == 1) {\n            int k;\n            char x;\n            cin >> k >> x;\n            // Update character at position k (convert 1-based index to 0-based index)\n            s[k - 1] = x;\n        } else if (type == 2) {\n            int a, b;\n            cin >> a >> b;\n            // Check if substring s[a-1:b] is a palindrome (1-based index to 0-based index)\n            bool isPalindrome = true;\n            for (int i = 0; i < (b - a + 1) / 2; ++i) {\n                if (s[a - 1 + i] != s[b - 1 - i]) {\n                    isPalindrome = false;\n                    break;\n                }\n            }\n            if (isPalindrome) {\n                cout << \"YES\\n\";\n            } else {\n                cout << \"NO\\n\";\n            }\n        }\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 8,
            "total_test_cases": 14,
            "mean_time_taken": 0.49994005475725445,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                6,
                8,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 65,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Palindrome Reorder",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nint main() {\n    std::string s;\n    std::cin >> s;\n    std::unordered_map<char, int> freq;\n    \n    // Count frequency of each character\n    for (char c : s) {\n        freq[c]++;\n    }\n\n    // Check for the number of odd frequency characters\n    int oddCount = 0;\n    char oddChar = 0;\n    for (auto& pair : freq) {\n        if (pair.second % 2 != 0) {\n            oddCount++;\n            oddChar = pair.first;\n        }\n    }\n\n    // If there is more than one character with an odd frequency, no solution\n    if (oddCount > 1) {\n        std::cout << \"NO SOLUTION\" << std::endl;\n        return 0;\n    }\n\n    // Construct the first half and second half of the palindrome\n    std::string firstHalf, secondHalf;\n    for (auto& pair : freq) {\n        std::string part(pair.second / 2, pair.first);\n        firstHalf += part;\n        secondHalf = part + secondHalf;\n    }\n\n    // Construct the full palindrome\n    std::string palindrome = firstHalf;\n    if (oddCount == 1) {\n        palindrome += std::string(freq[oddChar], oddChar);\n    }\n    palindrome += secondHalf;\n\n    std::cout << palindrome << std::endl;\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 17,
            "mean_time_taken": 0.10679726039662081,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                6,
                7,
                9,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 65,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Parcel Delivery",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <climits>\n\nusing namespace std;\n\nstruct Edge {\n    int to, maxParcels, costPerParcel;\n};\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n    \n    vector<vector<Edge>> graph(n + 1);\n    \n    for (int i = 0; i < m; ++i) {\n        int a, b, r, c;\n        cin >> a >> b >> r >> c;\n        graph[a].push_back({b, r, c});\n        graph[b].push_back({a, r, c});  // Assuming the routes are bidirectional\n    }\n    \n    vector<vector<int>> dp(n + 1, vector<int>(k + 1, INT_MAX));\n    dp[1][0] = 0;\n    \n    priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;\n    pq.push({0, 1, 0});  // {cost, city, parcelsDelivered}\n    \n    while (!pq.empty()) {\n        auto [cost, city, parcelsDelivered] = pq.top();\n        pq.pop();\n        \n        if (cost > dp[city][parcelsDelivered]) continue;\n        \n        for (const auto& edge : graph[city]) {\n            int nextCity = edge.to;\n            int maxParcels = edge.maxParcels;\n            int costPerParcel = edge.costPerParcel;\n            \n            for (int p = 1; p <= maxParcels; ++p) {\n                if (parcelsDelivered + p > k) break;\n                int newCost = cost + p * costPerParcel;\n                if (newCost < dp[nextCity][parcelsDelivered + p]) {\n                    dp[nextCity][parcelsDelivered + p] = newCost;\n                    pq.push({newCost, nextCity, parcelsDelivered + p});\n                }\n            }\n        }\n    }\n    \n    int finalCost = dp[n][k];\n    cout << (finalCost == INT_MAX ? -1 : finalCost) << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 13,
            "mean_time_taken": 0.2701124044565054,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 65,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Path Queries",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200005;\n\nvector<int> tree[MAXN];\nint values[MAXN];\nlong long sumToNode[MAXN];  // sum from root to each node\n\nvoid dfs(int node, int parent) {\n    if (node != 1) {\n        sumToNode[node] = sumToNode[parent] + values[node];\n    } else {\n        sumToNode[node] = values[node];\n    }\n    \n    for (int child : tree[node]) {\n        if (child != parent) {\n            dfs(child, node);\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int n, q;\n    cin >> n >> q;\n    \n    for (int i = 1; i <= n; ++i) {\n        cin >> values[i];\n    }\n    \n    for (int i = 0; i < n - 1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        tree[a].push_back(b);\n        tree[b].push_back(a);\n    }\n    \n    // Preprocess the sum from root to each node using DFS\n    dfs(1, -1);\n    \n    while (q--) {\n        int type, s, x;\n        cin >> type;\n        \n        if (type == 1) {\n            cin >> s >> x;\n            int diff = x - values[s];\n            values[s] = x;\n            \n            // Update sumToNode values for all descendants of s\n            queue<int> q;\n            q.push(s);\n            \n            while (!q.empty()) {\n                int curr = q.front();\n                q.pop();\n                \n                sumToNode[curr] += diff;\n                \n                for (int child : tree[curr]) {\n                    if (sumToNode[child] == sumToNode[curr] + values[child]) {\n                        q.push(child);\n                    }\n                }\n            }\n        } else if (type == 2) {\n            cin >> s;\n            cout << sumToNode[s] << \"\\n\";\n        }\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 10,
            "mean_time_taken": 0.1529470682144165,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 65,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Path Queries II",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 200005;\nconst int INF = 1e9;\n\nvector<int> adj[MAXN];\nint values[MAXN];\nint parent[MAXN], depth[MAXN], heavy[MAXN], head[MAXN], pos[MAXN];\nint cur_pos;\nint segtree[4 * MAXN];\n\nint dfs(int v) {\n    int size = 1;\n    int max_c_size = 0;\n    for (int c : adj[v]) {\n        if (c == parent[v]) continue;\n        parent[c] = v;\n        depth[c] = depth[v] + 1;\n        int c_size = dfs(c);\n        size += c_size;\n        if (c_size > max_c_size) {\n            max_c_size = c_size;\n            heavy[v] = c;\n        }\n    }\n    return size;\n}\n\nvoid decompose(int v, int h) {\n    head[v] = h, pos[v] = cur_pos++;\n    if (heavy[v] != -1)\n        decompose(heavy[v], h);\n    for (int c : adj[v]) {\n        if (c != parent[v] && c != heavy[v])\n            decompose(c, c);\n    }\n}\n\nvoid buildSegTree(int node, int start, int end) {\n    if (start == end) {\n        segtree[node] = values[start];\n    } else {\n        int mid = (start + end) / 2;\n        buildSegTree(2 * node, start, mid);\n        buildSegTree(2 * node + 1, mid + 1, end);\n        segtree[node] = max(segtree[2 * node], segtree[2 * node + 1]);\n    }\n}\n\nvoid updateSegTree(int node, int start, int end, int idx, int val) {\n    if (start == end) {\n        segtree[node] = val;\n    } else {\n        int mid = (start + end) / 2;\n        if (start <= idx && idx <= mid) {\n            updateSegTree(2 * node, start, mid, idx, val);\n        } else {\n            updateSegTree(2 * node + 1, mid + 1, end, idx, val);\n        }\n        segtree[node] = max(segtree[2 * node], segtree[2 * node + 1]);\n    }\n}\n\nint querySegTree(int node, int start, int end, int L, int R) {\n    if (R < start || end < L) {\n        return -INF;\n    }\n    if (L <= start && end <= R) {\n        return segtree[node];\n    }\n    int mid = (start + end) / 2;\n    int left_query = querySegTree(2 * node, start, mid, L, R);\n    int right_query = querySegTree(2 * node + 1, mid + 1, end, L, R);\n    return max(left_query, right_query);\n}\n\nint query(int a, int b) {\n    int res = -INF;\n    for (; head[a] != head[b]; b = parent[head[b]]) {\n        if (depth[head[a]] > depth[head[b]])\n            swap(a, b);\n        res = max(res, querySegTree(1, 0, cur_pos - 1, pos[head[b]], pos[b]));\n    }\n    if (depth[a] > depth[b])\n        swap(a, b);\n    res = max(res, querySegTree(1, 0, cur_pos - 1, pos[a], pos[b]));\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, q;\n    cin >> n >> q;\n\n    for (int i = 0; i < n; ++i) {\n        cin >> values[i];\n    }\n\n    for (int i = 0; i < n - 1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a, --b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    fill(heavy, heavy + n, -1);\n    parent[0] = -1;\n    depth[0] = 0;\n    dfs(0);\n    cur_pos = 0;\n    decompose(0, 0);\n\n    vector<int> new_values(n);\n    for (int i = 0; i < n; ++i) {\n        new_values[pos[i]] = values[i];\n    }\n    \n    for (int i = 0; i < n; ++i) {\n        values[i] = new_values[i];\n    }\n\n    buildSegTree(1, 0, n - 1);\n\n    while (q--) {\n        int type;\n        cin >> type;\n        if (type == 1) {\n            int s, x;\n            cin >> s >> x;\n            --s;\n            updateSegTree(1, 0, n - 1, pos[s], x);\n        } else {\n            int a, b;\n            cin >> a >> b;\n            --a, --b;\n            cout << query(a, b) << \" \";\n        }\n    }\n    cout << '\\n';\n\n    return 0;\n}",
            "passed_test_cases": 8,
            "total_test_cases": 10,
            "mean_time_taken": 0.34832966327667236,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 65,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Pattern Positions",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\n// Function to compute the LPS (Longest Prefix Suffix) array for KMP algorithm\nstd::vector<int> computeLPSArray(const std::string& pattern) {\n    int m = pattern.length();\n    std::vector<int> lps(m);\n    int len = 0;\n    int i = 1;\n    lps[0] = 0;\n\n    while (i < m) {\n        if (pattern[i] == pattern[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        } else {\n            if (len != 0) {\n                len = lps[len - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    return lps;\n}\n\n// Function to find the first occurrence of a pattern in a text using KMP algorithm\nint KMPSearch(const std::string& text, const std::string& pattern) {\n    int n = text.length();\n    int m = pattern.length();\n\n    if (m == 0) return 1; // Empty pattern is found at index 1\n\n    std::vector<int> lps = computeLPSArray(pattern);\n\n    int i = 0;\n    int j = 0;\n    while (i < n) {\n        if (pattern[j] == text[i]) {\n            i++;\n            j++;\n        }\n\n        if (j == m) {\n            return i - j + 1; // Pattern found at index (i - j)\n        } else if (i < n && pattern[j] != text[i]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    return -1; // Pattern not found\n}\n\nint main() {\n    std::string text;\n    std::cin >> text;\n\n    int k;\n    std::cin >> k;\n\n    for (int i = 0; i < k; ++i) {\n        std::string pattern;\n        std::cin >> pattern;\n        int position = KMPSearch(text, pattern);\n        std::cout << position << std::endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 10,
            "mean_time_taken": 0.49771182537078856,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                5,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 65,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Permutation Inversions",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    // DP table\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\n\n    // Base case\n    dp[0][0] = 1;\n\n    // Fill the DP table\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 0; j <= k; ++j) {\n            for (int m = 0; m <= min(j, i - 1); ++m) {\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - m]) % MOD;\n            }\n        }\n    }\n\n    // The result is dp[n][k]\n    cout << dp[n][k] << endl;\n\n    return 0;\n}",
            "passed_test_cases": 13,
            "total_test_cases": 16,
            "mean_time_taken": 0.2739608734846115,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                7,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 65,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Permutations",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    if (n == 1) {\n        cout << 1 << endl;\n    } else if (n == 2 || n == 3) {\n        cout << \"NO SOLUTION\" << endl;\n    } else {\n        for (int i = 2; i <= n; i += 2) {\n            cout << i << \" \";\n        }\n        for (int i = 1; i <= n; i += 2) {\n            cout << i << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 21,
            "total_test_cases": 21,
            "mean_time_taken": 0.10225442477634974,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 66,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Permutations II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n;\n    cin >> n;\n\n    if (n == 1) {\n        cout << 1 << endl;\n        return 0;\n    }\n    \n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n\n    // Initialization for the case when the length of permutation is 1\n    for (int j = 1; j <= n; ++j) {\n        dp[1][j] = 1;\n    }\n\n    for (int i = 2; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            dp[i][j] = 0;\n            for (int k = 1; k <= n; ++k) {\n                if (abs(j - k) != 1) {\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % MOD;\n                }\n            }\n        }\n    }\n\n    int result = 0;\n    for (int j = 1; j <= n; ++j) {\n        result = (result + dp[n][j]) % MOD;\n    }\n\n    cout << result << endl;\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 23,
            "mean_time_taken": 0.4499845504760742,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 66,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Pizzeria Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits.h>\nusing namespace std;\n\nclass SegmentTree {\n    vector<long long> tree;\n    int n;\n\n    void build(const vector<long long>& data, int v, int tl, int tr) {\n        if (tl == tr) {\n            tree[v] = data[tl];\n        } else {\n            int tm = (tl + tr) / 2;\n            build(data, v * 2, tl, tm);\n            build(data, v * 2 + 1, tm + 1, tr);\n            tree[v] = min(tree[v * 2], tree[v * 2 + 1]);\n        }\n    }\n\n    void update(int v, int tl, int tr, int pos, long long new_val) {\n        if (tl == tr) {\n            tree[v] = new_val;\n        } else {\n            int tm = (tl + tr) / 2;\n            if (pos <= tm)\n                update(v * 2, tl, tm, pos, new_val);\n            else\n                update(v * 2 + 1, tm + 1, tr, pos, new_val);\n            tree[v] = min(tree[v * 2], tree[v * 2 + 1]);\n        }\n    }\n\n    long long query(int v, int tl, int tr, int l, int r) {\n        if (l > r)\n            return LLONG_MAX;\n        if (l == tl && r == tr) {\n            return tree[v];\n        }\n        int tm = (tl + tr) / 2;\n        return min(query(v * 2, tl, tm, l, min(r, tm)),\n                   query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r));\n    }\n\npublic:\n    SegmentTree(const vector<long long>& data) {\n        n = data.size();\n        tree.resize(n * 4);\n        build(data, 1, 0, n - 1);\n    }\n\n    void update(int pos, long long new_val) {\n        update(1, 0, n - 1, pos, new_val);\n    }\n\n    long long query(int l, int r) {\n        return query(1, 0, n - 1, l, r);\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, q;\n    cin >> n >> q;\n    vector<long long> p(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> p[i];\n    }\n\n    vector<long long> add(n), sub(n);\n    for (int i = 0; i < n; ++i) {\n        add[i] = p[i] + i;\n        sub[i] = p[i] - i;\n    }\n\n    SegmentTree segTreeAdd(add), segTreeSub(sub);\n\n    while (q--) {\n        int type;\n        cin >> type;\n        if (type == 1) {\n            int k;\n            long long x;\n            cin >> k >> x;\n            --k;\n            segTreeAdd.update(k, x + k);\n            segTreeSub.update(k, x - k);\n        } else if (type == 2) {\n            int k;\n            cin >> k;\n            --k;\n            long long result = min(segTreeAdd.query(0, k) - k, segTreeSub.query(k, n - 1) + k);\n            cout << result << \"\\n\";\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 4,
            "mean_time_taken": 0.17401450872421265,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 66,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Planets Cycles",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid dfs(int node, const vector<int>& teleports, vector<int>& visited, vector<int>& steps, vector<int>& stack, vector<int>& in_cycle) {\n    visited[node] = 1;\n    stack.push_back(node);\n\n    int next_node = teleports[node];\n    if (visited[next_node] == 0) {\n        dfs(next_node, teleports, visited, steps, stack, in_cycle);\n    } else if (visited[next_node] == 1) {\n        // Cycle detected\n        int cycle_length = 0;\n        for (int i = stack.size() - 1; i >= 0; --i) {\n            in_cycle[stack[i]] = 1;\n            cycle_length++;\n            if (stack[i] == next_node) break;\n        }\n        for (int i = stack.size() - 1; i >= 0; --i) {\n            steps[stack[i]] = cycle_length;\n            if (stack[i] == next_node) break;\n        }\n    }\n\n    if (in_cycle[node] == 0) {\n        steps[node] = steps[next_node] + 1;\n    }\n\n    visited[node] = 2;\n    stack.pop_back();\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> teleports(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> teleports[i];\n        teleports[i]--;  // Convert to 0-based indexing\n    }\n\n    vector<int> visited(n, 0);\n    vector<int> steps(n, 0);\n    vector<int> stack;\n    vector<int> in_cycle(n, 0);\n\n    for (int i = 0; i < n; ++i) {\n        if (visited[i] == 0) {\n            dfs(i, teleports, visited, steps, stack, in_cycle);\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        cout << steps[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 14,
            "mean_time_taken": 0.12083661556243896,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                8,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 66,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Planets Queries I",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 200000;\nconst int LOG = 30; // Since 2^30 is greater than 10^9\n\nint up[MAXN + 1][LOG];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> t(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        cin >> t[i];\n        up[i][0] = t[i];\n    }\n\n    // Precompute the binary lifting table\n    for (int j = 1; j < LOG; ++j) {\n        for (int i = 1; i <= n; ++i) {\n            up[i][j] = up[up[i][j-1]][j-1];\n        }\n    }\n\n    // Process each query\n    while (q--) {\n        int x, k;\n        cin >> x >> k;\n        int current = x;\n\n        for (int j = 0; j < LOG; ++j) {\n            if (k & (1 << j)) {\n                current = up[current][j];\n            }\n        }\n\n        cout << current << '\\n';\n    }\n\n    return 0;\n}",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.13132673043471116,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 67,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Planets Queries II",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> teleporter(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        cin >> teleporter[i];\n    }\n\n    // Process each query\n    while (q--) {\n        int a, b;\n        cin >> a >> b;\n\n        if (a == b) {\n            // If starting and destination planets are the same\n            cout << 0 << '\\n';\n            continue;\n        }\n\n        // BFS setup\n        vector<int> distance(n + 1, INT_MAX);\n        queue<int> q;\n        \n        distance[a] = 0;\n        q.push(a);\n\n        bool found = false;\n\n        while (!q.empty() && !found) {\n            int current = q.front();\n            q.pop();\n\n            int next = teleporter[current];\n            if (distance[next] == INT_MAX) {\n                distance[next] = distance[current] + 1;\n                q.push(next);\n                \n                if (next == b) {\n                    cout << distance[next] << '\\n';\n                    found = true;\n                    break;\n                }\n            }\n        }\n\n        if (!found) {\n            cout << -1 << '\\n';\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 15,
            "mean_time_taken": 0.5964686870574951,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                7,
                9,
                11,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 67,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Planets and Kingdoms",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nvoid dfs1(int v, vector<vector<int>>& adj, vector<bool>& visited, stack<int>& finishStack) {\n    visited[v] = true;\n    for (int u : adj[v]) {\n        if (!visited[u]) {\n            dfs1(u, adj, visited, finishStack);\n        }\n    }\n    finishStack.push(v);\n}\n\nvoid dfs2(int v, vector<vector<int>>& adjT, vector<bool>& visited, vector<int>& component, int label) {\n    visited[v] = true;\n    component[v] = label;\n    for (int u : adjT[v]) {\n        if (!visited[u]) {\n            dfs2(u, adjT, visited, component, label);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> adj(n + 1), adjT(n + 1);\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adjT[b].push_back(a);\n    }\n\n    stack<int> finishStack;\n    vector<bool> visited(n + 1, false);\n\n    for (int i = 1; i <= n; ++i) {\n        if (!visited[i]) {\n            dfs1(i, adj, visited, finishStack);\n        }\n    }\n\n    fill(visited.begin(), visited.end(), false);\n    vector<int> component(n + 1, 0);\n    int label = 0;\n\n    while (!finishStack.empty()) {\n        int v = finishStack.top();\n        finishStack.pop();\n        if (!visited[v]) {\n            ++label;\n            dfs2(v, adjT, visited, component, label);\n        }\n    }\n\n    cout << label << endl;\n    for (int i = 1; i <= n; ++i) {\n        cout << component[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.1623309850692749,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 68,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Playlist",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <unordered_set>\n#include <vector>\n\nint main() {\n    int n;\n    std::cin >> n;\n    std::vector<int> songs(n);\n\n    for (int i = 0; i < n; ++i) {\n        std::cin >> songs[i];\n    }\n\n    std::unordered_set<int> unique_songs;\n    int start = 0, longest = 0;\n\n    for (int end = 0; end < n; ++end) {\n        while (unique_songs.find(songs[end]) != unique_songs.end()) {\n            unique_songs.erase(songs[start]);\n            ++start;\n        }\n        unique_songs.insert(songs[end]);\n        longest = std::max(longest, end - start + 1);\n    }\n\n    std::cout << longest << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 19,
            "total_test_cases": 20,
            "mean_time_taken": 0.18373026847839355,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                ""
            ],
            "failed_test_cases": [
                1
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 68,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Point Location Test",
            "category": "Geometry",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n\n    while (t--) {\n        long long x1, y1, x2, y2, x3, y3;\n        cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\n        long long cross_product = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);\n\n        if (cross_product > 0) {\n            cout << \"LEFT\\n\";\n        } else if (cross_product < 0) {\n            cout << \"RIGHT\\n\";\n        } else {\n            cout << \"TOUCH\\n\";\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 6,
            "mean_time_taken": 0.11028492450714111,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 69,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Point in Polygon",
            "category": "Geometry",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if point (x, y) is on the segment (x1, y1) - (x2, y2)\nbool onSegment(long long x1, long long y1, long long x2, long long y2, long long x, long long y) {\n    if (x <= max(x1, x2) && x >= min(x1, x2) && y <= max(y1, y2) && y >= min(y1, y2))\n        return true;\n    return false;\n}\n\n// Function to find orientation of ordered triplet (p, q, r).\n// 0 -> p, q and r are collinear\n// 1 -> Clockwise\n// 2 -> Counterclockwise\nint orientation(long long px, long long py, long long qx, long long qy, long long rx, long long ry) {\n    long long val = (qy - py) * (rx - qx) - (qx - px) * (ry - qy);\n    if (val == 0) return 0; // collinear\n    return (val > 0) ? 1 : 2; // clock or counterclock wise\n}\n\n// Function to check if point (x, y) is inside the polygon\nstring isInsidePolygon(vector<pair<long long, long long>>& polygon, int n, long long x, long long y) {\n    if (n < 3) return \"OUTSIDE\"; // A polygon must have at least 3 vertices\n\n    pair<long long, long long> extreme = {INT_MAX, y};\n    int count = 0, i = 0;\n    do {\n        int next = (i + 1) % n;\n\n        if (onSegment(polygon[i].first, polygon[i].second, polygon[next].first, polygon[next].second, x, y))\n            return \"BOUNDARY\";\n\n        if (orientation(polygon[i].first, polygon[i].second, polygon[next].first, polygon[next].second, x, y) == 0 &&\n            onSegment(polygon[i].first, polygon[i].second, polygon[next].first, polygon[next].second, x, y))\n            return \"BOUNDARY\";\n\n        if (orientation(polygon[i].first, polygon[i].second, polygon[next].first, polygon[next].second, x, y) != \n            orientation(polygon[i].first, polygon[next].second, extreme.first, extreme.second, x, y))\n            count++;\n\n        i = next;\n    } while (i != 0);\n\n    return (count % 2 == 1) ? \"INSIDE\" : \"OUTSIDE\";\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<pair<long long, long long>> polygon(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> polygon[i].first >> polygon[i].second;\n    }\n\n    for (int i = 0; i < m; ++i) {\n        long long x, y;\n        cin >> x >> y;\n        cout << isInsidePolygon(polygon, n, x, y) << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 69,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Police Chase",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\nconst int MAXN = 500;\n\nvector<int> adj[MAXN + 1], capacity[MAXN + 1];\nvector<vector<int>> edges;\nint parent[MAXN + 1];\n\nint bfs(int s, int t) {\n    fill(parent, parent + MAXN + 1, -1);\n    parent[s] = s;\n    queue<pair<int, int>> q;\n    q.push({s, INF});\n    \n    while (!q.empty()) {\n        int cur = q.front().first;\n        int flow = q.front().second;\n        q.pop();\n        \n        for (int next : adj[cur]) {\n            if (parent[next] == -1 && capacity[cur][next] > 0) {\n                parent[next] = cur;\n                int new_flow = min(flow, capacity[cur][next]);\n                if (next == t)\n                    return new_flow;\n                q.push({next, new_flow});\n            }\n        }\n    }\n    return 0;\n}\n\nint edmonds_karp(int s, int t) {\n    int flow = 0;\n    int new_flow;\n    \n    while ((new_flow = bfs(s, t))) {\n        flow += new_flow;\n        int cur = t;\n        while (cur != s) {\n            int prev = parent[cur];\n            capacity[prev][cur] -= new_flow;\n            capacity[cur][prev] += new_flow;\n            cur = prev;\n        }\n    }\n    return flow;\n}\n\nvoid dfs(int s, vector<bool>& visited) {\n    visited[s] = true;\n    for (int next : adj[s]) {\n        if (!visited[next] && capacity[s][next] > 0) {\n            dfs(next, visited);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    capacity.assign(n + 1, vector<int>(n + 1, 0));\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        edges.push_back({a, b});\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n        capacity[a][b] = 1;\n        capacity[b][a] = 1;\n    }\n\n    int max_flow = edmonds_karp(1, n);\n\n    vector<bool> visited(n + 1, false);\n    dfs(1, visited);\n\n    vector<pair<int, int>> min_cut;\n\n    for (auto& edge : edges) {\n        int a = edge[0], b = edge[1];\n        if (visited[a] && !visited[b]) {\n            min_cut.push_back({a, b});\n        } else if (visited[b] && !visited[a]) {\n            min_cut.push_back({b, a});\n        }\n    }\n\n    cout << min_cut.size() << endl;\n    for (auto& edge : min_cut) {\n        cout << edge.first << \" \" << edge.second << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 69,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Polygon Area",
            "category": "Geometry",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<long long, long long>> vertices(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> vertices[i].first >> vertices[i].second;\n    }\n\n    long long area = 0;\n    for (int i = 0; i < n; ++i) {\n        long long x1 = vertices[i].first;\n        long long y1 = vertices[i].second;\n        long long x2 = vertices[(i + 1) % n].first;\n        long long y2 = vertices[(i + 1) % n].second;\n        area += x1 * y2 - y1 * x2;\n    }\n\n    cout << abs(area) << endl;\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 5,
            "mean_time_taken": 0.09499726295471192,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 70,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Polygon Lattice Points",
            "category": "Geometry",
            "solution": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Point {\n    ll x, y;\n};\n\n// Function to calculate the area using the Shoelace formula\nll polygonArea(const vector<Point>& points) {\n    ll area = 0;\n    int n = points.size();\n    for (int i = 0; i < n; ++i) {\n        int j = (i + 1) % n;\n        area += points[i].x * points[j].y;\n        area -= points[i].y * points[j].x;\n    }\n    return abs(area);\n}\n\n// Function to calculate the number of boundary points\nll boundaryPoints(const vector<Point>& points) {\n    ll boundary = 0;\n    int n = points.size();\n    for (int i = 0; i < n; ++i) {\n        int j = (i + 1) % n;\n        ll dx = abs(points[j].x - points[i].x);\n        ll dy = abs(points[j].y - points[i].y);\n        boundary += __gcd(dx, dy);\n    }\n    return boundary;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> points(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> points[i].x >> points[i].y;\n    }\n    \n    // Calculate area and boundary points\n    ll area = polygonArea(points);\n    ll boundary = boundaryPoints(points);\n    \n    // Using Pick's Theorem to calculate interior points\n    ll interior = (area - boundary) / 2 + 1;\n    \n    // Output the result\n    cout << interior << \" \" << boundary << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 5,
            "mean_time_taken": 0.09479551315307617,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 71,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Polynomial Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, q;\n    cin >> n >> q;\n\n    vector<long long> arr(n + 1, 0);\n    vector<long long> diff(n + 2, 0);\n\n    for (int i = 1; i <= n; ++i) {\n        cin >> arr[i];\n    }\n\n    while (q--) {\n        int type, a, b;\n        cin >> type >> a >> b;\n\n        if (type == 1) {\n            // Increase query: 1 a b\n            diff[a] += 1;\n            if (b + 1 <= n) diff[b + 1] -= (b - a + 2);\n        } else {\n            // Sum query: 2 a b\n            long long result = 0;\n            long long current_inc = 0;\n            for (int i = 1; i <= n; ++i) {\n                current_inc += diff[i];\n                arr[i] += current_inc;\n                if (i >= a && i <= b) {\n                    result += arr[i];\n                }\n            }\n            cout << result << '\\n';\n\n            // Reset the array to initial values by subtracting the same increments\n            current_inc = 0;\n            for (int i = 1; i <= n; ++i) {\n                current_inc += diff[i];\n                arr[i] -= current_inc;\n            }\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 0.724371592203776,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 71,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Prefix Sum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Node {\n    long long sum;\n    long long max_prefix_sum;\n    long long max_suffix_sum;\n    long long max_subarray_sum;\n};\n\nclass SegmentTree {\nprivate:\n    vector<Node> tree;\n    int n;\n\n    Node merge(Node a, Node b) {\n        Node res;\n        res.sum = a.sum + b.sum;\n        res.max_prefix_sum = max(a.max_prefix_sum, a.sum + b.max_prefix_sum);\n        res.max_suffix_sum = max(b.max_suffix_sum, b.sum + a.max_suffix_sum);\n        res.max_subarray_sum = max({a.max_subarray_sum, b.max_subarray_sum, a.max_suffix_sum + b.max_prefix_sum});\n        return res;\n    }\n\n    void build(vector<long long> &arr, int v, int tl, int tr) {\n        if (tl == tr) {\n            tree[v] = {arr[tl], arr[tl], arr[tl], arr[tl]};\n        } else {\n            int tm = (tl + tr) / 2;\n            build(arr, v*2, tl, tm);\n            build(arr, v*2+1, tm+1, tr);\n            tree[v] = merge(tree[v*2], tree[v*2+1]);\n        }\n    }\n\n    void update(int v, int tl, int tr, int pos, long long new_val) {\n        if (tl == tr) {\n            tree[v] = {new_val, new_val, new_val, new_val};\n        } else {\n            int tm = (tl + tr) / 2;\n            if (pos <= tm)\n                update(v*2, tl, tm, pos, new_val);\n            else\n                update(v*2+1, tm+1, tr, pos, new_val);\n            tree[v] = merge(tree[v*2], tree[v*2+1]);\n        }\n    }\n\n    Node query(int v, int tl, int tr, int l, int r) {\n        if (l > r)\n            return {-1e18, -1e18, -1e18, -1e18}; // Return a very negative value since it's max query\n        if (l == tl && r == tr)\n            return tree[v];\n        int tm = (tl + tr) / 2;\n        Node left_part = query(v*2, tl, tm, l, min(r, tm));\n        Node right_part = query(v*2+1, tm+1, tr, max(l, tm+1), r);\n        return merge(left_part, right_part);\n    }\n\npublic:\n    SegmentTree(vector<long long> &arr) {\n        n = arr.size();\n        tree.resize(4 * n);\n        build(arr, 1, 0, n-1);\n    }\n\n    void update(int pos, long long new_val) {\n        update(1, 0, n-1, pos, new_val);\n    }\n\n    long long max_prefix_sum(int l, int r) {\n        return query(1, 0, n-1, l, r).max_prefix_sum;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, q;\n    cin >> n >> q;\n    vector<long long> arr(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i];\n    }\n\n    SegmentTree segtree(arr);\n\n    while (q--) {\n        int type;\n        cin >> type;\n        if (type == 1) {\n            int k;\n            long long u;\n            cin >> k >> u;\n            --k; // 0-based index\n            segtree.update(k, u);\n        } else if (type == 2) {\n            int a, b;\n            cin >> a >> b;\n            --a; --b; // 0-based index\n            cout << segtree.max_prefix_sum(a, b) << '\\n';\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 71,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Prime Multiples",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to compute the greatest common divisor\nlong long gcd(long long a, long long b) {\n    while (b) {\n        a %= b;\n        swap(a, b);\n    }\n    return a;\n}\n\n// Function to compute the least common multiple\nlong long lcm(long long a, long long b) {\n    return a / gcd(a, b) * b;\n}\n\nint main() {\n    long long n;\n    int k;\n    cin >> n >> k;\n    vector<long long> primes(k);\n    for (int i = 0; i < k; ++i) {\n        cin >> primes[i];\n    }\n\n    long long count = 0;\n\n    // Iterate over all subsets of the prime numbers\n    for (int mask = 1; mask < (1 << k); ++mask) {\n        long long l = 1;\n        int bits = 0;\n\n        for (int i = 0; i < k; ++i) {\n            if (mask & (1 << i)) {\n                l = lcm(l, primes[i]);\n                if (l > n) break; // If LCM exceeds n, no need to continue (overflow avoidance)\n                ++bits;\n            }\n        }\n\n        if (l > n) continue;\n\n        if (bits % 2 == 1) {\n            count += n / l;  // Inclusion\n        } else {\n            count -= n / l;  // Exclusion\n        }\n    }\n\n    cout << count << endl;\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 5,
            "mean_time_taken": 0.19784183502197267,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 71,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Programmers and Artists",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int a, b, n;\n    cin >> a >> b >> n;\n    \n    vector<pair<int, int>> applicants(n);\n    \n    for (int i = 0; i < n; ++i) {\n        cin >> applicants[i].first >> applicants[i].second;\n    }\n    \n    // Sort applicants by programming skill in descending order\n    sort(applicants.begin(), applicants.end(), [](const pair<int, int> &a, const pair<int, int> &b) {\n        return a.first > b.first;\n    });\n    \n    // Get the sum of top 'a' programming skills\n    long long maxProgrammingSkillSum = 0;\n    for (int i = 0; i < a; ++i) {\n        maxProgrammingSkillSum += applicants[i].first;\n    }\n    \n    // Sort applicants by artistic skill in descending order\n    sort(applicants.begin(), applicants.end(), [](const pair<int, int> &a, const pair<int, int> &b) {\n        return a.second > b.second;\n    });\n    \n    // Get the sum of top 'b' artistic skills\n    long long maxArtisticSkillSum = 0;\n    for (int i = 0; i < b; ++i) {\n        maxArtisticSkillSum += applicants[i].second;\n    }\n    \n    // Sum of the maximum programming and artistic skills\n    long long maxSkillSum = maxProgrammingSkillSum + maxArtisticSkillSum;\n    \n    cout << maxSkillSum << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 11,
            "mean_time_taken": 0.13730372082103381,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 71,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Projects",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Project {\n    int start, end, reward;\n};\n\nbool compareByEnd(const Project &a, const Project &b) {\n    return a.end < b.end;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Project> projects(n);\n    \n    for (int i = 0; i < n; ++i) {\n        cin >> projects[i].start >> projects[i].end >> projects[i].reward;\n    }\n    \n    // Sort projects by their ending day\n    sort(projects.begin(), projects.end(), compareByEnd);\n    \n    vector<long long> dp(n);\n    dp[0] = projects[0].reward;\n    \n    for (int i = 1; i < n; ++i) {\n        // Include the current project\n        long long include = projects[i].reward;\n\n        // Find the last non-overlapping project using binary search\n        int low = 0, high = i - 1, lastNonOverlapping = -1;\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (projects[mid].end < projects[i].start) {\n                lastNonOverlapping = mid;\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n\n        if (lastNonOverlapping != -1) {\n            include += dp[lastNonOverlapping];\n        }\n\n        // Take the maximum of including or not including the current project\n        dp[i] = max(dp[i - 1], include);\n    }\n    \n    // The answer is the maximum reward obtainable\n    cout << dp[n - 1] << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.1707615852355957,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 72,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Pr\u00fcfer Code",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> pruferCode(n - 2);\n    for (int i = 0; i < n - 2; i++) {\n        cin >> pruferCode[i];\n    }\n\n    vector<int> degree(n + 1, 1); // degrees of nodes\n    for (int code : pruferCode) {\n        degree[code]++;\n    }\n\n    priority_queue<int, vector<int>, greater<int>> pq; // min-heap to track smallest leaves\n    for (int i = 1; i <= n; i++) {\n        if (degree[i] == 1) {\n            pq.push(i);\n        }\n    }\n\n    vector<pair<int, int>> edges;\n\n    for (int code : pruferCode) {\n        int leaf = pq.top();\n        pq.pop();\n\n        edges.push_back({leaf, code});\n\n        degree[leaf]--;\n        degree[code]--;\n\n        if (degree[code] == 1) {\n            pq.push(code);\n        }\n    }\n\n    // Two nodes with degree 1 will remain at the end\n    int u = pq.top(); pq.pop();\n    int v = pq.top(); pq.pop();\n    edges.push_back({u, v});\n\n    for (auto edge : edges) {\n        cout << edge.first << \" \" << edge.second << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 11,
            "mean_time_taken": 0.17681748216802423,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 72,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Pyramid Array",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint countSwapsToSort(vector<int>& arr, int start, int end, bool increasing) {\n    vector<int> subArr(arr.begin() + start, arr.begin() + end);\n    if (!increasing) {\n        sort(subArr.rbegin(), subArr.rend());\n    } else {\n        sort(subArr.begin(), subArr.end());\n    }\n    vector<int> posArr = subArr;\n    int swaps = 0;\n    \n    for (int i = start; i < end; ++i) {\n        auto it = find(posArr.begin(), posArr.end(), arr[i]);\n        swaps += it - posArr.begin();\n        posArr.erase(it);\n    }\n    \n    return swaps;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n\n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i];\n    }\n    \n    vector<int> sortedArr = arr;\n    sort(sortedArr.begin(), sortedArr.end());\n    \n    int medianIdx = n / 2;\n    int median = sortedArr[medianIdx];\n    \n    int leftSwaps = countSwapsToSort(arr, 0, medianIdx + 1, true);\n    int rightSwaps = countSwapsToSort(arr, medianIdx, n, false);\n    \n    int totalSwaps = leftSwaps + rightSwaps;\n    cout << totalSwaps << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 12,
            "mean_time_taken": 0.40655585130055744,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 72,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Range Queries and Copies",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, q;\n    cin >> n >> q;\n    \n    vector<vector<int>> arrays(1, vector<int>(n));\n    \n    for (int i = 0; i < n; ++i) {\n        cin >> arrays[0][i];\n    }\n\n    while (q--) {\n        int type;\n        cin >> type;\n\n        if (type == 1) {\n            int k, a, x;\n            cin >> k >> a >> x;\n            --k; --a;  // Convert to 0-based index\n            arrays[k][a] = x;\n        } else if (type == 2) {\n            int k, a, b;\n            cin >> k >> a >> b;\n            --k; --a; --b;  // Convert to 0-based index\n            long long sum = 0;\n            for (int i = a; i <= b; ++i) {\n                sum += arrays[k][i];\n            }\n            cout << sum << '\\n';\n        } else if (type == 3) {\n            int k;\n            cin >> k;\n            --k;  // Convert to 0-based index\n            arrays.push_back(arrays[k]);\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 7,
            "mean_time_taken": 0.21675539016723633,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                4,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 72,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Range Update Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> arr(n + 1), diff(n + 2, 0);\n    for (int i = 1; i <= n; ++i) {\n        cin >> arr[i];\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int type;\n        cin >> type;\n        if (type == 1) {\n            int a, b, u;\n            cin >> a >> b >> u;\n            diff[a] += u;\n            if (b + 1 <= n) {\n                diff[b + 1] -= u;\n            }\n        } else if (type == 2) {\n            int k;\n            cin >> k;\n            long long result = arr[k];\n            for (int j = 1; j <= k; ++j) {\n                result += diff[j];\n            }\n            cout << result << '\\n';\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 3,
            "mean_time_taken": 0.42127100626627606,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 72,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Range Updates and Sums",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAXN = 200005;\nlong long segtree[4 * MAXN], lazy_add[4 * MAXN], lazy_set[4 * MAXN];\nbool is_set[4 * MAXN];\n\nvoid build(vector<long long>& arr, int node, int start, int end) {\n    if (start == end) {\n        segtree[node] = arr[start];\n    } else {\n        int mid = (start + end) / 2;\n        build(arr, 2 * node, start, mid);\n        build(arr, 2 * node + 1, mid + 1, end);\n        segtree[node] = segtree[2 * node] + segtree[2 * node + 1];\n    }\n}\n\nvoid propagate(int node, int start, int end) {\n    if (is_set[node]) {\n        segtree[node] = (end - start + 1) * lazy_set[node];\n        if (start != end) {\n            is_set[2 * node] = is_set[2 * node + 1] = true;\n            lazy_set[2 * node] = lazy_set[2 * node + 1] = lazy_set[node];\n            lazy_add[2 * node] = lazy_add[2 * node + 1] = 0;\n        }\n        is_set[node] = false;\n    }\n    if (lazy_add[node] != 0) {\n        segtree[node] += (end - start + 1) * lazy_add[node];\n        if (start != end) {\n            lazy_add[2 * node] += lazy_add[node];\n            lazy_add[2 * node + 1] += lazy_add[node];\n        }\n        lazy_add[node] = 0;\n    }\n}\n\nvoid update_add(int node, int start, int end, int l, int r, long long val) {\n    propagate(node, start, end);\n    if (start > r || end < l) return;\n    if (start >= l && end <= r) {\n        lazy_add[node] += val;\n        propagate(node, start, end);\n        return;\n    }\n    int mid = (start + end) / 2;\n    update_add(2 * node, start, mid, l, r, val);\n    update_add(2 * node + 1, mid + 1, end, l, r, val);\n    segtree[node] = segtree[2 * node] + segtree[2 * node + 1];\n}\n\nvoid update_set(int node, int start, int end, int l, int r, long long val) {\n    propagate(node, start, end);\n    if (start > r || end < l) return;\n    if (start >= l && end <= r) {\n        is_set[node] = true;\n        lazy_set[node] = val;\n        lazy_add[node] = 0;\n        propagate(node, start, end);\n        return;\n    }\n    int mid = (start + end) / 2;\n    update_set(2 * node, start, mid, l, r, val);\n    update_set(2 * node + 1, mid + 1, end, l, r, val);\n    segtree[node] = segtree[2 * node] + segtree[2 * node + 1];\n}\n\nlong long query(int node, int start, int end, int l, int r) {\n    propagate(node, start, end);\n    if (start > r || end < l) return 0;\n    if (start >= l && end <= r) return segtree[node];\n    int mid = (start + end) / 2;\n    long long p1 = query(2 * node, start, mid, l, r);\n    long long p2 = query(2 * node + 1, mid + 1, end, l, r);\n    return p1 + p2;\n}\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    vector<long long> arr(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i];\n    }\n    \n    build(arr, 1, 0, n - 1);\n    \n    while (q--) {\n        int type, a, b;\n        cin >> type >> a >> b;\n        if (type == 1) {\n            long long x;\n            cin >> x;\n            update_add(1, 0, n - 1, a - 1, b - 1, x);\n        } else if (type == 2) {\n            long long x;\n            cin >> x;\n            update_set(1, 0, n - 1, a - 1, b - 1, x);\n        } else if (type == 3) {\n            cout << query(1, 0, n - 1, a - 1, b - 1) << endl;\n        }\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 4,
            "mean_time_taken": 0.24758481979370117,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 73,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Range Xor Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    \n    vector<int> arr(n + 1, 0);\n    vector<int> prefixXor(n + 1, 0);\n\n    for (int i = 1; i <= n; ++i) {\n        cin >> arr[i];\n        prefixXor[i] = prefixXor[i - 1] ^ arr[i];\n    }\n\n    while (q--) {\n        int a, b;\n        cin >> a >> b;\n        int result = prefixXor[b] ^ prefixXor[a - 1];\n        cout << result << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 2,
            "mean_time_taken": 0.1702275276184082,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 74,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Reachability Queries",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nconst int MAXN = 50000;\n\nvector<int> adj[MAXN + 1];\nbool reachable[MAXN + 1][MAXN + 1];\nbool visited[MAXN + 1];\n\nvoid dfs(int start) {\n    stack<int> stk;\n    stk.push(start);\n    visited[start] = true;\n    reachable[start][start] = true;\n\n    while (!stk.empty()) {\n        int node = stk.top();\n        stk.pop();\n\n        for (int neighbor : adj[node]) {\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                stk.push(neighbor);\n            }\n            reachable[start][neighbor] = true;\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m, q;\n    cin >> n >> m >> q;\n\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        fill(visited, visited + n + 1, false);\n        dfs(i);\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int a, b;\n        cin >> a >> b;\n        if (reachable[a][b]) {\n            cout << \"YES\\n\";\n        } else {\n            cout << \"NO\\n\";\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 74,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Reachable Nodes",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nvoid dfs(int node, const vector<vector<int>>& adj, vector<bool>& visited, stack<int>& topoStack) {\n    visited[node] = true;\n    for (int neighbor : adj[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, adj, visited, topoStack);\n        }\n    }\n    topoStack.push(node);\n}\n\nvoid countReachableNodes(int node, const vector<vector<int>>& adj, vector<int>& reachableCount, vector<int>& dp) {\n    if (dp[node] != -1) {\n        return;\n    }\n    \n    int count = 1; // count itself\n    for (int neighbor : adj[node]) {\n        countReachableNodes(neighbor, adj, reachableCount, dp);\n        count += dp[neighbor];\n    }\n    dp[node] = count;\n    reachableCount[node] = count;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<vector<int>> adj(n + 1);\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n    \n    stack<int> topoStack;\n    vector<bool> visited(n + 1, false);\n    \n    // Perform topological sorting\n    for (int i = 1; i <= n; ++i) {\n        if (!visited[i]) {\n            dfs(i, adj, visited, topoStack);\n        }\n    }\n    \n    vector<int> reachableCount(n + 1, 0);\n    vector<int> dp(n + 1, -1); // dp[node] will store the count of reachable nodes from `node`\n    \n    // Calculate reachable nodes using topologically sorted order\n    while (!topoStack.empty()) {\n        int node = topoStack.top();\n        topoStack.pop();\n        if (dp[node] == -1) {\n            countReachableNodes(node, adj, reachableCount, dp);\n        }\n    }\n    \n    for (int i = 1; i <= n; ++i) {\n        cout << reachableCount[i] << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 4,
            "mean_time_taken": 0.12700670957565308,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 74,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Reading Books",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric> // For accumulate\n\nint main() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> times(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> times[i];\n    }\n    \n    long long total_sum = std::accumulate(times.begin(), times.end(), 0LL);\n    int max_time = *std::max_element(times.begin(), times.end());\n    \n    // The minimum total time will be the larger of total_sum or 2 * max_time\n    long long min_total_time = std::max(total_sum, 2LL * max_time);\n    \n    std::cout << min_total_time << std::endl;\n    \n    return 0;\n}",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.09772562980651855,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 75,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Rectangle Cutting",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n\n    vector<vector<int>> dp(501, vector<int>(501, INT_MAX));\n\n    // Base case: no cuts needed for squares\n    for (int i = 1; i <= 500; ++i) {\n        dp[i][i] = 0;\n    }\n\n    // Fill the DP table\n    for (int i = 1; i <= 500; ++i) {\n        for (int j = 1; j <= 500; ++j) {\n            if (i != j) {\n                // Horizontal cuts\n                for (int k = 1; k < i; ++k) {\n                    dp[i][j] = min(dp[i][j], dp[k][j] + dp[i - k][j] + 1);\n                }\n                // Vertical cuts\n                for (int k = 1; k < j; ++k) {\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[i][j - k] + 1);\n                }\n            }\n        }\n    }\n\n    cout << dp[a][b] << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 75,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Removal Game",
            "category": "Dynamic Programming",
            "solution": "dp[i][j] = max(x[i] + (total_sum from x[i+1] to x[j]) - dp[i+1][j],\n                  x[j] + (total_sum from x[i] to x[j-1]) - dp[i][j-1])",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 75,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Removing Digits",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint minSteps(int n) {\n    vector<int> dp(n + 1, 1e6); // Initialize dp array with a large number\n    dp[0] = 0; // Base case: 0 steps to reduce 0 to 0\n    \n    for (int i = 1; i <= n; ++i) {\n        int current = i;\n        while (current > 0) {\n            int digit = current % 10;\n            current /= 10;\n            if (digit != 0) {\n                dp[i] = min(dp[i], dp[i - digit] + 1);\n            }\n        }\n    }\n    \n    return dp[n];\n}\n\nint main() {\n    int n;\n    cin >> n;\n    cout << minSteps(n) << endl;\n    return 0;\n}",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.10230193819318499,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 76,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Removing Digits II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint minStepsToZero(long long n) {\n    vector<int> dp(n + 1, INT_MAX);\n    dp[0] = 0;\n\n    for (long long i = 1; i <= n; ++i) {\n        string s = to_string(i);\n        for (char c : s) {\n            int digit = c - '0';\n            if (i - digit >= 0) {\n                dp[i] = min(dp[i], dp[i - digit] + 1);\n            }\n        }\n    }\n\n    return dp[n];\n}\n\nint main() {\n    long long n;\n    cin >> n;\n    cout << minStepsToZero(n) << endl;\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 9,
            "mean_time_taken": 0.21969283951653373,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                5,
                7,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 76,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Repeating Substring",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n// Function to build the suffix array\nvector<int> buildSuffixArray(const string &s) {\n    int n = s.length();\n    vector<int> suffixArr(n), rank(n), temp(n);\n    for (int i = 0; i < n; ++i) {\n        suffixArr[i] = i;\n        rank[i] = s[i];\n    }\n    for (int k = 1; k < n; k *= 2) {\n        auto cmp = [&](int a, int b) {\n            if (rank[a] != rank[b]) return rank[a] < rank[b];\n            int ra = (a + k < n) ? rank[a + k] : -1;\n            int rb = (b + k < n) ? rank[b + k] : -1;\n            return ra < rb;\n        };\n        sort(suffixArr.begin(), suffixArr.end(), cmp);\n        temp[suffixArr[0]] = 0;\n        for (int i = 1; i < n; ++i) {\n            temp[suffixArr[i]] = temp[suffixArr[i - 1]] + cmp(suffixArr[i - 1], suffixArr[i]);\n        }\n        rank = temp;\n    }\n    return suffixArr;\n}\n\n// Function to build the LCP array\nvector<int> buildLCPArray(const string &s, const vector<int> &suffixArr) {\n    int n = s.length();\n    vector<int> lcp(n), rank(n);\n    for (int i = 0; i < n; ++i) rank[suffixArr[i]] = i;\n    int h = 0;\n    for (int i = 0; i < n; ++i) {\n        if (rank[i] > 0) {\n            int j = suffixArr[rank[i] - 1];\n            while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;\n            lcp[rank[i]] = h;\n            if (h > 0) --h;\n        }\n    }\n    return lcp;\n}\n\n// Function to find the longest repeating substring\nstring longestRepeatingSubstring(const string &s) {\n    int n = s.length();\n    if (n == 0) return \"-1\";\n    vector<int> suffixArr = buildSuffixArray(s);\n    vector<int> lcp = buildLCPArray(s, suffixArr);\n    int maxLength = 0, index = -1;\n    for (int i = 1; i < n; ++i) {\n        if (lcp[i] > maxLength) {\n            maxLength = lcp[i];\n            index = suffixArr[i];\n        }\n    }\n    return (maxLength > 0) ? s.substr(index, maxLength) : \"-1\";\n}\n\nint main() {\n    string s;\n    cin >> s;\n    cout << longestRepeatingSubstring(s) << endl;\n    return 0;\n}",
            "passed_test_cases": 8,
            "total_test_cases": 8,
            "mean_time_taken": 0.44770270586013794,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 77,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Repetitions",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nint main() {\n    std::string dna;\n    std::cin >> dna;\n\n    int n = dna.length();\n    if (n == 0) {\n        std::cout << 0 << std::endl;\n        return 0;\n    }\n\n    int maxLength = 1; // At least every character repeats once\n    int currentLength = 1;\n\n    for (int i = 1; i < n; ++i) {\n        if (dna[i] == dna[i - 1]) {\n            currentLength++;\n        } else {\n            maxLength = std::max(maxLength, currentLength);\n            currentLength = 1;\n        }\n    }\n\n    // Check the last repetition sequence\n    maxLength = std::max(maxLength, currentLength);\n\n    std::cout << maxLength << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.10223825772603352,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 78,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Required Substring",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n;\n    std::string pattern;\n    std::cin >> n >> pattern;\n    int m = pattern.length();\n\n    // dp[i][j] represents the number of ways to form a string of length i\n    // which matches the first j characters of the pattern\n    std::vector<std::vector<long long>> dp(n + 1, std::vector<long long>(m + 1, 0));\n\n    // Base case: dp[i][0] = 26^i (all strings of length i that don't need to match any part of the pattern)\n    for (int i = 0; i <= n; ++i) {\n        dp[i][0] = 1;\n        for (int j = 1; j <= i; ++j) {\n            dp[i][0] = dp[i][0] * 26 % MOD;\n        }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            // If the current character of the pattern matches, carry forward the previous state\n            if (pattern[j - 1] == pattern[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            }\n\n            // Add the number of ways to make a string of length i by placing any character at the end\n            // but only if it's not yet matching the current character of the pattern\n            dp[i][j] = (dp[i][j] + dp[i - 1][j] * 25) % MOD;\n        }\n    }\n\n    // Summing up all dp[n][j] where j varies from 0 to m\n    long long result = 0;\n    for (int j = 0; j <= m; ++j) {\n        result = (result + dp[n][j]) % MOD;\n    }\n\n    std::cout << result << std::endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 19,
            "mean_time_taken": 0.09346306951422441,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 78,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Restaurant Customers",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<int, int>> events;\n\n    for (int i = 0; i < n; ++i) {\n        int a, b;\n        cin >> a >> b;\n        events.push_back({a, 1});  // arrival event\n        events.push_back({b, -1}); // departure event\n    }\n\n    // Sort events; if times are same, departure (-1) comes before arrival (+1)\n    sort(events.begin(), events.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        if (a.first == b.first) return a.second < b.second;\n        return a.first < b.first;\n    });\n\n    int current_customers = 0;\n    int max_customers = 0;\n\n    // Process events\n    for (const auto& event : events) {\n        current_customers += event.second;\n        max_customers = max(max_customers, current_customers);\n    }\n\n    cout << max_customers << endl;\n\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.16382842063903807,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 79,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Reversal Sorting",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to reverse a subarray from start index to end index\nvoid reverseSubarray(vector<int>& arr, int start, int end) {\n    while (start < end) {\n        swap(arr[start], arr[end]);\n        start++;\n        end--;\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    vector<pair<int, int>> reversals;\n\n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i];\n    }\n\n    for (int i = 0; i < n; ++i) {\n        // Find the position where the current element should be\n        if (arr[i] != i + 1) {\n            int correct_pos = find(arr.begin(), arr.end(), i + 1) - arr.begin();\n            // Reverse the subarray to place the element in the correct position\n            reverseSubarray(arr, i, correct_pos);\n            reversals.push_back({i + 1, correct_pos + 1}); // 1-based index\n        }\n    }\n\n    // Output the number of reversals\n    cout << reversals.size() << endl;\n    // Output each reversal\n    for (const auto& p : reversals) {\n        cout << p.first << \" \" << p.second << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 12,
            "mean_time_taken": 0.2507524887720744,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 79,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Reversals and Sums",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct SegmentTree {\n    int n;\n    vector<long long> tree, lazy;\n    vector<bool> to_reverse;\n\n    SegmentTree(const vector<int>& arr) {\n        n = arr.size();\n        tree.resize(4 * n);\n        lazy.resize(4 * n);\n        to_reverse.resize(4 * n, false);\n        build(arr, 0, 0, n - 1);\n    }\n\n    void build(const vector<int>& arr, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = arr[start];\n        } else {\n            int mid = (start + end) / 2;\n            build(arr, 2 * node + 1, start, mid);\n            build(arr, 2 * node + 2, mid + 1, end);\n            tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n        }\n    }\n\n    void propagate(int node, int start, int end) {\n        if (to_reverse[node]) {\n            tree[node] = end - start + 1 - tree[node];\n            if (start != end) {\n                to_reverse[2 * node + 1] = !to_reverse[2 * node + 1];\n                to_reverse[2 * node + 2] = !to_reverse[2 * node + 2];\n            }\n            to_reverse[node] = false;\n        }\n    }\n\n    void updateRange(int node, int start, int end, int l, int r) {\n        propagate(node, start, end);\n        if (start > end or start > r or end < l) {\n            return;\n        }\n        if (start >= l and end <= r) {\n            to_reverse[node] = !to_reverse[node];\n            propagate(node, start, end);\n            return;\n        }\n        int mid = (start + end) / 2;\n        updateRange(2 * node + 1, start, mid, l, r);\n        updateRange(2 * node + 2, mid + 1, end, l, r);\n        tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n    }\n\n    long long queryRange(int node, int start, int end, int l, int r) {\n        propagate(node, start, end);\n        if (start > end or start > r or end < l) {\n            return 0;\n        }\n        if (start >= l and end <= r) {\n            return tree[node];\n        }\n        int mid = (start + end) / 2;\n        long long left = queryRange(2 * node + 1, start, mid, l, r);\n        long long right = queryRange(2 * node + 2, mid + 1, end, l, r);\n        return left + right;\n    }\n\n    void updateRange(int l, int r) {\n        updateRange(0, 0, n - 1, l, r);\n    }\n\n    long long queryRange(int l, int r) {\n        return queryRange(0, 0, n - 1, l, r);\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> arr(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i];\n    }\n\n    SegmentTree segTree(arr);\n\n    for (int i = 0; i < m; ++i) {\n        int t, a, b;\n        cin >> t >> a >> b;\n        if (t == 1) {\n            segTree.updateRange(a - 1, b - 1);\n        } else if (t == 2) {\n            cout << segTree.queryRange(a - 1, b - 1) << endl;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.49685806035995483,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 79,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Road Construction",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass UnionFind {\npublic:\n    UnionFind(int n) : parent(n + 1), size(n + 1, 1), numComponents(n), largestComponentSize(1) {\n        for (int i = 1; i <= n; ++i) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int a) {\n        if (parent[a] != a) {\n            parent[a] = find(parent[a]);\n        }\n        return parent[a];\n    }\n\n    void unite(int a, int b) {\n        int rootA = find(a);\n        int rootB = find(b);\n        if (rootA != rootB) {\n            if (size[rootA] < size[rootB]) {\n                swap(rootA, rootB);\n            }\n            parent[rootB] = rootA;\n            size[rootA] += size[rootB];\n            largestComponentSize = max(largestComponentSize, size[rootA]);\n            --numComponents;\n        }\n    }\n\n    int getNumComponents() const {\n        return numComponents;\n    }\n\n    int getLargestComponentSize() const {\n        return largestComponentSize;\n    }\n\nprivate:\n    vector<int> parent;\n    vector<int> size;\n    int numComponents;\n    int largestComponentSize;\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    UnionFind uf(n);\n\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        uf.unite(a, b);\n        cout << uf.getNumComponents() << \" \" << uf.getLargestComponentSize() << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 8,
            "total_test_cases": 8,
            "mean_time_taken": 0.13660359382629395,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 80,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Road Reparation",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n    int u, v, cost;\n    bool operator<(const Edge& other) const {\n        return cost < other.cost;\n    }\n};\n\nvector<int> parent, rank;\n\nint find(int v) {\n    if (parent[v] == v) return v;\n    return parent[v] = find(parent[v]);\n}\n\nvoid unite(int a, int b) {\n    a = find(a);\n    b = find(b);\n    if (a != b) {\n        if (rank[a] < rank[b]) swap(a, b);\n        parent[b] = a;\n        if (rank[a] == rank[b]) rank[a]++;\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<Edge> edges(m);\n    for (int i = 0; i < m; i++) {\n        cin >> edges[i].u >> edges[i].v >> edges[i].cost;\n    }\n    \n    sort(edges.begin(), edges.end());\n    \n    parent.resize(n + 1);\n    rank.resize(n + 1, 0);\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n    }\n    \n    int total_cost = 0;\n    int edges_used = 0;\n    \n    for (const auto& edge : edges) {\n        if (find(edge.u) != find(edge.v)) {\n            unite(edge.u, edge.v);\n            total_cost += edge.cost;\n            edges_used++;\n            if (edges_used == n - 1) break;\n        }\n    }\n    \n    if (edges_used == n - 1) {\n        cout << total_cost << endl;\n    } else {\n        cout << \"IMPOSSIBLE\" << endl;\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 80,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Robot Path",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<char, int>> commands(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> commands[i].first >> commands[i].second;\n    }\n\n    set<pair<int, int>> visited;\n    int x = 0, y = 0;\n    visited.insert({x, y});\n    int totalDistance = 0;\n\n    for (const auto& command : commands) {\n        char direction = command.first;\n        int distance = command.second;\n        for (int i = 0; i < distance; ++i) {\n            if (direction == 'U') ++y;\n            else if (direction == 'D') --y;\n            else if (direction == 'L') --x;\n            else if (direction == 'R') ++x;\n\n            totalDistance++;\n            if (visited.count({x, y})) {\n                cout << totalDistance << endl;\n                return 0;\n            }\n            visited.insert({x, y});\n        }\n    }\n\n    cout << totalDistance << endl;\n    return 0;\n}",
            "passed_test_cases": 21,
            "total_test_cases": 35,
            "mean_time_taken": 0.3977997166769845,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                4,
                6,
                7,
                8,
                10,
                18,
                23,
                26,
                28,
                29,
                30,
                33,
                35
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 80,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Room Allocation",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Customer {\n    int arrival, departure, index;\n};\n\nbool compareCustomers(const Customer &a, const Customer &b) {\n    return a.arrival < b.arrival;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<Customer> customers(n);\n    \n    for (int i = 0; i < n; ++i) {\n        cin >> customers[i].arrival >> customers[i].departure;\n        customers[i].index = i;\n    }\n    \n    sort(customers.begin(), customers.end(), compareCustomers);\n    \n    // Priority queue to store the room end times and room index\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    \n    vector<int> roomAssignment(n);\n    int roomCount = 0;\n    \n    for (const auto &cust : customers) {\n        if (!pq.empty() && pq.top().first < cust.arrival) {\n            // Reuse the earliest available room\n            int roomId = pq.top().second;\n            pq.pop();\n            pq.push({cust.departure, roomId});\n            roomAssignment[cust.index] = roomId;\n        } else {\n            // Allocate a new room\n            roomCount++;\n            pq.push({cust.departure, roomCount});\n            roomAssignment[cust.index] = roomCount;\n        }\n    }\n    \n    cout << roomCount << endl;\n    for (const int &room : roomAssignment) {\n        cout << room << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 12,
            "mean_time_taken": 0.19270322720209757,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 80,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Round Trip",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 100005;\n\nvector<int> adj[MAXN];\nbool visited[MAXN];\nint parent[MAXN];\nint start = -1, end = -1;\n\nbool dfs(int v, int par) {\n    visited[v] = true;\n    parent[v] = par;\n    for (int u : adj[v]) {\n        if (u == par) continue;  // Skip the edge to the parent\n        if (visited[u]) {\n            start = u;\n            end = v;\n            return true;\n        }\n        parent[u] = v;\n        if (dfs(u, v)) return true;\n    }\n    return false;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    fill(visited, visited + n + 1, false);\n    fill(parent, parent + n + 1, -1);\n\n    for (int i = 1; i <= n; ++i) {\n        if (!visited[i] && dfs(i, -1)) break;\n    }\n\n    if (start == -1) {\n        cout << \"IMPOSSIBLE\" << endl;\n    } else {\n        vector<int> cycle;\n        for (int v = end; v != start; v = parent[v]) {\n            cycle.push_back(v);\n        }\n        cycle.push_back(start);\n        cycle.push_back(end);\n        reverse(cycle.begin(), cycle.end());\n        \n        cout << cycle.size() << endl;\n        for (int v : cycle) {\n            cout << v << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 80,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Round Trip II",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<int> state, parent;\nvector<int> cycle;\nint cycle_start, cycle_end;\n\nbool dfs(int v) {\n    state[v] = 1; // mark the node as visiting\n    for (int u : adj[v]) {\n        if (state[u] == 0) {\n            parent[u] = v;\n            if (dfs(u)) return true;\n        } else if (state[u] == 1) {\n            cycle_end = v;\n            cycle_start = u;\n            return true;\n        }\n    }\n    state[v] = 2; // mark the node as visited\n    return false;\n}\n\nvoid find_cycle(int n) {\n    state.assign(n, 0);\n    parent.assign(n, -1);\n    cycle_start = -1;\n\n    for (int v = 0; v < n; ++v) {\n        if (state[v] == 0 && dfs(v))\n            break;\n    }\n\n    if (cycle_start == -1) {\n        cout << \"IMPOSSIBLE\\n\";\n    } else {\n        cycle.push_back(cycle_start);\n        for (int v = cycle_end; v != cycle_start; v = parent[v])\n            cycle.push_back(v);\n        cycle.push_back(cycle_start);\n        reverse(cycle.begin(), cycle.end());\n\n        cout << cycle.size() << '\\n';\n        for (int v : cycle)\n            cout << v + 1 << ' ';\n        cout << '\\n';\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n\n    adj.resize(n);\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a - 1].push_back(b - 1);\n    }\n\n    find_cycle(n);\n\n    return 0;\n}",
            "passed_test_cases": 19,
            "total_test_cases": 20,
            "mean_time_taken": 0.10293779373168946,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                ""
            ],
            "failed_test_cases": [
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 80,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Salary Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nclass FenwickTree {\npublic:\n    FenwickTree(int n) : bit(n + 1, 0), N(n) {}\n\n    void update(int idx, int delta) {\n        while (idx <= N) {\n            bit[idx] += delta;\n            idx += idx & -idx;\n        }\n    }\n\n    int query(int idx) {\n        int sum = 0;\n        while (idx > 0) {\n            sum += bit[idx];\n            idx -= idx & -idx;\n        }\n        return sum;\n    }\n\n    int range_query(int l, int r) {\n        return query(r) - query(l - 1);\n    }\n\nprivate:\n    vector<int> bit;\n    int N;\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> salaries(n + 1);\n    map<int, int> salary_count;\n    for (int i = 1; i <= n; ++i) {\n        cin >> salaries[i];\n        salary_count[salaries[i]]++;\n    }\n\n    vector<pair<char, pair<int, int>>> queries(q);\n    for (int i = 0; i < q; ++i) {\n        char type;\n        int a, b;\n        cin >> type >> a >> b;\n        queries[i] = {type, {a, b}};\n    }\n\n    vector<int> all_salaries;\n    for (const auto& [salary, _] : salary_count) {\n        all_salaries.push_back(salary);\n    }\n\n    sort(all_salaries.begin(), all_salaries.end());\n    all_salaries.erase(unique(all_salaries.begin(), all_salaries.end()), all_salaries.end());\n\n    auto get_index = [&](int value) {\n        return lower_bound(all_salaries.begin(), all_salaries.end(), value) - all_salaries.begin() + 1;\n    };\n\n    FenwickTree fenwick(all_salaries.size());\n\n    for (const auto& [salary, count] : salary_count) {\n        fenwick.update(get_index(salary), count);\n    }\n\n    for (const auto& [type, params] : queries) {\n        if (type == '!') {\n            int k = params.first;\n            int new_salary = params.second;\n            int old_salary = salaries[k];\n\n            if (old_salary != new_salary) {\n                fenwick.update(get_index(old_salary), -1);\n                fenwick.update(get_index(new_salary), 1);\n                salaries[k] = new_salary;\n            }\n        } else if (type == '?') {\n            int a = params.first;\n            int b = params.second;\n            int left_idx = get_index(a);\n            int right_idx = get_index(b + 1) - 1;\n\n            if (left_idx > right_idx) {\n                cout << 0 << '\\n';\n            } else {\n                cout << fenwick.range_query(left_idx, right_idx) << '\\n';\n            }\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 9,
            "total_test_cases": 13,
            "mean_time_taken": 0.2640405985025259,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                6,
                8,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 80,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "School Dance",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAXN = 501;\n\nvector<int> adj[MAXN];\nint pairU[MAXN], pairV[MAXN], dist[MAXN];\nint n, m, k;\n\nbool bfs() {\n    queue<int> Q;\n    for (int u = 1; u <= n; ++u) {\n        if (pairU[u] == 0) {\n            dist[u] = 0;\n            Q.push(u);\n        } else {\n            dist[u] = INT_MAX;\n        }\n    }\n    dist[0] = INT_MAX;\n    while (!Q.empty()) {\n        int u = Q.front();\n        Q.pop();\n        if (dist[u] < dist[0]) {\n            for (int v : adj[u]) {\n                if (dist[pairV[v]] == INT_MAX) {\n                    dist[pairV[v]] = dist[u] + 1;\n                    Q.push(pairV[v]);\n                }\n            }\n        }\n    }\n    return dist[0] != INT_MAX;\n}\n\nbool dfs(int u) {\n    if (u != 0) {\n        for (int v : adj[u]) {\n            if (dist[pairV[v]] == dist[u] + 1 && dfs(pairV[v])) {\n                pairV[v] = u;\n                pairU[u] = v;\n                return true;\n            }\n        }\n        dist[u] = INT_MAX;\n        return false;\n    }\n    return true;\n}\n\nint hopcroftKarp() {\n    memset(pairU, 0, sizeof(pairU));\n    memset(pairV, 0, sizeof(pairV));\n    int matching = 0;\n    while (bfs()) {\n        for (int u = 1; u <= n; ++u) {\n            if (pairU[u] == 0 && dfs(u)) {\n                matching++;\n            }\n        }\n    }\n    return matching;\n}\n\nint main() {\n    cin >> n >> m >> k;\n    for (int i = 0; i < k; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n\n    int maxPairs = hopcroftKarp();\n    cout << maxPairs << endl;\n    for (int u = 1; u <= n; ++u) {\n        if (pairU[u] != 0) {\n            cout << u << \" \" << pairU[u] << endl;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 80,
            "passed": false,
            "shot": 1
        },
        {
            "title": "School Excursion",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to perform DFS and find the size of each connected component\nvoid dfs(int node, vector<vector<int>>& adj, vector<bool>& visited, int& size) {\n    visited[node] = true;\n    size++;\n    for (int neighbor : adj[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, adj, visited, size);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> adj(n + 1);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    vector<bool> visited(n + 1, false);\n    vector<int> component_sizes;\n\n    // Find all connected components and their sizes\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            int size = 0;\n            dfs(i, adj, visited, size);\n            component_sizes.push_back(size);\n        }\n    }\n\n    // Use dynamic programming to find all possible sums of component sizes\n    bitset<100001> possible;\n    possible[0] = 1; // We can always have 0 children visiting Korkeasaari\n\n    for (int size : component_sizes) {\n        possible |= (possible << size);\n    }\n\n    // Output the result as a bit string\n    for (int i = 1; i <= n; i++) {\n        cout << possible[i];\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 13,
            "mean_time_taken": 0.21923978512103742,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                ""
            ],
            "failed_test_cases": [
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 80,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Shortest Routes I",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nconst long long INF = numeric_limits<long long>::max();\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<pair<int, long long>>> adj(n + 1);\n\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        long long c;\n        cin >> a >> b >> c;\n        adj[a].emplace_back(b, c);\n    }\n\n    vector<long long> dist(n + 1, INF);\n    dist[1] = 0;\n\n    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\n    pq.emplace(0, 1);\n\n    while (!pq.empty()) {\n        auto [d, u] = pq.top();\n        pq.pop();\n\n        if (d != dist[u]) continue;\n\n        for (auto &[v, weight] : adj[u]) {\n            if (dist[u] + weight < dist[v]) {\n                dist[v] = dist[u] + weight;\n                pq.emplace(dist[v], v);\n            }\n        }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        cout << dist[i] << \" \";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 23,
            "total_test_cases": 23,
            "mean_time_taken": 0.1947022417317266,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 81,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Shortest Routes II",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nconst long long INF = LLONG_MAX;\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n\n    // Initialize distance matrix\n    vector<vector<long long>> dist(n + 1, vector<long long>(n + 1, INF));\n\n    // Distance to self is zero\n    for (int i = 1; i <= n; ++i) {\n        dist[i][i] = 0;\n    }\n\n    // Read roads and update distance matrix\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        long long c;\n        cin >> a >> b >> c;\n        dist[a][b] = min(dist[a][b], c);\n        dist[b][a] = min(dist[b][a], c);\n    }\n\n    // Floyd-Warshall algorithm\n    for (int k = 1; k <= n; ++k) {\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                if (dist[i][k] < INF && dist[k][j] < INF) {\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n    }\n\n    // Process queries\n    for (int i = 0; i < q; ++i) {\n        int a, b;\n        cin >> a >> b;\n        if (dist[a][b] == INF) {\n            cout << -1 << endl;\n        } else {\n            cout << dist[a][b] << endl;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 15,
            "mean_time_taken": 0.6214209397633871,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                7,
                13,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 81,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Shortest Subsequence",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n\n// Function to generate all subsequences of length `k`\nvoid generateSubsequences(const string &s, int k, unordered_set<string> &subsequences) {\n    int n = s.size();\n    if (k > n) return;\n\n    // Use a sliding window to generate all subsequences of length `k`\n    for (int i = 0; i <= n - k; ++i) {\n        subsequences.insert(s.substr(i, k));\n    }\n}\n\nstring findShortestMissingSubsequence(const string &s) {\n    // All characters in the DNA\n    vector<char> dna_chars = {'A', 'C', 'G', 'T'};\n    \n    // Check for lengths from 1 to 3\n    for (int length = 1; length <= 3; ++length) {\n        unordered_set<string> subsequences;\n        \n        // Generate all subsequences of the given length\n        generateSubsequences(s, length, subsequences);\n        \n        // Generate all possible sequences of the given length and check if they are missing\n        string current(length, 'A');\n        while (true) {\n            // Check if the current sequence is missing\n            if (subsequences.find(current) == subsequences.end()) {\n                return current;\n            }\n            \n            // Generate the next sequence lexicographically\n            int pos = length - 1;\n            while (pos >= 0 && current[pos] == 'T') {\n                current[pos] = 'A';\n                --pos;\n            }\n            if (pos < 0) break;\n            current[pos] = dna_chars[dna_chars.find(current[pos]) + 1];\n        }\n    }\n    return \"\"; // Should never reach here because a solution always exists\n}\n\nint main() {\n    string s;\n    cin >> s;\n    cout << findShortestMissingSubsequence(s) << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 81,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Signal Processing",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n\nint main() {\n    int n, m;\n    std::cin >> n >> m;\n    \n    std::vector<int> signal(n);\n    std::vector<int> mask(m);\n    \n    for (int i = 0; i < n; ++i) {\n        std::cin >> signal[i];\n    }\n    \n    for (int i = 0; i < m; ++i) {\n        std::cin >> mask[i];\n    }\n    \n    int result_length = n + m - 1;\n    std::vector<int> result(result_length, 0);\n    \n    for (int i = 0; i < result_length; ++i) {\n        int sum = 0;\n        for (int j = 0; j < m; ++j) {\n            int signal_index = i - j;\n            if (signal_index >= 0 && signal_index < n) {\n                sum += signal[signal_index] * mask[j];\n            }\n        }\n        result[i] = sum;\n    }\n    \n    for (int i = 0; i < result_length; ++i) {\n        std::cout << result[i] << (i == result_length - 1 ? '\\n' : ' ');\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.7229077021280924,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 81,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sliding Window Cost",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n\nvector<long long> slidingWindowCost(vector<int>& nums, int k) {\n    int n = nums.size();\n    vector<long long> result;\n    multiset<int> low, high;\n    long long low_sum = 0, high_sum = 0;\n\n    auto add = [&](int x) {\n        if (low.empty() || x <= *low.rbegin()) {\n            low.insert(x);\n            low_sum += x;\n        } else {\n            high.insert(x);\n            high_sum += x;\n        }\n        if (low.size() > high.size() + 1) {\n            auto it = prev(low.end());\n            high.insert(*it);\n            high_sum += *it;\n            low_sum -= *it;\n            low.erase(it);\n        } else if (high.size() > low.size()) {\n            auto it = high.begin();\n            low.insert(*it);\n            low_sum += *it;\n            high_sum -= *it;\n            high.erase(it);\n        }\n    };\n\n    auto remove = [&](int x) {\n        if (low.find(x) != low.end()) {\n            low.erase(low.find(x));\n            low_sum -= x;\n        } else {\n            high.erase(high.find(x));\n            high_sum -= x;\n        }\n        if (low.size() > high.size() + 1) {\n            auto it = prev(low.end());\n            high.insert(*it);\n            high_sum += *it;\n            low_sum -= *it;\n            low.erase(it);\n        } else if (high.size() > low.size()) {\n            auto it = high.begin();\n            low.insert(*it);\n            low_sum += *it;\n            high_sum -= *it;\n            high.erase(it);\n        }\n    };\n\n    for (int i = 0; i < n; i++) {\n        add(nums[i]);\n        if (i >= k - 1) {\n            int median = *low.rbegin();\n            long long cost = (long long)median * low.size() - low_sum + high_sum - (long long)median * high.size();\n            result.push_back(cost);\n            remove(nums[i - k + 1]);\n        }\n    }\n    return result;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> nums(n);\n    for (int i = 0; i < n; i++) {\n        cin >> nums[i];\n    }\n\n    vector<long long> result = slidingWindowCost(nums, k);\n    for (long long cost : result) {\n        cout << cost << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 34,
            "total_test_cases": 34,
            "mean_time_taken": 0.15402055487913244,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 82,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Sliding Window Median",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nclass SlidingWindowMedian {\npublic:\n    vector<int> medianSlidingWindow(vector<int>& nums, int k) {\n        vector<int> result;\n        multiset<int> low, high;\n\n        auto balance = [&]() {\n            while (low.size() > high.size() + 1) {\n                high.insert(*low.rbegin());\n                low.erase(prev(low.end()));\n            }\n            while (low.size() < high.size()) {\n                low.insert(*high.begin());\n                high.erase(high.begin());\n            }\n        };\n\n        for (int i = 0; i < nums.size(); i++) {\n            if (low.empty() || nums[i] <= *low.rbegin()) {\n                low.insert(nums[i]);\n            } else {\n                high.insert(nums[i]);\n            }\n            if (i >= k) {\n                if (low.find(nums[i - k]) != low.end()) {\n                    low.erase(low.find(nums[i - k]));\n                } else {\n                    high.erase(high.find(nums[i - k]));\n                }\n            }\n            balance();\n            if (i >= k - 1) {\n                result.push_back(*low.rbegin());\n            }\n        }\n\n        return result;\n    }\n};\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> nums(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> nums[i];\n    }\n\n    SlidingWindowMedian solution;\n    vector<int> result = solution.medianSlidingWindow(nums, k);\n\n    for (int median : result) {\n        cout << median << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 40,
            "total_test_cases": 40,
            "mean_time_taken": 0.1532163441181183,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 83,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Sorting Methods",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\n\n// Function to count inversions using merge sort\nlong long mergeAndCount(std::vector<int>& arr, int l, int m, int r) {\n    int n1 = m - l + 1;\n    int n2 = r - m;\n    std::vector<int> left(arr.begin() + l, arr.begin() + m + 1);\n    std::vector<int> right(arr.begin() + m + 1, arr.begin() + r + 1);\n    int i = 0, j = 0, k = l;\n    long long swaps = 0;\n    while (i < n1 && j < n2) {\n        if (left[i] <= right[j]) {\n            arr[k++] = left[i++];\n        } else {\n            arr[k++] = right[j++];\n            swaps += (n1 - i);\n        }\n    }\n    while (i < n1) arr[k++] = left[i++];\n    while (j < n2) arr[k++] = right[j++];\n    return swaps;\n}\n\nlong long countInversions(std::vector<int>& arr, int l, int r) {\n    long long inversions = 0;\n    if (l < r) {\n        int m = l + (r - l) / 2;\n        inversions += countInversions(arr, l, m);\n        inversions += countInversions(arr, m + 1, r);\n        inversions += mergeAndCount(arr, l, m, r);\n    }\n    return inversions;\n}\n\n// Function to find the minimum number of swaps required to sort the array\nint minSwaps(std::vector<int>& arr) {\n    int n = arr.size();\n    std::vector<std::pair<int, int>> vec(n);\n    for (int i = 0; i < n; ++i) {\n        vec[i] = {arr[i], i};\n    }\n    std::sort(vec.begin(), vec.end());\n    std::vector<bool> visited(n, false);\n    int swaps = 0;\n    for (int i = 0; i < n; ++i) {\n        if (visited[i] || vec[i].second == i) continue;\n        int cycle_size = 0;\n        int j = i;\n        while (!visited[j]) {\n            visited[j] = true;\n            j = vec[j].second;\n            cycle_size++;\n        }\n        if (cycle_size > 0) {\n            swaps += (cycle_size - 1);\n        }\n    }\n    return swaps;\n}\n\n// Function to find the length of the longest increasing subsequence\nint lengthOfLIS(std::vector<int>& arr) {\n    std::vector<int> lis;\n    for (int x : arr) {\n        auto it = std::lower_bound(lis.begin(), lis.end(), x);\n        if (it == lis.end()) {\n            lis.push_back(x);\n        } else {\n            *it = x;\n        }\n    }\n    return lis.size();\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    std::vector<int> arr(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> arr[i];\n    }\n\n    // Method 1: Adjacent Swap\n    std::vector<int> temp = arr;\n    long long adj_swaps = countInversions(temp, 0, n - 1);\n\n    // Method 2: Any Two Elements Swap\n    int any_two_swaps = minSwaps(arr);\n\n    // Method 3: Move Any Element to Another Position\n    temp = arr;\n    long long move_any_pos = countInversions(temp, 0, n - 1);\n\n    // Method 4: Move Any Element to the Front\n    int lis_length = lengthOfLIS(arr);\n    int move_to_front = n - lis_length;\n\n    std::cout << adj_swaps << \" \" << any_two_swaps << \" \" << move_any_pos << \" \" << move_to_front << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 10,
            "mean_time_taken": 0.21886935234069824,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 83,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Special Substrings",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\nint countSpecialSubstrings(const string& s) {\n    int n = s.size();\n    int result = 0;\n\n    // Iterate over all possible starting points of the substring\n    for (int start = 0; start < n; ++start) {\n        unordered_map<char, int> freq;\n        unordered_set<int> unique_freq;\n        \n        // Iterate over all possible ending points of the substring\n        for (int end = start; end < n; ++end) {\n            char current_char = s[end];\n            freq[current_char]++;\n            unique_freq.clear();\n            \n            // Collect unique frequencies\n            for (const auto& pair : freq) {\n                unique_freq.insert(pair.second);\n            }\n            \n            // Check if all characters have the same frequency\n            if (unique_freq.size() == 1) {\n                result++;\n            }\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    cout << countSpecialSubstrings(s) << endl;\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 8,
            "mean_time_taken": 0.8008318543434143,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 83,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Stack Weights",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> leftStack, rightStack;\n    int leftSum = 0, rightSum = 0;\n\n    for (int i = 0; i < n; ++i) {\n        int c, s;\n        cin >> c >> s;\n        if (s == 1) {\n            leftStack.push_back(c);\n            leftSum += c;\n        } else {\n            rightStack.push_back(c);\n            rightSum += c;\n        }\n\n        if (leftSum > rightSum) {\n            cout << \">\" << endl;\n        } else if (rightSum > leftSum) {\n            cout << \"<\" << endl;\n        } else {\n            cout << \"?\" << endl;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 5,
            "mean_time_taken": 0.21627459526062012,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 83,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Stair Game",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> p(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> p[i];\n        }\n\n        // Determine the first non-zero stair\n        int first_non_zero_stair = -1;\n        for (int i = 0; i < n; ++i) {\n            if (p[i] > 0) {\n                first_non_zero_stair = i + 1;\n                break;\n            }\n        }\n\n        // If no non-zero stair is found, the second player wins by default\n        if (first_non_zero_stair == -1) {\n            cout << \"second\" << endl;\n        } else {\n            if (first_non_zero_stair % 2 == 1) {\n                cout << \"first\" << endl;\n            } else {\n                cout << \"second\" << endl;\n            }\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 7,
            "mean_time_taken": 0.09721463067190987,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 83,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Static Range Minimum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits.h>\n\nusing namespace std;\n\nclass SegmentTree {\nprivate:\n    int n;\n    vector<int> tree;\n\n    void build(const vector<int>& arr, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = arr[start];\n        } else {\n            int mid = (start + end) / 2;\n            build(arr, 2 * node + 1, start, mid);\n            build(arr, 2 * node + 2, mid + 1, end);\n            tree[node] = min(tree[2 * node + 1], tree[2 * node + 2]);\n        }\n    }\n\n    int query(int node, int start, int end, int L, int R) {\n        if (R < start || L > end) {\n            return INT_MAX;\n        }\n        if (L <= start && end <= R) {\n            return tree[node];\n        }\n        int mid = (start + end) / 2;\n        int leftQuery = query(2 * node + 1, start, mid, L, R);\n        int rightQuery = query(2 * node + 2, mid + 1, end, L, R);\n        return min(leftQuery, rightQuery);\n    }\n\npublic:\n    SegmentTree(const vector<int>& arr) {\n        n = arr.size();\n        tree.resize(4 * n);\n        build(arr, 0, 0, n - 1);\n    }\n\n    int query(int L, int R) {\n        return query(0, 0, n - 1, L, R);\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, q;\n    cin >> n >> q;\n    vector<int> arr(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i];\n    }\n\n    SegmentTree segTree(arr);\n\n    for (int i = 0; i < q; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a; --b; // Convert to 0-based index\n        cout << segTree.query(a, b) << '\\n';\n    }\n\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 4,
            "mean_time_taken": 0.13269060850143433,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 84,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Static Range Sum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    // Read the number of elements and queries\n    int n, q;\n    cin >> n >> q;\n    \n    // Read the array\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    \n    // Compute the prefix sums\n    vector<long long> prefix(n + 1, 0);\n    for (int i = 1; i <= n; i++) {\n        prefix[i] = prefix[i - 1] + arr[i - 1];\n    }\n    \n    // Process each query\n    for (int i = 0; i < q; i++) {\n        int a, b;\n        cin >> a >> b;\n        // Compute the sum for the range [a, b]\n        long long result = prefix[b] - prefix[a - 1];\n        cout << result << endl;\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 2,
            "mean_time_taken": 0.1806555986404419,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 85,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Stick Divisions",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    int x, n;\n    cin >> x >> n;\n    \n    priority_queue<int, vector<int>, greater<int>> pq;\n    for (int i = 0; i < n; ++i) {\n        int length;\n        cin >> length;\n        pq.push(length);\n    }\n    \n    long long total_cost = 0;\n    while (pq.size() > 1) {\n        int stick1 = pq.top();\n        pq.pop();\n        int stick2 = pq.top();\n        pq.pop();\n        \n        int new_stick = stick1 + stick2;\n        total_cost += new_stick;\n        pq.push(new_stick);\n    }\n    \n    cout << total_cost << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 6,
            "mean_time_taken": 0.20077057679494223,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 86,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Stick Game",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> moves(k);\n    for (int i = 0; i < k; ++i) {\n        cin >> moves[i];\n    }\n\n    vector<bool> dp(n + 1, false);\n\n    for (int i = 1; i <= n; ++i) {\n        for (int move : moves) {\n            if (i - move >= 0 && !dp[i - move]) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n\n    string result;\n    for (int i = 1; i <= n; ++i) {\n        result += (dp[i] ? 'W' : 'L');\n    }\n\n    cout << result << endl;\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 6,
            "mean_time_taken": 0.3311384916305542,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                ""
            ],
            "failed_test_cases": [
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 86,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Stick Lengths",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    int n;\n    std::cin >> n;\n    std::vector<long long> sticks(n);\n    \n    for(int i = 0; i < n; ++i) {\n        std::cin >> sticks[i];\n    }\n    \n    // Sort the stick lengths\n    std::sort(sticks.begin(), sticks.end());\n    \n    // The median is the middle element in the sorted array\n    long long median = sticks[n / 2];\n    \n    // Calculate the total cost\n    long long total_cost = 0;\n    for(int i = 0; i < n; ++i) {\n        total_cost += std::abs(sticks[i] - median);\n    }\n    \n    // Output the result\n    std::cout << total_cost << std::endl;\n    \n    return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.10800522023981268,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 87,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "String Functions",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to compute the Z-function\nvector<int> computeZFunction(const string &s) {\n    int n = s.length();\n    vector<int> z(n, 0);\n    int l = 0, r = 0;\n    for (int i = 1; i < n; ++i) {\n        if (i <= r) {\n            z[i] = min(r - i + 1, z[i - l]);\n        }\n        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n            ++z[i];\n        }\n        if (i + z[i] - 1 > r) {\n            l = i;\n            r = i + z[i] - 1;\n        }\n    }\n    return z;\n}\n\n// Function to compute the prefix function\nvector<int> computePrefixFunction(const string &s) {\n    int n = s.length();\n    vector<int> pi(n, 0);\n    for (int i = 1; i < n; ++i) {\n        int j = pi[i - 1];\n        while (j > 0 && s[i] != s[j]) {\n            j = pi[j - 1];\n        }\n        if (s[i] == s[j]) {\n            ++j;\n        }\n        pi[i] = j;\n    }\n    return pi;\n}\n\nint main() {\n    string s;\n    cin >> s;\n\n    vector<int> z = computeZFunction(s);\n    vector<int> pi = computePrefixFunction(s);\n\n    for (int i = 0; i < z.size(); ++i) {\n        cout << z[i] << \" \";\n    }\n    cout << endl;\n\n    for (int i = 0; i < pi.size(); ++i) {\n        cout << pi[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 5,
            "mean_time_taken": 0.2216784954071045,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 88,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "String Matching",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to preprocess the pattern and create the prefix function\nvector<int> computePrefixFunction(const string& pattern) {\n    int m = pattern.size();\n    vector<int> prefix(m, 0);\n    int k = 0;\n    \n    for (int i = 1; i < m; ++i) {\n        while (k > 0 && pattern[k] != pattern[i]) {\n            k = prefix[k - 1];\n        }\n        if (pattern[k] == pattern[i]) {\n            ++k;\n        }\n        prefix[i] = k;\n    }\n    \n    return prefix;\n}\n\n// Function to count the number of occurrences of the pattern in the text\nint countPatternOccurrences(const string& text, const string& pattern) {\n    int n = text.size();\n    int m = pattern.size();\n    \n    if (m == 0) return 0; // Edge case: empty pattern\n    \n    vector<int> prefix = computePrefixFunction(pattern);\n    int matches = 0;\n    int q = 0;\n    \n    for (int i = 0; i < n; ++i) {\n        while (q > 0 && pattern[q] != text[i]) {\n            q = prefix[q - 1];\n        }\n        if (pattern[q] == text[i]) {\n            ++q;\n        }\n        if (q == m) {\n            ++matches;\n            q = prefix[q - 1];\n        }\n    }\n    \n    return matches;\n}\n\nint main() {\n    string text;\n    string pattern;\n    cin >> text >> pattern;\n    \n    int result = countPatternOccurrences(text, pattern);\n    cout << result << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 37,
            "total_test_cases": 37,
            "mean_time_taken": 0.09187180931503708,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 89,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "String Removals",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#define MOD 1000000007\n\nusing namespace std;\n\nint countDistinctSubsequences(string s) {\n    int n = s.size();\n    vector<long long> dp(n + 1, 0);\n    dp[0] = 1;  // Base case: empty subsequence\n    unordered_map<char, int> last;\n\n    for (int i = 1; i <= n; ++i) {\n        char current_char = s[i - 1];\n        \n        // Calculate dp[i] based on previous subsequences\n        dp[i] = (2 * dp[i - 1]) % MOD;\n        \n        // If the character has appeared before, subtract the overcounted subsequences\n        if (last.find(current_char) != last.end()) {\n            dp[i] = (dp[i] - dp[last[current_char] - 1] + MOD) % MOD;\n        }\n        \n        // Update the last occurrence of the current character\n        last[current_char] = i;\n    }\n\n    // Subtract 1 to exclude the empty subsequence\n    return (dp[n] - 1 + MOD) % MOD;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    cout << countDistinctSubsequences(s) << endl;\n    return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 7,
            "mean_time_taken": 0.10304931231907435,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 90,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "String Reorder",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n\nusing namespace std;\n\nstring reorderString(string s) {\n    int n = s.size();\n    unordered_map<char, int> freq;\n    \n    // Step 1: Count character frequencies\n    for (char c : s) {\n        freq[c]++;\n    }\n    \n    // Step 2: Check if the reordering is possible\n    int max_freq = 0;\n    for (auto p : freq) {\n        max_freq = max(max_freq, p.second);\n    }\n    if (max_freq > (n + 1) / 2) {\n        return \"-1\";\n    }\n    \n    // Step 3: Use a priority queue to build the result string\n    priority_queue<pair<int, char>> pq;\n    for (auto p : freq) {\n        pq.push({p.second, p.first});\n    }\n    \n    string result;\n    pair<int, char> prev = {0, '#'};\n    \n    while (!pq.empty()) {\n        auto [count, char_curr] = pq.top(); pq.pop();\n        \n        // Append current character to the result\n        result += char_curr;\n        \n        // Decrease count and push the previous character back to the heap if it still has remaining count\n        if (prev.first > 0) {\n            pq.push(prev);\n        }\n        \n        // Update the previous character\n        prev = {count - 1, char_curr};\n    }\n    \n    return result;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    cout << reorderString(s) << endl;\n    return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 15,
            "mean_time_taken": 0.19396168390909832,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8,
                13,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 90,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "String Transform",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring inverseBWT(const string &bwt) {\n    int n = bwt.size();\n    vector<string> table(n);\n    \n    // Initialize the table with empty strings\n    for (int i = 0; i < n; ++i) {\n        table[i] = \"\";\n    }\n    \n    // Perform n iterations\n    for (int i = 0; i < n; ++i) {\n        // Prepend characters of BWT to the table strings\n        for (int j = 0; j < n; ++j) {\n            table[j] = bwt[j] + table[j];\n        }\n        // Sort the table\n        sort(table.begin(), table.end());\n    }\n    \n    // Find the row that ends with '#'\n    for (int i = 0; i < n; ++i) {\n        if (table[i].back() == '#') {\n            // Return the string without the trailing '#'\n            return table[i].substr(0, n - 1);\n        }\n    }\n    \n    // Return empty string if not found (should not happen)\n    return \"\";\n}\n\nint main() {\n    string bwt;\n    cin >> bwt;\n    cout << inverseBWT(bwt) << endl;\n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 6,
            "mean_time_taken": 0.5643539031346639,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 90,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Strongly Connected Edges",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <utility>\n\nusing namespace std;\n\nvector<vector<int>> adj; // adjacency list of the original graph\nvector<vector<int>> adj_rev; // adjacency list of the reversed graph\nvector<bool> visited;\nstack<int> finish_stack;\n\nvoid dfs1(int v) {\n    visited[v] = true;\n    for (int u : adj[v]) {\n        if (!visited[u]) {\n            dfs1(u);\n        }\n    }\n    finish_stack.push(v);\n}\n\nvoid dfs2(int v) {\n    visited[v] = true;\n    for (int u : adj_rev[v]) {\n        if (!visited[u]) {\n            dfs2(u);\n        }\n    }\n}\n\nbool isStronglyConnected(int n) {\n    visited.assign(n + 1, false);\n    dfs1(1); // run DFS from node 1\n\n    if (finish_stack.size() != n) {\n        return false; // not all nodes are reachable from node 1\n    }\n\n    int last = finish_stack.top();\n    visited.assign(n + 1, false);\n    dfs2(last); // run DFS on the reversed graph starting from the last finished node\n\n    for (int i = 1; i <= n; ++i) {\n        if (!visited[i]) {\n            return false; // not all nodes can reach the last finished node\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    adj.resize(n + 1);\n    adj_rev.resize(n + 1);\n    vector<pair<int, int>> edges(m);\n\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n        adj_rev[b].push_back(a); // reverse direction\n        adj_rev[a].push_back(b); // reverse direction\n        edges[i] = {a, b};\n    }\n\n    if (!isStronglyConnected(n)) {\n        cout << \"IMPOSSIBLE\" << endl;\n        return 0;\n    }\n\n    visited.assign(n + 1, false);\n    stack<int> s;\n    s.push(1);\n    visited[1] = true;\n    vector<pair<int, int>> result;\n\n    while (!s.empty()) {\n        int v = s.top();\n        s.pop();\n\n        for (int u : adj[v]) {\n            if (!visited[u]) {\n                visited[u] = true;\n                result.push_back({v, u});\n                s.push(u);\n            }\n        }\n    }\n\n    for (auto &edge : result) {\n        cout << edge.first << \" \" << edge.second << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 11,
            "mean_time_taken": 0.13841132684187454,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 90,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Distinct Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> arr(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i];\n    }\n\n    unordered_map<int, int> freq;\n    int left = 0;\n    long long result = 0;\n\n    for (int right = 0; right < n; ++right) {\n        freq[arr[right]]++;\n        \n        while (freq.size() > k) {\n            freq[arr[left]]--;\n            if (freq[arr[left]] == 0) {\n                freq.erase(arr[left]);\n            }\n            left++;\n        }\n        \n        result += (right - left + 1);\n    }\n\n    cout << result << endl;\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.1506119966506958,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 91,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Subarray Divisibility",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n\n    unordered_map<int, int> prefix_count;\n    prefix_count[0] = 1; // Initial condition to handle subarrays starting from the beginning\n    long long prefix_sum = 0;\n    long long result = 0;\n    \n    for (int i = 0; i < n; ++i) {\n        prefix_sum += a[i];\n        int mod = ((prefix_sum % n) + n) % n; // Ensure non-negative mod value\n        \n        if (prefix_count.find(mod) != prefix_count.end()) {\n            result += prefix_count[mod];\n        }\n        prefix_count[mod]++;\n    }\n    \n    cout << result << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.11289653778076172,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 92,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Subarray Squares",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    \n    vector<int> arr(n + 1);\n    vector<long long> prefix_sum(n + 1, 0);\n    \n    for (int i = 1; i <= n; ++i) {\n        cin >> arr[i];\n        prefix_sum[i] = prefix_sum[i-1] + arr[i];\n    }\n    \n    vector<vector<long long>> dp(n + 1, vector<long long>(k + 1, LLONG_MAX));\n    dp[0][0] = 0;\n    \n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= k; ++j) {\n            for (int p = 0; p < i; ++p) {\n                if (dp[p][j-1] != LLONG_MAX) {\n                    long long subarray_sum = prefix_sum[i] - prefix_sum[p];\n                    dp[i][j] = min(dp[i][j], dp[p][j-1] + subarray_sum * subarray_sum);\n                }\n            }\n        }\n    }\n    \n    cout << dp[n][k] << endl;\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 11,
            "mean_time_taken": 0.6585477698932994,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 92,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Sum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct SegmentTreeNode {\n    long long total_sum;\n    long long best_prefix_sum;\n    long long best_suffix_sum;\n    long long max_subarray_sum;\n\n    SegmentTreeNode() : total_sum(0), best_prefix_sum(0), best_suffix_sum(0), max_subarray_sum(0) {}\n};\n\nclass SegmentTree {\npublic:\n    SegmentTree(const vector<int>& arr) : n(arr.size()), data(arr) {\n        tree.resize(4 * n);\n        build(0, 0, n - 1);\n    }\n\n    void update(int pos, int value) {\n        update(0, 0, n - 1, pos, value);\n    }\n\n    long long getMaxSubarraySum() const {\n        return tree[0].max_subarray_sum;\n    }\n\nprivate:\n    int n;\n    vector<int> data;\n    vector<SegmentTreeNode> tree;\n\n    void build(int node, int start, int end) {\n        if (start == end) {\n            tree[node].total_sum = data[start];\n            tree[node].best_prefix_sum = max(0LL, (long long)data[start]);\n            tree[node].best_suffix_sum = max(0LL, (long long)data[start]);\n            tree[node].max_subarray_sum = max(0LL, (long long)data[start]);\n        } else {\n            int mid = (start + end) / 2;\n            build(2 * node + 1, start, mid);\n            build(2 * node + 2, mid + 1, end);\n            tree[node] = merge(tree[2 * node + 1], tree[2 * node + 2]);\n        }\n    }\n\n    void update(int node, int start, int end, int pos, int value) {\n        if (start == end) {\n            tree[node].total_sum = value;\n            tree[node].best_prefix_sum = max(0LL, (long long)value);\n            tree[node].best_suffix_sum = max(0LL, (long long)value);\n            tree[node].max_subarray_sum = max(0LL, (long long)value);\n        } else {\n            int mid = (start + end) / 2;\n            if (pos <= mid) {\n                update(2 * node + 1, start, mid, pos, value);\n            } else {\n                update(2 * node + 2, mid + 1, end, pos, value);\n            }\n            tree[node] = merge(tree[2 * node + 1], tree[2 * node + 2]);\n        }\n    }\n\n    SegmentTreeNode merge(const SegmentTreeNode& left, const SegmentTreeNode& right) {\n        SegmentTreeNode result;\n        result.total_sum = left.total_sum + right.total_sum;\n        result.best_prefix_sum = max(left.best_prefix_sum, left.total_sum + right.best_prefix_sum);\n        result.best_suffix_sum = max(right.best_suffix_sum, right.total_sum + left.best_suffix_sum);\n        result.max_subarray_sum = max({left.max_subarray_sum, right.max_subarray_sum, left.best_suffix_sum + right.best_prefix_sum});\n        return result;\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> arr(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i];\n    }\n\n    SegmentTree segTree(arr);\n\n    for (int i = 0; i < m; ++i) {\n        int k, x;\n        cin >> k >> x;\n        segTree.update(k - 1, x);\n        cout << segTree.getMaxSubarraySum() << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 15,
            "total_test_cases": 15,
            "mean_time_taken": 0.2360652764638265,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 93,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Subarray Sums I",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nint main() {\n    int n;\n    long long x;\n    std::cin >> n >> x;\n    \n    std::vector<long long> a(n);\n    for(int i = 0; i < n; ++i) {\n        std::cin >> a[i];\n    }\n    \n    std::unordered_map<long long, int> prefix_sums;\n    long long current_sum = 0;\n    int count = 0;\n    \n    for(int i = 0; i < n; ++i) {\n        current_sum += a[i];\n        \n        if(current_sum == x) {\n            ++count;\n        }\n        \n        long long needed_sum = current_sum - x;\n        if(prefix_sums.find(needed_sum) != prefix_sums.end()) {\n            count += prefix_sums[needed_sum];\n        }\n        \n        prefix_sums[current_sum]++;\n    }\n    \n    std::cout << count << std::endl;\n    \n    return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.13199198246002197,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 94,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Subarray Sums II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint main() {\n    int n;\n    long long x;\n    cin >> n >> x;\n    vector<long long> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n\n    unordered_map<long long, int> prefix_sum_count;\n    long long current_prefix_sum = 0;\n    int count_subarrays = 0;\n    \n    // Initial condition: to handle subarrays starting from the beginning of the array\n    prefix_sum_count[0] = 1;\n\n    for (int i = 0; i < n; ++i) {\n        current_prefix_sum += a[i];\n        \n        // Check if there is a prefix sum that, when subtracted from current_prefix_sum, equals x\n        if (prefix_sum_count.find(current_prefix_sum - x) != prefix_sum_count.end()) {\n            count_subarrays += prefix_sum_count[current_prefix_sum - x];\n        }\n        \n        // Update the count of the current prefix sum in the map\n        prefix_sum_count[current_prefix_sum]++;\n    }\n\n    cout << count_subarrays << endl;\n\n    return 0;\n}",
            "passed_test_cases": 25,
            "total_test_cases": 27,
            "mean_time_taken": 0.14194754317954736,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 94,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subordinates",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid dfs(int node, const vector<vector<int>>& adj, vector<int>& subordinates) {\n    for (int subordinate : adj[node]) {\n        dfs(subordinate, adj, subordinates);\n        subordinates[node] += 1 + subordinates[subordinate];\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<vector<int>> adj(n + 1);\n    for (int i = 2; i <= n; ++i) {\n        int boss;\n        cin >> boss;\n        adj[boss].push_back(i);\n    }\n\n    vector<int> subordinates(n + 1, 0);\n    dfs(1, adj, subordinates);\n\n    for (int i = 1; i <= n; ++i) {\n        cout << subordinates[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 9,
            "total_test_cases": 12,
            "mean_time_taken": 0.1252386768658956,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 94,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Substring Distribution",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <unordered_set>\n#include <vector>\n\nint main() {\n    std::string s;\n    std::cin >> s;\n    int n = s.size();\n\n    // Vector to store the results\n    std::vector<int> result(n);\n\n    // Iterate over each possible substring length\n    for (int len = 1; len <= n; ++len) {\n        std::unordered_set<std::string> substrings;\n\n        // Use a sliding window to extract all substrings of length `len`\n        for (int i = 0; i <= n - len; ++i) {\n            std::string sub = s.substr(i, len);\n            substrings.insert(sub);\n        }\n\n        // Store the number of distinct substrings of length `len`\n        result[len - 1] = substrings.size();\n    }\n\n    // Output the results\n    for (int i = 0; i < n; ++i) {\n        std::cout << result[i] << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 9,
            "mean_time_taken": 0.8263087537553575,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 94,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Substring Order I",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\n// Function to build suffix array\nvector<int> build_suffix_array(const string &s) {\n    int n = s.size();\n    vector<int> suffix_array(n), rank(n), temp(n);\n    for (int i = 0; i < n; ++i) suffix_array[i] = i, rank[i] = s[i];\n    for (int k = 1; k < n; k *= 2) {\n        auto compare = [&](int i, int j) {\n            if (rank[i] != rank[j])\n                return rank[i] < rank[j];\n            int ri = i + k < n ? rank[i + k] : -1;\n            int rj = j + k < n ? rank[j + k] : -1;\n            return ri < rj;\n        };\n        sort(suffix_array.begin(), suffix_array.end(), compare);\n        temp[suffix_array[0]] = 0;\n        for (int i = 1; i < n; ++i)\n            temp[suffix_array[i]] = temp[suffix_array[i - 1]] + compare(suffix_array[i - 1], suffix_array[i]);\n        rank = temp;\n    }\n    return suffix_array;\n}\n\n// Function to build LCP array\nvector<int> build_lcp_array(const string &s, const vector<int> &suffix_array) {\n    int n = s.size();\n    vector<int> rank(n), lcp(n);\n    for (int i = 0; i < n; ++i) rank[suffix_array[i]] = i;\n    for (int i = 0, h = 0; i < n; ++i) {\n        if (rank[i] > 0) {\n            int j = suffix_array[rank[i] - 1];\n            while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;\n            lcp[rank[i]] = h;\n            if (h > 0) --h;\n        }\n    }\n    return lcp;\n}\n\n// Function to find the k-th smallest distinct substring\nstring find_kth_substring(const string &s, int k) {\n    int n = s.size();\n    vector<int> suffix_array = build_suffix_array(s);\n    vector<int> lcp = build_lcp_array(s, suffix_array);\n    \n    for (int i = 0; i < n; ++i) {\n        int suffix_len = n - suffix_array[i];\n        int new_substrings = suffix_len - lcp[i];\n        if (k <= new_substrings) {\n            return s.substr(suffix_array[i], lcp[i] + k);\n        }\n        k -= new_substrings;\n    }\n    return \"\"; // This should never be reached if input constraints are satisfied\n}\n\nint main() {\n    string s;\n    int k;\n    cin >> s >> k;\n    cout << find_kth_substring(s, k) << endl;\n    return 0;\n}",
            "passed_test_cases": 8,
            "total_test_cases": 9,
            "mean_time_taken": 0.4590483506520589,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                ""
            ],
            "failed_test_cases": [
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 94,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Substring Order II",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to build suffix array\nvector<int> buildSuffixArray(const string &s) {\n    int n = s.size();\n    vector<int> suffixArray(n), rank(n), temp(n);\n    iota(suffixArray.begin(), suffixArray.end(), 0);\n    for (int i = 0; i < n; ++i) rank[i] = s[i];\n\n    for (int k = 1; k < n; k *= 2) {\n        auto cmp = [&rank, &k, &n](int i, int j) {\n            if (rank[i] != rank[j]) return rank[i] < rank[j];\n            int ri = (i + k < n) ? rank[i + k] : -1;\n            int rj = (j + k < n) ? rank[j + k] : -1;\n            return ri < rj;\n        };\n        sort(suffixArray.begin(), suffixArray.end(), cmp);\n        temp[suffixArray[0]] = 0;\n        for (int i = 1; i < n; ++i) {\n            temp[suffixArray[i]] = temp[suffixArray[i - 1]] + cmp(suffixArray[i - 1], suffixArray[i]);\n        }\n        rank = temp;\n    }\n    return suffixArray;\n}\n\n// Function to find the kth smallest substring\nstring findKthSubstring(const string &s, int k) {\n    int n = s.size();\n    vector<int> suffixArray = buildSuffixArray(s);\n    vector<int> lcp(n); // Longest common prefix array\n\n    for (int i = 1; i < n; ++i) {\n        int len = 0;\n        while (suffixArray[i] + len < n && suffixArray[i - 1] + len < n && s[suffixArray[i] + len] == s[suffixArray[i - 1] + len]) {\n            len++;\n        }\n        lcp[i] = len;\n    }\n\n    int rankSum = 0;\n    for (int i = 0; i < n; ++i) {\n        int substrCount = n - suffixArray[i] - lcp[i];\n        if (rankSum + substrCount >= k) {\n            return s.substr(suffixArray[i], lcp[i] + k - rankSum);\n        }\n        rankSum += substrCount;\n    }\n\n    return \"\";\n}\n\nint main() {\n    string s;\n    int k;\n    cin >> s >> k;\n    cout << findKthSubstring(s, k) << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 94,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Substring Reversals",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nint main() {\n    int n, m;\n    std::cin >> n >> m;\n    std::string s;\n    std::cin >> s;\n    \n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        std::cin >> a >> b;\n        // Convert to 0-based indexing\n        --a;\n        --b;\n        std::reverse(s.begin() + a, s.begin() + b + 1);\n    }\n    \n    std::cout << s << std::endl;\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 4,
            "mean_time_taken": 0.5670987963676453,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 94,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subtree Queries",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 200005;\nvector<int> adj[MAXN];\nint value[MAXN], start[MAXN], finish[MAXN], euler[MAXN], timer = 0;\nlong long segtree[4 * MAXN], lazy[4 * MAXN];\nint n, q;\n\nvoid dfs(int node, int parent) {\n    start[node] = timer;\n    euler[timer] = node;\n    timer++;\n    for (int neighbor : adj[node]) {\n        if (neighbor != parent) {\n            dfs(neighbor, node);\n        }\n    }\n    finish[node] = timer - 1;\n}\n\nvoid build(int node, int start, int end) {\n    if (start == end) {\n        segtree[node] = value[euler[start]];\n    } else {\n        int mid = (start + end) / 2;\n        build(2 * node, start, mid);\n        build(2 * node + 1, mid + 1, end);\n        segtree[node] = segtree[2 * node] + segtree[2 * node + 1];\n    }\n}\n\nvoid update(int node, int start, int end, int idx, int val) {\n    if (start == end) {\n        segtree[node] = val;\n    } else {\n        int mid = (start + end) / 2;\n        if (start <= idx && idx <= mid) {\n            update(2 * node, start, mid, idx, val);\n        } else {\n            update(2 * node + 1, mid + 1, end, idx, val);\n        }\n        segtree[node] = segtree[2 * node] + segtree[2 * node + 1];\n    }\n}\n\nlong long query(int node, int start, int end, int l, int r) {\n    if (r < start || end < l) {\n        return 0;\n    }\n    if (l <= start && end <= r) {\n        return segtree[node];\n    }\n    int mid = (start + end) / 2;\n    long long p1 = query(2 * node, start, mid, l, r);\n    long long p2 = query(2 * node + 1, mid + 1, end, l, r);\n    return p1 + p2;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> n >> q;\n    for (int i = 1; i <= n; ++i) {\n        cin >> value[i];\n    }\n    for (int i = 1; i < n; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    dfs(1, -1);\n    build(1, 0, n - 1);\n\n    while (q--) {\n        int type, s, x;\n        cin >> type >> s;\n        if (type == 1) {\n            cin >> x;\n            update(1, 0, n - 1, start[s], x);\n        } else if (type == 2) {\n            cout << query(1, 0, n - 1, start[s], finish[s]) << '\\n';\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 13,
            "mean_time_taken": 0.16064893282376802,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 94,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sum of Divisors",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <cmath>\n\nconst int MOD = 1e9 + 7;\n\nlong long sum_of_divisors(long long n) {\n    long long result = 0;\n    long long sqrt_n = static_cast<long long>(sqrt(n));\n\n    for (long long i = 1; i <= sqrt_n; ++i) {\n        long long quotient = n / i;\n        result = (result + i * quotient) % MOD;\n\n        if (i != quotient) {\n            // Sum of the series from i+1 to quotient\n            long long sum_series = (quotient * (quotient + 1) / 2 % MOD - i * (i + 1) / 2 % MOD + MOD) % MOD;\n            result = (result + sum_series * i % MOD) % MOD;\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    long long n;\n    std::cin >> n;\n    std::cout << sum_of_divisors(n) << std::endl;\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 18,
            "mean_time_taken": 0.0912010669708252,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 94,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sum of Four Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n;\n    long long x;\n    cin >> n >> x;\n\n    vector<long long> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    // Map to store sum of pairs and their indices\n    unordered_map<long long, pair<int, int>> pairSum;\n\n    // Iterate over all pairs (i, j)\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            long long currentSum = a[i] + a[j];\n            long long requiredSum = x - currentSum;\n\n            // Check if requiredSum is already in the map\n            if (pairSum.find(requiredSum) != pairSum.end()) {\n                auto p = pairSum[requiredSum];\n                // Ensure all indices are distinct\n                if (p.first != i && p.first != j && p.second != i && p.second != j) {\n                    cout << p.first + 1 << \" \" << p.second + 1 << \" \" << i + 1 << \" \" << j + 1 << endl;\n                    return 0;\n                }\n            }\n\n            // Store the current pair sum and their indices\n            pairSum[currentSum] = {i, j};\n        }\n    }\n\n    cout << \"IMPOSSIBLE\" << endl;\n    return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 28,
            "mean_time_taken": 0.11403176614216395,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                7,
                9,
                11,
                12,
                15,
                16,
                18,
                20,
                21,
                22,
                26,
                27,
                28
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 94,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sum of Three Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Element {\n    int value;\n    int index;\n};\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n    vector<Element> arr(n);\n    \n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i].value;\n        arr[i].index = i + 1;\n    }\n    \n    // Sort the array based on values\n    sort(arr.begin(), arr.end(), [](const Element &a, const Element &b) {\n        return a.value < b.value;\n    });\n    \n    // Iterate through each element to fix the first element of the triplet\n    for (int i = 0; i < n; ++i) {\n        int target = x - arr[i].value;\n        int left = i + 1;\n        int right = n - 1;\n        \n        // Use two-pointer technique to find the other two elements\n        while (left < right) {\n            int sum = arr[left].value + arr[right].value;\n            if (sum == target) {\n                // Print the indices of the three elements\n                cout << arr[i].index << \" \" << arr[left].index << \" \" << arr[right].index << endl;\n                return 0;\n            } else if (sum < target) {\n                ++left;\n            } else {\n                --right;\n            }\n        }\n    }\n    \n    // If no triplet is found\n    cout << \"IMPOSSIBLE\" << endl;\n    return 0;\n}",
            "passed_test_cases": 26,
            "total_test_cases": 27,
            "mean_time_taken": 0.10090523295932347,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                ""
            ],
            "failed_test_cases": [
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 94,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sum of Two Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n\nint main() {\n    int n, x;\n    std::cin >> n >> x;\n    std::vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> a[i];\n    }\n\n    std::unordered_map<int, int> value_to_index;\n\n    for (int i = 0; i < n; ++i) {\n        int complement = x - a[i];\n        if (value_to_index.find(complement) != value_to_index.end()) {\n            std::cout << value_to_index[complement] + 1 << \" \" << i + 1 << std::endl;\n            return 0;\n        }\n        value_to_index[a[i]] = i;\n    }\n\n    std::cout << \"IMPOSSIBLE\" << std::endl;\n    return 0;\n}",
            "passed_test_cases": 18,
            "total_test_cases": 27,
            "mean_time_taken": 0.1784369945526123,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                3,
                4,
                9,
                10,
                11,
                21,
                22,
                24,
                25
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 94,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Swap Game",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <queue>\n#include <unordered_set>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Possible movements in the 3x3 grid\nconst vector<vector<int>> adj = {\n    {1, 3}, {0, 2, 4}, {1, 5},\n    {0, 4, 6}, {1, 3, 5, 7}, {2, 4, 8},\n    {3, 7}, {4, 6, 8}, {5, 7}\n};\n\n// Function to perform BFS and find minimum number of moves\nint minMoves(string start) {\n    string target = \"123456789\";\n    if (start == target) return 0;\n\n    queue<pair<string, int>> q;\n    unordered_set<string> visited;\n\n    q.push({start, 0});\n    visited.insert(start);\n\n    while (!q.empty()) {\n        auto [current, moves] = q.front();\n        q.pop();\n\n        int zeroPos = find(current.begin(), current.end(), '9') - current.begin();\n\n        for (int nextPos : adj[zeroPos]) {\n            string nextState = current;\n            swap(nextState[zeroPos], nextState[nextPos]);\n\n            if (nextState == target) return moves + 1;\n\n            if (visited.find(nextState) == visited.end()) {\n                visited.insert(nextState);\n                q.push({nextState, moves + 1});\n            }\n        }\n    }\n\n    return -1; // Shouldn't reach here for valid inputs\n}\n\nint main() {\n    string start = \"\";\n    for (int i = 0; i < 9; ++i) {\n        char c;\n        cin >> c;\n        start += c;\n    }\n\n    cout << minMoves(start) << endl;\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 19,
            "mean_time_taken": 0.1955625007027074,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 94,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Swap Round Sorting",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> findCycles(const vector<int>& arr, int n) {\n    vector<bool> visited(n, false);\n    vector<vector<int>> cycles;\n    \n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            vector<int> cycle;\n            int x = i;\n            while (!visited[x]) {\n                visited[x] = true;\n                cycle.push_back(x);\n                x = arr[x] - 1; // move to the next index in the cycle\n            }\n            if (cycle.size() > 1) {\n                cycles.push_back(cycle);\n            }\n        }\n    }\n    return cycles;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i];\n    }\n\n    vector<vector<int>> cycles = findCycles(arr, n);\n    cout << cycles.size() << endl;\n\n    for (const auto& cycle : cycles) {\n        cout << cycle.size() << endl;\n        for (int i = 0; i < cycle.size(); ++i) {\n            cout << cycle[i] + 1 << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 15,
            "mean_time_taken": 0.11840553283691406,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                6,
                7,
                9,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 94,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Task Assignment",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits.h>\n\nusing namespace std;\n\nconst int MAXN = 201;\nint cost[MAXN][MAXN];\nint u[MAXN], v[MAXN], p[MAXN], way[MAXN];\nint minv[MAXN];\nbool used[MAXN];\n\nint main() {\n    int n;\n    cin >> n;\n    for(int i = 1; i <= n; i++) {\n        for(int j = 1; j <= n; j++) {\n            cin >> cost[i][j];\n        }\n    }\n\n    for(int i = 1; i <= n; i++) {\n        p[0] = i;\n        int j0 = 0;\n        fill(minv, minv + n + 1, INT_MAX);\n        fill(used, used + n + 1, false);\n        do {\n            used[j0] = true;\n            int i0 = p[j0], delta = INT_MAX, j1;\n            for(int j = 1; j <= n; j++) {\n                if (!used[j]) {\n                    int cur = cost[i0][j] - u[i0] - v[j];\n                    if (cur < minv[j]) {\n                        minv[j] = cur;\n                        way[j] = j0;\n                    }\n                    if (minv[j] < delta) {\n                        delta = minv[j];\n                        j1 = j;\n                    }\n                }\n            }\n            for(int j = 0; j <= n; j++) {\n                if (used[j]) {\n                    u[p[j]] += delta;\n                    v[j] -= delta;\n                } else {\n                    minv[j] -= delta;\n                }\n            }\n            j0 = j1;\n        } while(p[j0] != 0);\n\n        do {\n            int j1 = way[j0];\n            p[j0] = p[j1];\n            j0 = j1;\n        } while(j0 != 0);\n    }\n\n    vector<int> ans(n + 1);\n    for(int j = 1; j <= n; j++) {\n        ans[p[j]] = j;\n    }\n\n    cout << -v[0] << endl;\n    for(int i = 1; i <= n; i++) {\n        cout << i << \" \" << ans[i] << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 6,
            "mean_time_taken": 0.09726035594940186,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 94,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tasks and Deadlines",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<pair<int, int>> tasks(n); // pair of (duration, deadline)\n    \n    for (int i = 0; i < n; ++i) {\n        cin >> tasks[i].first >> tasks[i].second;\n    }\n    \n    // Sort tasks based on their durations\n    sort(tasks.begin(), tasks.end());\n    \n    long long currentTime = 0;\n    long long totalReward = 0;\n    \n    for (const auto& task : tasks) {\n        int duration = task.first;\n        int deadline = task.second;\n        \n        currentTime += duration;\n        totalReward += deadline - currentTime;\n    }\n    \n    cout << totalReward << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 6,
            "mean_time_taken": 0.14731248219807944,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 95,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Teleporters Path",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <unordered_map>\n\nusing namespace std;\n\nvoid findEulerianPath(int start, unordered_map<int, vector<int>>& graph, vector<int>& path) {\n    stack<int> st;\n    st.push(start);\n    while (!st.empty()) {\n        int u = st.top();\n        if (graph[u].empty()) {\n            path.push_back(u);\n            st.pop();\n        } else {\n            int v = graph[u].back();\n            graph[u].pop_back();\n            st.push(v);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    unordered_map<int, vector<int>> graph;\n    vector<int> in_degree(n + 1, 0), out_degree(n + 1, 0);\n\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        out_degree[a]++;\n        in_degree[b]++;\n    }\n\n    int start = 1, end = n;\n    int start_candidates = 0, end_candidates = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (out_degree[i] - in_degree[i] == 1) {\n            start = i;\n            start_candidates++;\n        } else if (in_degree[i] - out_degree[i] == 1) {\n            end = i;\n            end_candidates++;\n        } else if (in_degree[i] != out_degree[i]) {\n            cout << \"IMPOSSIBLE\" << endl;\n            return 0;\n        }\n    }\n\n    if (!(start_candidates == 1 && end_candidates == 1)) {\n        cout << \"IMPOSSIBLE\" << endl;\n        return 0;\n    }\n\n    vector<int> path;\n    findEulerianPath(start, graph, path);\n    if (path.size() != m + 1) {\n        cout << \"IMPOSSIBLE\" << endl;\n    } else {\n        reverse(path.begin(), path.end());\n        for (auto node : path) {\n            cout << node << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 95,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Throwing Dice",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nconst int MOD = 1000000007;\n\nusing namespace std;\n\ntypedef vector<vector<long long>> Matrix;\n\nMatrix multiply(Matrix &a, Matrix &b) {\n    int n = a.size();\n    Matrix result(n, vector<long long>(n, 0));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            for (int k = 0; k < n; ++k) {\n                result[i][j] = (result[i][j] + a[i][k] * b[k][j]) % MOD;\n            }\n        }\n    }\n    return result;\n}\n\nMatrix power(Matrix base, long long exp) {\n    int n = base.size();\n    Matrix result(n, vector<long long>(n, 0));\n    for (int i = 0; i < n; ++i) {\n        result[i][i] = 1;\n    }\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = multiply(result, base);\n        }\n        base = multiply(base, base);\n        exp /= 2;\n    }\n    return result;\n}\n\nint main() {\n    long long n;\n    cin >> n;\n\n    if (n <= 6) {\n        // Base cases\n        long long base_cases[] = {1, 2, 4, 8, 16, 32};\n        cout << base_cases[n-1] << endl;\n        return 0;\n    }\n\n    Matrix T = {\n        {1, 1, 1, 1, 1, 1},\n        {1, 0, 0, 0, 0, 0},\n        {0, 1, 0, 0, 0, 0},\n        {0, 0, 1, 0, 0, 0},\n        {0, 0, 0, 1, 0, 0},\n        {0, 0, 0, 0, 1, 0}\n    };\n\n    Matrix result = power(T, n-6);\n\n    vector<long long> base = {32, 16, 8, 4, 2, 1};\n    long long answer = 0;\n    for (int i = 0; i < 6; ++i) {\n        answer = (answer + result[0][i] * base[i]) % MOD;\n    }\n\n    cout << answer << endl;\n    return 0;\n}",
            "passed_test_cases": 32,
            "total_test_cases": 32,
            "mean_time_taken": 0.08754068613052368,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 96,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Tower of Hanoi",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to perform the move operation\nvoid move(int n, int from, int to, int aux, vector<pair<int, int>> &moves) {\n    if (n == 1) {\n        // Base case: only one disk to move\n        moves.push_back({from, to});\n        return;\n    }\n    // Move n-1 disks from 'from' to 'aux' using 'to' as auxiliary\n    move(n-1, from, aux, to, moves);\n    // Move the nth disk from 'from' to 'to'\n    moves.push_back({from, to});\n    // Move the n-1 disks from 'aux' to 'to' using 'from' as auxiliary\n    move(n-1, aux, to, from, moves);\n}\n\nint main() {\n    int n;\n    cin >> n; // Input number of disks\n    vector<pair<int, int>> moves;\n    \n    // Start the process of moving disks\n    move(n, 1, 3, 2, moves);\n    \n    // Output the minimum number of moves\n    cout << moves.size() << endl;\n    // Output the sequence of moves\n    for (const auto &move : moves) {\n        cout << move.first << \" \" << move.second << endl;\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 16,
            "total_test_cases": 16,
            "mean_time_taken": 0.09256497025489807,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 97,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Towers",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <set>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    multiset<int> towers;\n\n    for (int i = 0; i < n; ++i) {\n        int cube;\n        cin >> cube;\n\n        auto it = towers.upper_bound(cube);\n        if (it != towers.end()) {\n            towers.erase(it);\n        }\n        towers.insert(cube);\n    }\n\n    cout << towers.size() << endl;\n    return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.15165793895721436,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 98,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Traffic Lights",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    int x, n;\n    std::cin >> x >> n;\n    \n    std::vector<int> positions(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> positions[i];\n    }\n    \n    std::set<int> lights = {0, x};  // Initial traffic lights at the ends\n    std::multiset<int> lengths = {x};  // Initial length of the street\n    \n    for (int i = 0; i < n; ++i) {\n        int pos = positions[i];\n        \n        // Find the nearest traffic lights to the left and right\n        auto it = lights.upper_bound(pos);\n        int right = *it;\n        int left = *std::prev(it);\n        \n        // Remove the old passage length and add the new ones\n        lengths.erase(lengths.find(right - left));\n        lengths.insert(pos - left);\n        lengths.insert(right - pos);\n        \n        // Insert the new traffic light position\n        lights.insert(pos);\n        \n        // The longest passage is the maximum element in the multiset\n        std::cout << *lengths.rbegin() << \" \";\n    }\n    \n    std::cout << std::endl;\n    \n    return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.35210323333740234,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 99,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Trailing Zeros",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    long long n;\n    cin >> n;\n    \n    long long count = 0;\n    for (long long i = 5; n / i >= 1; i *= 5) {\n        count += n / i;\n    }\n\n    cout << count << endl;\n    return 0;\n}",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.08981965138362004,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 100,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Tree Diameter",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> adj;  // adjacency list\n\npair<int, int> bfs(int start, int n) {\n    vector<int> dist(n + 1, -1); // distance array initialized to -1\n    queue<int> q;\n    q.push(start);\n    dist[start] = 0;\n\n    int farthest_node = start;\n    int max_dist = 0;\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n\n        for (int neighbor : adj[node]) {\n            if (dist[neighbor] == -1) {  // if not visited\n                dist[neighbor] = dist[node] + 1;\n                q.push(neighbor);\n                \n                if (dist[neighbor] > max_dist) {\n                    max_dist = dist[neighbor];\n                    farthest_node = neighbor;\n                }\n            }\n        }\n    }\n\n    return {farthest_node, max_dist};\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n\n    adj.resize(n + 1);\n\n    for (int i = 0; i < n - 1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    // First BFS to find the farthest node from node 1\n    pair<int, int> p1 = bfs(1, n);\n\n    // Second BFS to find the diameter of the tree\n    pair<int, int> p2 = bfs(p1.first, n);\n\n    cout << p2.second << endl;\n\n    return 0;\n}",
            "passed_test_cases": 18,
            "total_test_cases": 18,
            "mean_time_taken": 0.12974419858720568,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 101,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Tree Distances I",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 200000;\nvector<int> adj[MAXN + 1];\nint distA[MAXN + 1];\nint distB[MAXN + 1];\n\nvoid dfs(int node, int parent, int dist[], int d) {\n    dist[node] = d;\n    for (int neighbor : adj[node]) {\n        if (neighbor != parent) {\n            dfs(neighbor, node, dist, d + 1);\n        }\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    for (int i = 0; i < n - 1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    \n    // First DFS to find the furthest node from node 1 (let's call it A)\n    dfs(1, -1, distA, 0);\n    int A = max_element(distA + 1, distA + n + 1) - distA;\n    \n    // Second DFS from A to find the furthest node from A (let's call it B)\n    dfs(A, -1, distA, 0);\n    int B = max_element(distA + 1, distA + n + 1) - distA;\n    \n    // Third DFS from B to find distances from B\n    dfs(B, -1, distB, 0);\n    \n    // The maximum distance for each node is the maximum of the distances from A and B\n    for (int i = 1; i <= n; ++i) {\n        cout << max(distA[i], distB[i]) << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 15,
            "mean_time_taken": 0.1668384552001953,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                5,
                11,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 101,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Distances II",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<vector<int>> tree;\nvector<long long> subtree_size, dist_sum, result;\n\nvoid dfs1(int node, int parent) {\n    subtree_size[node] = 1;  // The node itself counts as size 1\n    for (int neighbor : tree[node]) {\n        if (neighbor == parent) continue;  // Avoid going back to the parent\n        dfs1(neighbor, node);\n        subtree_size[node] += subtree_size[neighbor];\n        dist_sum[node] += dist_sum[neighbor] + subtree_size[neighbor];\n    }\n}\n\nvoid dfs2(int node, int parent, long long n) {\n    if (parent != -1) {\n        result[node] = result[parent] - subtree_size[node] + (n - subtree_size[node]);\n    }\n    for (int neighbor : tree[node]) {\n        if (neighbor == parent) continue;\n        dfs2(neighbor, node, n);\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    tree.resize(n + 1);\n    subtree_size.resize(n + 1);\n    dist_sum.resize(n + 1);\n    result.resize(n + 1);\n\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        tree[a].push_back(b);\n        tree[b].push_back(a);\n    }\n\n    // Perform the first DFS from node 1 (assuming 1 is the root)\n    dfs1(1, -1);\n\n    // The result for the root node is its dist_sum\n    result[1] = dist_sum[1];\n\n    // Perform the second DFS to calculate results for all nodes\n    dfs2(1, -1, n);\n\n    // Print the results\n    for (int i = 1; i <= n; i++) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 14,
            "mean_time_taken": 0.15791123253958567,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                5,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 101,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Isomorphism I",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<vector<int>> adj1, adj2;\n\nstring canonical_form(int node, const vector<vector<int>> &adj, vector<int> &visited) {\n    visited[node] = 1;\n    vector<string> children_forms;\n\n    for (int neighbor : adj[node]) {\n        if (!visited[neighbor]) {\n            children_forms.push_back(canonical_form(neighbor, adj, visited));\n        }\n    }\n\n    sort(children_forms.begin(), children_forms.end());\n    string result = \"(\";\n    for (const string &form : children_forms) {\n        result += form;\n    }\n    result += \")\";\n    return result;\n}\n\nbool are_isomorphic(int n) {\n    vector<int> visited1(n + 1, 0);\n    vector<int> visited2(n + 1, 0);\n\n    string form1 = canonical_form(1, adj1, visited1);\n    string form2 = canonical_form(1, adj2, visited2);\n\n    return form1 == form2;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n\n        adj1.assign(n + 1, vector<int>());\n        adj2.assign(n + 1, vector<int>());\n\n        for (int i = 0; i < n - 1; ++i) {\n            int u, v;\n            cin >> u >> v;\n            adj1[u].push_back(v);\n            adj1[v].push_back(u);\n        }\n\n        for (int i = 0; i < n - 1; ++i) {\n            int u, v;\n            cin >> u >> v;\n            adj2[u].push_back(v);\n            adj2[v].push_back(u);\n        }\n\n        if (are_isomorphic(n)) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 14,
            "total_test_cases": 15,
            "mean_time_taken": 0.19450054168701172,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                ""
            ],
            "failed_test_cases": [
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 101,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Isomorphism II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> find_centroids(const vector<vector<int>>& tree, int n) {\n    vector<int> centroids;\n    vector<int> size(n, 0);\n    vector<bool> visited(n, false);\n    \n    function<void(int)> dfs = [&](int node) {\n        visited[node] = true;\n        size[node] = 1;\n        bool is_centroid = true;\n        for (int neighbor : tree[node]) {\n            if (!visited[neighbor]) {\n                dfs(neighbor);\n                size[node] += size[neighbor];\n                if (size[neighbor] > n / 2) {\n                    is_centroid = false;\n                }\n            }\n        }\n        if (n - size[node] > n / 2) {\n            is_centroid = false;\n        }\n        if (is_centroid) {\n            centroids.push_back(node);\n        }\n    };\n    \n    dfs(0);\n    \n    return centroids;\n}\n\nstring encode_tree(const vector<vector<int>>& tree, int root) {\n    unordered_map<int, vector<string>> labels;\n    \n    function<string(int, int)> dfs = [&](int node, int parent) {\n        vector<string> children_labels;\n        for (int neighbor : tree[node]) {\n            if (neighbor != parent) {\n                children_labels.push_back(dfs(neighbor, node));\n            }\n        }\n        sort(children_labels.begin(), children_labels.end());\n        string label = \"(\";\n        for (const string& l : children_labels) {\n            label += l;\n        }\n        label += \")\";\n        return label;\n    };\n    \n    return dfs(root, -1);\n}\n\nbool are_isomorphic(const vector<vector<int>>& tree1, const vector<vector<int>>& tree2, int n) {\n    vector<int> centroids1 = find_centroids(tree1, n);\n    vector<int> centroids2 = find_centroids(tree2, n);\n\n    string encoding1 = encode_tree(tree1, centroids1[0]);\n    for (int centroid : centroids2) {\n        if (encoding1 == encode_tree(tree2, centroid)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<vector<int>> tree1(n), tree2(n);\n        for (int i = 0; i < n - 1; ++i) {\n            int u, v;\n            cin >> u >> v;\n            --u, --v;\n            tree1[u].push_back(v);\n            tree1[v].push_back(u);\n        }\n        for (int i = 0; i < n - 1; ++i) {\n            int u, v;\n            cin >> u >> v;\n            --u, --v;\n            tree2[u].push_back(v);\n            tree2[v].push_back(u);\n        }\n        if (are_isomorphic(tree1, tree2, n)) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}",
            "passed_test_cases": 13,
            "total_test_cases": 14,
            "mean_time_taken": 0.22199172633034842,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                ""
            ],
            "failed_test_cases": [
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 101,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Matching",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 200005;\n\nvector<int> adj[MAXN];\nint dp[MAXN][2];\n\nvoid dfs(int u, int parent) {\n    dp[u][0] = 0;\n    dp[u][1] = 0;\n    for (int v : adj[u]) {\n        if (v == parent) continue;\n        dfs(v, u);\n        dp[u][0] += max(dp[v][0], dp[v][1]);\n    }\n    for (int v : adj[u]) {\n        if (v == parent) continue;\n        dp[u][1] = max(dp[u][1], 1 + dp[u][0] - max(dp[v][0], dp[v][1]) + dp[v][0]);\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 1; i < n; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    dfs(1, 0);\n    cout << max(dp[1][0], dp[1][1]) << endl;\n    return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 13,
            "mean_time_taken": 0.15311088928809533,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                5,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 101,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Traversals",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\n// Function to build the tree and generate postorder traversal\nvoid buildPostOrder(int preStart, int preEnd, int inStart, int inEnd,\n                    const vector<int>& preorder, const vector<int>& inorder,\n                    unordered_map<int, int>& inorderIndexMap, vector<int>& postorder) {\n    if (preStart > preEnd || inStart > inEnd) return;\n    \n    // The first element in preorder is the root node\n    int root = preorder[preStart];\n    // Find the root in inorder traversal\n    int inRoot = inorderIndexMap[root];\n    // Numbers in left subtree\n    int numsLeft = inRoot - inStart;\n    \n    // Recursively build the left subtree\n    buildPostOrder(preStart + 1, preStart + numsLeft, inStart, inRoot - 1, preorder, inorder, inorderIndexMap, postorder);\n    // Recursively build the right subtree\n    buildPostOrder(preStart + numsLeft + 1, preEnd, inRoot + 1, inEnd, preorder, inorder, inorderIndexMap, postorder);\n    // Add root to postorder\n    postorder.push_back(root);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> preorder(n), inorder(n);\n    \n    for (int i = 0; i < n; ++i) {\n        cin >> preorder[i];\n    }\n    \n    for (int i = 0; i < n; ++i) {\n        cin >> inorder[i];\n    }\n    \n    // Create a hashmap to store the index of each value in inorder traversal\n    unordered_map<int, int> inorderIndexMap;\n    for (int i = 0; i < n; ++i) {\n        inorderIndexMap[inorder[i]] = i;\n    }\n    \n    vector<int> postorder;\n    buildPostOrder(0, n - 1, 0, n - 1, preorder, inorder, inorderIndexMap, postorder);\n    \n    for (int val : postorder) {\n        cout << val << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 12,
            "mean_time_taken": 0.13138192892074585,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 101,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Two Knights",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    for (int k = 1; k <= n; ++k) {\n        long long total_positions = (long long)k * k * (k * k - 1) / 2;\n        long long attacking_positions = 0;\n        if (k > 2) {\n            attacking_positions = 4 * (k - 1) * (k - 2);\n        }\n        cout << total_positions - attacking_positions << endl;\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 3,
            "mean_time_taken": 0.09547098477681477,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 102,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Two Sets",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    long long sum = (long long)n * (n + 1) / 2;\n\n    // If the sum is odd, it's not possible to divide it into two sets of equal sum\n    if (sum % 2 != 0) {\n        cout << \"NO\" << endl;\n        return 0;\n    }\n\n    cout << \"YES\" << endl;\n    \n    vector<int> set1, set2;\n    long long half_sum = sum / 2;\n\n    // We will use a greedy approach to build the sets\n    for (int i = n; i > 0; i--) {\n        if (half_sum - i >= 0) {\n            set1.push_back(i);\n            half_sum -= i;\n        } else {\n            set2.push_back(i);\n        }\n    }\n\n    // Output the sets\n    cout << set1.size() << endl;\n    for (int num : set1) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    cout << set2.size() << endl;\n    for (int num : set2) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 15,
            "total_test_cases": 23,
            "mean_time_taken": 0.09223980488984482,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                7,
                9,
                14,
                16,
                17,
                21,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 102,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Two Sets II",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int sum = n * (n + 1) / 2;\n    if (sum % 2 != 0) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    int target = sum / 2;\n    vector<int> dp(target + 1, 0);\n    dp[0] = 1; // There's one way to make a sum of 0\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = target; j >= i; --j) {\n            dp[j] = (dp[j] + dp[j - i]) % MOD;\n        }\n    }\n\n    // Since each partition is counted twice\n    cout << (dp[target] * 1LL * ((MOD + 1) / 2)) % MOD << endl;\n\n    return 0;\n}",
            "passed_test_cases": 24,
            "total_test_cases": 24,
            "mean_time_taken": 0.11034613847732544,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 103,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Two Stacks Sorting",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> input(n);\n    for (int i = 0; i < n; i++) {\n        cin >> input[i];\n    }\n\n    stack<int> stack1, stack2;\n    vector<int> result;\n    int next_num = 1;\n\n    for (int i = 0; i < n; i++) {\n        int num = input[i];\n        if (num == next_num) {\n            // Directly move to output\n            result.push_back(1); // Arbitrarily choose stack 1 for direct move\n            next_num++;\n            while (!stack1.empty() && stack1.top() == next_num) {\n                stack1.pop();\n                result.push_back(1);\n                next_num++;\n            }\n            while (!stack2.empty() && stack2.top() == next_num) {\n                stack2.pop();\n                result.push_back(2);\n                next_num++;\n            }\n        } else if (stack1.empty() || num < stack1.top()) {\n            stack1.push(num);\n            result.push_back(1);\n        } else if (stack2.empty() || num < stack2.top()) {\n            stack2.push(num);\n            result.push_back(2);\n        } else {\n            cout << \"IMPOSSIBLE\" << endl;\n            return 0;\n        }\n    }\n\n    cout << result[0];\n    for (size_t i = 1; i < result.size(); i++) {\n        cout << \" \" << result[i];\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 14,
            "mean_time_taken": 0.11425861290522984,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                5,
                6,
                8,
                10,
                11,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 103,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Visiting Cities",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<long long, int> PII;\nconst long long INF = numeric_limits<long long>::max();\n\nvector<vector<PII>> adj, rev_adj;\nvector<long long> dist_from_start, dist_to_end;\n\nvoid dijkstra(int start, vector<vector<PII>> &graph, vector<long long> &dist) {\n    priority_queue<PII, vector<PII>, greater<PII>> pq;\n    dist[start] = 0;\n    pq.push({0, start});\n    while (!pq.empty()) {\n        long long d = pq.top().first;\n        int u = pq.top().second;\n        pq.pop();\n        if (d > dist[u]) continue;\n        for (auto &edge : graph[u]) {\n            int v = edge.first;\n            long long w = edge.second;\n            if (dist[u] + w < dist[v]) {\n                dist[v] = dist[u] + w;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    adj.resize(n + 1);\n    rev_adj.resize(n + 1);\n    dist_from_start.resize(n + 1, INF);\n    dist_to_end.resize(n + 1, INF);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        long long c;\n        cin >> a >> b >> c;\n        adj[a].emplace_back(b, c);\n        rev_adj[b].emplace_back(a, c);\n    }\n\n    dijkstra(1, adj, dist_from_start);\n    dijkstra(n, rev_adj, dist_to_end);\n\n    long long shortest_path = dist_from_start[n];\n    vector<int> result;\n\n    for (int i = 1; i <= n; i++) {\n        if (dist_from_start[i] + dist_to_end[i] == shortest_path) {\n            result.push_back(i);\n        }\n    }\n\n    sort(result.begin(), result.end());\n    cout << result.size() << endl;\n    for (int city : result) {\n        cout << city << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 13,
            "mean_time_taken": 0.1806192581470196,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                7,
                10,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 103,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Weird Algorithm",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    long long n;\n    cin >> n;\n    \n    while (true) {\n        cout << n;\n        if (n == 1) break;\n        cout << \" \";\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = n * 3 + 1;\n        }\n    }\n    \n    return 0;\n}",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.08951309749058314,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 104,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Word Combinations",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <string>\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    std::string s;\n    int k;\n    std::cin >> s >> k;\n    int n = s.length();\n    \n    std::unordered_set<std::string> dictionary;\n    for (int i = 0; i < k; ++i) {\n        std::string word;\n        std::cin >> word;\n        dictionary.insert(word);\n    }\n    \n    std::vector<int> dp(n + 1, 0);\n    dp[0] = 1; // Base case: There's one way to create an empty string\n    \n    for (int i = 1; i <= n; ++i) {\n        for (const std::string& word : dictionary) {\n            int len = word.length();\n            if (i >= len && s.substr(i - len, len) == word) {\n                dp[i] = (dp[i] + dp[i - len]) % MOD;\n            }\n        }\n    }\n    \n    std::cout << dp[n] << std::endl;\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 6,
            "mean_time_taken": 0.578762968381246,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                ""
            ],
            "failed_test_cases": [
                4,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 104,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Writing Numbers",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nint main() {\n    long long n;\n    std::cin >> n;\n\n    std::vector<long long> digit_count(10, 0); // Counter for each digit from 0 to 9\n    long long number = 0;\n\n    while (true) {\n        number++;\n        std::string num_str = std::to_string(number);\n        std::vector<long long> temp_count = digit_count;\n\n        // Count digits for the current number\n        for (char ch : num_str) {\n            temp_count[ch - '0']++;\n        }\n\n        // Check if any digit exceeds the limit n\n        bool valid = true;\n        for (int i = 0; i < 10; i++) {\n            if (temp_count[i] > n) {\n                valid = false;\n                break;\n            }\n        }\n\n        if (!valid) {\n            number--; // Last valid number\n            break;\n        }\n\n        digit_count = temp_count; // Update the digit count\n    }\n\n    std::cout << number << std::endl;\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 21,
            "mean_time_taken": 0.5844318299066453,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                1,
                3,
                5,
                7,
                9,
                10,
                14,
                17,
                18,
                19,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 104,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Xor Pyramid",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nint main() {\n    // Read the size of the pyramid\n    int n;\n    std::cin >> n;\n    \n    // Read the bottom row of the pyramid\n    std::vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> a[i];\n    }\n    \n    // Build the pyramid from bottom to top\n    for (int layer = 1; layer < n; ++layer) {\n        for (int i = 0; i < n - layer; ++i) {\n            a[i] = a[i] ^ a[i + 1];\n        }\n    }\n    \n    // The topmost number\n    std::cout << a[0] << std::endl;\n    \n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 8,
            "mean_time_taken": 0.6822780668735504,
            "mean_memory_used": 7744780.0,
            "failure_reasons": [
                "",
                "",
                "",
                "",
                ""
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 104,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        }
    ],
    "total_passed_problems": 104
}