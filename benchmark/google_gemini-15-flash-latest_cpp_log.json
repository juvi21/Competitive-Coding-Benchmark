{
    "problems": [
        {
            "title": "Acyclic Graph Edges",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\nvector<int> order;\n\nvoid dfs(int node) {\n  visited[node] = true;\n  for (int neighbor : adj[node]) {\n    if (!visited[neighbor]) {\n      dfs(neighbor);\n    }\n  }\n  order.push_back(node);\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  adj.resize(n + 1);\n  visited.resize(n + 1, false);\n\n  for (int i = 0; i < m; ++i) {\n    int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n\n  for (int i = 1; i <= n; ++i) {\n    if (!visited[i]) {\n      dfs(i);\n    }\n  }\n\n  reverse(order.begin(), order.end());\n\n  for (int i = 0; i < m; ++i) {\n    int a, b;\n    cin >> a >> b;\n\n    // Determine the direction of the edge based on the topological order\n    if (find(order.begin(), order.end(), a) < find(order.begin(), order.end(), b)) {\n      cout << a << \" \" << b << endl;\n    } else {\n      cout << b << \" \" << a << endl;\n    }\n  }\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.3372564911842346,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Advertisement",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> heights(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> heights[i];\n    }\n\n    stack<int> st;\n    int maxArea = 0;\n    int i = 0;\n\n    while (i < n) {\n        if (st.empty() || heights[i] >= heights[st.top()]) {\n            st.push(i);\n            i++;\n        } else {\n            int top = st.top();\n            st.pop();\n            int width = st.empty() ? i : i - st.top() - 1;\n            maxArea = max(maxArea, heights[top] * width);\n        }\n    }\n\n    while (!st.empty()) {\n        int top = st.top();\n        st.pop();\n        int width = st.empty() ? i : i - st.top() - 1;\n        maxArea = max(maxArea, heights[top] * width);\n    }\n\n    cout << maxArea << endl;\n    return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 11,
            "mean_time_taken": 0.10916334932500665,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Another Game",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<int> heaps(n);\n    for (int i = 0; i < n; i++) {\n      cin >> heaps[i];\n    }\n\n    // Calculate the bitwise XOR of all the heap sizes\n    int xor_sum = 0;\n    for (int i = 0; i < n; i++) {\n      xor_sum ^= heaps[i];\n    }\n\n    // If the XOR sum is zero, the second player wins\n    // Otherwise, the first player wins\n    if (xor_sum == 0) {\n      cout << \"second\" << endl;\n    } else {\n      cout << \"first\" << endl;\n    }\n  }\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 0.1266465187072754,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Apartments",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int n, m, k;\n  cin >> n >> m >> k;\n\n  vector<int> applicants(n);\n  for (int i = 0; i < n; i++) {\n    cin >> applicants[i];\n  }\n\n  vector<int> apartments(m);\n  for (int i = 0; i < m; i++) {\n    cin >> apartments[i];\n  }\n\n  // Sort the applicants and apartments for efficient matching\n  sort(applicants.begin(), applicants.end());\n  sort(apartments.begin(), apartments.end());\n\n  int i = 0; // Index for applicants\n  int j = 0; // Index for apartments\n  int count = 0; // Count of matched applicants\n\n  // Iterate through both lists\n  while (i < n && j < m) {\n    // Check if the current apartment is within the acceptable range for the current applicant\n    if (abs(applicants[i] - apartments[j]) <= k) {\n      count++; // Match found, increment count\n      i++;\n      j++;\n    } else {\n      // If the apartment is too small, move on to the next apartment\n      if (applicants[i] > apartments[j]) {\n        j++;\n      }\n      // If the apartment is too big, move on to the next applicant\n      else {\n        i++;\n      }\n    }\n  }\n\n  cout << count << endl;\n\n  return 0;\n}",
            "passed_test_cases": 19,
            "total_test_cases": 19,
            "mean_time_taken": 0.15863781226308724,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 1,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Apple Division",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<int> apples(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> apples[i];\n  }\n\n  int min_diff = INT_MAX;\n\n  // Iterate through all possible bitmasks\n  for (int mask = 0; mask < (1 << n); ++mask) {\n    int group1_weight = 0;\n    int group2_weight = 0;\n\n    // Calculate the weight of each group\n    for (int i = 0; i < n; ++i) {\n      if (mask & (1 << i)) {\n        group1_weight += apples[i];\n      } else {\n        group2_weight += apples[i];\n      }\n    }\n\n    // Update minimum difference\n    min_diff = min(min_diff, abs(group1_weight - group2_weight));\n  }\n\n  cout << min_diff << endl;\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 1,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Apples and Bananas",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int k, n, m;\n  cin >> k >> n >> m;\n\n  vector<int> apples(n);\n  vector<int> bananas(m);\n\n  for (int i = 0; i < n; i++) {\n    cin >> apples[i];\n  }\n\n  for (int i = 0; i < m; i++) {\n    cin >> bananas[i];\n  }\n\n  // Sort the vectors for efficient counting\n  sort(apples.begin(), apples.end());\n  sort(bananas.begin(), bananas.end());\n\n  // Use two pointers to count the number of pairs with specific weight\n  int apple_ptr = 0;\n  int banana_ptr = 0;\n  for (int w = 2; w <= 2 * k; w++) {\n    int count = 0;\n    // Two pointers iterate through the sorted vectors\n    while (apple_ptr < n && apples[apple_ptr] <= w) {\n      while (banana_ptr < m && bananas[banana_ptr] <= w && bananas[banana_ptr] + apples[apple_ptr] <= w) {\n        banana_ptr++;\n      }\n      // Count valid combinations of apples and bananas\n      count += banana_ptr;\n      apple_ptr++;\n    }\n    cout << count << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.16789960861206055,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 1,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Area of Rectangles",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Event {\n  int x;\n  int y1;\n  int y2;\n  bool isStart;\n\n  Event(int x, int y1, int y2, bool isStart) : x(x), y1(y1), y2(y2), isStart(isStart) {}\n};\n\nbool compareEvents(const Event& e1, const Event& e2) {\n  if (e1.x != e2.x) {\n    return e1.x < e2.x;\n  }\n  return e1.isStart > e2.isStart;\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<Event> events;\n  for (int i = 0; i < n; i++) {\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    events.push_back(Event(x1, y1, y2, true));\n    events.push_back(Event(x2, y1, y2, false));\n  }\n\n  sort(events.begin(), events.end(), compareEvents);\n\n  long long area = 0;\n  long long activeLength = 0;\n  int prevX = events[0].x;\n  for (const Event& event : events) {\n    area += activeLength * (event.x - prevX);\n    prevX = event.x;\n    if (event.isStart) {\n      activeLength += event.y2 - event.y1;\n    } else {\n      activeLength -= event.y2 - event.y1;\n    }\n  }\n\n  cout << area << endl;\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 15,
            "mean_time_taken": 0.1486502170562744,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 1,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Array Description",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst long long MOD = 1e9 + 7;\n\nlong long dp[100005][105];\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n\n  // Base case: If the first element is known, initialize the DP table accordingly.\n  if (a[0] != 0) {\n    dp[0][a[0]] = 1;\n  } else {\n    for (int i = 1; i <= m; i++) {\n      dp[0][i] = 1;\n    }\n  }\n\n  // Iterate through the array, filling the DP table.\n  for (int i = 1; i < n; i++) {\n    for (int j = 1; j <= m; j++) {\n      // If the current element is known, update the DP table accordingly.\n      if (a[i] != 0) {\n        if (abs(a[i] - j) <= 1) {\n          dp[i][a[i]] = (dp[i][a[i]] + dp[i - 1][j]) % MOD;\n        }\n      } else {\n        // If the current element is unknown, consider all possible values.\n        if (j - 1 >= 1) {\n          dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD;\n        }\n        if (j + 1 <= m) {\n          dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MOD;\n        }\n        dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD;\n      }\n    }\n  }\n\n  // Sum up all possible values for the last element.\n  long long answer = 0;\n  for (int i = 1; i <= m; i++) {\n    answer = (answer + dp[n - 1][i]) % MOD;\n  }\n\n  cout << answer << endl;\n\n  return 0;\n}",
            "passed_test_cases": 29,
            "total_test_cases": 29,
            "mean_time_taken": 0.1184659168638032,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Array Division",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int n, k;\n  cin >> n >> k;\n\n  vector<int> arr(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> arr[i];\n  }\n\n  // Binary search for the maximum sum\n  int left = *max_element(arr.begin(), arr.end());\n  int right = accumulate(arr.begin(), arr.end(), 0); // Sum of all elements\n\n  int result = right; // Initialize with the maximum possible sum\n  while (left <= right) {\n    int mid = (left + right) / 2;\n\n    // Check if we can divide the array into 'k' subarrays\n    // with maximum sum 'mid'\n    int count = 1;\n    int sum = 0;\n    for (int i = 0; i < n; ++i) {\n      if (sum + arr[i] > mid) {\n        count++;\n        sum = arr[i];\n      } else {\n        sum += arr[i];\n      }\n    }\n\n    if (count <= k) {\n      // We can divide into 'k' subarrays with maximum sum 'mid'\n      result = mid;\n      right = mid - 1; // Try for a smaller maximum sum\n    } else {\n      // We need more than 'k' subarrays, increase the maximum sum\n      left = mid + 1;\n    }\n  }\n\n  cout << result << endl;\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Beautiful Subgrids",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<vector<int>> grid(n, vector<int>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n    int count = 0;\n\n    for (int i = 1; i < n; i++) {\n        for (int j = 1; j < n; j++) {\n            if (grid[i][j] == 1) {\n                if (grid[i - 1][j] == 1 && grid[i][j - 1] == 1) {\n                    int left = 1, above = 1;\n                    for (int k = j - 2; k >= 0 && grid[i][k] == 1; k--) {\n                        left++;\n                    }\n                    for (int k = i - 2; k >= 0 && grid[k][j] == 1; k--) {\n                        above++;\n                    }\n                    dp[i][j] = dp[i - 1][j - 1] + left * above;\n                    count += dp[i][j];\n                }\n            }\n        }\n    }\n\n    cout << count << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.1816267967224121,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Binary Subsequences",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    // Initialize the string with '1'\n    string ans = \"1\";\n    // Initialize the count of subsequences\n    int count = 2;\n\n    // Keep adding digits until we have 'n' subsequences\n    while (count < n) {\n        // Add '0' or '1' alternatively\n        if (ans.back() == '1') {\n            ans += \"0\";\n        } else {\n            ans += \"1\";\n        }\n        // Double the count of subsequences\n        count *= 2;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 12,
            "mean_time_taken": 0.3092305064201355,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Binomial Coefficients",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\n// Calculate factorial modulo MOD\nvector<long long> factorial(1e6 + 1, 1);\nfor (int i = 1; i <= 1e6; i++) {\n  factorial[i] = (factorial[i - 1] * i) % MOD;\n}\n\n// Calculate modular inverse using Fermat's Little Theorem\nlong long modInverse(long long a) {\n  return factorial[MOD - 2 - a]; \n}\n\n// Calculate binomial coefficient modulo MOD\nlong long binomialCoeff(int a, int b) {\n  return (factorial[a] * modInverse(factorial[b]) % MOD * modInverse(factorial[a - b]) % MOD);\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  for (int i = 0; i < n; i++) {\n    int a, b;\n    cin >> a >> b;\n\n    cout << binomialCoeff(a, b) << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Bit Inversions",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  string s;\n  int n, m;\n  cin >> s >> m;\n  n = s.size();\n\n  // Initialize a vector to store the lengths of the longest substrings\n  vector<int> lengths(n + 1, 0);\n\n  // Calculate the initial lengths of the longest substrings\n  int currentLength = 1;\n  for (int i = 1; i <= n; i++) {\n    if (s[i - 1] == s[i - 2]) {\n      currentLength++;\n    } else {\n      currentLength = 1;\n    }\n    lengths[i] = currentLength;\n  }\n\n  // Process the changes one by one\n  for (int i = 0; i < m; i++) {\n    int x;\n    cin >> x;\n\n    // Invert the bit at the specified position\n    s[x - 1] = (s[x - 1] == '0' ? '1' : '0');\n\n    // Update the lengths of the longest substrings\n    if (x > 1 && x < n) {\n      // If the change is not at the beginning or end of the string\n      if (s[x - 1] == s[x - 2]) {\n        lengths[x] = lengths[x - 1] + 1;\n      } else {\n        lengths[x] = 1;\n      }\n      if (s[x - 1] == s[x]) {\n        lengths[x + 1] = lengths[x] + 1;\n      } else {\n        lengths[x + 1] = 1;\n      }\n    } else if (x == 1) {\n      // If the change is at the beginning of the string\n      if (s[x - 1] == s[x]) {\n        lengths[x + 1] = lengths[x] + 1;\n      } else {\n        lengths[x + 1] = 1;\n      }\n    } else {\n      // If the change is at the end of the string\n      if (s[x - 1] == s[x - 2]) {\n        lengths[x] = lengths[x - 1] + 1;\n      } else {\n        lengths[x] = 1;\n      }\n    }\n\n    // Print the length of the longest substring after the change\n    int maxLength = 0;\n    for (int j = 1; j <= n; j++) {\n      maxLength = max(maxLength, lengths[j]);\n    }\n    cout << maxLength << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.9174911181131998,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bit Problem",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<int> numbers(n);\n  for (int i = 0; i < n; i++) {\n    cin >> numbers[i];\n  }\n\n  for (int i = 0; i < n; i++) {\n    int x = numbers[i];\n    int count_or = 0, count_and = 0, count_and_nonzero = 0;\n\n    for (int j = 0; j < n; j++) {\n      int y = numbers[j];\n\n      if ((x | y) == x) {\n        count_or++;\n      }\n\n      if ((x & y) == x) {\n        count_and++;\n      }\n\n      if ((x & y) != 0) {\n        count_and_nonzero++;\n      }\n    }\n\n    cout << count_or << \" \" << count_and << \" \" << count_and_nonzero << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 2,
            "mean_time_taken": 0.5670019388198853,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed"
            ],
            "failed_test_cases": [
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bit Strings",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#define MOD 1000000007\n\nusing namespace std;\n\nlong long int dp[1000001];\n\nlong long int countBitStrings(int n) {\n    if (n == 0) {\n        return 1;\n    }\n    if (dp[n] != -1) {\n        return dp[n];\n    }\n    dp[n] = (2 * countBitStrings(n - 1)) % MOD;\n    return dp[n];\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i <= 1000000; i++) {\n        dp[i] = -1;\n    }\n    cout << countBitStrings(n) << endl;\n    return 0;\n}",
            "passed_test_cases": 8,
            "total_test_cases": 12,
            "mean_time_taken": 0.12005168199539185,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                5,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bit Substrings",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n  string s;\n  cin >> s;\n  int n = s.size();\n  vector<long long> count(n + 1, 0);\n  long long ones = 0;\n  for (int i = 0; i < n; i++) {\n    if (s[i] == '1') {\n      ones++;\n    }\n    count[ones]++;\n  }\n  for (int i = 0; i <= n; i++) {\n    cout << count[i] - 1 << \" \";\n  }\n  cout << endl;\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Book Shop",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n  int n, x;\n  cin >> n >> x;\n\n  vector<int> h(n), s(n);\n  for (int i = 0; i < n; i++) {\n    cin >> h[i];\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> s[i];\n  }\n\n  // Initialize dp table\n  vector<vector<int>> dp(n + 1, vector<int>(x + 1, 0));\n\n  // Build the dp table\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= x; j++) {\n      if (j >= h[i - 1]) {\n        dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - h[i - 1]] + s[i - 1]);\n      } else {\n        dp[i][j] = dp[i - 1][j];\n      }\n    }\n  }\n\n  cout << dp[n][x] << endl;\n  return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 15,
            "mean_time_taken": 0.6495182037353515,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                7,
                9,
                11,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Book Shop II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int n, x;\n  cin >> n >> x;\n\n  vector<int> h(n), s(n), k(n);\n  for (int i = 0; i < n; i++) {\n    cin >> h[i];\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> s[i];\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> k[i];\n  }\n\n  // Create a vector of tuples to store the price, pages, and number of copies for each book\n  vector<tuple<int, int, int>> books;\n  for (int i = 0; i < n; i++) {\n    books.push_back(make_tuple(h[i], s[i], k[i]));\n  }\n\n  // Sort the books by price per page in ascending order\n  sort(books.begin(), books.end(), [](const tuple<int, int, int>& a, const tuple<int, int, int>& b) {\n    return (double)get<0>(a) / get<1>(a) < (double)get<0>(b) / get<1>(b);\n  });\n\n  int max_pages = 0;\n  int current_price = 0;\n\n  // Iterate through the books in order of price per page\n  for (int i = 0; i < n; i++) {\n    int price = get<0>(books[i]);\n    int pages = get<1>(books[i]);\n    int copies = get<2>(books[i]);\n\n    // Buy as many copies of the current book as possible without exceeding the budget\n    while (copies > 0 && current_price + price <= x) {\n      current_price += price;\n      max_pages += pages;\n      copies--;\n    }\n  }\n\n  cout << max_pages << endl;\n\n  return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 10,
            "mean_time_taken": 0.2973466873168945,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Bracket Sequences I",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#define MOD 1000000007\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    long long dp[n + 1][n + 1]; \n    memset(dp, 0, sizeof(dp));\n\n    dp[0][0] = 1; \n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= i; j++) {\n            if (j > 0) {\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD; \n            }\n            if (j < i) {\n                dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MOD; \n            }\n        }\n    }\n\n    cout << dp[n][0] << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Bracket Sequences II",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nconst long long MOD = 1e9 + 7;\n\nlong long dp[1000001][2];\n\nint main() {\n  int n;\n  string prefix;\n  cin >> n >> prefix;\n\n  // Base case: empty prefix\n  dp[0][0] = 1;\n  dp[0][1] = 0;\n\n  // Iterate over the prefix length\n  for (int i = 1; i <= prefix.length(); i++) {\n    // If the current character is '('\n    if (prefix[i - 1] == '(') {\n      // We can either add a '(' or a ')'\n      dp[i][0] = (dp[i - 1][0] + dp[i - 1][1]) % MOD;\n      // We cannot add a '(' because it would make the sequence invalid\n      dp[i][1] = 0;\n    } else { // If the current character is ')'\n      // We cannot add a '(' because it would make the sequence invalid\n      dp[i][0] = 0;\n      // We can add a ')' only if the number of '(' is greater than the number of ')' in the prefix so far\n      dp[i][1] = dp[i - 1][0];\n    }\n  }\n\n  // Calculate the remaining part of the sequence\n  for (int i = prefix.length() + 1; i <= n; i++) {\n    // We can either add a '(' or a ')'\n    dp[i][0] = (dp[i - 1][0] + dp[i - 1][1]) % MOD;\n    // We can add a ')' only if the number of '(' is greater than the number of ')'\n    dp[i][1] = dp[i - 1][0];\n  }\n\n  // The total number of valid sequences is the sum of the number of sequences ending with '(' and the number of sequences ending with ')'\n  cout << (dp[n][0] + dp[n][1]) % MOD << endl;\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 11,
            "mean_time_taken": 0.37156850641424005,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Building Roads",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\n\nvector<int> adj[MAXN];\nbool visited[MAXN];\n\nvoid dfs(int node) {\n  visited[node] = true;\n  for (int neighbor : adj[node]) {\n    if (!visited[neighbor]) {\n      dfs(neighbor);\n    }\n  }\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  // Read existing roads and build adjacency list\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n\n  // Find connected components\n  int num_components = 0;\n  vector<int> representatives;\n  for (int i = 1; i <= n; i++) {\n    if (!visited[i]) {\n      num_components++;\n      representatives.push_back(i);\n      dfs(i);\n    }\n  }\n\n  // Build new roads\n  cout << num_components - 1 << endl; // Number of roads to build\n  for (int i = 1; i < representatives.size(); i++) {\n    cout << representatives[0] << \" \" << representatives[i] << endl; // Connecting representatives\n  }\n\n  return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 12,
            "mean_time_taken": 0.15509031216303507,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                7,
                8,
                9,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Building Teams",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\n\nvector<int> adj[MAXN];\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n\n  vector<int> team(n + 1, 0);\n  team[1] = 1;\n\n  // We use a depth-first search to assign teams.\n  // Each node is assigned a team, and its neighbours are assigned to the opposite team.\n  // If we find a conflict, we know the teams cannot be formed.\n  function<void(int, int)> dfs = [&](int node, int t) {\n    team[node] = t;\n    for (int neighbour : adj[node]) {\n      if (team[neighbour] == 0) {\n        dfs(neighbour, 3 - t);\n      } else if (team[neighbour] == t) {\n        cout << \"IMPOSSIBLE\" << endl;\n        exit(0);\n      }\n    }\n  };\n\n  dfs(1, 1);\n\n  for (int i = 1; i <= n; i++) {\n    cout << team[i] << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 10,
            "mean_time_taken": 0.33511104583740237,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 2,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Candy Lottery",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n  int n, k;\n  cin >> n >> k;\n\n  double expected_max = 0;\n  for (int i = 1; i <= k; ++i) {\n    double probability = pow(double(i) / k, n) - pow(double(i - 1) / k, n);\n    expected_max += i * probability;\n  }\n\n  cout << fixed << setprecision(6) << expected_max << endl;\n\n  return 0;\n}",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.2059311866760254,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Chess Tournament",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<int> wants(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> wants[i];\n  }\n\n  // Sort the players in decreasing order of games wanted\n  vector<int> order(n);\n  for (int i = 0; i < n; ++i) {\n    order[i] = i;\n  }\n  sort(order.begin(), order.end(), [&wants](int a, int b) {\n    return wants[a] > wants[b];\n  });\n\n  // Keep track of how many games each player has played\n  vector<int> played(n, 0);\n\n  // Keep track of the games played\n  vector<pair<int, int>> games;\n\n  // Greedily assign games\n  int k = 0;\n  for (int i = 0; i < n; ++i) {\n    int player = order[i];\n    // If the player has already played enough games, continue\n    if (played[player] == wants[player]) {\n      continue;\n    }\n    // Iterate over the other players in decreasing order of games wanted\n    for (int j = i + 1; j < n; ++j) {\n      int other = order[j];\n      // If the other player has already played enough games, continue\n      if (played[other] == wants[other]) {\n        continue;\n      }\n      // If the players have not played against each other yet, assign a game\n      if (played[player] < wants[player] && played[other] < wants[other]) {\n        games.push_back({player + 1, other + 1});\n        played[player]++;\n        played[other]++;\n        k++;\n        // If the current player has played enough games, break out of the loop\n        if (played[player] == wants[player]) {\n          break;\n        }\n      }\n    }\n  }\n\n  // If not all players are happy, then it is impossible\n  for (int i = 0; i < n; ++i) {\n    if (played[i] != wants[i]) {\n      cout << \"IMPOSSIBLE\" << endl;\n      return 0;\n    }\n  }\n\n  // Print the number of games and the games\n  cout << k << endl;\n  for (auto game : games) {\n    cout << game.first << \" \" << game.second << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 21,
            "mean_time_taken": 0.1099572635832287,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Chessboard and Queens",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint N = 8;\nvector<vector<char>> board;\nvector<int> col;\nint ans = 0;\n\nbool is_safe(int row, int col) {\n    // Check if there is a queen in the same column\n    for (int i = 0; i < row; ++i) {\n        if (col == board[i]) {\n            return false;\n        }\n    }\n\n    // Check upper diagonals\n    for (int i = row, j = col; i >= 0 && j >= 0; --i, --j) {\n        if (col == board[i]) {\n            return false;\n        }\n    }\n\n    // Check lower diagonals\n    for (int i = row, j = col; i < N && j >= 0; ++i, --j) {\n        if (col == board[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid solve(int row) {\n    if (row == N) {\n        ++ans;\n        return;\n    }\n\n    for (int i = 0; i < N; ++i) {\n        if (board[row][i] == '.' && is_safe(row, i)) {\n            board[row] = i;\n            solve(row + 1);\n            board[row] = -1; // Resetting the board for backtracking\n        }\n    }\n}\n\nint main() {\n    for (int i = 0; i < N; ++i) {\n        string line;\n        cin >> line;\n        vector<char> row(N);\n        for (int j = 0; j < N; ++j) {\n            row[j] = line[j];\n        }\n        board.push_back(row);\n        col.push_back(-1); // Initialize col to -1 to indicate no queen is placed in that column yet\n    }\n\n    solve(0);\n    cout << ans << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Christmas Party",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst long long MOD = 1e9 + 7;\n\nlong long factorial(long long n) {\n  long long result = 1;\n  for (long long i = 2; i <= n; i++) {\n    result = (result * i) % MOD;\n  }\n  return result;\n}\n\nint main() {\n  long long n;\n  cin >> n;\n\n  // The number of ways to distribute gifts is (n-1)!\n  long long answer = factorial(n - 1);\n\n  cout << answer << endl;\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 15,
            "mean_time_taken": 0.2651092847188314,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coding Company",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint dp[101][5001]; // dp[i][j] is the number of ways to divide the first i coders with penalty sum at most j\nvector<int> skills;\n\nint main() {\n  int n, x;\n  cin >> n >> x;\n\n  skills.resize(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> skills[i];\n  }\n\n  // Base case: no coders, penalty sum is 0\n  dp[0][0] = 1;\n\n  // Iterate over each coder\n  for (int i = 1; i <= n; ++i) {\n    // Iterate over possible penalty sums\n    for (int j = 0; j <= x; ++j) {\n      // Option 1: Add the current coder to the last team\n      if (j >= skills[i - 1]) {\n        dp[i][j] = (dp[i][j] + dp[i - 1][j - skills[i - 1]]) % MOD;\n      }\n\n      // Option 2: Create a new team for the current coder\n      dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD;\n    }\n  }\n\n  cout << dp[n][x] << endl;\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.0925583044687907,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Arrangement",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<vector<int>> grid(2, vector<int>(n));\n\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    // Calculate the number of coins that need to be moved in each row\n    vector<int> moves(2, 0);\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < n; j++) {\n            moves[i] += abs(grid[i][j] - 1);\n        }\n    }\n\n    // Find the minimum number of moves\n    int minMoves = min(moves[0], moves[1]);\n\n    // Print the answer\n    cout << minMoves << endl;\n\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 10,
            "mean_time_taken": 0.10150387287139892,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Collector",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\n\nvector<int> adj[MAXN];\nint coins[MAXN];\n\nint dfs(int node, int parent, vector<bool>& visited) {\n    visited[node] = true;\n    int total_coins = coins[node];\n    for (int neighbour : adj[node]) {\n        if (!visited[neighbour] && neighbour != parent) {\n            total_coins += dfs(neighbour, node, visited);\n        }\n    }\n    return total_coins;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 1; i <= n; i++) {\n        cin >> coins[i];\n    }\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n\n    int max_coins = 0;\n    vector<bool> visited(n + 1, false);\n\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            max_coins = max(max_coins, dfs(i, -1, visited));\n        }\n    }\n\n    cout << max_coins << endl;\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 14,
            "mean_time_taken": 0.13875927243913924,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Combinations I",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n  int n, x;\n  cin >> n >> x;\n\n  vector<int> coins(n);\n  for (int i = 0; i < n; i++) {\n    cin >> coins[i];\n  }\n\n  // dp[i] represents the number of ways to make sum i\n  vector<int> dp(x + 1, 0);\n  dp[0] = 1; // There is 1 way to make sum 0 (using no coins)\n\n  // Iterate through each coin\n  for (int i = 0; i < n; i++) {\n    // Iterate through possible sums\n    for (int j = coins[i]; j <= x; j++) {\n      // Add the number of ways to make sum j - coins[i]\n      // to the number of ways to make sum j\n      dp[j] = (dp[j] + dp[j - coins[i]]) % MOD;\n    }\n  }\n\n  cout << dp[x] << endl;\n\n  return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 13,
            "mean_time_taken": 0.25167105748103213,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                6,
                7,
                8,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 3,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Combinations II",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n  int n, x;\n  cin >> n >> x;\n\n  vector<int> coins(n);\n  for (int i = 0; i < n; i++) {\n    cin >> coins[i];\n  }\n\n  // dp[i] stores the number of ways to make sum i\n  vector<int> dp(x + 1, 0);\n  dp[0] = 1; \n\n  // Iterate through each coin\n  for (int i = 0; i < n; i++) {\n    // Iterate through each possible sum\n    for (int j = coins[i]; j <= x; j++) {\n      // Add the number of ways to make the sum j - coins[i] \n      // to the number of ways to make the sum j\n      dp[j] = (dp[j] + dp[j - coins[i]]) % MOD;\n    }\n  }\n\n  cout << dp[x] << endl;\n\n  return 0;\n}",
            "passed_test_cases": 15,
            "total_test_cases": 15,
            "mean_time_taken": 0.3931320508321126,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Coin Grid",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<vector<char>> grid(n, vector<char>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      cin >> grid[i][j];\n    }\n  }\n\n  vector<int> rows(n, 0), cols(n, 0);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (grid[i][j] == 'o') {\n        rows[i]++;\n        cols[j]++;\n      }\n    }\n  }\n\n  int moves = 0;\n  vector<pair<int, int>> move_list;\n  for (int i = 0; i < n; i++) {\n    if (rows[i] > 0) {\n      moves++;\n      move_list.push_back({1, i + 1});\n    }\n    if (cols[i] > 0) {\n      moves++;\n      move_list.push_back({2, i + 1});\n    }\n  }\n\n  cout << moves << endl;\n  for (auto move : move_list) {\n    cout << move.first << \" \" << move.second << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 10,
            "mean_time_taken": 0.0884861707687378,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Coin Piles",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int a, b;\n        cin >> a >> b;\n\n        // A key observation:  If we can remove 1 coin from the left and 2 from the right,\n        // we can also remove 2 coins from the left and 1 from the right, since we\n        // can simply perform the first move twice.\n\n        // Therefore, we only need to consider the differences in the number of coins\n        // to see if the piles can be emptied.\n        int diff = abs(a - b);\n\n        // Check if the difference is a multiple of 3. If it is, the piles can be emptied.\n        if (diff % 3 == 0) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 3,
            "mean_time_taken": 0.1490794817606608,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Collecting Numbers",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    int rounds = 0;\n    int current_number = 1;\n    int i = 0;\n\n    while (current_number <= n) {\n        if (i == n) { // Reached the end of the array, increment rounds and reset i\n            rounds++;\n            i = 0; \n        } else if (arr[i] == current_number) { // Found the current number, collect it\n            current_number++;\n            i++;\n        } else { // Skip the current number\n            i++;\n        }\n    }\n\n    cout << rounds << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.6641416549682617,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Collecting Numbers II",
            "category": "Sorting and Searching",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n\n  vector<int> pos(n + 1);\n  for (int i = 0; i < n; i++) {\n    pos[a[i]] = i;\n  }\n\n  int rounds = 0;\n  for (int i = 1; i <= n; i++) {\n    if (a[i - 1] != i) {\n      rounds++;\n    }\n  }\n\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n\n    // Swap the numbers in the array\n    swap(a[x - 1], a[y - 1]);\n\n    // Update the positions\n    swap(pos[a[x - 1]], pos[a[y - 1]]);\n\n    // Update the number of rounds\n    if (a[x - 1] == x) {\n      rounds--;\n    } else {\n      rounds++;\n    }\n    if (a[y - 1] == y) {\n      rounds--;\n    } else {\n      rounds++;\n    }\n\n    cout << rounds << \" \";\n  }\n  cout << endl;\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.22509121894836426,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Common Divisors",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint gcd(int a, int b) {\n  if (b == 0) {\n    return a;\n  }\n  return gcd(b, a % b);\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  int arr[n];\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n  }\n\n  // Find the maximum element in the array\n  int max_element = *max_element(arr, arr + n);\n\n  // Initialize the maximum gcd to 1\n  int max_gcd = 1;\n\n  // Iterate through the array and find the gcd of each pair\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      max_gcd = max(max_gcd, gcd(arr[i], arr[j]));\n    }\n  }\n\n  // Print the maximum gcd\n  cout << max_gcd << endl;\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Company Queries I",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e5 + 5;\nvector<int> adj[N];\nint up[N][20];\n\nvoid dfs(int u, int p) {\n  up[u][0] = p;\n  for (int i = 1; i < 20; i++) {\n    up[u][i] = up[up[u][i - 1]][i - 1];\n  }\n  for (auto v : adj[u]) {\n    if (v != p) {\n      dfs(v, u);\n    }\n  }\n}\n\nint kth_parent(int u, int k) {\n  for (int i = 19; i >= 0; i--) {\n    if (k & (1 << i)) {\n      u = up[u][i];\n    }\n  }\n  return u;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n\n  int n, q;\n  cin >> n >> q;\n  for (int i = 2; i <= n; i++) {\n    int e;\n    cin >> e;\n    adj[e].push_back(i);\n  }\n  dfs(1, 0);\n\n  while (q--) {\n    int x, k;\n    cin >> x >> k;\n    if (kth_parent(x, k) == 0) {\n      cout << -1 << endl;\n    } else {\n      cout << kth_parent(x, k) << endl;\n    }\n  }\n  return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 13,
            "mean_time_taken": 0.1613448583162748,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Company Queries II",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\n\nvector<int> adj[MAXN];\nint depth[MAXN], parent[MAXN];\nint subtree_size[MAXN];\n\nvoid dfs(int node, int par) {\n  parent[node] = par;\n  depth[node] = depth[par] + 1;\n  subtree_size[node] = 1;\n  for (int child : adj[node]) {\n    if (child != par) {\n      dfs(child, node);\n      subtree_size[node] += subtree_size[child];\n    }\n  }\n}\n\nint lca(int a, int b) {\n  if (depth[a] > depth[b]) swap(a, b);\n  while (depth[a] < depth[b]) {\n    b = parent[b];\n  }\n  while (a != b) {\n    a = parent[a];\n    b = parent[b];\n  }\n  return a;\n}\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n\n  for (int i = 2; i <= n; i++) {\n    int boss;\n    cin >> boss;\n    adj[boss].push_back(i);\n  }\n\n  dfs(1, 0);\n\n  while (q--) {\n    int a, b;\n    cin >> a >> b;\n    cout << lca(a, b) << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 9,
            "total_test_cases": 12,
            "mean_time_taken": 0.3397413492202759,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Concert Tickets",
            "category": "Sorting and Searching",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  vector<int> tickets(n);\n  for (int i = 0; i < n; i++) {\n    cin >> tickets[i];\n  }\n\n  vector<int> customers(m);\n  for (int i = 0; i < m; i++) {\n    cin >> customers[i];\n  }\n\n  // Sort the tickets in ascending order.\n  sort(tickets.begin(), tickets.end());\n\n  // Use a set to efficiently find the nearest price.\n  set<int> availableTickets(tickets.begin(), tickets.end());\n\n  // Process each customer.\n  for (int i = 0; i < m; i++) {\n    // Find the nearest price that is less than or equal to the customer's maximum price.\n    auto it = availableTickets.upper_bound(customers[i]);\n    if (it != availableTickets.begin()) {\n      // If there is a suitable ticket, print the price.\n      it--;\n      cout << *it << endl;\n      availableTickets.erase(it);\n    } else {\n      // If there is no suitable ticket, print -1.\n      cout << -1 << endl;\n    }\n  }\n\n  return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 11,
            "mean_time_taken": 0.2323641993782737,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                5,
                6,
                7,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Convex Hull",
            "category": "Geometry",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Point {\n  int x, y;\n};\n\n// Function to find the orientation of three points\nint orientation(Point p, Point q, Point r) {\n  int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n  if (val == 0) return 0; // Collinear\n  return (val > 0) ? 1 : 2; // Clockwise or counterclockwise\n}\n\n// Function to compare points based on their polar angle w.r.t. the bottom-leftmost point\nbool compare(Point p1, Point p2) {\n  int o = orientation(p0, p1, p2);\n  if (o == 0)\n    return (dist(p0, p1) < dist(p0, p2));\n  return (o == 2);\n}\n\n// Function to find the distance between two points\nint dist(Point p1, Point p2) {\n  return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);\n}\n\n// Function to find the convex hull using Graham's scan\nvector<Point> convexHull(vector<Point>& points) {\n  int n = points.size();\n\n  // Find the bottom-leftmost point\n  int ymin = points[0].y, min = 0;\n  for (int i = 1; i < n; i++) {\n    if ((points[i].y < ymin) || (points[i].y == ymin && points[i].x < points[min].x)) {\n      ymin = points[i].y;\n      min = i;\n    }\n  }\n\n  // Swap the bottom-leftmost point with the first point\n  swap(points[0], points[min]);\n\n  // Sort the points based on polar angle w.r.t. the bottom-leftmost point\n  p0 = points[0];\n  sort(points.begin() + 1, points.end(), compare);\n\n  // Create an empty stack to store the points on the hull\n  vector<Point> hull;\n  hull.push_back(points[0]);\n  hull.push_back(points[1]);\n\n  // Process the remaining points\n  for (int i = 2; i < n; i++) {\n    while (hull.size() > 1 && orientation(hull[hull.size() - 2], hull[hull.size() - 1], points[i]) != 2) {\n      hull.pop_back();\n    }\n    hull.push_back(points[i]);\n  }\n\n  return hull;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  vector<Point> points(n);\n  for (int i = 0; i < n; i++) {\n    cin >> points[i].x >> points[i].y;\n  }\n\n  // Find the convex hull\n  vector<Point> hull = convexHull(points);\n\n  // Print the results\n  cout << hull.size() << endl;\n  for (Point p : hull) {\n    cout << p.x << \" \" << p.y << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Counting Bishops",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n  int n, k;\n  cin >> n >> k;\n\n  // dp[i][j][l] represents the number of ways to place j bishops on the first i diagonals,\n  // where l is either 0 or 1, indicating whether the last diagonal is used or not.\n  vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(k + 1, vector<int>(2, 0)));\n\n  // Base case: No bishops, all diagonals empty\n  dp[0][0][0] = 1;\n\n  // Iterate over diagonals\n  for (int i = 1; i <= n; ++i) {\n    // Iterate over number of bishops\n    for (int j = 0; j <= k; ++j) {\n      // Iterate over last diagonal used or not\n      for (int l = 0; l <= 1; ++l) {\n        // If we're not using the current diagonal, we can inherit from the previous state\n        if (l == 0) {\n          dp[i][j][l] = dp[i - 1][j][l];\n        }\n        // If we're using the current diagonal, we need to place a bishop on it\n        if (j > 0 && l == 1) {\n          // We can place a bishop on the current diagonal if we didn't place one on the previous diagonal\n          dp[i][j][l] = (dp[i][j][l] + dp[i - 1][j - 1][0]) % MOD;\n        }\n        // If we're using the current diagonal, we can also inherit from the previous state if we didn't place a bishop on the previous diagonal\n        if (j > 0 && l == 1) {\n          dp[i][j][l] = (dp[i][j][l] + dp[i - 1][j - 1][1]) % MOD;\n        }\n      }\n    }\n  }\n\n  // The final answer is the sum of ways to place k bishops using the last diagonal or not\n  cout << (dp[n][k][0] + dp[n][k][1]) % MOD << endl;\n\n  return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 13,
            "mean_time_taken": 0.41461851046635556,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                8,
                9,
                10,
                11,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Bits",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n\nusing namespace std;\n\nlong long countBits(long long n) {\n  long long count = 0;\n  for (long long i = 1; i <= n; i++) {\n    long long num = i;\n    while (num > 0) {\n      count += (num & 1);\n      num >>= 1;\n    }\n  }\n  return count;\n}\n\nint main() {\n  long long n;\n  cin >> n;\n  cout << countBits(n) << endl;\n  return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 21,
            "mean_time_taken": 0.615098067692348,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                5,
                7,
                9,
                10,
                14,
                17,
                18,
                19,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Coprime Pairs",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint gcd(int a, int b) {\n  if (b == 0) {\n    return a;\n  }\n  return gcd(b, a % b);\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<int> numbers(n);\n  for (int i = 0; i < n; i++) {\n    cin >> numbers[i];\n  }\n\n  int count = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      if (gcd(numbers[i], numbers[j]) == 1) {\n        count++;\n      }\n    }\n  }\n\n  cout << count << endl;\n\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 8,
            "mean_time_taken": 0.9450659453868866,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Divisors",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    \n    // Calculate the number of divisors\n    int count = 0;\n    for (int j = 1; j <= sqrt(x); j++) {\n      if (x % j == 0) {\n        count += 2; // Count both j and x/j\n      }\n    }\n    // Handle the case where the square root is an integer\n    if (sqrt(x) * sqrt(x) == x) {\n      count--;\n    }\n\n    cout << count << endl;\n  }\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 16,
            "mean_time_taken": 0.43915148079395294,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Grids",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst long long MOD = 1e9 + 7;\n\nlong long power(long long x, long long y) {\n  long long result = 1;\n  while (y > 0) {\n    if (y & 1) {\n      result = (result * x) % MOD;\n    }\n    x = (x * x) % MOD;\n    y >>= 1;\n  }\n  return result;\n}\n\nint main() {\n  long long n;\n  cin >> n;\n\n  // There are 2^(n*n) total possible grids\n  long long total_grids = power(2, n * n);\n\n  // We need to account for rotations\n  long long rotations = 4; \n  if (n == 1) {\n    rotations = 1;\n  } else if (n == 2) {\n    rotations = 2;\n  }\n\n  // Calculate the number of distinct grids\n  long long distinct_grids = (total_grids / rotations) % MOD;\n\n  cout << distinct_grids << endl;\n\n  return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 12,
            "mean_time_taken": 0.21437360843022665,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Necklaces",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n \nconst int MOD = 1e9 + 7;\n \nint main() {\n  int n, m;\n  cin >> n >> m;\n \n  // Calculate the number of ways to choose the colors for the pearls.\n  long long total = 1;\n  for (int i = 0; i < n; i++) {\n    total = (total * m) % MOD;\n  }\n \n  // Calculate the number of rotations that lead to the same necklace.\n  long long rotations = n;\n \n  // Calculate the number of different necklaces.\n  long long necklaces = total / rotations;\n  \n  // The answer is the number of necklaces modulo 10^9+7.\n  cout << necklaces % MOD << endl;\n \n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 10,
            "mean_time_taken": 0.10279605388641358,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Numbers",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nlong long count_valid_numbers(long long a, long long b) {\n  // Base case: if a is greater than b, return 0\n  if (a > b) {\n    return 0;\n  }\n\n  // Convert the numbers to strings\n  string str_a = to_string(a);\n  string str_b = to_string(b);\n\n  // Initialize the count\n  long long count = 0;\n\n  // Iterate through each digit in the string of b\n  for (int i = 0; i < str_b.length(); i++) {\n    // Get the current digit\n    int digit = str_b[i] - '0';\n\n    // If the current digit is less than 9, we can increment the count\n    // as there will be 9 valid numbers starting with the current digit\n    if (digit < 9) {\n      count += 9 * pow(9, str_b.length() - i - 1);\n    } else {\n      // If the current digit is 9, we can only increment the count by 8\n      // as we can't have 99 as a valid number\n      count += 8 * pow(9, str_b.length() - i - 1);\n    }\n\n    // If the current digit is greater than the corresponding digit in a, we\n    // need to subtract the count of invalid numbers starting with the current\n    // digit in a\n    if (i < str_a.length() && digit > str_a[i] - '0') {\n      count -= pow(9, str_b.length() - i - 1);\n    }\n\n    // If the current digit is equal to the corresponding digit in a, we need\n    // to subtract the count of invalid numbers starting with the current\n    // digit in a and less than or equal to the current digit in b\n    if (i < str_a.length() && digit == str_a[i] - '0') {\n      count -= count_valid_numbers(stoll(str_a.substr(i + 1)), stoll(str_b.substr(i + 1)));\n    }\n  }\n\n  // Return the count\n  return count;\n}\n\nint main() {\n  // Read the input\n  long long a, b;\n  cin >> a >> b;\n\n  // Calculate and print the answer\n  cout << count_valid_numbers(a, b) << endl;\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Counting Paths",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<int> subtreeSize;\nvector<int> pathCount;\n\nvoid dfs(int u, int parent) {\n    subtreeSize[u] = 1;\n    for (int v : adj[u]) {\n        if (v != parent) {\n            dfs(v, u);\n            subtreeSize[u] += subtreeSize[v];\n        }\n    }\n}\n\nvoid countPaths(int a, int b) {\n    dfs(a, -1);\n    dfs(b, -1);\n\n    for (int u = 1; u <= adj.size(); u++) {\n        pathCount[u] += subtreeSize[u] * subtreeSize[b];\n        pathCount[u] += subtreeSize[u] * subtreeSize[a];\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    adj.resize(n + 1);\n    subtreeSize.resize(n + 1);\n    pathCount.resize(n + 1, 0);\n\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        countPaths(a, b);\n    }\n\n    for (int i = 1; i <= n; i++) {\n        cout << pathCount[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 13,
            "mean_time_taken": 0.46814834154569185,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Patterns",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint main() {\n  string s;\n  cin >> s;\n\n  int k;\n  cin >> k;\n\n  vector<string> patterns(k);\n  for (int i = 0; i < k; ++i) {\n    cin >> patterns[i];\n  }\n\n  unordered_map<string, int> counts;\n  for (int i = 0; i < s.size(); ++i) {\n    for (int j = 0; j < k; ++j) {\n      if (i + patterns[j].size() <= s.size() && s.substr(i, patterns[j].size()) == patterns[j]) {\n        counts[patterns[j]]++;\n      }\n    }\n  }\n\n  for (int i = 0; i < k; ++i) {\n    cout << counts[patterns[i]] << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 11,
            "mean_time_taken": 0.8079247257926248,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                7,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Reorders",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n  string s;\n  cin >> s;\n\n  // Count the frequency of each character.\n  vector<int> freq(26, 0);\n  for (char c : s) {\n    freq[c - 'a']++;\n  }\n\n  // Calculate the number of ways to reorder the characters.\n  long long result = 1;\n  for (int i = 0; i < 26; i++) {\n    if (freq[i] > 1) {\n      // If there are multiple occurrences of a character, we need to divide by the number of ways to reorder them.\n      result = (result * (freq[i] * (freq[i] - 1) / 2)) % MOD;\n      freq[i] = 1;\n    }\n    // For each character, we can place it in any of the remaining positions.\n    result = (result * freq[i]) % MOD;\n  }\n\n  cout << result << endl;\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 9,
            "mean_time_taken": 0.26664341820610893,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Rooms",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint n, m;\nvector<vector<char>> grid;\nvector<vector<bool>> visited;\n\nvoid dfs(int row, int col) {\n  if (row < 0 || row >= n || col < 0 || col >= m || grid[row][col] == '#' || visited[row][col]) {\n    return;\n  }\n\n  visited[row][col] = true;\n\n  dfs(row + 1, col);\n  dfs(row - 1, col);\n  dfs(row, col + 1);\n  dfs(row, col - 1);\n}\n\nint countRooms() {\n  int rooms = 0;\n\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      if (grid[i][j] == '.' && !visited[i][j]) {\n        dfs(i, j);\n        rooms++;\n      }\n    }\n  }\n\n  return rooms;\n}\n\nint main() {\n  cin >> n >> m;\n  grid.resize(n, vector<char>(m));\n  visited.resize(n, vector<bool>(m, false));\n\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      cin >> grid[i][j];\n    }\n  }\n\n  cout << countRooms() << endl;\n\n  return 0;\n}",
            "passed_test_cases": 15,
            "total_test_cases": 19,
            "mean_time_taken": 0.23028012325889186,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                7,
                8,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Sequences",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint count_sequences(int n, int k, int used, vector<vector<int>> &memo) {\n    if (n == 0) {\n        return 1;\n    }\n    if (memo[n][used] != -1) {\n        return memo[n][used];\n    }\n    int count = 0;\n    for (int i = 1; i <= k; ++i) {\n        if ((used & (1 << (i - 1))) == 0) {\n            count = (count + count_sequences(n - 1, k, used | (1 << (i - 1)), memo)) % MOD;\n        }\n    }\n    memo[n][used] = count;\n    return count;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<vector<int>> memo(n + 1, vector<int>(1 << k, -1));\n    cout << count_sequences(n, k, 0, memo) << endl;\n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 10,
            "mean_time_taken": 0.13187382221221924,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                6,
                7,
                8,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Tilings",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  // Create a 2D vector to store the number of ways to tile a grid of size i x j\n  vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\n\n  // Base cases:\n  // If the width is 0, there's only 1 way to tile it (no tiles)\n  for (int i = 0; i <= n; i++) {\n    dp[i][0] = 1;\n  }\n  // If the height is 0, there's only 1 way to tile it (no tiles)\n  for (int j = 0; j <= m; j++) {\n    dp[0][j] = 1;\n  }\n\n  // Iterate through all possible grid sizes\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      // We can tile a grid of size i x j in two ways:\n      // 1. Place a horizontal tile at the bottom, leaving a grid of size (i-1) x j to tile\n      // 2. Place a vertical tile at the right, leaving a grid of size i x (j-1) to tile\n      dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD;\n    }\n  }\n\n  cout << dp[n][m] << endl;\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.19362540245056153,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Counting Towers",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main() {\n  int t;\n  cin >> t;\n\n  while (t--) {\n    int n;\n    cin >> n;\n\n    // Initialize DP array: dp[i] stores the number of towers of height i\n    long long dp[n + 1];\n    dp[0] = 1;\n    dp[1] = 2;\n\n    // Fill DP array using a bottom-up approach\n    for (int i = 2; i <= n; i++) {\n      dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 2]) % MOD; // Add the three possible configurations:\n                                                      //  1. One block on top of a tower of height i-1\n                                                      //  2. Two blocks on top of a tower of height i-2\n                                                      //  3. Two blocks on top of a tower of height i-2, rotated\n    }\n\n    cout << dp[n] << endl;\n  }\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.19479870796203613,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Course Schedule",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n// Function to check if a course can be taken\nbool canTakeCourse(const vector<vector<int>>& adj, vector<int>& indegree, int course) {\n    return indegree[course] == 0;\n}\n\n// Function to find a valid course order using Kahn's Algorithm\nvector<int> findCourseOrder(const vector<vector<int>>& adj, vector<int>& indegree) {\n    vector<int> order;\n    queue<int> q;\n\n    // Add courses with no prerequisites to the queue\n    for (int i = 1; i <= adj.size(); ++i) {\n        if (canTakeCourse(adj, indegree, i)) {\n            q.push(i);\n        }\n    }\n\n    while (!q.empty()) {\n        int course = q.front();\n        q.pop();\n        order.push_back(course);\n\n        // Decrement the indegree of all courses that depend on this course\n        for (int neighbor : adj[course]) {\n            if (--indegree[neighbor] == 0) {\n                q.push(neighbor);\n            }\n        }\n    }\n\n    // Check if all courses were included in the order\n    if (order.size() == adj.size()) {\n        return order;\n    } else {\n        return {}; // No valid order exists\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    // Create an adjacency list to represent course dependencies\n    vector<vector<int>> adj(n + 1);\n    // Initialize indegree array to store the number of prerequisites for each course\n    vector<int> indegree(n + 1, 0);\n\n    // Read the course requirements\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        ++indegree[b];\n    }\n\n    // Find a valid course order\n    vector<int> order = findCourseOrder(adj, indegree);\n\n    // Print the result\n    if (order.empty()) {\n        cout << \"IMPOSSIBLE\" << endl;\n    } else {\n        for (int course : order) {\n            cout << course << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 16,
            "mean_time_taken": 0.2973867505788803,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Course Schedule II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nvector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n    vector<vector<int>> adjList(numCourses); // Adjacency list\n    vector<int> inDegree(numCourses, 0); // In-degree of each course\n\n    // Build the adjacency list and calculate in-degree\n    for (auto& prerequisite : prerequisites) {\n        adjList[prerequisite[1]].push_back(prerequisite[0]);\n        inDegree[prerequisite[0]]++;\n    }\n\n    queue<int> q;\n\n    // Add courses with no prerequisites to the queue\n    for (int i = 0; i < numCourses; ++i) {\n        if (inDegree[i] == 0) {\n            q.push(i);\n        }\n    }\n\n    vector<int> result;\n    while (!q.empty()) {\n        int course = q.front();\n        q.pop();\n        result.push_back(course);\n\n        for (int neighbor : adjList[course]) {\n            inDegree[neighbor]--;\n            if (inDegree[neighbor] == 0) {\n                q.push(neighbor);\n            }\n        }\n    }\n\n    // Check if there is a cycle\n    if (result.size() != numCourses) {\n        return {}; // Return an empty vector if there's a cycle\n    }\n\n    return result;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> prerequisites(m, vector<int>(2));\n    for (int i = 0; i < m; ++i) {\n        cin >> prerequisites[i][1] >> prerequisites[i][0];\n    }\n\n    vector<int> order = findOrder(n, prerequisites);\n\n    if (order.empty()) {\n        cout << \"No valid order exists\" << endl;\n    } else {\n        for (int course : order) {\n            cout << course << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.5057847797870636,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Creating Offices",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\n\nvector<int> adj[MAXN];\nint depth[MAXN];\n\nvoid dfs(int u, int p) {\n  for (int v : adj[u]) {\n    if (v != p) {\n      depth[v] = depth[u] + 1;\n      dfs(v, u);\n    }\n  }\n}\n\nint main() {\n  int n, d;\n  cin >> n >> d;\n\n  for (int i = 1; i < n; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n\n  dfs(1, 0);\n\n  int max_depth = 0;\n  for (int i = 1; i <= n; i++) {\n    max_depth = max(max_depth, depth[i]);\n  }\n\n  int k = 0;\n  for (int i = 1; i <= n; i++) {\n    if (depth[i] >= d) {\n      k++;\n    }\n  }\n\n  cout << k << endl;\n\n  int cur_depth = 0;\n  for (int i = 1; i <= n; i++) {\n    if (depth[i] >= d && cur_depth + d <= max_depth) {\n      cout << i << \" \";\n      cur_depth = depth[i];\n    }\n  }\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 22,
            "mean_time_taken": 0.17040086876262317,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 4,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Creating Strings",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    string s;\n    cin >> s;\n\n    // Sort the string to get all permutations in lexicographical order\n    sort(s.begin(), s.end());\n\n    vector<string> permutations;\n    do {\n        permutations.push_back(s);\n    } while (next_permutation(s.begin(), s.end()));\n\n    cout << permutations.size() << endl;\n    for (const auto& permutation : permutations) {\n        cout << permutation << endl;\n    }\n    return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 6,
            "mean_time_taken": 0.25405041376749676,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 5,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Creating Strings II",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nconst long long MOD = 1000000007;\n\nlong long factorial(int n) {\n  long long fact = 1;\n  for (int i = 2; i <= n; i++) {\n    fact = (fact * i) % MOD;\n  }\n  return fact;\n}\n\nint main() {\n  string s;\n  cin >> s;\n\n  unordered_map<char, int> char_count;\n  for (char c : s) {\n    char_count[c]++;\n  }\n\n  long long total_permutations = factorial(s.length());\n\n  for (auto it : char_count) {\n    total_permutations = (total_permutations * factorial(it.second)) % MOD;\n  }\n\n  cout << (total_permutations * factorial(s.length())) % MOD << endl;\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.2889678478240967,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 5,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Critical Cities",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\n\nvoid dfs(int u) {\n  visited[u] = true;\n  for (int v : adj[u]) {\n    if (!visited[v]) {\n      dfs(v);\n    }\n  }\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  adj.assign(n + 1, vector<int>());\n  visited.assign(n + 1, false);\n\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n  }\n\n  dfs(1); // Start DFS from Syrj\u00e4l\u00e4 (city 1)\n\n  vector<int> critical_cities;\n\n  // Check if each city is on every path from Syrj\u00e4l\u00e4 to Lehm\u00e4l\u00e4\n  for (int i = 1; i <= n; i++) {\n    if (visited[i] && i != 1 && i != n) {\n      critical_cities.push_back(i);\n    }\n  }\n\n  int k = critical_cities.size();\n  cout << k << endl;\n  sort(critical_cities.begin(), critical_cities.end());\n  for (int city : critical_cities) {\n    cout << city << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 14,
            "mean_time_taken": 0.1596118722643171,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 5,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Cut and Paste",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  string s;\n  cin >> s;\n\n  // Process operations\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n\n    // Extract the substring to be cut\n    string cut = s.substr(a - 1, b - a + 1);\n\n    // Remove the cut substring from the original string\n    s.erase(a - 1, b - a + 1);\n\n    // Append the cut substring to the end\n    s += cut;\n  }\n\n  // Print the final string\n  cout << s << endl;\n\n  return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 7,
            "mean_time_taken": 0.511627061026437,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Cycle Finding",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\n\n// Structure to represent an edge in the graph\nstruct Edge {\n  int to;\n  int weight;\n};\n\n// Function to detect negative cycles in the graph using Bellman-Ford algorithm\nbool findNegativeCycle(const vector<vector<Edge>>& graph, int n, vector<int>& cycle) {\n  vector<int> dist(n + 1, INF);\n  dist[1] = 0; // Assuming node 1 as the starting node\n\n  // Relax all edges n - 1 times\n  for (int i = 0; i < n - 1; ++i) {\n    for (int u = 1; u <= n; ++u) {\n      for (const auto& edge : graph[u]) {\n        if (dist[u] != INF && dist[edge.to] > dist[u] + edge.weight) {\n          dist[edge.to] = dist[u] + edge.weight;\n        }\n      }\n    }\n  }\n\n  // Check for negative cycles\n  for (int u = 1; u <= n; ++u) {\n    for (const auto& edge : graph[u]) {\n      if (dist[u] != INF && dist[edge.to] > dist[u] + edge.weight) {\n        // Negative cycle found\n        cycle.push_back(edge.to);\n        int curr = u;\n        while (curr != edge.to) {\n          cycle.push_back(curr);\n          curr = dist[curr];\n        }\n        reverse(cycle.begin(), cycle.end());\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  // Adjacency list representation of the graph\n  vector<vector<Edge>> graph(n + 1);\n  for (int i = 0; i < m; ++i) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    graph[a].push_back({b, c});\n  }\n\n  vector<int> cycle;\n  if (findNegativeCycle(graph, n, cycle)) {\n    cout << \"YES\" << endl;\n    for (int node : cycle) {\n      cout << node << \" \";\n    }\n    cout << endl;\n  } else {\n    cout << \"NO\" << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Cyclic Array",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n, k;\n  cin >> n >> k;\n  vector<int> arr(n);\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n  }\n  int current_sum = 0;\n  int subarray_count = 1;\n  for (int i = 0; i < n; i++) {\n    current_sum += arr[i];\n    if (current_sum > k) {\n      subarray_count++;\n      current_sum = arr[i];\n    }\n  }\n  cout << subarray_count << endl;\n  return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 21,
            "mean_time_taken": 0.23981899306887672,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                5,
                7,
                9,
                10,
                13,
                14,
                18,
                19
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "De Bruijn Sequence",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n// Function to generate a Gray code sequence\nvector<int> gray_code(int n) {\n    vector<int> code;\n    code.push_back(0);\n    if (n == 0) {\n        return code;\n    }\n    code.push_back(1);\n    for (int i = 1; i < n; i++) {\n        int size = code.size();\n        for (int j = size - 1; j >= 0; j--) {\n            code.push_back(code[j] | (1 << i));\n        }\n    }\n    return code;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    // Generate Gray code sequence\n    vector<int> gray_seq = gray_code(n);\n\n    // Build De Bruijn sequence\n    string de_bruijn;\n    for (int i = 0; i < (1 << n); i++) {\n        de_bruijn += bitset<15>(gray_seq[i]).to_string();\n    }\n\n    // Remove last n-1 bits\n    de_bruijn = de_bruijn.substr(0, de_bruijn.length() - (n - 1));\n\n    cout << de_bruijn << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.09229828516642252,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Dice Combinations",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main() {\n  int n;\n  cin >> n;\n\n  long long dp[7] = {0}; // Rolling array to store dp values\n  dp[0] = 1; \n\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= 6 && i - j >= 0; j++) {\n      dp[i % 7] = (dp[i % 7] + dp[(i - j) % 7]) % MOD; // Calculate dp[i] using previous values\n    }\n  }\n\n  cout << dp[n % 7] << endl; // Print the final result\n  return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 20,
            "mean_time_taken": 0.09918527603149414,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                7,
                8,
                9,
                10,
                12,
                14,
                16,
                17,
                18,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Dice Probability",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\nint main() {\n  int n, a, b;\n  cin >> n >> a >> b;\n\n  long long dp[101][601] = {0};\n  dp[0][0] = 1;\n\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= 6 * i; ++j) {\n      for (int k = 1; k <= 6; ++k) {\n        if (j >= k) {\n          dp[i][j] += dp[i - 1][j - k];\n        }\n      }\n    }\n  }\n\n  long long total_ways = 0;\n  for (int i = a; i <= b; ++i) {\n    total_ways += dp[n][i];\n  }\n\n  double probability = (double)total_ways / pow(6, n);\n\n  cout << fixed << setprecision(6) << probability << endl;\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Digit Queries",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nlong long countDigits(long long n) {\n  long long count = 0;\n  long long i = 1;\n  while (n > 0) {\n    count += (9 * pow(10, i - 1)) * i;\n    n -= pow(10, i - 1);\n    i++;\n  }\n  return count;\n}\n\nchar getDigit(long long k) {\n  long long l = 1, r = 1e18;\n  while (l <= r) {\n    long long mid = l + (r - l) / 2;\n    if (countDigits(mid) >= k) {\n      r = mid - 1;\n    } else {\n      l = mid + 1;\n    }\n  }\n  long long usedDigits = countDigits(l - 1);\n  long long remainingDigits = k - usedDigits;\n  long long numDigits = to_string(l).size();\n  return to_string(l)[remainingDigits - 1];\n}\n\nint main() {\n  int q;\n  cin >> q;\n\n  while (q--) {\n    long long k;\n    cin >> k;\n    cout << getDigit(k) << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Distance Queries",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nvector<int> adj[MAXN];\nint depth[MAXN], parent[MAXN], subtree_size[MAXN];\n\nvoid dfs(int u, int p) {\n  parent[u] = p;\n  subtree_size[u] = 1;\n  for (auto v : adj[u]) {\n    if (v != p) {\n      depth[v] = depth[u] + 1;\n      dfs(v, u);\n      subtree_size[u] += subtree_size[v];\n    }\n  }\n}\n\nint lca(int a, int b) {\n  if (depth[a] < depth[b]) swap(a, b);\n  while (depth[a] > depth[b]) {\n    a = parent[a];\n  }\n  while (a != b) {\n    a = parent[a];\n    b = parent[b];\n  }\n  return a;\n}\n\nint distance(int a, int b) {\n  int l = lca(a, b);\n  return depth[a] + depth[b] - 2 * depth[l];\n}\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n  for (int i = 1; i < n; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n  dfs(1, 0);\n  while (q--) {\n    int a, b;\n    cin >> a >> b;\n    cout << distance(a, b) << endl;\n  }\n  return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 11,
            "mean_time_taken": 0.41888026757673785,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Colors",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e5 + 5;\n\nvector<int> adj[N];\nint color[N];\nint subtree_colors[N];\n\nvoid dfs(int node, int parent) {\n  // Initialize a set to store the distinct colors in the subtree\n  set<int> distinct_colors;\n  // Iterate over the children of the current node\n  for (int child : adj[node]) {\n    if (child != parent) {\n      // Recursively call dfs to explore the subtree rooted at the child\n      dfs(child, node);\n      // Add the distinct colors from the child's subtree to the current node's set\n      distinct_colors.insert(subtree_colors[child]);\n    }\n  }\n  // Add the current node's color to the set\n  distinct_colors.insert(color[node]);\n  // Store the number of distinct colors in the subtree of the current node\n  subtree_colors[node] = distinct_colors.size();\n}\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> color[i];\n  }\n  for (int i = 1; i < n; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n  dfs(1, -1);\n  for (int i = 1; i <= n; i++) {\n    cout << subtree_colors[i] << \" \";\n  }\n  cout << endl;\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.23880899747212728,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 6,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Numbers",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <set>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  set<int> distinctValues; // Use a set to store distinct values\n\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    distinctValues.insert(x); // Inserting into a set automatically avoids duplicates\n  }\n\n  cout << distinctValues.size() << endl; // The size of the set is the number of distinct values\n\n  return 0;\n}",
            "passed_test_cases": 15,
            "total_test_cases": 15,
            "mean_time_taken": 0.15744484265645345,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Distinct Routes",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  vector<vector<int>> graph(n + 1); // Adjacency list representation of the graph\n  vector<bool> used(m + 1, false); // Tracks whether a teleporter has been used\n\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    graph[a].push_back(b);\n  }\n\n  // Perform a Depth First Search to find distinct routes\n  int days = 0;\n  queue<vector<int>> routes;\n  routes.push({1});\n\n  while (!routes.empty()) {\n    vector<int> current_route = routes.front();\n    routes.pop();\n\n    int last_room = current_route.back();\n\n    if (last_room == n) {\n      // Found a route to the destination\n      days++;\n      for (int room : current_route) {\n        cout << room << \" \";\n      }\n      cout << endl;\n    } else {\n      // Explore available teleporters from the current room\n      for (int i = 0; i < graph[last_room].size(); i++) {\n        int next_room = graph[last_room][i];\n        // Only use each teleporter once\n        if (!used[i]) {\n          used[i] = true;\n          vector<int> new_route = current_route;\n          new_route.push_back(next_room);\n          routes.push(new_route);\n          used[i] = false; // Backtrack to explore other paths\n        }\n      }\n    }\n  }\n\n  cout << days << endl;\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 18,
            "mean_time_taken": 0.37998341189490425,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                12,
                13,
                14,
                15,
                16,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Routes II",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 500;\nconst int MAXM = 1000;\n\nint n, m, k;\nvector<int> adj[MAXN + 1];\nint dist[MAXN + 1];\n\nbool bfs(int start, int end) {\n  queue<int> q;\n  q.push(start);\n  dist[start] = 0;\n\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n\n    if (u == end) {\n      return true;\n    }\n\n    for (int v : adj[u]) {\n      if (dist[v] == -1) {\n        dist[v] = dist[u] + 1;\n        q.push(v);\n      }\n    }\n  }\n  return false;\n}\n\nint main() {\n  cin >> n >> m >> k;\n\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n  }\n\n  // Calculate the minimum number of coins needed for one day\n  int minCoins = 0;\n  for (int i = 1; i <= n; i++) {\n    fill(dist + 1, dist + n + 1, -1);\n    if (bfs(1, i)) {\n      minCoins = max(minCoins, dist[i]);\n    }\n  }\n\n  // Check if it's possible to play for k days\n  if (minCoins == 0 || k * minCoins > m) {\n    cout << -1 << endl;\n    return 0;\n  }\n\n  cout << k * minCoins << endl;\n\n  // Print the routes\n  for (int i = 1; i <= k; i++) {\n    vector<int> path;\n    int current = 1;\n    int coinsUsed = 0;\n    while (current != n && coinsUsed < minCoins) {\n      path.push_back(current);\n      // Find the next room that minimizes the total coins used\n      int next = -1;\n      for (int v : adj[current]) {\n        if (dist[v] == dist[current] + 1 && next == -1) {\n          next = v;\n        } else if (dist[v] == dist[current] + 1 && dist[v] < dist[next]) {\n          next = v;\n        }\n      }\n      current = next;\n      coinsUsed++;\n    }\n    path.push_back(n);\n\n    // Print the route\n    for (int j = 0; j < path.size(); j++) {\n      if (j != 0) {\n        cout << \" \";\n      }\n      cout << path[j];\n    }\n    cout << endl;\n  }\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.39260377883911135,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Substrings",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <unordered_set>\n\nusing namespace std;\n\nint main() {\n  string s;\n  cin >> s;\n\n  // Use a set to store distinct substrings\n  unordered_set<string> substrings;\n\n  // Iterate through all possible substring lengths\n  for (int i = 1; i <= s.length(); ++i) {\n    // Iterate through all starting positions for each length\n    for (int j = 0; j <= s.length() - i; ++j) {\n      // Extract the substring\n      string sub = s.substr(j, i);\n      // Add it to the set\n      substrings.insert(sub);\n    }\n  }\n\n  // The size of the set is the number of distinct substrings\n  cout << substrings.size() << endl;\n\n  return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 7,
            "mean_time_taken": 0.9118310723985944,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distinct Values Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\n\n// Segment Tree Node\nstruct Node {\n  set<int> distinct;\n};\n\n// Segment Tree\nvector<Node> tree(4 * MAXN);\n\n// Build the segment tree\nvoid build(vector<int>& arr, int node, int start, int end) {\n  if (start == end) {\n    tree[node].distinct.insert(arr[start]);\n    return;\n  }\n\n  int mid = (start + end) / 2;\n  build(arr, 2 * node, start, mid);\n  build(arr, 2 * node + 1, mid + 1, end);\n\n  tree[node].distinct.insert(tree[2 * node].distinct.begin(), \n                             tree[2 * node].distinct.end());\n  tree[node].distinct.insert(tree[2 * node + 1].distinct.begin(),\n                             tree[2 * node + 1].distinct.end());\n}\n\n// Query the segment tree\nset<int> query(int node, int start, int end, int l, int r) {\n  if (start > r || end < l) {\n    return {};\n  }\n\n  if (start >= l && end <= r) {\n    return tree[node].distinct;\n  }\n\n  int mid = (start + end) / 2;\n  set<int> left = query(2 * node, start, mid, l, r);\n  set<int> right = query(2 * node + 1, mid + 1, end, l, r);\n\n  left.insert(right.begin(), right.end());\n  return left;\n}\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n\n  vector<int> arr(n);\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n  }\n\n  build(arr, 1, 0, n - 1);\n\n  while (q--) {\n    int a, b;\n    cin >> a >> b;\n\n    set<int> distinct = query(1, 0, n - 1, a - 1, b - 1);\n    cout << distinct.size() << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 14,
            "mean_time_taken": 0.9606210504259381,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Distributing Apples",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#define MOD 1000000007\n\nusing namespace std;\n\nlong long int fact(int n) {\n    long long int res = 1;\n    for (int i = 2; i <= n; i++) {\n        res = (res * i) % MOD;\n    }\n    return res;\n}\n\nlong long int modInverse(long long int a) {\n    return fact(MOD - 2);\n}\n\nlong long int nCr(int n, int r) {\n    if (r > n) {\n        return 0;\n    }\n    return (fact(n) * modInverse(fact(r)) * modInverse(fact(n - r))) % MOD;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    cout << nCr(m + n - 1, n - 1) << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 13,
            "mean_time_taken": 1.0859639277824988,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Divisor Analysis",
            "category": "Mathematics",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n  int n;\n  cin >> n;\n\n  long long num_divisors = 1;\n  long long sum_divisors = 1;\n  long long product_divisors = 1;\n\n  for (int i = 0; i < n; i++) {\n    long long x, k;\n    cin >> x >> k;\n\n    // Number of divisors: (k + 1)\n    num_divisors = (num_divisors * (k + 1)) % MOD;\n\n    // Sum of divisors: (x^(k+1) - 1) / (x - 1)\n    long long power = 1;\n    for (int j = 0; j <= k; j++) {\n      sum_divisors = (sum_divisors + power) % MOD;\n      power = (power * x) % MOD;\n    }\n\n    // Product of divisors: x^(k * (k + 1) / 2)\n    product_divisors = (product_divisors * (long long)pow(x, k * (k + 1) / 2)) % MOD;\n  }\n\n  cout << num_divisors << \" \" << sum_divisors << \" \" << product_divisors << endl;\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 7,
            "mean_time_taken": 1.1069069589887346,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Download Speed",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst int MAXN = 500;\nconst int INF = 1e9;\n\nvector<pair<int, int>> graph[MAXN]; // Adjacency list to represent the network\nint dist[MAXN]; // Shortest distance from the server (computer 1) to each computer\n\n// Function to perform Dijkstra's algorithm to find the shortest distances from the server\nvoid dijkstra(int start) {\n    for (int i = 1; i <= MAXN; i++) {\n        dist[i] = INF;\n    }\n    dist[start] = 0;\n\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; // Min-heap to store distances\n    pq.push({0, start});\n\n    while (!pq.empty()) {\n        int u = pq.top().second;\n        int d = pq.top().first;\n        pq.pop();\n\n        if (d > dist[u]) {\n            continue; // If current distance is greater than the stored distance, skip\n        }\n\n        for (auto edge : graph[u]) {\n            int v = edge.first;\n            int w = edge.second;\n\n            if (dist[u] + w < dist[v]) {\n                dist[v] = dist[u] + w;\n                pq.push({dist[v], v}); // Update distance and add to priority queue\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m; // Number of computers and connections\n    cin >> n >> m;\n\n    // Read connections from input\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        graph[a].push_back({b, c});\n    }\n\n    dijkstra(1); // Run Dijkstra's algorithm starting from the server (computer 1)\n\n    cout << dist[n] << endl; // Print the maximum download speed (distance from server to Kotivalo's computer)\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 21,
            "mean_time_taken": 0.0942769277663458,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                14,
                15,
                16,
                17,
                19,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Dynamic Connectivity",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Disjoint set data structure with path compression and union by rank\nclass DisjointSet {\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n    int num_components;\n\npublic:\n    // Constructor: initialize disjoint sets for each node\n    DisjointSet(int n) : parent(n), rank(n, 0), num_components(n) {\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n    }\n\n    // Find the representative of the set containing node x\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    // Union the sets containing nodes x and y\n    void merge(int x, int y) {\n        int root_x = find(x);\n        int root_y = find(y);\n        if (root_x != root_y) {\n            if (rank[root_x] < rank[root_y]) {\n                parent[root_x] = root_y;\n            } else if (rank[root_x] > rank[root_y]) {\n                parent[root_y] = root_x;\n            } else {\n                parent[root_x] = root_y;\n                rank[root_y]++;\n            }\n            num_components--;\n        }\n    }\n\n    // Return the number of connected components\n    int getComponents() {\n        return num_components;\n    }\n};\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    // Initialize disjoint set data structure\n    DisjointSet ds(n);\n\n    // Read edges and initialize the disjoint sets\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        ds.merge(a - 1, b - 1);\n    }\n\n    // Print the initial number of components\n    cout << ds.getComponents() << \" \";\n\n    // Process events\n    for (int i = 0; i < k; ++i) {\n        int t, a, b;\n        cin >> t >> a >> b;\n\n        if (t == 1) {\n            // Create a new edge\n            ds.merge(a - 1, b - 1);\n        } else if (t == 2) {\n            // Remove an existing edge (not implemented in this solution)\n            // We don't have a way to remove edges with the current data structure\n            // You'd need to use a different approach, such as an adjacency list.\n        }\n\n        // Print the number of components after the event\n        cout << ds.getComponents() << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 7,
            "mean_time_taken": 0.17438231195722306,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Dynamic Range Minimum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Segment tree node\nstruct Node {\n  int start, end;\n  int minVal;\n};\n\n// Function to build the segment tree\nvector<Node> buildTree(const vector<int>& arr, int start, int end) {\n  vector<Node> tree;\n  if (start > end) {\n    return tree;\n  }\n  Node node;\n  node.start = start;\n  node.end = end;\n  if (start == end) {\n    node.minVal = arr[start];\n  } else {\n    int mid = (start + end) / 2;\n    vector<Node> leftTree = buildTree(arr, start, mid);\n    vector<Node> rightTree = buildTree(arr, mid + 1, end);\n    node.minVal = min(leftTree[0].minVal, rightTree[0].minVal);\n    tree.insert(tree.end(), leftTree.begin(), leftTree.end());\n    tree.insert(tree.end(), rightTree.begin(), rightTree.end());\n  }\n  tree.insert(tree.begin(), node);\n  return tree;\n}\n\n// Function to update a value in the segment tree\nvoid updateTree(vector<Node>& tree, int index, int newValue, int start, int end) {\n  if (start > end) {\n    return;\n  }\n  if (start == end && start == index) {\n    tree[0].minVal = newValue;\n    return;\n  }\n  int mid = (start + end) / 2;\n  if (index <= mid) {\n    updateTree(tree, index, newValue, start, mid);\n  } else {\n    updateTree(tree, index, newValue, mid + 1, end);\n  }\n  tree[0].minVal = min(tree[1].minVal, tree[1 + (mid - start + 1)].minVal);\n}\n\n// Function to query the minimum value in a range\nint queryTree(const vector<Node>& tree, int qStart, int qEnd, int start, int end) {\n  if (qStart > end || qEnd < start) {\n    return INT_MAX;\n  }\n  if (qStart <= start && qEnd >= end) {\n    return tree[0].minVal;\n  }\n  int mid = (start + end) / 2;\n  return min(queryTree(tree, qStart, qEnd, start, mid),\n              queryTree(tree, qStart, qEnd, mid + 1, end));\n}\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n  vector<int> arr(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> arr[i];\n  }\n  vector<Node> tree = buildTree(arr, 0, n - 1);\n  while (q--) {\n    int type, k, u, a, b;\n    cin >> type;\n    if (type == 1) {\n      cin >> k >> u;\n      updateTree(tree, k - 1, u, 0, n - 1);\n    } else if (type == 2) {\n      cin >> a >> b;\n      cout << queryTree(tree, a - 1, b - 1, 0, n - 1) << endl;\n    }\n  }\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Dynamic Range Sum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Segment Tree Node Structure\nstruct Node {\n    int start, end;\n    long long sum;\n};\n\n// Function to build the Segment Tree\nvector<Node> buildTree(vector<int>& arr, int start, int end) {\n    vector<Node> tree(4 * arr.size()); // Maximum size of tree is 4n\n    int index = 1; // Starting index of tree\n\n    // Recursive function to build the tree\n    function<void(int, int, int)> build = [&](int s, int e, int idx) {\n        tree[idx].start = s;\n        tree[idx].end = e;\n\n        if (s == e) { // Base case: Leaf node\n            tree[idx].sum = arr[s];\n            return;\n        }\n\n        int mid = (s + e) / 2;\n        build(s, mid, 2 * idx);\n        build(mid + 1, e, 2 * idx + 1);\n\n        tree[idx].sum = tree[2 * idx].sum + tree[2 * idx + 1].sum;\n    };\n\n    build(start, end, index);\n    return tree;\n}\n\n// Function to update a value in the array and the tree\nvoid update(vector<Node>& tree, int index, int value) {\n    int s = tree[1].start;\n    int e = tree[1].end;\n\n    // Recursive function to update the value\n    function<void(int, int, int)> updateHelper = [&](int s, int e, int idx) {\n        if (index < s || index > e) { // If index is outside the current range\n            return;\n        }\n\n        if (s == e) { // Base case: Leaf node\n            tree[idx].sum = value;\n            return;\n        }\n\n        int mid = (s + e) / 2;\n        updateHelper(s, mid, 2 * idx);\n        updateHelper(mid + 1, e, 2 * idx + 1);\n\n        tree[idx].sum = tree[2 * idx].sum + tree[2 * idx + 1].sum;\n    };\n\n    updateHelper(s, e, 1);\n}\n\n// Function to query the sum in a given range\nlong long query(vector<Node>& tree, int l, int r) {\n    int s = tree[1].start;\n    int e = tree[1].end;\n\n    // Recursive function to query the sum\n    function<long long(int, int, int)> queryHelper = [&](int s, int e, int idx) {\n        if (l > e || r < s) { // If range is outside the current range\n            return 0;\n        }\n\n        if (l <= s && r >= e) { // If range fully overlaps current range\n            return tree[idx].sum;\n        }\n\n        int mid = (s + e) / 2;\n        return queryHelper(s, mid, 2 * idx) + queryHelper(mid + 1, e, 2 * idx + 1);\n    };\n\n    return queryHelper(s, e, 1);\n}\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    // Build the Segment Tree\n    vector<Node> tree = buildTree(arr, 0, n - 1);\n\n    // Process queries\n    for (int i = 0; i < q; i++) {\n        int type, k, u, a, b;\n        cin >> type;\n\n        if (type == 1) { // Update query\n            cin >> k >> u;\n            k--; // Adjust index to 0-based\n            update(tree, k, u);\n        } else if (type == 2) { // Query sum\n            cin >> a >> b;\n            a--; // Adjust indices to 0-based\n            b--;\n            cout << query(tree, a, b) << endl;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Edit Distance",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  string s1, s2;\n  cin >> s1 >> s2;\n\n  int n = s1.length();\n  int m = s2.length();\n\n  // Initialize the DP table\n  int dp[n + 1][m + 1];\n  for (int i = 0; i <= n; i++) {\n    dp[i][0] = i;\n  }\n  for (int j = 0; j <= m; j++) {\n    dp[0][j] = j;\n  }\n\n  // Calculate the edit distance\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      if (s1[i - 1] == s2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1];\n      } else {\n        dp[i][j] = min({dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1, dp[i][j - 1] + 1});\n      }\n    }\n  }\n\n  // Output the edit distance\n  cout << dp[n][m] << endl;\n\n  return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 17,
            "mean_time_taken": 0.30098410213694854,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                5,
                6,
                7,
                9,
                11,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Elevator Rides",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n, x;\n  cin >> n >> x;\n\n  vector<int> weights(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> weights[i];\n  }\n\n  // Sort the weights in descending order.\n  sort(weights.begin(), weights.end(), greater<int>());\n\n  // Initialize the number of rides to 0.\n  int rides = 0;\n\n  // Iterate over the people.\n  int current_weight = 0;\n  for (int i = 0; i < n; ++i) {\n    // If the current weight plus the weight of the current person exceeds the maximum allowed weight, start a new ride.\n    if (current_weight + weights[i] > x) {\n      rides++;\n      current_weight = 0;\n    }\n    // Otherwise, add the weight of the current person to the current weight.\n    current_weight += weights[i];\n  }\n\n  // If there is still a group of people waiting, increment the number of rides.\n  if (current_weight > 0) {\n    rides++;\n  }\n\n  // Print the number of rides.\n  cout << rides << endl;\n\n  return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 39,
            "mean_time_taken": 0.1252914086366311,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                6,
                7,
                8,
                9,
                10,
                11,
                13,
                16,
                17,
                18,
                19,
                20,
                22,
                23,
                24,
                25,
                26,
                28,
                30,
                31,
                32,
                35,
                36,
                38,
                39
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Empty String",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nconst long long MOD = 1e9 + 7;\n\nint main() {\n  string s;\n  cin >> s;\n\n  int n = s.size();\n  vector<long long> dp(n + 1, 0);\n  dp[0] = 1;\n\n  for (int i = 1; i <= n; ++i) {\n    dp[i] = (dp[i - 1] * 2) % MOD;\n\n    if (i > 1 && s[i - 1] == s[i - 2]) {\n      dp[i] = (dp[i] + dp[i - 2]) % MOD;\n    }\n  }\n\n  cout << dp[n] << endl;\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.09630278746287028,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Eulerian Subgraphs",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  vector<vector<int>> adj(n + 1);\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n\n  long long ans = 1;\n  for (int i = 1; i <= n; i++) {\n    if (adj[i].size() % 2 == 0) {\n      ans = (ans * 2) % MOD;\n    }\n  }\n\n  cout << ans << endl;\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 0.11673243840535481,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Even Outdegree Edges",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  // Adjacency list to store the graph\n  vector<vector<int>> adj(n + 1);\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n\n  // Check if the graph is Eulerian\n  // A graph is Eulerian if all nodes have even degree\n  for (int i = 1; i <= n; i++) {\n    if (adj[i].size() % 2 != 0) {\n      cout << \"IMPOSSIBLE\" << endl;\n      return 0;\n    }\n  }\n\n  // Create a map to store the directions of the edges\n  unordered_map<int, vector<int>> directions;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j < adj[i].size(); j++) {\n      // If the edge is not already directed\n      if (directions.find(i) == directions.end() ||\n          find(directions[i].begin(), directions[i].end(), adj[i][j]) ==\n              directions[i].end()) {\n        directions[i].push_back(adj[i][j]);\n      }\n    }\n  }\n\n  // Print the directions of the edges\n  for (auto it : directions) {\n    for (int i = 0; i < it.second.size(); i++) {\n      cout << it.first << \" \" << it.second[i] << endl;\n    }\n  }\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 7,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Exponentiation",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\n\nlong long fast_power(long long a, long long b) {\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1) {\n            res = (res * a) % MOD;\n        }\n        a = (a * a) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    while (n--) {\n        long long a, b;\n        cin >> a >> b;\n        cout << fast_power(a, b) << endl;\n    }\n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 3,
            "mean_time_taken": 0.8870474497477213,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Exponentiation II",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n \nconst long long MOD = 1e9 + 7;\n \nlong long fast_pow(long long base, long long exp) {\n  long long result = 1;\n  while (exp > 0) {\n    if (exp % 2 == 1) {\n      result = (result * base) % MOD;\n    }\n    base = (base * base) % MOD;\n    exp /= 2;\n  }\n  return result;\n}\n \nint main() {\n  int n;\n  cin >> n;\n  while (n--) {\n    long long a, b, c;\n    cin >> a >> b >> c;\n    long long result = fast_pow(a, fast_pow(b, c));\n    cout << result << endl;\n  }\n  return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 13,
            "mean_time_taken": 0.15707597365746132,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Factory Machines",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n, t;\n  cin >> n >> t;\n\n  vector<int> k(n);\n  for (int i = 0; i < n; i++) {\n    cin >> k[i];\n  }\n\n  // Sort the machines by their production time in ascending order.\n  sort(k.begin(), k.end());\n\n  // Initialize the minimum time to the maximum production time of a machine.\n  int minTime = k[n - 1];\n\n  // Iterate through the machines and update the minimum time.\n  for (int i = 0; i < n; i++) {\n    // Calculate the time it takes to produce t products using the current machine.\n    int time = k[i] * t;\n    \n    // If the current machine can produce t products faster than the current minimum time, update the minimum time.\n    if (time < minTime) {\n      minTime = time;\n    }\n  }\n\n  // Print the minimum time.\n  cout << minTime << endl;\n\n  return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 18,
            "mean_time_taken": 0.17877643638186985,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                8,
                9,
                10,
                11,
                12,
                13,
                15,
                17,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 8,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Ferris Wheel",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n, x;\n  cin >> n >> x;\n\n  vector<int> weights(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> weights[i];\n  }\n\n  // Sort the weights in descending order.\n  sort(weights.begin(), weights.end(), greater<int>());\n\n  int gondolas = 0;\n  int i = 0;\n  int j = n - 1;\n\n  // Iterate through the weights, pairing the heaviest and lightest children.\n  while (i <= j) {\n    // If the heaviest and lightest child can fit in a gondola, pair them.\n    if (weights[i] + weights[j] <= x) {\n      i++;\n      j--;\n    } else {\n      // Otherwise, the heaviest child needs their own gondola.\n      i++;\n    }\n    gondolas++;\n  }\n\n  cout << gondolas << endl;\n\n  return 0;\n}",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.23003163704505333,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Fibonacci Numbers",
            "category": "Mathematics",
            "solution": "#include <iostream>\n\nusing namespace std;\n\nconst long long MOD = 1e9 + 7;\n\nlong long fib(long long n) {\n    if (n == 0) {\n        return 0;\n    } else if (n == 1) {\n        return 1;\n    } else {\n        long long prev = 0;\n        long long curr = 1;\n        for (long long i = 2; i <= n; i++) {\n            long long next = (prev + curr) % MOD;\n            prev = curr;\n            curr = next;\n        }\n        return curr;\n    }\n}\n\nint main() {\n    long long n;\n    cin >> n;\n    cout << fib(n) << endl;\n    return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 12,
            "mean_time_taken": 0.6762685974438986,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                7,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Filling Trominos",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nchar grid[101][101]; // Grid to store tromino placements\nint n, m;\n\n// Function to check if a position is valid for placing a tromino\nbool isValid(int x, int y) {\n  return (x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == '.'); \n}\n\n// Function to place an L-tromino at a given position\nvoid placeTromino(int x, int y, char ch) {\n  grid[x][y] = ch;\n  grid[x + 1][y] = ch; \n  grid[x][y + 1] = ch;\n}\n\n// Recursive function to fill the grid with L-trominos\nbool fillGrid(int x, int y, char ch) {\n  if (x == n) return true; // Base case: reached the bottom row\n\n  // If we reach the end of a row, move to the next row\n  if (y == m) return fillGrid(x + 1, 0, ch);\n\n  // If the current square is already filled, move to the next square\n  if (grid[x][y] != '.') return fillGrid(x, y + 1, ch);\n\n  // Try placing the tromino in all four possible orientations\n  for (int i = 0; i < 4; i++) {\n    // Position 1: Horizontal\n    if (isValid(x, y) && isValid(x, y + 1) && isValid(x + 1, y)) {\n      placeTromino(x, y, ch);\n      if (fillGrid(x, y + 1, ch)) return true;\n      // Backtrack if placement leads to failure\n      placeTromino(x, y, '.');\n    }\n\n    // Position 2: Vertical\n    if (isValid(x, y) && isValid(x + 1, y) && isValid(x, y + 1)) {\n      placeTromino(x, y, ch);\n      if (fillGrid(x, y + 1, ch)) return true;\n      placeTromino(x, y, '.');\n    }\n\n    // Position 3: Diagonal (Top-Left to Bottom-Right)\n    if (isValid(x, y) && isValid(x + 1, y + 1) && isValid(x + 1, y)) {\n      placeTromino(x, y, ch);\n      if (fillGrid(x, y + 1, ch)) return true;\n      placeTromino(x, y, '.');\n    }\n\n    // Position 4: Diagonal (Top-Right to Bottom-Left)\n    if (isValid(x, y) && isValid(x + 1, y) && isValid(x, y + 1)) {\n      placeTromino(x, y, ch);\n      if (fillGrid(x, y + 1, ch)) return true;\n      placeTromino(x, y, '.');\n    }\n\n    // Rotate the tromino for the next orientation\n    char temp = grid[x + 1][y];\n    grid[x + 1][y] = grid[x][y + 1];\n    grid[x][y + 1] = grid[x][y];\n    grid[x][y] = temp;\n  }\n\n  return false; // If no valid position found\n}\n\nint main() {\n  int t;\n  cin >> t;\n\n  while (t--) {\n    cin >> n >> m;\n\n    // Check feasibility\n    if ((n % 3 != 0 || m % 3 != 0) || (n % 2 == 1 && m % 2 == 1)) {\n      cout << \"NO\" << endl;\n      continue;\n    }\n\n    // Initialize the grid\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        grid[i][j] = '.';\n      }\n    }\n\n    // Fill the grid with trominos\n    char ch = 'A';\n    if (fillGrid(0, 0, ch)) {\n      cout << \"YES\" << endl;\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n          cout << grid[i][j];\n        }\n        cout << endl;\n      }\n    } else {\n      cout << \"NO\" << endl;\n    }\n  }\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 1.106995403766632,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding Borders",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> borders(string s) {\n  int n = s.size();\n  vector<int> b(n + 1, 0);\n  for (int i = 1; i < n; ++i) {\n    int j = b[i];\n    while (j > 0 && s[i] != s[j]) {\n      j = b[j];\n    }\n    if (s[i] == s[j]) {\n      j++;\n    }\n    b[i + 1] = j;\n  }\n  vector<int> result;\n  for (int i = 1; i < n; ++i) {\n    if (b[i] > 0) {\n      result.push_back(b[i]);\n    }\n  }\n  return result;\n}\n\nint main() {\n  string s;\n  cin >> s;\n  vector<int> border_lengths = borders(s);\n  for (int i = 0; i < border_lengths.size(); ++i) {\n    cout << border_lengths[i] << \" \";\n  }\n  cout << endl;\n  return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 11,
            "mean_time_taken": 0.12461363185535777,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding Patterns",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  string s;\n  cin >> s;\n  int k;\n  cin >> k;\n\n  vector<string> patterns(k);\n  for (int i = 0; i < k; ++i) {\n    cin >> patterns[i];\n  }\n\n  for (int i = 0; i < k; ++i) {\n    if (s.find(patterns[i]) != string::npos) {\n      cout << \"YES\" << endl;\n    } else {\n      cout << \"NO\" << endl;\n    }\n  }\n\n  return 0;\n}",
            "passed_test_cases": 15,
            "total_test_cases": 17,
            "mean_time_taken": 0.4166585136862362,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                8,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding Periods",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> find_periods(string s) {\n  int n = s.size();\n  vector<int> periods;\n  for (int i = 1; i <= n; ++i) {\n    if (n % i == 0) {\n      bool is_period = true;\n      for (int j = 0; j < n - i; ++j) {\n        if (s[j] != s[j + i]) {\n          is_period = false;\n          break;\n        }\n      }\n      if (is_period) {\n        periods.push_back(i);\n      }\n    }\n  }\n  return periods;\n}\n\nint main() {\n  string s;\n  cin >> s;\n  vector<int> periods = find_periods(s);\n  for (int period : periods) {\n    cout << period << \" \";\n  }\n  cout << endl;\n  return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 14,
            "mean_time_taken": 0.13970538548060826,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                8,
                9,
                10,
                11,
                12,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Finding a Centroid",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\n\nvector<int> adj[MAXN];\nint sz[MAXN];\n\n// Function to calculate the size of a subtree rooted at a given node.\nint dfs(int u, int p) {\n    sz[u] = 1;\n    for (int v : adj[u]) {\n        if (v != p) {\n            sz[u] += dfs(v, u);\n        }\n    }\n    return sz[u];\n}\n\n// Function to find a centroid of the tree.\nint findCentroid(int u, int p, int n) {\n    for (int v : adj[u]) {\n        if (v != p && sz[v] > n / 2) {\n            return findCentroid(v, u, n);\n        }\n    }\n    return u;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    for (int i = 1; i < n; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    // Calculate the size of each subtree.\n    dfs(1, 0);\n\n    // Find a centroid.\n    int centroid = findCentroid(1, 0, n);\n\n    cout << centroid << endl;\n\n    return 0;\n}",
            "passed_test_cases": 14,
            "total_test_cases": 16,
            "mean_time_taken": 0.15537627041339874,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                5,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Fixed-Length Paths I",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\n\nvector<int> adj[MAXN];\nint dp[MAXN][MAXN];\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    // Base case: paths of length 1\n    for (int i = 1; i <= n; i++) {\n        dp[i][1] = adj[i].size();\n    }\n\n    // Calculate paths of length 2 to k\n    for (int i = 2; i <= k; i++) {\n        for (int u = 1; u <= n; u++) {\n            for (int v : adj[u]) {\n                dp[u][i] += dp[v][i - 1];\n            }\n        }\n    }\n\n    // Calculate total paths of length k\n    int total_paths = 0;\n    for (int i = 1; i <= n; i++) {\n        total_paths += dp[i][k];\n    }\n\n    cout << total_paths << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Fixed-Length Paths II",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e5 + 5;\n\nvector<int> adj[N];\nint dp[N][N]; // dp[i][j] = number of paths starting from node i with length j\n\nvoid dfs(int u, int p) {\n  dp[u][0] = 1; // Base case: path of length 0 from u to u\n  for (auto v : adj[u]) {\n    if (v != p) {\n      dfs(v, u);\n      for (int j = 1; j <= N; j++) {\n        dp[u][j] += dp[v][j - 1]; // Add paths starting from v with length j-1 to paths starting from u with length j\n      }\n    }\n  }\n}\n\nint main() {\n  int n, k1, k2;\n  cin >> n >> k1 >> k2;\n\n  for (int i = 0; i < n - 1; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n\n  dfs(1, 0); // Start DFS from any node, e.g., node 1\n\n  long long ans = 0;\n  for (int i = 1; i <= n; i++) {\n    for (int j = k1; j <= k2; j++) {\n      ans += dp[i][j]; // Count paths with length between k1 and k2\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Flight Discount",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n// Structure to represent a flight\nstruct Flight {\n  int city;  // Destination city\n  int price; // Flight price\n};\n\n// Function to find the minimum-price flight route from Syrj\u00e4l\u00e4 to Mets\u00e4l\u00e4\nint findMinPriceRoute(int n, vector<vector<Flight>>& graph) {\n  // Initialize distance array with maximum value\n  vector<int> distance(n + 1, INT_MAX);\n  // Create a priority queue to store flights\n  priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n\n  // Initialize the starting city distance\n  distance[1] = 0;\n  // Push the starting city into the priority queue\n  pq.push({0, 1});\n\n  // Iterate through the priority queue\n  while (!pq.empty()) {\n    // Get the flight with minimum price\n    auto [curr_price, curr_city] = pq.top();\n    pq.pop();\n\n    // If the current city is Mets\u00e4l\u00e4, we found the minimum price route\n    if (curr_city == n) {\n      return curr_price;\n    }\n\n    // Iterate through all the flights from the current city\n    for (auto& flight : graph[curr_city]) {\n      // Calculate the new price after applying the discount\n      int new_price = flight.price / 2;\n\n      // Compare the new price with the current price and update the distance\n      if (curr_price + new_price < distance[flight.city]) {\n        distance[flight.city] = curr_price + new_price;\n        // Push the new flight into the priority queue\n        pq.push({curr_price + new_price, flight.city});\n      } else if (curr_price + flight.price < distance[flight.city]) {\n        // If the discount doesn't improve the price, use the original price\n        distance[flight.city] = curr_price + flight.price;\n        // Push the new flight into the priority queue\n        pq.push({curr_price + flight.price, flight.city});\n      }\n    }\n  }\n\n  // Return the minimum price\n  return distance[n];\n}\n\nint main() {\n  // Input the number of cities and flight connections\n  int n, m;\n  cin >> n >> m;\n\n  // Create a graph to store flight connections\n  vector<vector<Flight>> graph(n + 1);\n\n  // Input the flight connections\n  for (int i = 0; i < m; ++i) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    graph[a].push_back({b, c});\n  }\n\n  // Find the minimum price route\n  int min_price = findMinPriceRoute(n, graph);\n\n  // Print the minimum price\n  cout << min_price << endl;\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Flight Route Requests",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    // Adjacency list to represent the graph\n    vector<vector<int>> adj(n + 1);\n\n    // Map to store the number of incoming edges for each node\n    unordered_map<int, int> in_degree;\n\n    // Read the flight requests\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        in_degree[b]++;\n    }\n\n    // Initialize a queue to perform topological sort\n    queue<int> q;\n\n    // Add nodes with 0 in-degree to the queue\n    for (int i = 1; i <= n; i++) {\n        if (in_degree[i] == 0) {\n            q.push(i);\n        }\n    }\n\n    // Initialize the count of flight connections\n    int connections = 0;\n\n    // Perform topological sort\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        connections++;\n\n        // Decrement the in-degree of adjacent nodes\n        for (int v : adj[u]) {\n            if (--in_degree[v] == 0) {\n                q.push(v);\n            }\n        }\n    }\n\n    // Print the minimum number of flight connections\n    cout << connections << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 17,
            "mean_time_taken": 0.11910671346327838,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Flight Routes",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct Route {\n  int price;\n  vector<int> path;\n\n  bool operator<(const Route& other) const {\n    return price > other.price;  // Min-heap based on price\n  }\n};\n\nvector<int> findKShortestRoutes(int n, int m, int k, const vector<vector<int>>& flights) {\n  vector<vector<pair<int, int>>> adjList(n + 1);  // Adjacency list for flights\n  for (const auto& flight : flights) {\n    adjList[flight[0]].push_back({flight[1], flight[2]});\n  }\n\n  priority_queue<Route> minHeap;\n  minHeap.push({0, {1}});  // Starting route with price 0 from city 1\n\n  vector<int> kShortestPrices;\n  while (kShortestPrices.size() < k && !minHeap.empty()) {\n    Route current = minHeap.top();\n    minHeap.pop();\n\n    if (current.path.back() == n) {  // Reached Mets\u00e4l\u00e4\n      kShortestPrices.push_back(current.price);\n    } else {\n      for (const auto& neighbor : adjList[current.path.back()]) {\n        vector<int> newPath = current.path;\n        newPath.push_back(neighbor.first);\n        minHeap.push({current.price + neighbor.second, newPath});\n      }\n    }\n  }\n\n  return kShortestPrices;\n}\n\nint main() {\n  int n, m, k;\n  cin >> n >> m >> k;\n\n  vector<vector<int>> flights(m, vector<int>(3));\n  for (int i = 0; i < m; ++i) {\n    cin >> flights[i][0] >> flights[i][1] >> flights[i][2];\n  }\n\n  vector<int> kShortestPrices = findKShortestRoutes(n, m, k, flights);\n\n  for (int price : kShortestPrices) {\n    cout << price << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 17,
            "mean_time_taken": 0.8109964202432072,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                5,
                6,
                7,
                8,
                9,
                11,
                12,
                14,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Flight Routes Check",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n// Function to perform Depth First Search (DFS) from a given source node\nvoid dfs(int node, vector<vector<int>> &adj, vector<bool> &visited) {\n    visited[node] = true;\n    for (int neighbor : adj[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, adj, visited);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    // Adjacency list to represent the graph\n    vector<vector<int>> adj(n + 1);\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b); // Directed edge from a to b\n    }\n\n    // Check if all cities are reachable from any starting city using DFS\n    vector<bool> visited(n + 1, false);\n    dfs(1, adj, visited); // Start DFS from city 1\n\n    bool all_connected = true;\n    int unreachable_city = -1;\n\n    // Find a city that is not reachable from city 1\n    for (int i = 1; i <= n; ++i) {\n        if (!visited[i]) {\n            all_connected = false;\n            unreachable_city = i;\n            break;\n        }\n    }\n\n    if (all_connected) {\n        cout << \"YES\" << endl;\n    } else {\n        cout << \"NO\" << endl;\n        cout << unreachable_city << \" \" << 1 << endl; // Print unreachable city and any other city\n    }\n\n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 20,
            "mean_time_taken": 0.13064813613891602,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                18,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Food Division",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<int> a(n), b(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n  for (int i = 0; i < n; ++i) {\n    cin >> b[i];\n  }\n\n  // Calculate the net difference between desired and current food for each child\n  vector<int> diff(n);\n  for (int i = 0; i < n; ++i) {\n    diff[i] = b[i] - a[i];\n  }\n\n  // Calculate the total net difference (which should be zero)\n  int totalDiff = 0;\n  for (int i = 0; i < n; ++i) {\n    totalDiff += diff[i];\n  }\n\n  // If the total difference is not zero, there is no solution\n  if (totalDiff != 0) {\n    cout << \"-1\" << endl;\n    return 0;\n  }\n\n  // Calculate the minimum number of steps needed\n  int steps = 0;\n  for (int i = 0; i < n; ++i) {\n    steps += abs(diff[i]);\n  }\n  steps /= 2;\n\n  cout << steps << endl;\n  return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 5,
            "mean_time_taken": 0.3536396503448486,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Forbidden Cities",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\n\nvector<int> adj[MAXN];\nbool visited[MAXN];\n\n// Function to perform a BFS from a starting node and check if it reaches the destination without passing through a forbidden node.\nbool bfs(int start, int dest, int forbidden) {\n    queue<int> q;\n    q.push(start);\n    visited[start] = true;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        if (u == dest) {\n            return true;\n        }\n\n        for (int v : adj[u]) {\n            if (!visited[v] && v != forbidden) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n\n    // Read the edges (roads)\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    // Process each query\n    for (int i = 0; i < q; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n\n        // Reset visited array for each query\n        fill(visited, visited + n + 1, false);\n\n        // Perform BFS to check if there's a path from a to b without visiting c\n        if (bfs(a, b, c)) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 8,
            "total_test_cases": 14,
            "mean_time_taken": 0.46419874259403776,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                5,
                6,
                8,
                10,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 9,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Forest Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n\n  // Read the forest grid\n  vector<vector<char>> forest(n, vector<char>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      cin >> forest[i][j];\n    }\n  }\n\n  // Create a 2D prefix sum array to store the number of trees up to each point\n  vector<vector<int>> prefixSum(n + 1, vector<int>(n + 1, 0));\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      prefixSum[i][j] = prefixSum[i - 1][j] + prefixSum[i][j - 1] - prefixSum[i - 1][j - 1];\n      if (forest[i - 1][j - 1] == '*') {\n        prefixSum[i][j]++;\n      }\n    }\n  }\n\n  // Process queries\n  for (int i = 0; i < q; i++) {\n    int y1, x1, y2, x2;\n    cin >> y1 >> x1 >> y2 >> x2;\n\n    // Calculate the number of trees in the rectangle\n    int count = prefixSum[y2][x2] - prefixSum[y1 - 1][x2] - prefixSum[y2][x1 - 1] + prefixSum[y1 - 1][x1 - 1];\n\n    cout << count << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 3,
            "mean_time_taken": 0.22371904055277506,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Forest Queries II",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAXN = 1000;\n\nint n, q;\nchar forest[MAXN][MAXN];\nint tree_count[MAXN][MAXN]; // tree_count[i][j] = number of trees in the rectangle (1, 1) to (i, j)\n\n// Function to calculate the number of trees in the rectangle (y1, x1) to (y2, x2)\nint count_trees(int y1, int x1, int y2, int x2) {\n  return tree_count[y2][x2] - tree_count[y1 - 1][x2] - tree_count[y2][x1 - 1] + tree_count[y1 - 1][x1 - 1];\n}\n\nint main() {\n  cin >> n >> q;\n\n  // Read the forest\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      cin >> forest[i][j];\n      tree_count[i][j] = tree_count[i - 1][j] + tree_count[i][j - 1] - tree_count[i - 1][j - 1] + (forest[i][j] == '*');\n    }\n  }\n\n  // Process queries\n  for (int i = 0; i < q; i++) {\n    int type, y, x, y1, x1, y2, x2;\n    cin >> type;\n\n    if (type == 1) {\n      cin >> y >> x;\n      forest[y][x] = (forest[y][x] == '*') ? '.' : '*';\n      tree_count[y][x] = tree_count[y - 1][x] + tree_count[y][x - 1] - tree_count[y - 1][x - 1] + (forest[y][x] == '*');\n    } else if (type == 2) {\n      cin >> y1 >> x1 >> y2 >> x2;\n      cout << count_trees(y1, x1, y2, x2) << endl;\n    }\n  }\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 5,
            "mean_time_taken": 0.7579700469970703,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Functional Graph Distribution",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int MAXN = 5000;\n\nint dp[MAXN + 1][MAXN + 1]; // dp[i][j] is the number of functional graphs with i nodes and j components\n\nint main() {\n  int n;\n  cin >> n;\n\n  // Base case: dp[1][1] = 1 (only one graph with 1 node and 1 component)\n  dp[1][1] = 1;\n\n  // Iterate over all possible number of nodes (i)\n  for (int i = 2; i <= n; i++) {\n    // Iterate over all possible number of components (j)\n    for (int j = 1; j <= i; j++) {\n      // If we add a new node to an existing component, we can connect it to any of the existing nodes in that component\n      dp[i][j] = (dp[i][j] + (long long)dp[i - 1][j] * (i - 1)) % MOD;\n\n      // If we create a new component, we can connect the new node to any of the existing nodes\n      if (j > 1) {\n        dp[i][j] = (dp[i][j] + (long long)dp[i - 1][j - 1] * (i - 1)) % MOD;\n      }\n    }\n  }\n\n  // Print the number of graphs for each possible number of components\n  for (int k = 1; k <= n; k++) {\n    cout << dp[n][k] << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 0.11379173398017883,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Game Routes",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7; \n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    // Adjacency list to store teleporters\n    vector<vector<int>> adj(n + 1);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n\n    // Dynamic programming array\n    vector<long long> dp(n + 1, 0); // Use long long to prevent overflow\n    dp[1] = 1;\n\n    // Calculate paths for each level\n    for (int i = 2; i <= n; i++) {\n        for (int j = 0; j < adj[i].size(); j++) {\n            dp[i] = (dp[i] + dp[adj[i][j]]) % MOD; // Modulo after addition\n        }\n    }\n\n    cout << dp[n] << endl;\n    return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 15,
            "mean_time_taken": 0.14287060101826984,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Giant Pizza",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  vector<vector<int>> wishes(m + 1, vector<int>(2, 0)); // wishes[topping][0] = +1 if good, -1 if bad, 0 if not mentioned\n  for (int i = 0; i < n; i++) {\n    char sign;\n    int topping;\n    cin >> sign >> topping;\n    if (sign == '+') {\n      wishes[topping][0]++;\n    } else {\n      wishes[topping][1]++;\n    }\n  }\n\n  // Check if there is at least one wish for each topping\n  for (int i = 1; i <= m; i++) {\n    if (wishes[i][0] == 0 && wishes[i][1] == 0) {\n      cout << \"IMPOSSIBLE\" << endl;\n      return 0;\n    }\n  }\n\n  // Choose toppings to satisfy at least one wish per family member\n  string pizza(m, '-'); // Initialize pizza with all toppings excluded\n  for (int i = 1; i <= m; i++) {\n    // If there are more good wishes than bad wishes, include the topping\n    if (wishes[i][0] > wishes[i][1]) {\n      pizza[i - 1] = '+';\n    } \n    // Otherwise, exclude the topping\n    else {\n      pizza[i - 1] = '-';\n    }\n  }\n\n  cout << pizza << endl;\n\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 22,
            "mean_time_taken": 0.1761707284233787,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                22
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Graph Girth",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\n\n// Function to find the girth (shortest cycle) of an undirected graph\nint findGirth(const vector<vector<int>>& graph) {\n    int n = graph.size();\n    vector<int> distance(n, INF); // Initialize distances to infinity\n    vector<bool> visited(n, false); // Initialize visited status to false\n\n    // Iterate through each node as the starting point for BFS\n    for (int i = 0; i < n; i++) {\n        // If the node hasn't been visited yet\n        if (!visited[i]) {\n            // Perform Breadth-First Search (BFS) from the current node\n            queue<pair<int, int>> q; // Queue for BFS\n            q.push({i, 0}); // Push the starting node with distance 0\n            distance[i] = 0; // Set the starting node's distance to 0\n            visited[i] = true; // Mark the starting node as visited\n\n            while (!q.empty()) {\n                int u = q.front().first;\n                int d = q.front().second;\n                q.pop();\n\n                // Iterate through all neighbors of the current node\n                for (int v : graph[u]) {\n                    // If the neighbor has not been visited\n                    if (!visited[v]) {\n                        // Update the distance of the neighbor\n                        distance[v] = d + 1;\n                        // Push the neighbor into the queue\n                        q.push({v, distance[v]});\n                        // Mark the neighbor as visited\n                        visited[v] = true;\n                    } else if (v != i && distance[v] == d + 1) {\n                        // If the neighbor is already visited and its distance is d + 1,\n                        // we've found a cycle with length d + 2\n                        return d + 2;\n                    }\n                }\n            }\n        }\n    }\n\n    // If no cycles are found, return -1\n    return -1;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    // Adjacency list representation of the graph\n    vector<vector<int>> graph(n + 1);\n\n    // Read the edges and populate the adjacency list\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        graph[b].push_back(a); // Undirected graph\n    }\n\n    // Find the girth of the graph\n    int girth = findGirth(graph);\n\n    // Print the girth\n    cout << girth << endl;\n\n    return 0;\n}",
            "passed_test_cases": 8,
            "total_test_cases": 20,
            "mean_time_taken": 0.09353833198547364,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                5,
                6,
                7,
                9,
                11,
                12,
                16,
                17,
                18,
                19
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Graph Paths I",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n  int n, m, k;\n  cin >> n >> m >> k;\n\n  // Adjacency matrix representation of the graph\n  vector<vector<bool>> adj(n + 1, vector<bool>(n + 1, false));\n\n  // Read the edges\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a][b] = true;\n  }\n\n  // DP table to store the number of paths\n  vector<vector<int>> dp(k + 1, vector<int>(n + 1, 0));\n\n  // Base case: 0 edges, only 1 path from node 1 to itself\n  dp[0][1] = 1;\n\n  // Iterate over the number of edges\n  for (int i = 1; i <= k; i++) {\n    // Iterate over the destination node\n    for (int j = 1; j <= n; j++) {\n      // Iterate over the source node\n      for (int l = 1; l <= n; l++) {\n        // If there is an edge from node l to node j\n        if (adj[l][j]) {\n          // Update the DP table\n          dp[i][j] = (dp[i][j] + dp[i - 1][l]) % MOD;\n        }\n      }\n    }\n  }\n\n  // Print the number of paths from node 1 to node n with k edges\n  cout << dp[k][n] << endl;\n\n  return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 14,
            "mean_time_taken": 0.22830399445125035,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                7,
                8,
                10,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Graph Paths II",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <limits>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    // Adjacency list to store the graph\n    vector<vector<pair<int, int>>> adj(n + 1);\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        adj[a].push_back({b, c});\n    }\n\n    // Initialize the DP table\n    vector<vector<int>> dp(k + 1, vector<int>(n + 1, INF));\n    dp[0][1] = 0;\n\n    // Iterate through the number of edges\n    for (int i = 1; i <= k; i++) {\n        for (int j = 1; j <= n; j++) {\n            // Iterate through the neighbors of node j\n            for (auto neighbor : adj[j]) {\n                int next_node = neighbor.first;\n                int edge_weight = neighbor.second;\n                // Update the DP table\n                dp[i][j] = min(dp[i][j], dp[i - 1][next_node] + edge_weight);\n            }\n        }\n    }\n\n    // Print the minimum path length\n    if (dp[k][n] == INF) {\n        cout << -1 << endl;\n    } else {\n        cout << dp[k][n] << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 15,
            "mean_time_taken": 0.1195040225982666,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Gray Code",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> generateGrayCode(int n) {\n  if (n == 1) {\n    return {\"0\", \"1\"};\n  }\n  vector<string> prevCode = generateGrayCode(n - 1);\n  vector<string> reversedCode = prevCode;\n  reverse(reversedCode.begin(), reversedCode.end());\n  vector<string> grayCode;\n  for (auto &code : prevCode) {\n    grayCode.push_back(\"0\" + code);\n  }\n  for (auto &code : reversedCode) {\n    grayCode.push_back(\"1\" + code);\n  }\n  return grayCode;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  vector<string> grayCode = generateGrayCode(n);\n  for (auto &code : grayCode) {\n    cout << code << endl;\n  }\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Grid Completion",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<vector<char>> grid(n, vector<char>(n, '.'));\n  for (int i = 0; i < n; i++) {\n    string row;\n    cin >> row;\n    for (int j = 0; j < n; j++) {\n      grid[i][j] = row[j];\n    }\n  }\n\n  // Calculate the number of empty cells in each row and column\n  vector<int> rowEmpty(n, 0), colEmpty(n, 0);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (grid[i][j] == '.') {\n        rowEmpty[i]++;\n        colEmpty[j]++;\n      }\n    }\n  }\n\n  // Calculate the number of ways to fill the grid\n  long long ways = 1;\n  for (int i = 0; i < n; i++) {\n    if (rowEmpty[i] == 2) {\n      // Two empty cells in this row, we have 2 choices for placing A\n      ways = (ways * 2) % MOD;\n    } else if (rowEmpty[i] == 1 && colEmpty[i] == 1) {\n      // One empty cell in both this row and column, we have only one choice\n      // for placing A (the other will be B)\n      // We have to take care not to count this twice (once for row, once for column)\n      ways = (ways * 1) % MOD; \n    } \n  }\n\n  cout << ways << endl;\n\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 6,
            "mean_time_taken": 0.6050639549891154,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Path Construction",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool is_valid(int row, int col, int n, int m) {\n  return row >= 1 && row <= n && col >= 1 && col <= m;\n}\n\nbool dfs(int row, int col, int n, int m, vector<vector<bool>>& visited, vector<vector<char>>& path, int& path_len) {\n  if (visited[row][col]) {\n    return false;\n  }\n  visited[row][col] = true;\n  path_len++;\n  // Try all possible moves (up, down, left, right)\n  if (is_valid(row - 1, col, n, m) && dfs(row - 1, col, n, m, visited, path, path_len)) {\n    path[row][col] = 'U';\n    return true;\n  }\n  if (is_valid(row + 1, col, n, m) && dfs(row + 1, col, n, m, visited, path, path_len)) {\n    path[row][col] = 'D';\n    return true;\n  }\n  if (is_valid(row, col - 1, n, m) && dfs(row, col - 1, n, m, visited, path, path_len)) {\n    path[row][col] = 'L';\n    return true;\n  }\n  if (is_valid(row, col + 1, n, m) && dfs(row, col + 1, n, m, visited, path, path_len)) {\n    path[row][col] = 'R';\n    return true;\n  }\n  // Backtrack\n  visited[row][col] = false;\n  path_len--;\n  return false;\n}\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, m, y1, x1, y2, x2;\n    cin >> n >> m >> y1 >> x1 >> y2 >> x2;\n    vector<vector<bool>> visited(n + 1, vector<bool>(m + 1, false));\n    vector<vector<char>> path(n + 1, vector<char>(m + 1, ' '));\n    int path_len = 0;\n    if (dfs(y1, x1, n, m, visited, path, path_len) && path_len == n * m) {\n      cout << \"YES\" << endl;\n      for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n          if (path[i][j] != ' ') {\n            cout << path[i][j];\n          }\n        }\n      }\n      cout << endl;\n    } else {\n      cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 20,
            "mean_time_taken": 0.7545226812362671,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Paths",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  // Create a vector to store the trap locations\n  vector<pair<int, int>> traps(m);\n  for (int i = 0; i < m; i++) {\n    cin >> traps[i].first >> traps[i].second;\n  }\n\n  // Initialize the dp array\n  vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n  dp[1][1] = 1;\n\n  // Iterate through the grid\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      // Check if current cell is a trap\n      bool isTrap = false;\n      for (auto trap : traps) {\n        if (trap.first == i && trap.second == j) {\n          isTrap = true;\n          break;\n        }\n      }\n\n      // Update dp value if not a trap\n      if (!isTrap) {\n        dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD;\n      }\n    }\n  }\n\n  // Print the result\n  cout << dp[n][n] << endl;\n  return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 20,
            "mean_time_taken": 0.1877734661102295,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                6,
                7,
                8,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Paths",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate the number of valid paths from a given cell to the destination.\nlong long countPaths(int row, int col, const string& path, vector<vector<long long>>& dp) {\n    // Base case: Reached the destination.\n    if (row == 6 && col == 0) {\n        return 1;\n    }\n\n    // If this cell has already been calculated, return the result.\n    if (dp[row][col] != -1) {\n        return dp[row][col];\n    }\n\n    // Calculate the number of paths for each possible direction.\n    long long count = 0;\n    if (path[row * 7 + col] == 'D' || path[row * 7 + col] == '?') {\n        if (row < 6) {\n            count += countPaths(row + 1, col, path, dp);\n        }\n    }\n    if (path[row * 7 + col] == 'U' || path[row * 7 + col] == '?') {\n        if (row > 0) {\n            count += countPaths(row - 1, col, path, dp);\n        }\n    }\n    if (path[row * 7 + col] == 'R' || path[row * 7 + col] == '?') {\n        if (col < 6) {\n            count += countPaths(row, col + 1, path, dp);\n        }\n    }\n    if (path[row * 7 + col] == 'L' || path[row * 7 + col] == '?') {\n        if (col > 0) {\n            count += countPaths(row, col - 1, path, dp);\n        }\n    }\n\n    // Store the result in the DP table.\n    dp[row][col] = count;\n    return count;\n}\n\nint main() {\n    string path;\n    cin >> path;\n\n    // Create a DP table to store the number of paths for each cell.\n    vector<vector<long long>> dp(7, vector<long long>(7, -1));\n\n    // Calculate the number of paths from the starting cell.\n    long long result = countPaths(0, 0, path, dp);\n\n    cout << result << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 20,
            "mean_time_taken": 0.2548477292060852,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Paths",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main() {\n  int n;\n  cin >> n;\n\n  // Read the grid\n  vector<vector<char>> grid(n, vector<char>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      cin >> grid[i][j];\n    }\n  }\n\n  // Initialize a dp table\n  vector<vector<long long>> dp(n, vector<long long>(n, 0));\n\n  // Base case: the starting cell has one path\n  dp[0][0] = (grid[0][0] == '.') ? 1 : 0;\n\n  // Iterate through the grid\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      // If the current cell is a trap, skip it\n      if (grid[i][j] == '*') {\n        continue;\n      }\n\n      // If we are not in the first row, add the number of paths from the cell above\n      if (i > 0) {\n        dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD;\n      }\n\n      // If we are not in the first column, add the number of paths from the cell to the left\n      if (j > 0) {\n        dp[i][j] = (dp[i][j] + dp[i][j - 1]) % MOD;\n      }\n    }\n  }\n\n  // Print the number of paths to the destination cell\n  cout << dp[n - 1][n - 1] << endl;\n\n  return 0;\n}",
            "passed_test_cases": 15,
            "total_test_cases": 20,
            "mean_time_taken": 0.11901625394821166,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                7,
                10,
                16,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Puzzle I",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<int> a(n), b(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> b[i];\n  }\n\n  vector<vector<char>> grid(n, vector<char>(n, '.'));\n\n  // Iterate through rows\n  for (int i = 0; i < n; i++) {\n    // Iterate through columns\n    for (int j = 0; j < n; j++) {\n      // If we need to choose more squares in the current row\n      if (a[i] > 0 && b[j] > 0) {\n        grid[i][j] = 'X';\n        a[i]--;\n        b[j]--;\n      }\n    }\n  }\n\n  // Check if all conditions are met\n  for (int i = 0; i < n; i++) {\n    if (a[i] != 0 || b[i] != 0) {\n      cout << -1 << endl;\n      return 0;\n    }\n  }\n\n  // Print the grid\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      cout << grid[i][j];\n    }\n    cout << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 12,
            "mean_time_taken": 0.09513533115386963,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                6,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grid Puzzle II",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 50;\nint n, a[N], b[N], c[N][N];\n\nbool check(int x, int y) {\n  return x >= 1 && x <= n && y >= 1 && y <= n;\n}\n\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  for (int i = 1; i <= n; i++) cin >> b[i];\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      cin >> c[i][j];\n    }\n  }\n\n  int ans = 0;\n  vector<vector<char>> grid(n + 1, vector<char>(n + 1, '.'));\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      if (a[i] > 0 && b[j] > 0) {\n        ans += c[i][j];\n        grid[i][j] = 'X';\n        a[i]--;\n        b[j]--;\n      }\n    }\n  }\n\n  for (int i = 1; i <= n; i++) {\n    if (a[i] > 0) {\n      for (int j = 1; j <= n; j++) {\n        if (b[j] > 0 && check(i, j) && grid[i][j] == '.') {\n          ans += c[i][j];\n          grid[i][j] = 'X';\n          a[i]--;\n          b[j]--;\n        }\n      }\n    }\n  }\n\n  if (accumulate(a + 1, a + n + 1, 0) != 0) {\n    cout << -1 << endl;\n    return 0;\n  }\n\n  cout << ans << endl;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      cout << grid[i][j];\n    }\n    cout << endl;\n  }\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 8,
            "mean_time_taken": 0.3449295163154602,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Grundy's Game",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate the Grundy number of a heap with n coins\nint grundy(int n) {\n    // Base case: if n is 1, the Grundy number is 0\n    if (n == 1) {\n        return 0;\n    }\n\n    // Create a vector to store the Grundy numbers of all heaps from 1 to n\n    vector<int> grundyNumbers(n + 1, 0);\n\n    // Iterate over all heap sizes from 2 to n\n    for (int i = 2; i <= n; ++i) {\n        // Create a set to store the Grundy numbers of all possible subheaps\n        set<int> subheapGrundyNumbers;\n\n        // Iterate over all possible splits of the heap\n        for (int j = 1; j < i; ++j) {\n            // Calculate the Grundy number of the subheap with j coins\n            subheapGrundyNumbers.insert(grundyNumbers[j]);\n\n            // Calculate the Grundy number of the subheap with (i - j) coins\n            subheapGrundyNumbers.insert(grundyNumbers[i - j]);\n        }\n\n        // The Grundy number of the current heap is the smallest non-negative integer that is not in the set of subheap Grundy numbers\n        int grundyNumber = 0;\n        while (subheapGrundyNumbers.count(grundyNumber)) {\n            grundyNumber++;\n        }\n        grundyNumbers[i] = grundyNumber;\n    }\n\n    // Return the Grundy number of the heap with n coins\n    return grundyNumbers[n];\n}\n\nint main() {\n    // Read the number of test cases\n    int t;\n    cin >> t;\n\n    // Iterate over the test cases\n    while (t--) {\n        // Read the number of coins in the initial heap\n        int n;\n        cin >> n;\n\n        // Determine who wins the game\n        if (grundy(n) == 0) {\n            cout << \"second\" << endl;\n        } else {\n            cout << \"first\" << endl;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Hamiltonian Flights",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<bool>> graph(n + 1, vector<bool>(n + 1, false));\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a][b] = true;\n    }\n\n    vector<vector<int>> dp(1 << n, vector<int>(n + 1, 0));\n    dp[1][1] = 1;\n\n    for (int mask = 1; mask < (1 << n); mask++) {\n        for (int curr = 1; curr <= n; curr++) {\n            if (!(mask & (1 << (curr - 1)))) { // City not visited\n                continue;\n            }\n            for (int next = 1; next <= n; next++) {\n                if (graph[curr][next] && !(mask & (1 << (next - 1)))) {\n                    dp[mask | (1 << (next - 1))][next] = (dp[mask | (1 << (next - 1))][next] + dp[mask][curr]) % MOD;\n                }\n            }\n        }\n    }\n\n    cout << dp[(1 << n) - 1][n] << endl; // All cities visited, ending at Lehm\u00e4l\u00e4\n    return 0;\n}",
            "passed_test_cases": 8,
            "total_test_cases": 20,
            "mean_time_taken": 0.7605966210365296,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                4,
                5,
                6,
                8,
                9,
                12,
                14,
                16,
                17,
                18,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Hamming Distance",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<string> strings(n);\n    for (int i = 0; i < n; i++) {\n        cin >> strings[i];\n    }\n\n    int min_distance = INT_MAX;\n\n    // Calculate Hamming distance for all pairs of strings\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int distance = 0;\n            for (int l = 0; l < k; l++) {\n                if (strings[i][l] != strings[j][l]) {\n                    distance++;\n                }\n            }\n            min_distance = min(min_distance, distance);\n        }\n    }\n\n    cout << min_distance << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shot": 1
        },
        {
            "title": "High Score",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  vector<vector<pair<int, int>>> adj(n + 1);\n  for (int i = 0; i < m; i++) {\n    int a, b, x;\n    cin >> a >> b >> x;\n    adj[a].push_back({b, x});\n  }\n\n  vector<int> dist(n + 1, -INF);\n  dist[1] = 0;\n\n  // Bellman-Ford algorithm\n  for (int i = 1; i <= n - 1; i++) {\n    for (int u = 1; u <= n; u++) {\n      for (auto [v, w] : adj[u]) {\n        if (dist[u] != -INF && dist[v] < dist[u] + w) {\n          dist[v] = dist[u] + w;\n        }\n      }\n    }\n  }\n\n  // Check for negative cycles\n  for (int u = 1; u <= n; u++) {\n    for (auto [v, w] : adj[u]) {\n      if (dist[u] != -INF && dist[v] < dist[u] + w) {\n        cout << -1 << endl;\n        return 0;\n      }\n    }\n  }\n\n  cout << dist[n] << endl;\n  return 0;\n}",
            "passed_test_cases": 32,
            "total_test_cases": 43,
            "mean_time_taken": 0.18966053807458214,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                5,
                6,
                10,
                13,
                14,
                23,
                25,
                34,
                35,
                36,
                42
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Hotel Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  vector<int> hotels(n);\n  for (int i = 0; i < n; i++) {\n    cin >> hotels[i];\n  }\n\n  vector<int> groups(m);\n  for (int i = 0; i < m; i++) {\n    cin >> groups[i];\n  }\n\n  for (int i = 0; i < m; i++) {\n    bool assigned = false;\n    for (int j = 0; j < n; j++) {\n      if (hotels[j] >= groups[i]) {\n        hotels[j] -= groups[i];\n        cout << j + 1 << \" \";\n        assigned = true;\n        break;\n      }\n    }\n    if (!assigned) {\n      cout << 0 << \" \";\n    }\n  }\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 11,
            "mean_time_taken": 0.7526481368324973,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Houses and Schools",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n, k;\n  cin >> n >> k;\n  vector<long long> c(n);\n  for (int i = 0; i < n; i++) {\n    cin >> c[i];\n  }\n  vector<long long> prefix_sum(n + 1, 0);\n  for (int i = 0; i < n; i++) {\n    prefix_sum[i + 1] = prefix_sum[i] + c[i];\n  }\n  long long min_distance = LLONG_MAX;\n  for (int i = k - 1; i < n; i++) {\n    long long left_sum = prefix_sum[i - k + 1];\n    long long right_sum = prefix_sum[n] - prefix_sum[i + 1];\n    long long distance = (i - k + 1) * left_sum + (n - i - 1) * right_sum;\n    min_distance = min(min_distance, distance);\n  }\n  cout << min_distance << endl;\n  return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 6,
            "mean_time_taken": 0.09827888011932373,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 10,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Increasing Array",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<int> arr(n);\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n  }\n\n  long long moves = 0;  // Use long long to handle potential large sums\n  for (int i = 1; i < n; i++) {\n    if (arr[i] < arr[i - 1]) {\n      moves += arr[i - 1] - arr[i];\n      arr[i] = arr[i - 1]; // Update the current element for the next comparison\n    }\n  }\n\n  cout << moves << endl;\n\n  return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 7,
            "mean_time_taken": 0.11032755034310478,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Increasing Array II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int arr[n];\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    int moves = 0;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < arr[i - 1]) {\n            moves += arr[i - 1] - arr[i];\n            arr[i] = arr[i - 1]; // Update the current element to make it non-decreasing\n        }\n    }\n\n    cout << moves << endl;\n\n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 7,
            "mean_time_taken": 0.10817664010184151,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Increasing Array Queries",
            "category": "Range Queries",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n\n    while (q--) {\n        int l, r;\n        cin >> l >> r;\n        --l; // Adjust for 0-based indexing\n\n        long long ops = 0;\n        for (int i = l + 1; i < r; ++i) {\n            if (a[i] < a[i - 1]) {\n                ops += a[i - 1] - a[i];\n                a[i] = a[i - 1];\n            }\n        }\n\n        cout << ops << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 1.046719342470169,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Increasing Subsequence",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  // dp[i] stores the length of the longest increasing subsequence ending at a[i].\n  vector<int> dp(n, 1); \n  // Initialize the dp array with 1, as each element can be a subsequence of length 1.\n  for (int i = 1; i < n; i++) {\n    for (int j = 0; j < i; j++) {\n      // If the element at a[i] is greater than a[j] and the length of the longest increasing subsequence ending at a[j] plus 1 is greater than the current length of the longest increasing subsequence ending at a[i], then update dp[i].\n      if (a[i] > a[j] && dp[j] + 1 > dp[i]) {\n        dp[i] = dp[j] + 1;\n      }\n    }\n  }\n  // Find the maximum value in the dp array, which represents the length of the longest increasing subsequence.\n  int longest_increasing_subsequence = 1;\n  for (int i = 0; i < n; i++) {\n    longest_increasing_subsequence = max(longest_increasing_subsequence, dp[i]);\n  }\n  cout << longest_increasing_subsequence << endl;\n  return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 17,
            "mean_time_taken": 0.5757593126857982,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                9,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Increasing Subsequence II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n\n  // dp[i] stores the number of increasing subsequences ending at index i\n  vector<long long> dp(n, 1); \n\n  // Iterate through the array from left to right\n  for (int i = 1; i < n; i++) {\n    // For each element, check all previous elements\n    for (int j = 0; j < i; j++) {\n      // If the current element is greater than the previous element,\n      // it can be added to the increasing subsequence ending at the previous element\n      if (a[i] > a[j]) {\n        // Add the number of increasing subsequences ending at j to dp[i]\n        dp[i] = (dp[i] + dp[j]) % MOD;\n      }\n    }\n  }\n\n  // Calculate the total number of increasing subsequences by summing dp[i] for all i\n  long long total = 0;\n  for (int i = 0; i < n; i++) {\n    total = (total + dp[i]) % MOD;\n  }\n\n  cout << total << endl;\n  return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 10,
            "mean_time_taken": 0.47257635593414304,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Intersection Points",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nstruct LineSegment {\n    int x1, y1, x2, y2;\n};\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<LineSegment> segments(n);\n    for (int i = 0; i < n; i++) {\n        cin >> segments[i].x1 >> segments[i].y1 >> segments[i].x2 >> segments[i].y2;\n    }\n\n    int intersectionCount = 0;\n    set<int> verticalLines; // Store x-coordinates of vertical lines\n\n    for (const auto& segment : segments) {\n        if (segment.y1 == segment.y2) { // Horizontal line\n            for (int x : verticalLines) {\n                if (x >= segment.x1 && x <= segment.x2) {\n                    intersectionCount++;\n                }\n            }\n        } else { // Vertical line\n            verticalLines.insert(segment.x1);\n        }\n    }\n\n    cout << intersectionCount << endl;\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 5,
            "mean_time_taken": 0.8197258472442627,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Inverse Inversions",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n, k;\n  cin >> n >> k;\n\n  vector<int> permutation(n);\n  // Initialize the permutation with increasing numbers\n  for (int i = 0; i < n; ++i) {\n    permutation[i] = i + 1;\n  }\n\n  // Create the inversions by swapping elements from the end\n  int i = n - 1;\n  while (k > 0) {\n    // Find the element to swap with\n    int j = i - 1;\n    while (j >= 0 && permutation[i] > permutation[j]) {\n      --j;\n    }\n\n    // Swap the elements and update k\n    swap(permutation[i], permutation[j + 1]);\n    k -= (i - (j + 1));\n    --i;\n  }\n\n  // Print the permutation\n  for (int i = 0; i < n; ++i) {\n    cout << permutation[i] << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 10,
            "mean_time_taken": 0.4786278486251831,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                8,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Inversion Probability",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n  int r[100];\n  double expected_inversions = 0;\n\n  // Input the range of possible values for each array position\n  for (int i = 0; i < n; i++) {\n    cin >> r[i];\n  }\n\n  // Calculate the expected number of inversions for each pair of positions\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      // Probability that x_i > x_j\n      double probability = (double) min(r[i], r[j]) / (double) (r[i] * r[j]);\n      expected_inversions += probability;\n    }\n  }\n\n  // Output the expected number of inversions\n  cout << fixed << setprecision(6) << expected_inversions << endl;\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 20,
            "mean_time_taken": 0.09585527181625367,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Investigation",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nstruct Edge {\n    int to, cost;\n};\n\nvector<vector<Edge>> graph;\nvector<long long> dist;\nvector<int> cnt;\nvector<int> min_flights, max_flights;\n\nvoid dijkstra(int start) {\n    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\n    dist[start] = 0;\n    cnt[start] = 1;\n    min_flights[start] = 0;\n    max_flights[start] = 0;\n    pq.push({0, start});\n\n    while (!pq.empty()) {\n        long long d = pq.top().first;\n        int u = pq.top().second;\n        pq.pop();\n\n        if (d != dist[u]) {\n            continue;\n        }\n\n        for (auto& e : graph[u]) {\n            int v = e.to;\n            int cost = e.cost;\n\n            if (dist[u] + cost < dist[v]) {\n                dist[v] = dist[u] + cost;\n                cnt[v] = cnt[u];\n                min_flights[v] = min_flights[u] + 1;\n                max_flights[v] = max_flights[u] + 1;\n                pq.push({dist[v], v});\n            } else if (dist[u] + cost == dist[v]) {\n                cnt[v] = (cnt[v] + cnt[u]) % MOD;\n                min_flights[v] = min(min_flights[v], min_flights[u] + 1);\n                max_flights[v] = max(max_flights[v], max_flights[u] + 1);\n                pq.push({dist[v], v});\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    graph.resize(n + 1);\n    dist.resize(n + 1, LLONG_MAX);\n    cnt.resize(n + 1, 0);\n    min_flights.resize(n + 1, INT_MAX);\n    max_flights.resize(n + 1, INT_MIN);\n\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        graph[a].push_back({b, c});\n    }\n\n    dijkstra(1);\n\n    cout << dist[n] << \" \" << cnt[n] << \" \" << min_flights[n] << \" \" << max_flights[n] << endl;\n\n    return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 10,
            "mean_time_taken": 0.7296945095062256,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                5,
                8,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Josephus Problem I",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  // Initialize a vector to store the removal order\n  vector<int> order(n);\n\n  // Start with the first child (index 0)\n  int current = 0;\n  // Iterate through the children\n  for (int i = 0; i < n; i++) {\n    // Calculate the index of the next child to be removed\n    int next = (current + 1) % n;\n    // Add the child's index to the removal order\n    order[i] = next + 1;\n    // Move to the next child\n    current = next;\n    // Skip the next child\n    current = (current + 1) % n;\n  }\n\n  // Print the removal order\n  for (int i = 0; i < n; i++) {\n    cout << order[i] << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 13,
            "mean_time_taken": 0.09142341980567345,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Josephus Problem II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n, k;\n  cin >> n >> k;\n\n  // Create a vector to store the children's numbers.\n  vector<int> children(n);\n  for (int i = 0; i < n; ++i) {\n    children[i] = i + 1;\n  }\n\n  // Initialize the index of the first child.\n  int index = 0;\n\n  // Keep removing children until only one remains.\n  while (children.size() > 1) {\n    // Skip k children.\n    index = (index + k - 1) % children.size();\n\n    // Remove the child at the current index.\n    cout << children[index] << \" \";\n    children.erase(children.begin() + index);\n  }\n\n  // Print the last remaining child.\n  cout << children[0] << endl;\n\n  return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 17,
            "mean_time_taken": 0.290251142838422,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                9,
                11,
                13,
                14,
                15,
                17
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Josephus Queries",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint josephus(int n, int k) {\n    int pos = 0;\n    int bit = 1; // starting with the least significant bit\n    while (n > 0) {\n        if (n & 1) {\n            // If the current bit is 1, add the corresponding value to the position\n            pos += bit * (k - 1);\n            k = (k + 1) / 2;\n        } else {\n            // If the current bit is 0, the kth child position will be k / 2\n            k /= 2;\n        }\n        bit <<= 1; // Shift to the next bit position\n        n >>= 1;  // Shift the number to the right \n    }\n    return pos + 1; // Adjust to 1-based indexing\n}\n\nint main() {\n    int q;\n    cin >> q;\n    while (q--) {\n        int n, k;\n        cin >> n >> k;\n        cout << josephus(n, k) << endl;\n    }\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.19771766662597656,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Knight's Tour",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a move is valid\nbool isValidMove(int x, int y, vector<vector<int>>& board) {\n  return (x >= 1 && x <= 8 && y >= 1 && y <= 8 && board[x - 1][y - 1] == 0);\n}\n\n// Function to print the chessboard\nvoid printBoard(vector<vector<int>>& board) {\n  for (int i = 0; i < 8; i++) {\n    for (int j = 0; j < 8; j++) {\n      cout << board[i][j] << \" \";\n    }\n    cout << endl;\n  }\n}\n\n// Function to solve the Knight's Tour problem using Warnsdorff's rule\nbool solveKnightTour(int x, int y, int move, vector<vector<int>>& board) {\n  // Base case: All squares visited\n  if (move == 64) {\n    return true;\n  }\n\n  // Possible moves for the knight\n  int dx[] = {2, 1, -1, -2, -2, -1, 1, 2};\n  int dy[] = {1, 2, 2, 1, -1, -2, -2, -1};\n\n  // Array to store the number of possible moves from each cell\n  vector<int> possibleMoves(8, 0);\n\n  // Calculate the number of possible moves from each cell\n  for (int i = 0; i < 8; i++) {\n    int newX = x + dx[i];\n    int newY = y + dy[i];\n    if (isValidMove(newX, newY, board)) {\n      possibleMoves[i]++;\n    }\n  }\n\n  // Find the cell with the minimum possible moves\n  int minMoves = 8;\n  int minIndex = -1;\n  for (int i = 0; i < 8; i++) {\n    if (possibleMoves[i] > 0 && possibleMoves[i] < minMoves) {\n      minMoves = possibleMoves[i];\n      minIndex = i;\n    }\n  }\n\n  // If there are no possible moves, backtrack\n  if (minIndex == -1) {\n    return false;\n  }\n\n  // Make the move\n  int newX = x + dx[minIndex];\n  int newY = y + dy[minIndex];\n  board[newX - 1][newY - 1] = move;\n\n  // Recursively solve for the next move\n  if (solveKnightTour(newX, newY, move + 1, board)) {\n    return true;\n  }\n\n  // Backtrack: If the move doesn't lead to a solution, reset the cell\n  board[newX - 1][newY - 1] = 0;\n  return false;\n}\n\nint main() {\n  int x, y;\n  cin >> x >> y;\n\n  // Initialize the chessboard\n  vector<vector<int>> board(8, vector<int>(8, 0));\n\n  // Start the knight's tour\n  if (solveKnightTour(x, y, 1, board)) {\n    printBoard(board);\n  } else {\n    cout << \"No solution found.\" << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 23,
            "mean_time_taken": 0.10709554216136104,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Knuth Division",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct Subarray {\n    int start;\n    int end;\n    int sum;\n\n    Subarray(int start, int end, int sum) : start(start), end(end), sum(sum) {}\n\n    // Overload the less than operator to define the priority queue ordering\n    bool operator<(const Subarray& other) const {\n        return sum < other.sum;\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    // Initialize the priority queue with the entire array\n    priority_queue<Subarray> pq;\n    pq.push(Subarray(0, n - 1, 0));\n\n    // Calculate the sum of the array elements\n    for (int i = 0; i < n; i++) {\n        pq.top().sum += arr[i];\n    }\n\n    // Calculate the total cost of splitting the array\n    long long total_cost = 0;\n    while (!pq.empty()) {\n        Subarray current = pq.top();\n        pq.pop();\n\n        if (current.end - current.start > 0) {\n            // Split the subarray into two\n            int mid = (current.start + current.end) / 2;\n            pq.push(Subarray(current.start, mid, current.sum / 2));\n            pq.push(Subarray(mid + 1, current.end, current.sum - current.sum / 2));\n\n            // Add the cost of the split\n            total_cost += current.sum;\n        }\n    }\n\n    cout << total_cost << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Labyrinth",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint n, m;\nchar maze[1001][1001];\nint dx[] = {0, 0, -1, 1};\nint dy[] = {-1, 1, 0, 0};\nchar dir[] = {'L', 'R', 'U', 'D'};\n\nstruct Node {\n  int x, y;\n  int dist;\n  string path;\n};\n\nbool isValid(int x, int y) {\n  return x >= 0 && x < n && y >= 0 && y < m && maze[x][y] != '#';\n}\n\nbool BFS(int sx, int sy, int ex, int ey) {\n  queue<Node> q;\n  q.push({sx, sy, 0, \"\"});\n  vector<vector<bool>> visited(n, vector<bool>(m, false));\n  visited[sx][sy] = true;\n\n  while (!q.empty()) {\n    Node curr = q.front();\n    q.pop();\n\n    if (curr.x == ex && curr.y == ey) {\n      cout << \"YES\" << endl;\n      cout << curr.dist << endl;\n      cout << curr.path << endl;\n      return true;\n    }\n\n    for (int i = 0; i < 4; i++) {\n      int newX = curr.x + dx[i];\n      int newY = curr.y + dy[i];\n\n      if (isValid(newX, newY) && !visited[newX][newY]) {\n        visited[newX][newY] = true;\n        q.push({newX, newY, curr.dist + 1, curr.path + dir[i]});\n      }\n    }\n  }\n\n  return false;\n}\n\nint main() {\n  cin >> n >> m;\n  int sx, sy, ex, ey;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      cin >> maze[i][j];\n      if (maze[i][j] == 'A') {\n        sx = i;\n        sy = j;\n      } else if (maze[i][j] == 'B') {\n        ex = i;\n        ey = j;\n      }\n    }\n  }\n\n  if (BFS(sx, sy, ex, ey)) {\n    return 0;\n  }\n\n  cout << \"NO\" << endl;\n  return 0;\n}",
            "passed_test_cases": 15,
            "total_test_cases": 17,
            "mean_time_taken": 0.4583319355459774,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Letter Pair Move Game",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    string s;\n    cin >> n >> s;\n\n    // Find the positions of the empty boxes.\n    int empty1, empty2;\n    for (int i = 0; i < 2 * n; ++i) {\n        if (s[i] == '.') {\n            if (empty1 == -1) {\n                empty1 = i;\n            } else {\n                empty2 = i;\n            }\n        }\n    }\n\n    // If there are no empty boxes, there's no solution.\n    if (empty1 == -1 || empty2 == -1) {\n        cout << \"-1\" << endl;\n        return 0;\n    }\n\n    // If the empty boxes are not adjacent, there's no solution.\n    if (abs(empty1 - empty2) != 1) {\n        cout << \"-1\" << endl;\n        return 0;\n    }\n\n    // Initialize a vector to store the moves.\n    vector<string> moves;\n\n    // Iterate until all A's are to the left of all B's.\n    while (true) {\n        // Find the first 'B' after the first empty box.\n        int bPos = empty1 + 1;\n        while (bPos < 2 * n && s[bPos] != 'B') {\n            ++bPos;\n        }\n\n        // If there are no more 'B's, we're done.\n        if (bPos == 2 * n) {\n            break;\n        }\n\n        // Find the last 'A' before the second empty box.\n        int aPos = empty2 - 1;\n        while (aPos >= 0 && s[aPos] != 'A') {\n            --aPos;\n        }\n\n        // If there are no more 'A's, there's no solution.\n        if (aPos == -1) {\n            cout << \"-1\" << endl;\n            return 0;\n        }\n\n        // Swap the 'A' and 'B'.\n        swap(s[aPos], s[bPos]);\n\n        // Update the empty boxes.\n        empty1 = aPos;\n        empty2 = bPos;\n\n        // Add the move to the vector.\n        moves.push_back(s);\n    }\n\n    // Print the number of moves.\n    cout << moves.size() << endl;\n\n    // Print the moves.\n    for (auto move : moves) {\n        cout << move << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 24,
            "mean_time_taken": 0.09492647647857666,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                16,
                17,
                18,
                20,
                21,
                22,
                24
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Line Segment Intersection",
            "category": "Geometry",
            "solution": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to calculate the cross product of two vectors\nlong long cross_product(int x1, int y1, int x2, int y2) {\n  return (long long)x1 * y2 - (long long)x2 * y1;\n}\n\n// Function to determine if two line segments intersect\nbool intersect(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) {\n  // Calculate the cross products to determine the relative orientations\n  long long cp1 = cross_product(x2 - x1, y2 - y1, x3 - x1, y3 - y1);\n  long long cp2 = cross_product(x2 - x1, y2 - y1, x4 - x1, y4 - y1);\n  long long cp3 = cross_product(x4 - x3, y4 - y3, x1 - x3, y1 - y3);\n  long long cp4 = cross_product(x4 - x3, y4 - y3, x2 - x3, y2 - y3);\n\n  // If the cross products have opposite signs, the line segments intersect\n  return ((cp1 * cp2 <= 0) && (cp3 * cp4 <= 0));\n}\n\nint main() {\n  int t;\n  cin >> t;\n\n  while (t--) {\n    int x1, y1, x2, y2, x3, y3, x4, y4;\n    cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4;\n\n    // Call the intersect function and print the result\n    if (intersect(x1, y1, x2, y2, x3, y3, x4, y4)) {\n      cout << \"YES\" << endl;\n    } else {\n      cout << \"NO\" << endl;\n    }\n  }\n\n  return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 6,
            "mean_time_taken": 0.4772742986679077,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 11,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "List Removals",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<int> nums(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> nums[i];\n  }\n\n  vector<int> positions(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> positions[i];\n  }\n\n  vector<int> removed;\n  for (int i = 0; i < n; ++i) {\n    int pos = positions[i] - 1;\n    removed.push_back(nums[pos]);\n    nums.erase(nums.begin() + pos);\n  }\n\n  for (int i = 0; i < n; ++i) {\n    cout << removed[i] << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 9,
            "total_test_cases": 9,
            "mean_time_taken": 0.295221487681071,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "List of Sums",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> B(n * (n - 1) / 2);\n    for (int i = 0; i < n * (n - 1) / 2; i++) {\n        cin >> B[i];\n    }\n\n    // Calculate the sum of elements in A\n    int sumA = 0;\n    for (int i = 0; i < n * (n - 1) / 2; i++) {\n        sumA += B[i];\n    }\n    sumA = sumA / (n - 1);\n\n    // Find the smallest element in A\n    int minA = *min_element(B.begin(), B.end());\n\n    // Initialize set to store elements in A\n    set<int> A;\n    A.insert(minA);\n\n    // Reconstruct the remaining elements in A\n    for (int b : B) {\n        int potentialA = b - minA;\n        if (A.count(potentialA) == 0) {\n            A.insert(potentialA);\n        }\n    }\n\n    // Print the reconstructed list A\n    for (int a : A) {\n        cout << a << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.4059570550918579,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Longest Flight Route",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  vector<vector<int>> adj(n + 1);\n  for (int i = 0; i < m; ++i) {\n    int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n  }\n\n  vector<int> dist(n + 1, -1);\n  queue<int> q;\n  q.push(1);\n  dist[1] = 1;\n\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n\n    for (int v : adj[u]) {\n      if (dist[v] == -1) {\n        dist[v] = dist[u] + 1;\n        q.push(v);\n      }\n    }\n  }\n\n  if (dist[n] == -1) {\n    cout << \"IMPOSSIBLE\" << endl;\n  } else {\n    cout << dist[n] << endl;\n\n    vector<int> path;\n    int u = n;\n    while (u != 1) {\n      path.push_back(u);\n      for (int v : adj[u]) {\n        if (dist[v] + 1 == dist[u]) {\n          u = v;\n          break;\n        }\n      }\n    }\n    path.push_back(1);\n\n    for (int i = path.size() - 1; i >= 0; --i) {\n      cout << path[i] << \" \";\n    }\n    cout << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 24,
            "mean_time_taken": 1.0539444486300151,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                11,
                12,
                13,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Longest Palindrome",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstring longestPalindrome(string s) {\n    string preprocessed = \"#\";\n    for (char c : s) {\n        preprocessed += c;\n        preprocessed += \"#\";\n    }\n\n    int n = preprocessed.size();\n    vector<int> dp(n, 0);\n    int center = 0;\n    int radius = 0;\n\n    for (int i = 1; i < n - 1; i++) {\n        int mirror = center - (i - center);\n        dp[i] = max(1, min(dp[mirror], radius - (i - center)));\n\n        while (i - dp[i] >= 0 && i + dp[i] < n && preprocessed[i - dp[i]] == preprocessed[i + dp[i]]) {\n            dp[i]++;\n        }\n\n        if (i + dp[i] > center + radius) {\n            center = i;\n            radius = dp[i];\n        }\n    }\n\n    int maxLen = 0;\n    int maxIndex = 0;\n    for (int i = 0; i < n; i++) {\n        if (dp[i] > maxLen) {\n            maxLen = dp[i];\n            maxIndex = i;\n        }\n    }\n\n    int start = maxIndex - maxLen + 1;\n    return preprocessed.substr(start, 2 * maxLen - 1);\n}\n\nint main() {\n    string s;\n    cin >> s;\n    cout << longestPalindrome(s) << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 19,
            "mean_time_taken": 0.28821822216636256,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Mail Delivery",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> graph;\nvector<bool> visited;\nvector<int> path;\n\nbool isEulerianCycle(int n, int m) {\n  // Check if the degree of each vertex is even.\n  for (int i = 1; i <= n; ++i) {\n    if (graph[i].size() % 2 != 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\nvoid dfs(int u) {\n  visited[u] = true;\n  for (int& v : graph[u]) {\n    if (!visited[v]) {\n      dfs(v);\n    }\n  }\n  path.push_back(u);\n}\n\nvoid findEulerianCycle(int start) {\n  dfs(start);\n  reverse(path.begin(), path.end());\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  graph.resize(n + 1);\n  visited.resize(n + 1, false);\n\n  // Read the input and build the graph.\n  for (int i = 0; i < m; ++i) {\n    int a, b;\n    cin >> a >> b;\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n\n  // Check if the graph has an Eulerian cycle.\n  if (!isEulerianCycle(n, m)) {\n    cout << \"IMPOSSIBLE\" << endl;\n    return 0;\n  }\n\n  // Find the Eulerian cycle.\n  findEulerianCycle(1);\n\n  // Print the solution.\n  for (int i = 0; i < path.size(); ++i) {\n    cout << path[i] << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 16,
            "mean_time_taken": 0.26873576641082764,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Maximum Building I",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  vector<vector<char>> forest(n, vector<char>(m));\n\n  // Read the forest map\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      cin >> forest[i][j];\n    }\n  }\n\n  // Initialize the maximum area to 0\n  int max_area = 0;\n\n  // Iterate over all possible top-left corners of the building\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      // Check if the current square is empty\n      if (forest[i][j] == '.') {\n        // Iterate over all possible bottom-right corners of the building\n        for (int k = i; k < n; ++k) {\n          for (int l = j; l < m; ++l) {\n            // Check if all squares within the rectangle are empty\n            bool valid = true;\n            for (int p = i; p <= k; ++p) {\n              for (int q = j; q <= l; ++q) {\n                if (forest[p][q] == '*') {\n                  valid = false;\n                  break;\n                }\n              }\n              if (!valid) {\n                break;\n              }\n            }\n\n            // If the rectangle is valid, update the maximum area\n            if (valid) {\n              int area = (k - i + 1) * (l - j + 1);\n              max_area = max(max_area, area);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Print the maximum area\n  if (max_area > 0) {\n    cout << max_area << endl;\n  } else {\n    cout << \"Not found\" << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 12,
            "mean_time_taken": 0.8351635535558065,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                7,
                9,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Maximum Building II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  vector<vector<char>> forest(n, vector<char>(m));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      cin >> forest[i][j];\n    }\n  }\n\n  vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\n\n  // DP initialization: Count empty squares in each row and column\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      if (forest[i][j] == '.') {\n        dp[i + 1][j + 1] = dp[i + 1][j] + 1;\n      }\n    }\n  }\n\n  // DP calculation: Iterate through all possible building sizes\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      // Calculate the number of ways to place a building of size i x j\n      for (int k = i; k <= n; k++) {\n        for (int l = j; l <= m; l++) {\n          // Check if there are no trees within the building area\n          if (dp[k][l] - dp[k][j - 1] - dp[i - 1][l] + dp[i - 1][j - 1] == (k - i + 1) * (l - j + 1)) {\n            dp[k][l] += (k - i + 1) * (l - j + 1);\n          }\n        }\n      }\n    }\n  }\n\n  // Print the results\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      cout << dp[i][j] << \" \";\n    }\n    cout << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 13,
            "mean_time_taken": 1.0062740399287298,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Maximum Subarray Sum",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n\n  int max_so_far = a[0];\n  int current_max = a[0];\n\n  for (int i = 1; i < n; i++) {\n    current_max = max(a[i], current_max + a[i]);\n    max_so_far = max(max_so_far, current_max);\n  }\n  cout << max_so_far << endl;\n  return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 15,
            "mean_time_taken": 0.12165160179138183,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                6,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Maximum Subarray Sum II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n, a, b;\n  cin >> n >> a >> b;\n  vector<int> arr(n);\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n  }\n\n  // Calculate the maximum sum for subarrays of all possible lengths\n  vector<int> max_sums(n + 1, 0);\n  for (int i = 1; i <= n; i++) {\n    max_sums[i] = max(max_sums[i - 1], 0) + arr[i - 1];\n  }\n\n  int max_sum = 0;\n  // Iterate through all possible subarray lengths\n  for (int len = a; len <= b; len++) {\n    // Calculate the maximum sum for subarrays of length len\n    for (int i = len; i <= n; i++) {\n      max_sum = max(max_sum, max_sums[i] - max_sums[i - len]);\n    }\n  }\n\n  cout << max_sum << endl;\n  return 0;\n}",
            "passed_test_cases": 8,
            "total_test_cases": 23,
            "mean_time_taken": 0.4666891927304475,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                5,
                8,
                9,
                10,
                13,
                14,
                15,
                16,
                17,
                19,
                20,
                21,
                22,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 12,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Maximum Xor Subarray",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TrieNode {\n  TrieNode* children[2]; // 0 for 0-bit, 1 for 1-bit\n  TrieNode() {\n    children[0] = children[1] = nullptr;\n  }\n};\n\nvoid insert(TrieNode* root, int value) {\n  TrieNode* node = root;\n  for (int i = 31; i >= 0; --i) {\n    int bit = (value >> i) & 1;\n    if (node->children[bit] == nullptr) {\n      node->children[bit] = new TrieNode();\n    }\n    node = node->children[bit];\n  }\n}\n\nint findMaxXor(TrieNode* root, int value) {\n  TrieNode* node = root;\n  int maxXor = 0;\n  for (int i = 31; i >= 0; --i) {\n    int bit = (value >> i) & 1;\n    if (node->children[1 - bit] != nullptr) {\n      maxXor |= (1 << i);\n      node = node->children[1 - bit];\n    } else {\n      node = node->children[bit];\n    }\n  }\n  return maxXor;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  vector<int> arr(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> arr[i];\n  }\n\n  TrieNode* root = new TrieNode();\n  insert(root, 0);\n\n  int currentXor = 0;\n  int maxXor = 0;\n\n  for (int i = 0; i < n; ++i) {\n    currentXor ^= arr[i];\n    maxXor = max(maxXor, findMaxXor(root, currentXor));\n    insert(root, currentXor);\n  }\n\n  cout << maxXor << endl;\n  return 0;\n}",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.14621101106916154,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Meet in the Middle",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    // Divide into halves\n    int mid = n / 2;\n    vector<int> left(arr.begin(), arr.begin() + mid);\n    vector<int> right(arr.begin() + mid, arr.end());\n\n    // Generate subset sums\n    set<int> left_sums, right_sums;\n    for (int i = 0; i < (1 << left.size()); i++) {\n        int sum = 0;\n        for (int j = 0; j < left.size(); j++) {\n            if (i & (1 << j)) {\n                sum += left[j];\n            }\n        }\n        left_sums.insert(sum);\n    }\n    for (int i = 0; i < (1 << right.size()); i++) {\n        int sum = 0;\n        for (int j = 0; j < right.size(); j++) {\n            if (i & (1 << j)) {\n                sum += right[j];\n            }\n        }\n        right_sums.insert(sum);\n    }\n\n    // Meet in the middle\n    int count = 0;\n    for (int s1 : left_sums) {\n        if (right_sums.count(x - s1)) {\n            count++;\n        }\n    }\n\n    cout << count << endl;\n    return 0;\n}",
            "passed_test_cases": 9,
            "total_test_cases": 40,
            "mean_time_taken": 0.8283194780349732,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                11,
                12,
                13,
                14,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                24,
                26,
                28,
                29,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                40
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 13,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Message Route",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\n\nvector<int> adj[MAXN];\nint dist[MAXN];\nint parent[MAXN];\n\nvoid bfs(int s) {\n  queue<int> q;\n  q.push(s);\n  dist[s] = 0;\n  parent[s] = -1;\n\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n\n    for (int v : adj[u]) {\n      if (dist[v] == -1) {\n        dist[v] = dist[u] + 1;\n        parent[v] = u;\n        q.push(v);\n      }\n    }\n  }\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n\n  for (int i = 1; i <= n; i++) {\n    dist[i] = -1;\n    parent[i] = -1;\n  }\n\n  bfs(1);\n\n  if (dist[n] == -1) {\n    cout << \"IMPOSSIBLE\" << endl;\n  } else {\n    cout << dist[n] + 1 << endl;\n    vector<int> path;\n    int u = n;\n    while (u != -1) {\n      path.push_back(u);\n      u = parent[u];\n    }\n    for (int i = path.size() - 1; i >= 0; i--) {\n      cout << path[i] << \" \";\n    }\n    cout << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.4136575659116109,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Minimal Rotation",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring findLexicographicallyMinimalRotation(string s) {\n    int n = s.length();\n    string concat = s + s; // Concatenate the string with itself\n\n    int start = 0; // Keep track of the starting index for the minimal rotation\n    for (int i = 1; i < n; ++i) {\n        if (concat.substr(i, n) < concat.substr(start, n)) {\n            start = i; // Update the starting index if a lexicographically smaller rotation is found\n        }\n    }\n\n    return concat.substr(start, n); // Extract the minimal rotation from the concatenated string\n}\n\nint main() {\n    string s;\n    cin >> s;\n\n    string minRotation = findLexicographicallyMinimalRotation(s);\n    cout << minRotation << endl;\n    return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 20,
            "mean_time_taken": 0.5258149981498719,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                6,
                11,
                12,
                14,
                15,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Minimizing Coins",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int n, x;\n  cin >> n >> x;\n\n  vector<int> coins(n);\n  for (int i = 0; i < n; i++) {\n    cin >> coins[i];\n  }\n\n  // Initialize a dp table to store the minimum number of coins needed to make each sum from 0 to x.\n  vector<int> dp(x + 1, INT_MAX);\n  dp[0] = 0;\n\n  // Iterate through each sum from 1 to x.\n  for (int i = 1; i <= x; i++) {\n    // Iterate through each coin.\n    for (int j = 0; j < n; j++) {\n      // If the coin value is less than or equal to the current sum.\n      if (coins[j] <= i) {\n        // Check if the current sum minus the coin value has a valid minimum number of coins.\n        if (dp[i - coins[j]] != INT_MAX) {\n          // Update the minimum number of coins needed for the current sum.\n          dp[i] = min(dp[i], dp[i - coins[j]] + 1);\n        }\n      }\n    }\n  }\n\n  // Print the minimum number of coins if it is possible to make the desired sum, otherwise print -1.\n  if (dp[x] == INT_MAX) {\n    cout << -1 << endl;\n  } else {\n    cout << dp[x] << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Minimum Euclidean Distance",
            "category": "Geometry",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nstruct Point {\n    int x;\n    int y;\n};\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<Point> points(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> points[i].x >> points[i].y;\n    }\n\n    // We will calculate the squared Euclidean distance, so we don't need to use sqrt()\n    long long min_distance_squared = LONG_LONG_MAX; \n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            long long dx = points[i].x - points[j].x;\n            long long dy = points[i].y - points[j].y;\n            min_distance_squared = min(min_distance_squared, dx * dx + dy * dy);\n        }\n    }\n\n    cout << min_distance_squared << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Missing Coin Sum",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n  vector<int> coins(n);\n  for (int i = 0; i < n; i++) {\n    cin >> coins[i];\n  }\n  sort(coins.begin(), coins.end());\n  int maxSum = 0;\n  for (int i = 0; i < n; i++) {\n    maxSum += coins[i];\n  }\n  vector<bool> canForm(maxSum + 1, false);\n  canForm[0] = true;\n  for (int i = 0; i < n; i++) {\n    for (int j = maxSum; j >= coins[i]; j--) {\n      if (canForm[j - coins[i]]) {\n        canForm[j] = true;\n      }\n    }\n  }\n  for (int i = 1; i <= maxSum; i++) {\n    if (!canForm[i]) {\n      cout << i << endl;\n      return 0;\n    }\n  }\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 9,
            "mean_time_taken": 0.6047920915815566,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                7,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Missing Coin Sum Queries",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n\n  vector<int> coins(n);\n  for (int i = 0; i < n; i++) {\n    cin >> coins[i];\n  }\n\n  // Calculate the smallest sum that cannot be produced for each prefix\n  vector<int> dp(n + 1, 0);\n  for (int i = 1; i <= n; i++) {\n    dp[i] = dp[i - 1] + coins[i - 1];\n  }\n\n  // Process each query\n  for (int i = 0; i < q; i++) {\n    int a, b;\n    cin >> a >> b;\n\n    // Find the smallest sum that cannot be produced using coins a to b\n    int sum = dp[b];\n    for (int j = a - 1; j < b; j++) {\n      if (sum - coins[j] >= 0 && sum - coins[j] != dp[j]) {\n        sum = sum - coins[j];\n        break;\n      }\n    }\n\n    // Print the answer\n    cout << sum + 1 << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 8,
            "mean_time_taken": 1.0260875523090363,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Missing Number",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  // Read the input numbers.\n  vector<int> numbers(n - 1);\n  for (int i = 0; i < n - 1; i++) {\n    cin >> numbers[i];\n  }\n\n  // Calculate the sum of numbers from 1 to n.\n  int sum_of_all = (n * (n + 1)) / 2;\n\n  // Calculate the sum of the input numbers.\n  int sum_of_input = 0;\n  for (int i = 0; i < n - 1; i++) {\n    sum_of_input += numbers[i];\n  }\n\n  // The missing number is the difference between the two sums.\n  int missing_number = sum_of_all - sum_of_input;\n\n  // Print the missing number.\n  cout << missing_number << endl;\n\n  return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 14,
            "mean_time_taken": 0.18204443795340403,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                8,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Money Sums",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n  vector<int> coins(n);\n  for (int i = 0; i < n; i++) {\n    cin >> coins[i];\n  }\n\n  // Sort the coins in ascending order\n  sort(coins.begin(), coins.end());\n\n  // Create a vector to store the possible sums\n  vector<int> sums;\n  sums.push_back(0); \n\n  // Iterate through each coin\n  for (int i = 0; i < n; i++) {\n    // Create a new vector to store the sums that can be created by adding the current coin to the existing sums\n    vector<int> newSums;\n    for (int j = 0; j < sums.size(); j++) {\n      // Add the current coin to the existing sum\n      int sum = sums[j] + coins[i];\n      // If the sum is not already in the sums vector, add it\n      if (find(sums.begin(), sums.end(), sum) == sums.end()) {\n        newSums.push_back(sum);\n      }\n    }\n    // Add the new sums to the sums vector\n    sums.insert(sums.end(), newSums.begin(), newSums.end());\n  }\n\n  // Print the number of distinct money sums\n  cout << sums.size() << endl;\n\n  // Sort the sums in ascending order\n  sort(sums.begin(), sums.end());\n\n  // Print the possible sums\n  for (int i = 0; i < sums.size(); i++) {\n    cout << sums[i] << \" \";\n  }\n  cout << endl;\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 13,
            "mean_time_taken": 0.32430580946115345,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Monotone Subsequences",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, k;\n    cin >> n >> k;\n    if (k == 1 || k == n) {\n      for (int i = 1; i <= n; ++i) {\n        cout << i << \" \";\n      }\n      cout << endl;\n    } else if (k == 2) {\n      cout << n << \" \" << 1 << \" \";\n      for (int i = 2; i < n; ++i) {\n        cout << i << \" \";\n      }\n      cout << endl;\n    } else if (k == n - 1) {\n      cout << 1 << \" \" << n << \" \";\n      for (int i = 2; i < n; ++i) {\n        cout << i << \" \";\n      }\n      cout << endl;\n    } else {\n      cout << \"IMPOSSIBLE\" << endl;\n    }\n  }\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.7050971984863281,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Monster Game I",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n, x;\n  cin >> n >> x;\n  vector<int> s(n), f(n);\n  for (int i = 0; i < n; i++) {\n    cin >> s[i];\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> f[i];\n  }\n\n  // dp[i] represents the minimum time to win the game if we are currently at level i\n  vector<long long> dp(n + 1, LLONG_MAX);\n  dp[n] = s[n - 1] * x;\n  for (int i = n - 1; i >= 0; i--) {\n    dp[i] = min(dp[i + 1], s[i] * x); // either skip the monster\n    if (i < n - 1) {\n      dp[i] = min(dp[i], dp[i + 2] + s[i] * f[i]); // or kill the monster\n    }\n  }\n\n  cout << dp[0] << endl;\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Monster Game II",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int n, x;\n  cin >> n >> x;\n\n  vector<int> s(n), f(n);\n  for (int i = 0; i < n; i++) {\n    cin >> s[i];\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> f[i];\n  }\n\n  // dp[i][j] = minimum time to win the game after killing monster i with skill factor j\n  vector<vector<long long>> dp(n + 1, vector<long long>(1000001, LLONG_MAX));\n  dp[0][x] = 0;\n\n  // Iterate through each level\n  for (int i = 1; i <= n; i++) {\n    // Iterate through possible skill factors\n    for (int j = 1; j <= 1000000; j++) {\n      // If we kill the monster at this level\n      if (i < n) {\n        dp[i][f[i - 1]] = min(dp[i][f[i - 1]], dp[i - 1][j] + s[i - 1] * j);\n      }\n      // If we don't kill the monster at this level\n      dp[i][j] = min(dp[i][j], dp[i - 1][j]);\n    }\n  }\n\n  // The minimum time to win the game is dp[n][j] for any j\n  long long min_time = LLONG_MAX;\n  for (int j = 1; j <= 1000000; j++) {\n    min_time = min(min_time, dp[n][j]);\n  }\n\n  cout << min_time << endl;\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Monsters",
            "category": "Graph Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1000;\nchar grid[MAXN][MAXN];\nint n, m;\nint sx, sy;\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nchar dir[] = {'D', 'U', 'R', 'L'};\n\nbool valid(int x, int y) {\n    return x >= 0 && x < n && y >= 0 && y < m && grid[x][y] != '#';\n}\n\nbool reachable(int x, int y, int steps) {\n    // We can reach a boundary square if we are already on it\n    if (x == 0 || x == n - 1 || y == 0 || y == m - 1) {\n        return true;\n    }\n    // We can reach a boundary square if we are on it after the monsters take a step\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (valid(nx, ny)) {\n            return true;\n        }\n    }\n    // We can reach a boundary square if we can take a step without the monsters reaching the boundary square\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (valid(nx, ny)) {\n            // Check if the monster can reach a boundary square in the next step\n            bool monster_reachable = false;\n            for (int j = 0; j < 4; j++) {\n                int mx = nx + dx[j];\n                int my = ny + dy[j];\n                if (valid(mx, my)) {\n                    monster_reachable = true;\n                    break;\n                }\n            }\n            if (!monster_reachable) {\n                return true;\n            }\n        }\n    }\n    // We can reach a boundary square if we can move somewhere where the monsters cannot reach a boundary square in the next step\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (valid(nx, ny)) {\n            // Check if the monster can reach a boundary square in the next step\n            bool monster_reachable = false;\n            for (int j = 0; j < 4; j++) {\n                int mx = nx + dx[j];\n                int my = ny + dy[j];\n                if (valid(mx, my)) {\n                    monster_reachable = true;\n                    break;\n                }\n            }\n            // If the monster cannot reach a boundary square, we can reach it\n            if (!monster_reachable) {\n                return true;\n            }\n            // If the monster can reach a boundary square, we need to see if we can reach a boundary square in the next step\n            else {\n                return reachable(nx, ny, steps + 1);\n            }\n        }\n    }\n    // If we cannot reach a boundary square in any way, we return false\n    return false;\n}\n\nint main() {\n    cin >> n >> m;\n    for (int i = 0; i < n; i++) {\n        cin >> grid[i];\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 'A') {\n                sx = i;\n                sy = j;\n            }\n        }\n    }\n    if (reachable(sx, sy, 0)) {\n        cout << \"YES\" << endl;\n        // We use a queue to store the path\n        queue<pair<int, int>> q;\n        // We add the starting position to the queue\n        q.push({sx, sy});\n        // We mark the starting position as visited\n        grid[sx][sy] = '.';\n        // We store the path\n        string path = \"\";\n        // We iterate until the queue is empty\n        while (!q.empty()) {\n            // We get the current position from the queue\n            int x = q.front().first;\n            int y = q.front().second;\n            q.pop();\n            // We iterate over all possible moves\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                // If the move is valid and the square is not visited\n                if (valid(nx, ny) && grid[nx][ny] != '.') {\n                    // We add the move to the path\n                    path += dir[i];\n                    // We mark the square as visited\n                    grid[nx][ny] = '.';\n                    // We add the new position to the queue\n                    q.push({nx, ny});\n                    // We break the loop\n                    break;\n                }\n            }\n        }\n        // We print the length of the path\n        cout << path.length() << endl;\n        // We print the path\n        cout << path << endl;\n    } else {\n        cout << \"NO\" << endl;\n    }\n    return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 28,
            "mean_time_taken": 0.22354097877229964,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                9,
                10,
                11,
                12,
                13,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                25,
                26,
                27
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 14,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Movie Festival",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<pair<int, int>> movies(n);\n  for (int i = 0; i < n; i++) {\n    cin >> movies[i].first >> movies[i].second;\n  }\n\n  sort(movies.begin(), movies.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n    return a.second < b.second;\n  });\n\n  vector<int> selected;\n  selected.push_back(0);\n\n  for (int i = 1; i < n; i++) {\n    if (movies[i].first >= movies[selected.back()].second) {\n      selected.push_back(i);\n    }\n  }\n\n  cout << selected.size() << endl;\n\n  return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.15926103158430618,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Movie Festival II",
            "category": "Sorting and Searching",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n, k;\n  cin >> n >> k;\n\n  vector<pair<int, int>> movies(n);\n  for (int i = 0; i < n; i++) {\n    cin >> movies[i].first >> movies[i].second;\n  }\n\n  // Sort movies by ending time\n  sort(movies.begin(), movies.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n    return a.second < b.second;\n  });\n\n  // Initialize priority queue to store the starting times of movies already watched\n  priority_queue<int, vector<int>, greater<int>> watched;\n\n  // Iterate over movies\n  int count = 0;\n  for (int i = 0; i < n; i++) {\n    // If there are enough members to watch the movie\n    if (watched.size() < k) {\n      count++;\n      watched.push(movies[i].second);\n    } else {\n      // If the current movie starts after the earliest ending time of watched movies\n      if (movies[i].first >= watched.top()) {\n        watched.pop();\n        watched.push(movies[i].second);\n        count++;\n      }\n    }\n  }\n\n  cout << count << endl;\n  return 0;\n}",
            "passed_test_cases": 9,
            "total_test_cases": 13,
            "mean_time_taken": 0.17295208344092736,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                5,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Movie Festival Queries",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<pair<int, int>> movies(n);\n    for (int i = 0; i < n; i++) {\n        cin >> movies[i].first >> movies[i].second;\n    }\n\n    // Sort movies by their starting time\n    sort(movies.begin(), movies.end());\n\n    // Process queries\n    for (int i = 0; i < q; i++) {\n        int arrival, departure;\n        cin >> arrival >> departure;\n\n        // Binary search to find the first movie starting after or at arrival time\n        int start_index = lower_bound(movies.begin(), movies.end(), make_pair(arrival, 0)) - movies.begin();\n\n        int count = 0;\n        for (int j = start_index; j < n && movies[j].second <= departure; j++) {\n            count++;\n            j++; // Skip to the next movie\n        }\n\n        cout << count << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 5,
            "mean_time_taken": 0.5659556865692139,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Moving Robots",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\nint main() {\n  int k;\n  cin >> k;\n\n  double expected_empty = 0;\n\n  // Calculate the probability of a robot being on a specific square after k turns\n  for (int i = 0; i <= k; ++i) {\n    for (int j = 0; j <= k; ++j) {\n      // Calculate the number of ways to reach the square (i, j) in k steps\n      double ways = 0;\n      if (i + j <= k) {\n        ways = (double) (k - (i + j)) / (i + j); \n        ways *= (double) (i + j) / (i + j) * (i + j);\n        ways *= (double) (k - (i + j)) / (k - (i + j));\n        ways *= (double) (i + j) / (i + j);\n      }\n      // Probability of a robot landing on a specific square\n      double prob = ways / (double) (4 * k);\n\n      // Calculate the expected number of empty squares\n      expected_empty += (1 - prob) * 64;\n    }\n  }\n  // Print the answer rounded to 6 decimal places\n  cout << fixed << setprecision(6) << expected_empty << endl;\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 16,
            "mean_time_taken": 0.10910767316818237,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Multiplication Table",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n\n   using namespace std;\n\n   int main() {\n       int n;\n       cin >> n;\n\n       // Calculate the middle element of the multiplication table\n       int middleElement = ((n + 1) / 2) * ((n + 1) / 2);\n\n       cout << middleElement << endl;\n       return 0;\n   }",
            "passed_test_cases": 1,
            "total_test_cases": 8,
            "mean_time_taken": 0.10191535949707031,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Nearest Smaller Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<int> arr(n);\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n  }\n\n  vector<int> ans(n, 0);\n  stack<int> st;\n\n  for (int i = 0; i < n; i++) {\n    while (!st.empty() && arr[st.top()] >= arr[i]) {\n      st.pop();\n    }\n\n    if (!st.empty()) {\n      ans[i] = st.top();\n    }\n\n    st.push(i);\n  }\n\n  for (int i = 0; i < n; i++) {\n    cout << ans[i] << \" \";\n  }\n\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 13,
            "mean_time_taken": 0.2857306737166185,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                7,
                10,
                11,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Necessary Cities",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\n\nvector<int> adj[MAXN];\nbool visited[MAXN];\n\nvoid dfs(int u) {\n  visited[u] = true;\n  for (int v : adj[u]) {\n    if (!visited[v]) {\n      dfs(v);\n    }\n  }\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n\n  vector<int> necessary;\n  for (int i = 1; i <= n; i++) {\n    memset(visited, false, sizeof(visited));\n    dfs(i);\n    bool is_necessary = false;\n    for (int j = 1; j <= n; j++) {\n      if (j != i && !visited[j]) {\n        is_necessary = true;\n        break;\n      }\n    }\n    if (is_necessary) {\n      necessary.push_back(i);\n    }\n  }\n\n  cout << necessary.size() << endl;\n  for (int city : necessary) {\n    cout << city << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 8,
            "mean_time_taken": 0.4164470136165619,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Necessary Roads",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 5;\nvector<int> adj[N];\nvector<pair<int, int>> edges;\nbool visited[N];\n\nvoid dfs(int node) {\n  visited[node] = true;\n  for (auto it : adj[node]) {\n    if (!visited[it]) {\n      dfs(it);\n    }\n  }\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n    edges.push_back({a, b});\n  }\n  int k = 0;\n  vector<pair<int, int>> necessary_edges;\n  for (int i = 0; i < m; i++) {\n    int a = edges[i].first, b = edges[i].second;\n    adj[a].erase(remove(adj[a].begin(), adj[a].end(), b), adj[a].end());\n    adj[b].erase(remove(adj[b].begin(), adj[b].end(), a), adj[b].end());\n    memset(visited, false, sizeof(visited));\n    dfs(1);\n    bool is_necessary = false;\n    for (int j = 1; j <= n; j++) {\n      if (!visited[j]) {\n        is_necessary = true;\n        break;\n      }\n    }\n    if (is_necessary) {\n      necessary_edges.push_back({a, b});\n      k++;\n    }\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n  cout << k << endl;\n  for (auto it : necessary_edges) {\n    cout << it.first << \" \" << it.second << endl;\n  }\n  return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 5,
            "mean_time_taken": 0.8452428340911865,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Nested Ranges Check",
            "category": "Sorting and Searching",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define f first\n#define s second\n#define pii pair<int,int>\n#define vi vector<int>\n#define vpii vector<pii>\n\nconst ll INF = 1e18;\nconst int MOD = 1e9 + 7;\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n;\n    cin >> n;\n    vpii ranges(n);\n    for (int i = 0; i < n; i++) {\n        cin >> ranges[i].f >> ranges[i].s;\n    }\n    vi contains(n, 0);\n    vi contained(n, 0);\n    // Sort ranges by starting point\n    sort(ranges.begin(), ranges.end());\n    // Iterate through ranges and check for containment\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (ranges[i].f <= ranges[j].f && ranges[j].s <= ranges[i].s) {\n                contains[i] = 1;\n                contained[j] = 1;\n                break;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        cout << contains[i] << \" \";\n    }\n    cout << endl;\n    for (int i = 0; i < n; i++) {\n        cout << contained[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 12,
            "mean_time_taken": 0.6072813073794047,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Nested Ranges Count",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Range {\n    int start;\n    int end;\n};\n\nbool compareStart(const Range &a, const Range &b) {\n    return a.start < b.start;\n}\n\nbool compareEnd(const Range &a, const Range &b) {\n    return a.end < b.end;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<Range> ranges(n);\n    for (int i = 0; i < n; i++) {\n        cin >> ranges[i].start >> ranges[i].end;\n    }\n\n    // Sort ranges by start for counting contains\n    sort(ranges.begin(), ranges.end(), compareStart);\n    vector<int> containsCount(n, 0);\n    int currentEnd = -1;\n    for (int i = 0; i < n; i++) {\n        if (ranges[i].start > currentEnd) {\n            currentEnd = ranges[i].end;\n        } else {\n            containsCount[i] = i - 1;\n        }\n    }\n\n    // Sort ranges by end for counting contained\n    sort(ranges.begin(), ranges.end(), compareEnd);\n    vector<int> containedCount(n, 0);\n    currentEnd = -1;\n    for (int i = n - 1; i >= 0; i--) {\n        if (ranges[i].end < currentEnd) {\n            currentEnd = ranges[i].start;\n        } else {\n            containedCount[i] = n - i - 1;\n        }\n    }\n\n    // Print the results\n    for (int i = 0; i < n; i++) {\n        cout << containsCount[i] << \" \";\n    }\n    cout << endl;\n\n    for (int i = 0; i < n; i++) {\n        cout << containedCount[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.33225123087565106,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Network Breakdown",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Union-Find data structure for disjoint set union\nclass UnionFind {\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n\npublic:\n    UnionFind(int n) : parent(n), rank(n, 0) {\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int u) {\n        if (parent[u] != u) {\n            parent[u] = find(parent[u]);\n        }\n        return parent[u];\n    }\n\n    void unite(int u, int v) {\n        int pu = find(u);\n        int pv = find(v);\n        if (pu != pv) {\n            if (rank[pu] < rank[pv]) {\n                parent[pu] = pv;\n            } else {\n                parent[pv] = pu;\n                if (rank[pu] == rank[pv]) {\n                    rank[pu]++;\n                }\n            }\n        }\n    }\n};\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    // Create the Union-Find data structure\n    UnionFind uf(n);\n\n    // Read the connections and unite the corresponding nodes\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        uf.unite(a - 1, b - 1);\n    }\n\n    // Read the breakdowns and update the number of components\n    for (int i = 0; i < k; ++i) {\n        int a, b;\n        cin >> a >> b;\n        uf.unite(a - 1, b - 1);\n\n        // Count the number of distinct components by finding the number of unique roots\n        int num_components = 0;\n        for (int j = 0; j < n; ++j) {\n            if (uf.find(j) == j) {\n                num_components++;\n            }\n        }\n\n        cout << num_components << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 13,
            "mean_time_taken": 0.7621065286489633,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Network Renovation",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> graph;\nvector<bool> visited;\n\nvoid dfs(int node) {\n  visited[node] = true;\n  for (int neighbor : graph[node]) {\n    if (!visited[neighbor]) {\n      dfs(neighbor);\n    }\n  }\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  graph.resize(n + 1);\n  visited.resize(n + 1, false);\n\n  for (int i = 0; i < n - 1; i++) {\n    int a, b;\n    cin >> a >> b;\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n\n  // Find the articulation points (critical nodes)\n  int articulation_points = 0;\n  for (int i = 1; i <= n; i++) {\n    if (!visited[i]) {\n      dfs(i);\n      articulation_points++;\n    }\n  }\n\n  // The minimum number of new connections is the number of articulation points - 1\n  int k = articulation_points - 1;\n  cout << k << endl;\n\n  // Connect the articulation points to ensure connectivity\n  vector<int> articulation_nodes;\n  for (int i = 1; i <= n; i++) {\n    if (graph[i].size() > 1) {\n      articulation_nodes.push_back(i);\n    }\n  }\n\n  for (int i = 1; i < articulation_nodes.size(); i++) {\n    cout << articulation_nodes[i - 1] << \" \" << articulation_nodes[i] << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 21,
            "mean_time_taken": 0.14058511597769602,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "New Flight Routes",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\n\nvector<int> adj[MAXN];\nbool visited[MAXN];\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    // Read the input flights\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n\n    // Perform a Depth First Search (DFS) to find connected components\n    int connected_components = 0;\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            connected_components++;\n            queue<int> q;\n            q.push(i);\n            visited[i] = true;\n            while (!q.empty()) {\n                int u = q.front();\n                q.pop();\n                for (int v : adj[u]) {\n                    if (!visited[v]) {\n                        visited[v] = true;\n                        q.push(v);\n                    }\n                }\n            }\n        }\n    }\n\n    // The minimum number of new flights required is one less than the number of connected components\n    int new_flights = connected_components - 1;\n\n    // Print the output\n    cout << new_flights << endl;\n\n    // Print the new flights\n    if (new_flights > 0) {\n        // Choose an arbitrary city from each connected component\n        vector<int> component_cities;\n        for (int i = 1; i <= n; i++) {\n            if (!visited[i]) {\n                component_cities.push_back(i);\n                visited[i] = true;\n                queue<int> q;\n                q.push(i);\n                while (!q.empty()) {\n                    int u = q.front();\n                    q.pop();\n                    for (int v : adj[u]) {\n                        if (!visited[v]) {\n                            visited[v] = true;\n                            q.push(v);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Add a new flight between the first and second city of each component\n        for (int i = 1; i < component_cities.size(); i++) {\n            cout << component_cities[i - 1] << \" \" << component_cities[i] << endl;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 26,
            "mean_time_taken": 0.12276004827939548,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "New Roads Queries",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\n\nvector<int> adj[MAXN];\nint parent[MAXN];\nint depth[MAXN];\nint first_appear[MAXN][MAXN];\n\nvoid dfs(int node, int par, int d) {\n  parent[node] = par;\n  depth[node] = d;\n  for (int child : adj[node]) {\n    if (child != par) {\n      dfs(child, node, d + 1);\n    }\n  }\n}\n\nint lca(int a, int b) {\n  if (depth[a] < depth[b]) swap(a, b);\n  while (depth[a] > depth[b]) {\n    a = parent[a];\n  }\n  while (a != b) {\n    a = parent[a];\n    b = parent[b];\n  }\n  return a;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, m, q;\n  cin >> n >> m >> q;\n\n  for (int i = 1; i <= m; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n\n  dfs(1, 0, 0);\n\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      first_appear[i][j] = -1;\n    }\n  }\n\n  for (int i = 1; i <= m; i++) {\n    int a, b;\n    cin >> a >> b;\n    int l = lca(a, b);\n    first_appear[a][b] = i;\n    first_appear[b][a] = i;\n    first_appear[a][l] = i;\n    first_appear[l][a] = i;\n    first_appear[b][l] = i;\n    first_appear[l][b] = i;\n  }\n\n  for (int i = 1; i <= q; i++) {\n    int a, b;\n    cin >> a >> b;\n    cout << first_appear[a][b] << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 15,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Nim Game I",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<int> heaps(n);\n    for (int i = 0; i < n; ++i) {\n      cin >> heaps[i];\n    }\n    int xorSum = 0;\n    for (int i = 0; i < n; ++i) {\n      xorSum ^= heaps[i];\n    }\n    if (xorSum == 0) {\n      cout << \"second\" << endl;\n    } else {\n      cout << \"first\" << endl;\n    }\n  }\n  return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 4,
            "mean_time_taken": 0.8584455847740173,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Nim Game II",
            "category": "Mathematics",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    int nim_sum = 0;\n    for (int i = 0; i < n; i++) {\n      int x;\n      cin >> x;\n      nim_sum ^= x;\n    }\n    if (nim_sum == 0) {\n      cout << \"second\" << endl;\n    } else {\n      cout << \"first\" << endl;\n    }\n  }\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.14796984195709229,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Number Grid",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n  long long y, x;\n  cin >> y >> x;\n\n  // The value at (y, x) is the maximum of y and x.\n  cout << max(y, x) << endl;\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 20,
            "mean_time_taken": 0.10555166006088257,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                7,
                8,
                9,
                10,
                11,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Number Spiral",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int t;\n  cin >> t;\n\n  while (t--) {\n    long long y, x;\n    cin >> y >> x;\n\n    // Find the layer of the spiral\n    long long layer = max(abs(y), abs(x));\n\n    // Find the starting number of the layer\n    long long start = (layer - 1) * (layer - 1) + 1;\n\n    // Calculate the offset from the starting number\n    long long offset;\n    if (y == layer) {\n      // Right side of the layer\n      offset = x - layer;\n    } else if (x == layer) {\n      // Bottom side of the layer\n      offset = layer - y;\n    } else if (y == -layer) {\n      // Top side of the layer\n      offset = x + layer;\n    } else {\n      // Left side of the layer\n      offset = y + layer;\n    }\n\n    // Calculate the final number\n    long long number = start + offset;\n    cout << number << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.7744889259338379,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "One Bit Positions",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  string s;\n  cin >> s;\n\n  int n = s.size();\n  vector<int> ans(n - 1, 0);\n\n  // For each possible distance 'k'\n  for (int k = 1; k < n; ++k) {\n    // Iterate over all possible starting positions 'i'\n    for (int i = 0; i + k < n; ++i) {\n      // Check if both positions have a '1'\n      if (s[i] == '1' && s[i + k] == '1') {\n        ans[k - 1]++;\n      }\n    }\n  }\n\n  // Print the results for each distance 'k'\n  for (int i = 0; i < n - 1; ++i) {\n    cout << ans[i] << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 5,
            "mean_time_taken": 0.9196028232574462,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Palindrome Queries",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  string s;\n  cin >> s;\n\n  // Adjust string indexing to 0-based\n  s = \" \" + s;\n\n  for (int i = 0; i < m; i++) {\n    int type, k, a, b;\n    cin >> type >> k >> a;\n    if (type == 1) {\n      // Change character at position k\n      char x;\n      cin >> x;\n      s[k] = x;\n    } else {\n      // Check if substring from a to b is a palindrome\n      cin >> b;\n      bool is_palindrome = true;\n      for (int j = a; j <= (a + b) / 2; j++) {\n        if (s[j] != s[a + b - j]) {\n          is_palindrome = false;\n          break;\n        }\n      }\n      if (is_palindrome) {\n        cout << \"YES\" << endl;\n      } else {\n        cout << \"NO\" << endl;\n      }\n    }\n  }\n  return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 14,
            "mean_time_taken": 0.36800030299595426,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Palindrome Reorder",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nint main() {\n  string s;\n  cin >> s;\n\n  // Count the frequency of each character\n  unordered_map<char, int> charCount;\n  for (char c : s) {\n    charCount[c]++;\n  }\n\n  // Check if there is more than one character with an odd count\n  int oddCount = 0;\n  for (auto it : charCount) {\n    if (it.second % 2 != 0) {\n      oddCount++;\n    }\n  }\n\n  // If there are more than one character with an odd count, it's impossible to form a palindrome\n  if (oddCount > 1) {\n    cout << \"NO SOLUTION\" << endl;\n    return 0;\n  }\n\n  // Build the palindrome string\n  string palindrome = \"\";\n  string middle = \"\";\n\n  // Add pairs of characters to the palindrome\n  for (auto it : charCount) {\n    if (it.second % 2 == 0) {\n      for (int i = 0; i < it.second / 2; i++) {\n        palindrome += it.first;\n      }\n    } else {\n      // The character with the odd count forms the middle of the palindrome\n      middle = string(it.second, it.first);\n    }\n  }\n\n  // Reverse the first part of the palindrome and concatenate it with the middle and the original palindrome\n  string reversedPalindrome = string(palindrome.rbegin(), palindrome.rend());\n  cout << reversedPalindrome << middle << palindrome << endl;\n\n  return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 17,
            "mean_time_taken": 0.21798173119040096,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                6,
                8,
                9,
                12,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Parcel Delivery",
            "category": "Advanced Techniques",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n  int n, m, k;\n  cin >> n >> m >> k;\n\n  vector<vector<pair<int, int>>> graph(n + 1); // graph[u] = {(v, r, c)}: route from u to v with capacity r and cost c\n  for (int i = 0; i < m; i++) {\n    int a, b, r, c;\n    cin >> a >> b >> r >> c;\n    graph[a].push_back({b, r, c});\n  }\n\n  vector<vector<int>> dp(n + 1, vector<int>(k + 1, INF)); // dp[u][i] = minimum cost to send i parcels to city u\n  dp[1][0] = 0;\n\n  for (int i = 1; i <= k; i++) {\n    for (int u = 1; u <= n; u++) {\n      for (auto [v, r, c] : graph[u]) {\n        if (i <= r) {\n          dp[v][i] = min(dp[v][i], dp[u][i - 1] + c);\n        }\n      }\n    }\n  }\n\n  int ans = dp[n][k];\n  if (ans == INF) {\n    cout << -1 << endl;\n  } else {\n    cout << ans << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Path Queries",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e5 + 5;\n\nvector<int> adj[N];\nint val[N];\nint par[N];\nint subtree_sum[N];\n\nvoid dfs(int u, int p) {\n  par[u] = p;\n  subtree_sum[u] = val[u];\n  for (auto v : adj[u]) {\n    if (v != p) {\n      dfs(v, u);\n      subtree_sum[u] += subtree_sum[v];\n    }\n  }\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, q;\n  cin >> n >> q;\n\n  for (int i = 1; i <= n; i++) {\n    cin >> val[i];\n  }\n\n  for (int i = 1; i < n; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n\n  dfs(1, 0);\n\n  while (q--) {\n    int type, s, x;\n    cin >> type >> s;\n\n    if (type == 1) {\n      cin >> x;\n      val[s] = x;\n      int u = s;\n      while (u != 0) {\n        subtree_sum[u] += (x - val[u]);\n        u = par[u];\n        val[u] = subtree_sum[u];\n      }\n    } else {\n      cout << subtree_sum[s] << \"\\n\";\n    }\n  }\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.43924994468688966,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Path Queries II",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e5 + 5;\nvector<int> adj[N];\nint val[N];\nint par[N], depth[N];\nint subtree_max[N], chain_head[N], chain_no, pos_in_base[N];\nint base[N], segtree[4 * N];\n\nvoid dfs(int u, int p) {\n  par[u] = p;\n  depth[u] = depth[p] + 1;\n  subtree_max[u] = val[u];\n  for (int v : adj[u]) {\n    if (v != p) {\n      dfs(v, u);\n      subtree_max[u] = max(subtree_max[u], subtree_max[v]);\n    }\n  }\n}\n\nvoid hld(int u, int p) {\n  if (chain_head[chain_no] == -1) {\n    chain_head[chain_no] = u;\n  }\n  pos_in_base[u] = base[chain_no]++;\n  int heavy = -1;\n  for (int v : adj[u]) {\n    if (v != p && subtree_max[v] > subtree_max[heavy]) {\n      heavy = v;\n    }\n  }\n  if (heavy != -1) {\n    hld(heavy, u);\n  }\n  for (int v : adj[u]) {\n    if (v != p && v != heavy) {\n      chain_no++;\n      hld(v, u);\n    }\n  }\n}\n\nvoid build(int node, int l, int r) {\n  if (l == r) {\n    segtree[node] = val[base[l]];\n    return;\n  }\n  int mid = (l + r) / 2;\n  build(2 * node, l, mid);\n  build(2 * node + 1, mid + 1, r);\n  segtree[node] = max(segtree[2 * node], segtree[2 * node + 1]);\n}\n\nvoid update(int node, int l, int r, int pos, int val) {\n  if (l == r) {\n    segtree[node] = val;\n    return;\n  }\n  int mid = (l + r) / 2;\n  if (pos <= mid) {\n    update(2 * node, l, mid, pos, val);\n  } else {\n    update(2 * node + 1, mid + 1, r, pos, val);\n  }\n  segtree[node] = max(segtree[2 * node], segtree[2 * node + 1]);\n}\n\nint query(int node, int l, int r, int ql, int qr) {\n  if (ql > r || qr < l) {\n    return 0;\n  }\n  if (ql <= l && qr >= r) {\n    return segtree[node];\n  }\n  int mid = (l + r) / 2;\n  return max(query(2 * node, l, mid, ql, qr), query(2 * node + 1, mid + 1, r, ql, qr));\n}\n\nint query_path(int a, int b) {\n  int ans = 0;\n  while (chain_head[a] != chain_head[b]) {\n    if (depth[chain_head[a]] < depth[chain_head[b]]) {\n      swap(a, b);\n    }\n    ans = max(ans, query(1, 0, base[chain_no] - 1, pos_in_base[chain_head[a]], pos_in_base[a]));\n    a = par[chain_head[a]];\n  }\n  if (depth[a] > depth[b]) {\n    swap(a, b);\n  }\n  ans = max(ans, query(1, 0, base[chain_no] - 1, pos_in_base[a], pos_in_base[b]));\n  return ans;\n}\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n  for (int i = 1; i <= n; i++) {\n    cin >> val[i];\n  }\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    cin >> u >> v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  memset(chain_head, -1, sizeof(chain_head));\n  dfs(1, 0);\n  chain_no = 0;\n  hld(1, 0);\n  build(1, 0, base[chain_no] - 1);\n  while (q--) {\n    int type, a, b;\n    cin >> type >> a >> b;\n    if (type == 1) {\n      update(1, 0, base[chain_no] - 1, pos_in_base[a], b);\n      val[a] = b;\n    } else {\n      cout << query_path(a, b) << endl;\n    }\n  }\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.9354934692382812,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Pattern Positions",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint main() {\n  string text;\n  cin >> text;\n\n  int k;\n  cin >> k;\n\n  vector<string> patterns(k);\n  for (int i = 0; i < k; ++i) {\n    cin >> patterns[i];\n  }\n\n  // Create a map to store the first occurrence of each pattern in the text\n  unordered_map<string, int> patternPositions;\n\n  // Iterate over the text and find the first occurrence of each pattern\n  for (int i = 0; i < text.length(); ++i) {\n    for (int j = 0; j < k; ++j) {\n      // Check if the current substring of the text matches the pattern\n      if (text.substr(i, patterns[j].length()) == patterns[j]) {\n        // If the pattern is not already in the map, add it with its position\n        if (patternPositions.find(patterns[j]) == patternPositions.end()) {\n          patternPositions[patterns[j]] = i + 1;\n        }\n        break;\n      }\n    }\n  }\n\n  // Print the first position of each pattern or -1 if it does not appear\n  for (int i = 0; i < k; ++i) {\n    if (patternPositions.find(patterns[i]) != patternPositions.end()) {\n      cout << patternPositions[patterns[i]] << endl;\n    } else {\n      cout << -1 << endl;\n    }\n  }\n\n  return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 10,
            "mean_time_taken": 0.7096768856048584,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                4,
                5,
                7,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Permutation Inversions",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n  int n, k;\n  cin >> n >> k;\n\n  // Initialize DP table\n  vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\n  dp[0][0] = 1;\n\n  // Build up DP table\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 0; j <= k; ++j) {\n      if (j >= i) {\n        dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - i]) % MOD;\n      } else {\n        dp[i][j] = dp[i - 1][j] % MOD;\n      }\n    }\n  }\n\n  // Print the answer\n  cout << dp[n][k] << endl;\n\n  return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 16,
            "mean_time_taken": 0.17961996793746948,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                9,
                11,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Permutations",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  // If n is 1 or 2, there's no solution\n  if (n <= 2) {\n    cout << \"NO SOLUTION\" << endl;\n    return 0;\n  }\n\n  // We can construct a beautiful permutation for all other values of n\n  vector<int> permutation(n);\n\n  // Fill the permutation with numbers in a zig-zag pattern\n  // Start with the first number being n\n  permutation[0] = n;\n\n  // For even positions, we'll fill with decreasing numbers\n  for (int i = 1; i < n; i += 2) {\n    permutation[i] = n - i;\n  }\n\n  // For odd positions, we'll fill with increasing numbers, starting from 1\n  for (int i = 2; i < n; i += 2) {\n    permutation[i] = i;\n  }\n\n  // Print the constructed permutation\n  for (int i = 0; i < n; i++) {\n    cout << permutation[i] << \" \";\n  }\n  cout << endl;\n  return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 21,
            "mean_time_taken": 0.1770004772004627,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Permutations II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<vector<long long>> dp(n + 1, vector<long long>(n + 1, 0));\n\n  // Base case\n  for (int j = 1; j <= n; j++) {\n    dp[1][j] = 1;\n  }\n\n  // Build the DP table\n  for (int i = 2; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      if (j - 1 >= 1) {\n        dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD;\n      }\n      if (j + 1 <= n) {\n        dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MOD;\n      }\n    }\n  }\n\n  // Calculate the final answer\n  long long answer = 0;\n  for (int j = 1; j <= n; j++) {\n    answer = (answer + dp[n][j]) % MOD;\n  }\n\n  cout << answer << endl;\n\n  return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 23,
            "mean_time_taken": 0.22080562425696332,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Pizzeria Queries",
            "category": "Range Queries",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, q;\n  cin >> n >> q;\n  vector<int> p(n + 1);\n  for (int i = 1; i <= n; ++i) {\n    cin >> p[i];\n  }\n  while (q--) {\n    int type, k, x;\n    cin >> type >> k;\n    if (type == 1) {\n      cin >> x;\n      p[k] = x;\n    } else {\n      int min_price = INT_MAX;\n      for (int i = 1; i <= n; ++i) {\n        min_price = min(min_price, p[i] + abs(i - k));\n      }\n      cout << min_price << '\\n';\n    }\n  }\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 4,
            "mean_time_taken": 0.5914584994316101,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Planets Cycles",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<int> t(n);\n  for (int i = 0; i < n; i++) {\n    cin >> t[i];\n    t[i]--; // Adjust for 0-based indexing\n  }\n\n  vector<int> cycle_length(n, 0);\n  vector<bool> visited(n, false);\n\n  for (int i = 0; i < n; i++) {\n    if (!visited[i]) {\n      int current = i;\n      int count = 0;\n      while (!visited[current]) {\n        visited[current] = true;\n        current = t[current];\n        count++;\n      }\n      // Assign the cycle length to all planets in this cycle\n      current = i;\n      while (!visited[current]) {\n        cycle_length[current] = count;\n        current = t[current];\n      }\n    }\n  }\n\n  for (int i = 0; i < n; i++) {\n    cout << cycle_length[i] << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 14,
            "mean_time_taken": 0.25381466320582796,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Planets Queries I",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n\n  vector<int> t(n + 1);\n  for (int i = 1; i <= n; i++) {\n    cin >> t[i];\n  }\n\n  for (int i = 0; i < q; i++) {\n    int x, k;\n    cin >> x >> k;\n\n    // Track the current planet and number of teleports used\n    int currentPlanet = x;\n    int teleportsUsed = 0;\n\n    // While we haven't used all the teleports\n    while (teleportsUsed < k) {\n      // Take the teleport from the current planet\n      currentPlanet = t[currentPlanet];\n      teleportsUsed++;\n    }\n\n    // Print the final planet reached\n    cout << currentPlanet << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 13,
            "mean_time_taken": 0.7635349126962515,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                5,
                6,
                8,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Planets Queries II",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint n, q;\nvector<int> teleporters;\nvector<int> dist;\n\nvoid dfs(int node, int depth) {\n    if (dist[node] != -1) return; // Already visited\n    dist[node] = depth;\n    dfs(teleporters[node], depth + 1);\n}\n\nint main() {\n    cin >> n >> q;\n    teleporters.resize(n + 1);\n    dist.resize(n + 1, -1);\n    for (int i = 1; i <= n; i++) {\n        cin >> teleporters[i];\n    }\n\n    for (int i = 0; i < q; i++) {\n        int a, b;\n        cin >> a >> b;\n\n        if (a == b) {\n            cout << 0 << endl;\n        } else {\n            fill(dist.begin(), dist.end(), -1);\n            dfs(a, 0);\n            if (dist[b] != -1) {\n                cout << dist[b] << endl;\n            } else {\n                cout << -1 << endl;\n            }\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 15,
            "mean_time_taken": 0.7914741198221843,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                9,
                11,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Planets and Kingdoms",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 100000;\n\nvector<int> adj[MAXN + 1];\nint kingdom[MAXN + 1];\nbool visited[MAXN + 1];\n\nvoid dfs(int u, int k) {\n  visited[u] = true;\n  kingdom[u] = k;\n  for (int v : adj[u]) {\n    if (!visited[v]) {\n      dfs(v, k);\n    }\n  }\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n\n  int k = 0;\n  for (int i = 1; i <= n; i++) {\n    if (!visited[i]) {\n      k++;\n      dfs(i, k);\n    }\n  }\n\n  cout << k << endl;\n  for (int i = 1; i <= n; i++) {\n    cout << kingdom[i] << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.43842463493347167,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Playlist",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <unordered_map>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  int songId;\n  unordered_map<int, int> songCounts;\n  int start = 0, end = 0;\n  int max_len = 0;\n\n  for (int i = 0; i < n; i++) {\n    cin >> songId;\n\n    // If the song is not in the current window, add it to the map\n    if (songCounts.find(songId) == songCounts.end()) {\n      songCounts[songId] = 1;\n      end++;\n      max_len = max(max_len, end - start); \n    } else {\n      // If the song is repeated, shift the window start to the right\n      while (songCounts[songId] > 0) {\n        songCounts[songId]--;\n        songCounts.erase(songId);\n        start++;\n      }\n      songCounts[songId] = 1;\n      end++;\n      max_len = max(max_len, end - start);\n    }\n  }\n\n  cout << max_len << endl;\n\n  return 0;\n}",
            "passed_test_cases": 14,
            "total_test_cases": 20,
            "mean_time_taken": 0.22562264204025267,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                4,
                8,
                12,
                15,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Point Location Test",
            "category": "Geometry",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int x1, y1, x2, y2, x3, y3;\n    cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\n    // Calculate the cross product of the vectors p1p2 and p1p3\n    long long cross_product = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);\n\n    if (cross_product > 0) {\n      cout << \"LEFT\" << endl;\n    } else if (cross_product < 0) {\n      cout << \"RIGHT\" << endl;\n    } else {\n      cout << \"TOUCH\" << endl;\n    }\n  }\n  return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 6,
            "mean_time_taken": 0.21810797850290933,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Point in Polygon",
            "category": "Geometry",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate the orientation of three points\n// Returns 0 if collinear, 1 if clockwise, -1 if counterclockwise\nint orientation(int x1, int y1, int x2, int y2, int x3, int y3) {\n    int val = (y2 - y1) * (x3 - x2) - (x2 - x1) * (y3 - y2);\n    if (val == 0) return 0;\n    return (val > 0) ? 1 : -1;\n}\n\n// Function to check if a point lies inside, outside or on the boundary of a polygon\n// Returns 1 if inside, -1 if outside, 0 if on boundary\nint pointInPolygon(vector<int> &x, vector<int> &y, int n, int px, int py) {\n    int inside = 0;\n    for (int i = 0; i < n; i++) {\n        int j = (i + 1) % n;\n        // Check if the point is on an edge\n        if (orientation(x[i], y[i], x[j], y[j], px, py) == 0 && \n            min(x[i], x[j]) <= px && px <= max(x[i], x[j]) && \n            min(y[i], y[j]) <= py && py <= max(y[i], y[j])) {\n            return 0;\n        }\n        // Check if the point is below the current edge\n        if (y[i] <= py && y[j] > py && orientation(x[i], y[i], x[j], y[j], px, py) == 1) {\n            inside ^= 1;\n        } else if (y[j] <= py && y[i] > py && orientation(x[i], y[i], x[j], y[j], px, py) == -1) {\n            inside ^= 1;\n        }\n    }\n    return inside;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i];\n    }\n\n    for (int i = 0; i < m; i++) {\n        int px, py;\n        cin >> px >> py;\n\n        int result = pointInPolygon(x, y, n, px, py);\n\n        if (result == 1) {\n            cout << \"INSIDE\" << endl;\n        } else if (result == -1) {\n            cout << \"OUTSIDE\" << endl;\n        } else {\n            cout << \"BOUNDARY\" << endl;\n        }\n    }\n    return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 8,
            "mean_time_taken": 0.11158227920532227,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Police Chase",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n// Function to find the minimum number of streets to be closed\n// to disconnect the bank from the harbor\nint findMinStreets(int n, vector<vector<int>>& graph) {\n    // Initialize a queue to perform a breadth-first search\n    queue<int> q;\n    // Mark all crossings as unvisited\n    vector<bool> visited(n + 1, false);\n    // Start the breadth-first search from the bank (crossing 1)\n    q.push(1);\n    visited[1] = true;\n    // Iterate until the queue is empty\n    while (!q.empty()) {\n        // Get the current crossing from the queue\n        int curr = q.front();\n        q.pop();\n        // Iterate over the neighbors of the current crossing\n        for (int neighbor : graph[curr]) {\n            // If the neighbor is not visited, mark it as visited and add it to the queue\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                q.push(neighbor);\n            }\n        }\n    }\n    // If the harbor (crossing n) is visited, it means there is still a path between the bank and the harbor\n    // Return 0 in this case\n    if (visited[n]) {\n        return 0;\n    }\n    // Otherwise, we need to close at least one street to disconnect the bank from the harbor\n    // We can close the direct street between the bank and the harbor\n    return 1;\n}\n\nint main() {\n    // Read the number of crossings and streets\n    int n, m;\n    cin >> n >> m;\n    // Create a graph to represent the streets\n    vector<vector<int>> graph(n + 1);\n    // Read the streets and add them to the graph\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    // Find the minimum number of streets to be closed\n    int k = findMinStreets(n, graph);\n    // Print the result\n    cout << k << endl;\n    // If we need to close at least one street, we can choose to close the direct street between the bank and the harbor\n    if (k == 1) {\n        cout << \"1 \" << n << endl;\n    }\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.11913248697916666,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Polygon Area",
            "category": "Geometry",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<int> x(n), y(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n  }\n\n  long long area = 0;\n  for (int i = 0; i < n; i++) {\n    int j = (i + 1) % n;\n    area += x[i] * y[j] - x[j] * y[i];\n  }\n\n  cout << abs(area) << endl;\n\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 5,
            "mean_time_taken": 0.10762586593627929,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Polygon Lattice Points",
            "category": "Geometry",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nstruct Point {\n  int x, y;\n};\n\n// Calculate the cross product of two vectors\nint cross(const Point& a, const Point& b, const Point& c) {\n  return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\n// Check if a point lies inside a segment\nbool onSegment(const Point& p, const Point& a, const Point& b) {\n  return min(a.x, b.x) <= p.x && p.x <= max(a.x, b.x) &&\n         min(a.y, b.y) <= p.y && p.y <= max(a.y, b.y);\n}\n\n// Check if a point is inside the polygon\nbool isInside(const vector<Point>& polygon, const Point& p) {\n  int n = polygon.size();\n  bool inside = false;\n\n  for (int i = 0; i < n; ++i) {\n    int j = (i + 1) % n;\n    if (onSegment(p, polygon[i], polygon[j])) {\n      return true;\n    }\n    if (((polygon[i].y <= p.y && polygon[j].y > p.y) ||\n         (polygon[j].y <= p.y && polygon[i].y > p.y)) &&\n        (p.x < (polygon[j].x - polygon[i].x) * (p.y - polygon[i].y) /\n                  (polygon[j].y - polygon[i].y) +\n            polygon[i].x)) {\n      inside = !inside;\n    }\n  }\n  return inside;\n}\n\n// Count the number of lattice points inside and on the boundary\npair<int, int> countLatticePoints(const vector<Point>& polygon) {\n  int inside = 0;\n  int boundary = 0;\n\n  // Iterate over all lattice points within a bounding box\n  int minX = INT_MAX, maxX = INT_MIN, minY = INT_MAX, maxY = INT_MIN;\n  for (const Point& p : polygon) {\n    minX = min(minX, p.x);\n    maxX = max(maxX, p.x);\n    minY = min(minY, p.y);\n    maxY = max(maxY, p.y);\n  }\n\n  for (int x = minX; x <= maxX; ++x) {\n    for (int y = minY; y <= maxY; ++y) {\n      Point p = {x, y};\n      if (isInside(polygon, p)) {\n        if (onSegment(p, polygon[0], polygon[polygon.size() - 1])) {\n          boundary++;\n        } else {\n          for (int i = 0; i < polygon.size() - 1; ++i) {\n            if (onSegment(p, polygon[i], polygon[i + 1])) {\n              boundary++;\n              break;\n            }\n          }\n          if (boundary == 0) {\n            inside++;\n          }\n        }\n      }\n    }\n  }\n  return make_pair(inside, boundary);\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<Point> polygon(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> polygon[i].x >> polygon[i].y;\n  }\n\n  pair<int, int> result = countLatticePoints(polygon);\n  cout << result.first << \" \" << result.second << endl;\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Polynomial Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    // Read initial array\n    vector<int> arr(n + 1, 0); // Add an extra element for ease of calculation\n    for (int i = 1; i <= n; ++i) {\n        cin >> arr[i];\n    }\n\n    // Create difference array\n    vector<int> diff(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        diff[i] = arr[i] - arr[i - 1];\n    }\n\n    while (q--) {\n        int type, a, b;\n        cin >> type >> a >> b;\n\n        if (type == 1) { \n            // Increase query\n            diff[a] += 1;\n            diff[b + 1] -= (b - a + 1); \n        } else if (type == 2) {\n            // Sum query\n            // Calculate prefix sum\n            vector<int> prefixSum(n + 1, 0);\n            prefixSum[0] = 0;\n            for (int i = 1; i <= n; ++i) {\n                prefixSum[i] = prefixSum[i - 1] + diff[i];\n            }\n            // Output sum of range [a, b]\n            cout << prefixSum[b] - prefixSum[a - 1] << endl;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 0.841317892074585,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Prefix Sum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    vector<int> arr(n);\n    vector<long long> ps(n + 1, 0); // Prefix sum array\n\n    // Input the array\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n        ps[i + 1] = ps[i] + arr[i];\n    }\n\n    // Process queries\n    while (q--) {\n        int type, k, u, a, b;\n        cin >> type;\n        if (type == 1) { // Update\n            cin >> k >> u;\n            k--; // Adjust index for 0-based indexing\n            arr[k] = u;\n            ps[k + 1] = ps[k] + arr[k]; // Update prefix sum from k onwards\n            for (int i = k + 2; i <= n; i++) {\n                ps[i] = ps[i - 1] + arr[i - 1];\n            }\n        } else if (type == 2) { // Query\n            cin >> a >> b;\n            a--; // Adjust index for 0-based indexing\n            b--;\n            long long max_prefix_sum = ps[b + 1] - ps[a]; // Calculate max prefix sum in range [a,b]\n            cout << max_prefix_sum << endl;\n        }\n    }\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.7218072017033895,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Prime Multiples",
            "category": "Mathematics",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  long long n, k;\n  cin >> n >> k;\n  vector<long long> a(k);\n  for (int i = 0; i < k; ++i) {\n    cin >> a[i];\n  }\n\n  // Using Inclusion-Exclusion Principle\n  long long ans = 0;\n  for (int i = 1; i < (1 << k); ++i) {\n    long long prod = 1, count = 0;\n    for (int j = 0; j < k; ++j) {\n      if (i & (1 << j)) {\n        prod *= a[j];\n        count++;\n      }\n    }\n    if (count % 2 == 1) {\n      ans += n / prod;\n    } else {\n      ans -= n / prod;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 5,
            "mean_time_taken": 0.5272894382476807,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Programmers and Artists",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int a, b, n;\n  cin >> a >> b >> n;\n\n  vector<pair<int, int>> applicants(n); // Store (programming skill, artistic skill)\n  for (int i = 0; i < n; ++i) {\n    cin >> applicants[i].first >> applicants[i].second;\n  }\n\n  // Sort in descending order based on sum of skills\n  sort(applicants.begin(), applicants.end(), [](const pair<int, int>& p1, const pair<int, int>& p2) {\n    return p1.first + p1.second > p2.first + p2.second;\n  });\n\n  vector<int> programmers;\n  vector<int> artists;\n\n  // Select top a programmers and top b artists\n  for (const auto& applicant : applicants) {\n    if (programmers.size() < a) {\n      programmers.push_back(applicant.first);\n    } else if (artists.size() < b) {\n      artists.push_back(applicant.second);\n    } else {\n      break; // We have enough programmers and artists\n    }\n  }\n\n  // Calculate the sum of skills\n  int sum = 0;\n  for (int skill : programmers) {\n    sum += skill;\n  }\n  for (int skill : artists) {\n    sum += skill;\n  }\n\n  cout << sum << endl;\n  return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 11,
            "mean_time_taken": 0.32668133215470746,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                7,
                9,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Projects",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Project {\n    int start;\n    int end;\n    int profit;\n};\n\nbool compareProjects(const Project &a, const Project &b) {\n    return a.end < b.end; \n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<Project> projects(n);\n    for (int i = 0; i < n; i++) {\n        cin >> projects[i].start >> projects[i].end >> projects[i].profit;\n    }\n\n    // Sort projects by ending day\n    sort(projects.begin(), projects.end(), compareProjects);\n\n    // dp[i] represents the maximum profit achievable up to day 'i'\n    vector<long long> dp(1e9 + 1, 0); \n\n    for (int i = 0; i < n; i++) {\n        int latestValidDay = projects[i].start - 1; \n        dp[projects[i].end] = max(dp[projects[i].end], dp[latestValidDay] + projects[i].profit);\n    }\n\n    long long maxProfit = 0;\n    for (int i = 0; i <= 1e9; i++) {\n        maxProfit = max(maxProfit, dp[i]);\n    }\n\n    cout << maxProfit << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 14,
            "mean_time_taken": 0.45402482577732634,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Pr\u00fcfer Code",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<int> code(n - 2);\n  for (int i = 0; i < n - 2; i++) {\n    cin >> code[i];\n  }\n\n  vector<int> degree(n + 1, 1); // degree of each node\n  for (int i = 0; i < n - 2; i++) {\n    degree[code[i]]++;\n  }\n\n  vector<pair<int, int>> edges; // store the edges\n  vector<int> leaves; // store the leaves\n\n  // find all leaves (nodes with degree 1)\n  for (int i = 1; i <= n; i++) {\n    if (degree[i] == 1) {\n      leaves.push_back(i);\n    }\n  }\n\n  // construct the tree\n  for (int i = 0; i < n - 2; i++) {\n    // find the smallest leaf\n    int leaf = *min_element(leaves.begin(), leaves.end());\n\n    // add the edge between the leaf and its neighbor\n    edges.push_back({leaf, code[i]});\n\n    // remove the leaf from the leaves vector\n    leaves.erase(remove(leaves.begin(), leaves.end(), leaf), leaves.end());\n\n    // update the degree of the neighbor\n    degree[code[i]]--;\n\n    // add the neighbor to the leaves vector if its degree is now 1\n    if (degree[code[i]] == 1) {\n      leaves.push_back(code[i]);\n    }\n  }\n\n  // the last edge connects the two remaining nodes\n  edges.push_back({leaves[0], leaves[1]});\n\n  // print the edges\n  for (auto edge : edges) {\n    cout << edge.first << \" \" << edge.second << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 11,
            "mean_time_taken": 0.36551211097023706,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Pyramid Array",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n\n  // Find the index of the minimum element.\n  int min_index = 0;\n  for (int i = 1; i < n; i++) {\n    if (a[i] < a[min_index]) {\n      min_index = i;\n    }\n  }\n\n  // Calculate the minimum number of moves.\n  int moves = 0;\n  if (min_index == 0) {\n    // The minimum element is already at the beginning.\n    moves = min(n - 1, min_index + 1);\n  } else if (min_index == n - 1) {\n    // The minimum element is already at the end.\n    moves = min(n - 1, min_index);\n  } else {\n    // The minimum element is in the middle.\n    moves = min(min_index, n - min_index - 1);\n  }\n\n  cout << moves << endl;\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 12,
            "mean_time_taken": 0.11678691705067952,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Range Queries and Copies",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n\n  vector<vector<int>> arrays;\n  vector<int> initial_array(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> initial_array[i];\n  }\n  arrays.push_back(initial_array);\n\n  for (int i = 0; i < q; ++i) {\n    int query_type, k, a, b, x;\n    cin >> query_type;\n    if (query_type == 1) {\n      cin >> k >> a >> x;\n      arrays[k - 1][a - 1] = x;\n    } else if (query_type == 2) {\n      cin >> k >> a >> b;\n      int sum = 0;\n      for (int j = a - 1; j < b; ++j) {\n        sum += arrays[k - 1][j];\n      }\n      cout << sum << endl;\n    } else if (query_type == 3) {\n      cin >> k;\n      arrays.push_back(arrays[k - 1]);\n    }\n  }\n\n  return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 7,
            "mean_time_taken": 0.2919814246041434,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n"
            ],
            "failed_test_cases": [
                2,
                4,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Range Update Queries",
            "category": "Range Queries",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\n\n// Segment tree node structure\nstruct Node {\n  int l, r, sum, lazy;\n};\n\n// Array to store the tree\nNode tree[4 * MAXN];\n\n// Function to initialize a node\nvoid init(int node, int l, int r) {\n  tree[node].l = l;\n  tree[node].r = r;\n  tree[node].sum = 0;\n  tree[node].lazy = 0;\n\n  if (l == r) {  // Leaf node\n    return;\n  }\n\n  int mid = (l + r) / 2;\n  init(2 * node, l, mid);\n  init(2 * node + 1, mid + 1, r);\n}\n\n// Function to propagate lazy updates\nvoid propagate(int node) {\n  if (tree[node].lazy != 0) {\n    tree[2 * node].sum += tree[node].lazy * (tree[2 * node].r - tree[2 * node].l + 1);\n    tree[2 * node + 1].sum += tree[node].lazy * (tree[2 * node + 1].r - tree[2 * node + 1].l + 1);\n    tree[2 * node].lazy += tree[node].lazy;\n    tree[2 * node + 1].lazy += tree[node].lazy;\n    tree[node].lazy = 0;\n  }\n}\n\n// Function to update a range [a, b]\nvoid update(int node, int a, int b, int u) {\n  propagate(node); // Push down lazy updates\n\n  if (tree[node].l > b || tree[node].r < a) {\n    return; // Range doesn't overlap\n  }\n\n  if (tree[node].l >= a && tree[node].r <= b) { // Range completely overlaps\n    tree[node].sum += u * (tree[node].r - tree[node].l + 1);\n    tree[node].lazy += u;\n    return;\n  }\n\n  int mid = (tree[node].l + tree[node].r) / 2;\n  update(2 * node, a, b, u);\n  update(2 * node + 1, a, b, u);\n\n  tree[node].sum = tree[2 * node].sum + tree[2 * node + 1].sum;\n}\n\n// Function to query the value at position k\nint query(int node, int k) {\n  propagate(node); // Push down lazy updates\n\n  if (tree[node].l == tree[node].r) {\n    return tree[node].sum; // Leaf node, return value\n  }\n\n  int mid = (tree[node].l + tree[node].r) / 2;\n  if (k <= mid) {\n    return query(2 * node, k);\n  } else {\n    return query(2 * node + 1, k);\n  }\n}\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n\n  // Initialize array\n  int arr[MAXN];\n  for (int i = 1; i <= n; i++) {\n    cin >> arr[i];\n  }\n\n  // Build the segment tree\n  init(1, 1, n);\n\n  // Process queries\n  while (q--) {\n    int type, a, b, u, k;\n    cin >> type;\n\n    if (type == 1) {\n      cin >> a >> b >> u;\n      update(1, a, b, u); // Update range [a, b] by u\n    } else if (type == 2) {\n      cin >> k;\n      cout << query(1, k) << endl; // Query value at position k\n    }\n  }\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 0.19456815719604492,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Range Updates and Sums",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Structure for each node of the segment tree\nstruct Node {\n  int start, end;\n  long long sum;\n  Node *left, *right;\n\n  Node(int s, int e) : start(s), end(e), sum(0), left(nullptr), right(nullptr) {}\n};\n\n// Function to create a new segment tree node\nNode* newNode(int s, int e) {\n  return new Node(s, e);\n}\n\n// Function to build the segment tree\nNode* buildTree(vector<int>& arr, int s, int e) {\n  if (s > e) {\n    return nullptr;\n  }\n\n  Node* root = newNode(s, e);\n\n  if (s == e) {\n    root->sum = arr[s];\n    return root;\n  }\n\n  int mid = (s + e) / 2;\n  root->left = buildTree(arr, s, mid);\n  root->right = buildTree(arr, mid + 1, e);\n\n  root->sum = root->left->sum + root->right->sum;\n  return root;\n}\n\n// Function to increase the values in range [a, b] by x\nvoid updateIncrease(Node* root, int a, int b, int x, int s, int e) {\n  if (s > e || s > b || e < a) {\n    return;\n  }\n\n  if (s >= a && e <= b) {\n    root->sum += (long long)x * (e - s + 1);\n    return;\n  }\n\n  int mid = (s + e) / 2;\n  updateIncrease(root->left, a, b, x, s, mid);\n  updateIncrease(root->right, a, b, x, mid + 1, e);\n\n  root->sum = root->left->sum + root->right->sum;\n}\n\n// Function to set the values in range [a, b] to x\nvoid updateSet(Node* root, int a, int b, int x, int s, int e) {\n  if (s > e || s > b || e < a) {\n    return;\n  }\n\n  if (s >= a && e <= b) {\n    root->sum = (long long)x * (e - s + 1);\n    return;\n  }\n\n  int mid = (s + e) / 2;\n  updateSet(root->left, a, b, x, s, mid);\n  updateSet(root->right, a, b, x, mid + 1, e);\n\n  root->sum = root->left->sum + root->right->sum;\n}\n\n// Function to calculate the sum of values in range [a, b]\nlong long querySum(Node* root, int a, int b, int s, int e) {\n  if (s > e || s > b || e < a) {\n    return 0;\n  }\n\n  if (s >= a && e <= b) {\n    return root->sum;\n  }\n\n  int mid = (s + e) / 2;\n  return querySum(root->left, a, b, s, mid) + querySum(root->right, a, b, mid + 1, e);\n}\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n\n  vector<int> arr(n);\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n  }\n\n  // Build the segment tree\n  Node* root = buildTree(arr, 0, n - 1);\n\n  // Process queries\n  while (q--) {\n    int type, a, b, x;\n    cin >> type >> a >> b;\n\n    if (type == 1) {\n      cin >> x;\n      updateIncrease(root, a - 1, b - 1, x, 0, n - 1);\n    } else if (type == 2) {\n      cin >> x;\n      updateSet(root, a - 1, b - 1, x, 0, n - 1);\n    } else if (type == 3) {\n      cout << querySum(root, a - 1, b - 1, 0, n - 1) << endl;\n    }\n  }\n\n  return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 4,
            "mean_time_taken": 0.22730422019958496,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Range Xor Queries",
            "category": "Range Queries",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n\n  // Calculate prefix XOR array\n  vector<int> prefixXor(n + 1, 0);\n  for (int i = 1; i <= n; i++) {\n    prefixXor[i] = prefixXor[i - 1] ^ a[i - 1];\n  }\n\n  // Process queries\n  while (q--) {\n    int a, b;\n    cin >> a >> b;\n\n    // XOR sum of values in range [a, b] is prefixXor[b + 1] ^ prefixXor[a]\n    cout << (prefixXor[b + 1] ^ prefixXor[a]) << endl;\n  }\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.19165706634521484,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Reachability Queries",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 5e4 + 5;\n\nvector<int> adj[MAXN];\n\n// Function to perform Depth First Search (DFS) from a given node\nvoid dfs(int node, vector<bool>& visited) {\n  visited[node] = true;\n  for (int neighbor : adj[node]) {\n    if (!visited[neighbor]) {\n      dfs(neighbor, visited);\n    }\n  }\n}\n\nint main() {\n  int n, m, q;\n  cin >> n >> m >> q;\n\n  // Read the edges and build the adjacency list\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n  }\n\n  // Handle each query\n  for (int i = 0; i < q; i++) {\n    int a, b;\n    cin >> a >> b;\n\n    // Initialize a vector to keep track of visited nodes\n    vector<bool> visited(n + 1, false);\n\n    // Perform DFS from node 'a'\n    dfs(a, visited);\n\n    // Check if node 'b' was visited during DFS\n    if (visited[b]) {\n      cout << \"YES\" << endl;\n    } else {\n      cout << \"NO\" << endl;\n    }\n  }\n\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 7,
            "mean_time_taken": 0.8185547760554722,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Reachable Nodes",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<vector<int>> graph;\nvector<bool> visited;\n\nint dfs(int node) {\n    visited[node] = true;\n    int count = 1; // Count the node itself\n    for (int neighbor : graph[node]) {\n        if (!visited[neighbor]) {\n            count += dfs(neighbor);\n        }\n    }\n    return count;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    graph.assign(n + 1, vector<int>());\n    visited.assign(n + 1, false);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n    }\n\n    vector<int> reachable_nodes(n + 1);\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            reachable_nodes[i] = dfs(i);\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        cout << reachable_nodes[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 4,
            "mean_time_taken": 0.143052339553833,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Reading Books",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<int> t(n);\n  for (int i = 0; i < n; i++) {\n    cin >> t[i];\n  }\n\n  // Sort the reading times in descending order\n  sort(t.begin(), t.end(), greater<int>());\n\n  // Calculate the minimum total time\n  int total_time = 0;\n  for (int i = 0; i < n; i += 2) {\n    if (i + 1 < n) {\n      total_time += max(t[i], t[i + 1]);\n    } else {\n      total_time += t[i];\n    }\n  }\n\n  cout << total_time << endl;\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 13,
            "mean_time_taken": 0.20302838545579177,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Rectangle Cutting",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n\nusing namespace std;\n\nint gcd(int a, int b) {\n  if (b == 0) {\n    return a;\n  }\n  return gcd(b, a % b);\n}\n\nint main() {\n  int a, b;\n  cin >> a >> b;\n\n  int g = gcd(a, b);\n  int cuts = ((a / g) - 1) + ((b / g) - 1);\n\n  cout << cuts << endl;\n\n  return 0;\n}",
            "passed_test_cases": 7,
            "total_test_cases": 26,
            "mean_time_taken": 0.16215497713822585,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                5,
                6,
                8,
                9,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                19,
                20,
                22,
                23,
                24,
                26
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Removal Game",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> nums(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> nums[i];\n    }\n\n    // dp[i][j] = maximum score for the first player from nums[i:j]\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n\n    // Base cases\n    for (int i = 0; i < n; ++i) {\n        dp[i][i] = nums[i];\n    }\n\n    // Bottom-up iteration\n    for (int len = 2; len <= n; ++len) {\n        for (int i = 0; i <= n - len; ++i) {\n            int j = i + len - 1;\n            dp[i][j] = max(\n                nums[i] + (dp[i + 1][j] - dp[i + 1][j - 1]),\n                nums[j] + (dp[i][j - 1] - dp[i + 1][j - 1])\n            );\n        }\n    }\n\n    cout << dp[0][n - 1] << endl;\n\n    return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 14,
            "mean_time_taken": 0.42975521087646484,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 16,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Removing Digits",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  // Calculate the number of digits in n\n  int digits = 0;\n  int temp = n;\n  while (temp > 0) {\n    digits++;\n    temp /= 10;\n  }\n\n  // Calculate the minimum number of steps\n  int steps = 0;\n  while (n > 0) {\n    // Find the largest digit in n\n    int max_digit = 0;\n    temp = n;\n    while (temp > 0) {\n      max_digit = max(max_digit, temp % 10);\n      temp /= 10;\n    }\n\n    // Subtract the largest digit from n\n    n -= max_digit;\n    steps++;\n  }\n\n  // Print the minimum number of steps\n  cout << steps << endl;\n\n  return 0;\n}",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.09876094545636858,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Removing Digits II",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  long long n;\n  cin >> n;\n\n  // We can greedily remove the largest digit at each step.\n  // We can do this by sorting the digits of n and then removing them from largest to smallest.\n  vector<int> digits;\n  while (n > 0) {\n    digits.push_back(n % 10);\n    n /= 10;\n  }\n  sort(digits.begin(), digits.end());\n\n  // We can remove the largest digit a maximum of 9 times (since it can be a 9).\n  int steps = 0;\n  for (int i = digits.size() - 1; i >= 0; i--) {\n    steps += digits[i];\n  }\n\n  cout << steps << endl;\n\n  return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 9,
            "mean_time_taken": 0.21726616223653158,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Repeating Substring",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring longestRepeatingSubstring(string s) {\n  int n = s.size();\n  // Create a 2D array to store the lengths of longest common suffixes\n  int dp[n + 1][n + 1];\n  for (int i = 0; i <= n; ++i) {\n    for (int j = 0; j <= n; ++j) {\n      dp[i][j] = 0;\n    }\n  }\n  // Calculate the lengths of longest common suffixes\n  int maxLength = 0;\n  int endIndex = 0;\n  for (int i = 1; i <= n; ++i) {\n    for (int j = i + 1; j <= n; ++j) {\n      if (s[i - 1] == s[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1] + 1;\n        if (dp[i][j] > maxLength) {\n          maxLength = dp[i][j];\n          endIndex = i;\n        }\n      }\n    }\n  }\n  // If there is no repeating substring\n  if (maxLength == 0) {\n    return \"-1\";\n  }\n  // Extract the longest repeating substring\n  return s.substr(endIndex - maxLength, maxLength);\n}\n\nint main() {\n  string s;\n  cin >> s;\n  cout << longestRepeatingSubstring(s) << endl;\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 8,
            "mean_time_taken": 0.1502377688884735,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 17,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Repetitions",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n  string dna;\n  cin >> dna;\n\n  int current_length = 1; // Length of the current repetition\n  int max_length = 1; // Length of the longest repetition found so far\n\n  char prev_char = dna[0]; // Store the first character\n\n  for (int i = 1; i < dna.length(); i++) {\n    if (dna[i] == prev_char) {\n      current_length++;\n    } else {\n      current_length = 1;\n      prev_char = dna[i];\n    }\n    max_length = max(max_length, current_length);\n  }\n\n  cout << max_length << endl;\n\n  return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 12,
            "mean_time_taken": 0.3262168963750203,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Required Substring",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  string pattern;\n  cin >> pattern;\n\n  // Calculate the number of possible characters for each position in the final string.\n  long long count = 26; // 26 characters (A-Z) are possible for the first position.\n  for (int i = 1; i < n - m + 1; i++) {\n    count = (count * 26) % MOD; // For each subsequent position, we have 26 options.\n  }\n\n  // Account for the positions where the pattern is forced.\n  for (int i = n - m + 1; i < n; i++) {\n    count = (count * 1) % MOD; // Only 1 character is possible for these positions.\n  }\n\n  // Calculate the final count by multiplying the possibilities for each position.\n  cout << count << endl;\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 19,
            "mean_time_taken": 0.1080458540665476,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 18,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Restaurant Customers",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> arrivals;\n    vector<int> departures;\n\n    // Read arrival and departure times\n    for (int i = 0; i < n; i++) {\n        int a, b;\n        cin >> a >> b;\n        arrivals.push_back(a);\n        departures.push_back(b);\n    }\n\n    // Sort the times\n    sort(arrivals.begin(), arrivals.end());\n    sort(departures.begin(), departures.end());\n\n    // Initialize variables\n    int currentCustomers = 0;\n    int maxCustomers = 0;\n    int i = 0, j = 0;\n\n    // Iterate through arrival and departure times\n    while (i < n && j < n) {\n        if (arrivals[i] <= departures[j]) {\n            currentCustomers++;\n            i++;\n        } else {\n            currentCustomers--;\n            j++;\n        }\n        maxCustomers = max(maxCustomers, currentCustomers); \n    }\n\n    // Print the maximum number of customers\n    cout << maxCustomers << endl;\n\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.16720185279846192,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Reversal Sorting",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n\n  vector<int> b(n);\n  for (int i = 0; i < n; i++) {\n    b[i] = i + 1;\n  }\n\n  vector<pair<int, int>> reversals;\n\n  int k = 0;\n  for (int i = 0; i < n; i++) {\n    if (a[i] != b[i]) {\n      int j = i;\n      while (a[j] != b[i]) {\n        j++;\n      }\n      reversals.push_back({i, j});\n      reverse(a.begin() + i, a.begin() + j + 1);\n      k++;\n    }\n  }\n\n  cout << k << endl;\n  for (auto p : reversals) {\n    cout << p.first + 1 << \" \" << p.second + 1 << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Reversals and Sums",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  vector<int> arr(n);\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n  }\n\n  for (int i = 0; i < m; i++) {\n    int t, a, b;\n    cin >> t >> a >> b;\n\n    if (t == 1) {\n      // Reverse subarray\n      a--;\n      b--;\n      while (a < b) {\n        swap(arr[a], arr[b]);\n        a++;\n        b--;\n      }\n    } else if (t == 2) {\n      // Calculate sum of subarray\n      a--;\n      b--;\n      long long sum = 0;\n      for (int j = a; j <= b; j++) {\n        sum += arr[j];\n      }\n      cout << sum << endl;\n    }\n  }\n\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 4,
            "mean_time_taken": 0.5738898515701294,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Road Construction",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  // Initialize a vector of size n, representing the parent of each node\n  vector<int> parent(n + 1);\n  // Initially, each node is its own parent\n  for (int i = 1; i <= n; ++i) {\n    parent[i] = i;\n  }\n\n  // Initialize a vector to store the size of each component\n  vector<int> componentSize(n + 1, 1);\n\n  // Number of components\n  int numComponents = n;\n\n  // Process each road construction\n  for (int i = 0; i < m; ++i) {\n    int a, b;\n    cin >> a >> b;\n\n    // Find the root of the component containing city a\n    int rootA = a;\n    while (parent[rootA] != rootA) {\n      rootA = parent[rootA];\n    }\n\n    // Find the root of the component containing city b\n    int rootB = b;\n    while (parent[rootB] != rootB) {\n      rootB = parent[rootB];\n    }\n\n    // If the two cities belong to different components, merge them\n    if (rootA != rootB) {\n      // Merge the components by setting the parent of the smaller component\n      // to the root of the larger component\n      if (componentSize[rootA] > componentSize[rootB]) {\n        parent[rootB] = rootA;\n        componentSize[rootA] += componentSize[rootB];\n      } else {\n        parent[rootA] = rootB;\n        componentSize[rootB] += componentSize[rootA];\n      }\n\n      // Decrease the number of components by 1\n      numComponents--;\n    }\n\n    // Find the size of the largest component\n    int maxSize = 0;\n    for (int i = 1; i <= n; ++i) {\n      maxSize = max(maxSize, componentSize[i]);\n    }\n\n    // Print the number of components and the size of the largest component\n    cout << numComponents << \" \" << maxSize << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 8,
            "mean_time_taken": 0.9429870247840881,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Road Reparation",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst long long INF = 1e18;\n\nstruct Edge {\n  int to;\n  long long cost;\n};\n\nvector<vector<Edge>> graph;\nvector<long long> dist;\nvector<bool> visited;\n\nvoid dijkstra(int start) {\n  priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\n  dist[start] = 0;\n  pq.push({0, start});\n\n  while (!pq.empty()) {\n    auto [d, u] = pq.top();\n    pq.pop();\n\n    if (visited[u]) {\n      continue;\n    }\n    visited[u] = true;\n\n    for (auto& edge : graph[u]) {\n      if (dist[edge.to] > d + edge.cost) {\n        dist[edge.to] = d + edge.cost;\n        pq.push({dist[edge.to], edge.to});\n      }\n    }\n  }\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  graph.resize(n + 1);\n  dist.assign(n + 1, INF);\n  visited.assign(n + 1, false);\n\n  for (int i = 0; i < m; ++i) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    graph[a].push_back({b, c});\n    graph[b].push_back({a, c});\n  }\n\n  dijkstra(1);\n\n  if (dist[n] == INF) {\n    cout << \"IMPOSSIBLE\" << endl;\n  } else {\n    cout << dist[n] << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 16,
            "mean_time_taken": 0.33329035341739655,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                5,
                6,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                16
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Robot Path",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  int x = 0, y = 0;\n  int total_distance = 0;\n\n  unordered_map<pair<int, int>, bool> visited;\n  visited[{0, 0}] = true;\n\n  for (int i = 0; i < n; i++) {\n    char direction;\n    int distance;\n    cin >> direction >> distance;\n\n    switch (direction) {\n      case 'U':\n        y += distance;\n        break;\n      case 'D':\n        y -= distance;\n        break;\n      case 'L':\n        x -= distance;\n        break;\n      case 'R':\n        x += distance;\n        break;\n    }\n\n    total_distance += distance;\n\n    if (visited.count({x, y})) {\n      break;\n    } else {\n      visited[{x, y}] = true;\n    }\n  }\n\n  cout << total_distance << endl;\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Room Allocation",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<pair<int, int>> customers(n);\n  for (int i = 0; i < n; i++) {\n    cin >> customers[i].first >> customers[i].second;\n  }\n\n  // Priority queue to store available rooms (sorted by departure day)\n  priority_queue<int, vector<int>, greater<int>> rooms;\n  int numRooms = 0;\n  vector<int> assignedRooms(n);\n\n  for (int i = 0; i < n; i++) {\n    // Check if there's a room available\n    if (!rooms.empty()) {\n      assignedRooms[i] = rooms.top();\n      rooms.pop();\n    } else {\n      // Allocate a new room\n      numRooms++;\n      assignedRooms[i] = numRooms;\n    }\n\n    // Add the current customer's departure day to the priority queue\n    rooms.push(customers[i].second);\n  }\n\n  // Output the results\n  cout << numRooms << endl;\n  for (int i = 0; i < n; i++) {\n    cout << assignedRooms[i] << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 12,
            "mean_time_taken": 0.17866885662078857,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Round Trip",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n// Function to find a cycle in the graph using Depth First Search (DFS)\nbool dfs(int node, int parent, vector<vector<int>>& graph, vector<bool>& visited, vector<int>& cycle) {\n  visited[node] = true;\n  cycle.push_back(node);\n  for (int neighbor : graph[node]) {\n    if (neighbor != parent) {\n      if (!visited[neighbor]) {\n        if (dfs(neighbor, node, graph, visited, cycle)) {\n          return true;\n        }\n      } else {\n        // Found a cycle, return true\n        return true;\n      }\n    }\n  }\n  // Backtrack: remove the current node from the cycle path\n  cycle.pop_back();\n  return false;\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  // Create an adjacency list to represent the graph\n  vector<vector<int>> graph(n + 1);\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n\n  // Mark all nodes as not visited initially\n  vector<bool> visited(n + 1, false);\n\n  // Find a cycle in the graph\n  vector<int> cycle;\n  for (int i = 1; i <= n; i++) {\n    if (!visited[i]) {\n      if (dfs(i, -1, graph, visited, cycle)) {\n        // Cycle found, print the path\n        cout << cycle.size() << endl;\n        for (int city : cycle) {\n          cout << city << \" \";\n        }\n        cout << endl;\n        return 0;\n      }\n    }\n  }\n\n  // No cycle found\n  cout << \"IMPOSSIBLE\" << endl;\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 26,
            "mean_time_taken": 0.1488087819172786,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                26
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Round Trip II",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n// Adjacency list to represent the graph\nvector<vector<int>> adj;\n\n// Function to perform Depth First Search (DFS) from a given city\nvoid dfs(int city, vector<int>& visited, vector<int>& path) {\n  visited[city] = 1;\n  path.push_back(city);\n\n  // Explore all adjacent cities\n  for (int neighbor : adj[city]) {\n    if (!visited[neighbor]) {\n      dfs(neighbor, visited, path);\n      // If we find a cycle, return\n      if (path.size() >= 3 && path[0] == neighbor) {\n        return;\n      }\n    }\n  }\n\n  // If no cycle is found, remove the current city from the path\n  path.pop_back();\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  // Initialize adjacency list\n  adj.resize(n + 1);\n\n  // Read flight connections\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n  }\n\n  // Initialize visited array and path vector\n  vector<int> visited(n + 1, 0);\n  vector<int> path;\n\n  // Iterate through each city to perform DFS\n  for (int i = 1; i <= n; i++) {\n    if (!visited[i]) {\n      dfs(i, visited, path);\n      // If a cycle is found, print the path and exit\n      if (path.size() >= 3) {\n        cout << path.size() << endl;\n        for (int j = 0; j < path.size(); j++) {\n          cout << path[j] << \" \";\n        }\n        return 0;\n      }\n    }\n  }\n\n  // If no cycle is found, print \"IMPOSSIBLE\"\n  cout << \"IMPOSSIBLE\" << endl;\n  return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 20,
            "mean_time_taken": 0.2206824779510498,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                18,
                20
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Salary Queries",
            "category": "Range Queries",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n\n  vector<int> salaries(n);\n  for (int i = 0; i < n; i++) {\n    cin >> salaries[i];\n  }\n\n  // Use a binary indexed tree (Fenwick tree) to efficiently handle the queries.\n  vector<int> BIT(1e9 + 1, 0); // Initialize with size 1e9+1 as salaries range from 1 to 1e9.\n\n  // Function to update the BIT with a new value at a specific index.\n  auto update = [&](int idx, int val) {\n    while (idx <= 1e9) {\n      BIT[idx] += val;\n      idx += (idx & -idx);\n    }\n  };\n\n  // Function to query the sum of values from 1 to a given index.\n  auto query = [&](int idx) {\n    int sum = 0;\n    while (idx > 0) {\n      sum += BIT[idx];\n      idx -= (idx & -idx);\n    }\n    return sum;\n  };\n\n  // Initially, update the BIT with the salaries.\n  for (int i = 0; i < n; i++) {\n    update(salaries[i], 1);\n  }\n\n  // Process the queries.\n  while (q--) {\n    char type;\n    int k, x, a, b;\n    cin >> type;\n\n    if (type == '!') {\n      cin >> k >> x;\n      // Update the BIT with the new salary.\n      update(salaries[k - 1], -1); // Decrease count of the old salary.\n      salaries[k - 1] = x;\n      update(salaries[k - 1], 1); // Increase count of the new salary.\n    } else {\n      cin >> a >> b;\n      // Calculate the number of salaries between a and b.\n      int count = query(b) - query(a - 1);\n      cout << count << endl;\n    }\n  }\n  return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 13,
            "mean_time_taken": 0.3084759528820331,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "School Dance",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    // Adjacency list to represent the graph\n    vector<vector<int>> adj(n + 1); \n    for (int i = 0; i < k; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n\n    // Store the potential pairs along with their popularity\n    vector<pair<int, int>> pairs;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 0; j < adj[i].size(); ++j) {\n            pairs.push_back({i, adj[i][j]}); \n        }\n    }\n\n    // Sort the pairs based on the popularity of the boy\n    sort(pairs.begin(), pairs.end(), [&adj](const pair<int, int>& a, const pair<int, int>& b) {\n        return adj[a.first].size() > adj[b.first].size(); \n    });\n\n    // Keep track of taken boys and girls\n    vector<bool> takenBoys(n + 1, false); \n    vector<bool> takenGirls(m + 1, false);\n\n    // Greedy matching\n    int count = 0; \n    vector<pair<int, int>> result;\n    for (auto p : pairs) {\n        int boy = p.first;\n        int girl = p.second;\n\n        // If both are not taken, create a pair\n        if (!takenBoys[boy] && !takenGirls[girl]) {\n            takenBoys[boy] = true;\n            takenGirls[girl] = true;\n            count++;\n            result.push_back({boy, girl});\n        }\n    }\n\n    cout << count << endl;\n    for (auto p : result) {\n        cout << p.first << \" \" << p.second << endl;\n    }\n\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 15,
            "mean_time_taken": 0.27379393577575684,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                7,
                8,
                9,
                11,
                12,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "School Excursion",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  // Create a vector to store the children's wishes.\n  vector<vector<int>> wishes(n + 1);\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    wishes[a].push_back(b);\n    wishes[b].push_back(a);\n  }\n\n  // Create a vector to store the possible number of children visiting Korkeasaari.\n  vector<bool> possible(n + 1, false);\n\n  // Start by assuming all children can visit Korkeasaari.\n  possible[n] = true;\n\n  // Iterate over the wishes in reverse order.\n  for (int i = n - 1; i >= 0; i--) {\n    // If the current child has any wishes, check if the number of children visiting Korkeasaari can be reduced.\n    if (!wishes[i].empty()) {\n      // If the current child wants to visit the same attraction as another child, then the number of children visiting Korkeasaari can be reduced by one.\n      if (possible[i + 1]) {\n        possible[i] = true;\n      }\n      // Iterate over the wishes of the current child.\n      for (int j = 0; j < wishes[i].size(); j++) {\n        // If the other child wants to visit the same attraction as the current child, then the number of children visiting Korkeasaari can be reduced by two.\n        if (possible[i + 2]) {\n          possible[i] = true;\n        }\n      }\n    } else {\n      // If the current child doesn't have any wishes, then the number of children visiting Korkeasaari can be reduced by one.\n      if (possible[i + 1]) {\n        possible[i] = true;\n      }\n    }\n  }\n\n  // Print the possible number of children visiting Korkeasaari.\n  for (int i = 1; i <= n; i++) {\n    cout << (possible[i] ? 1 : 0);\n  }\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 13,
            "mean_time_taken": 0.3305783821986272,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Shortest Routes I",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n// Structure to represent a flight connection\nstruct Flight {\n    int destination;\n    int length;\n};\n\n// Function to find the shortest routes from Syrj\u00e4l\u00e4 (city 1) to all other cities\nvector<int> shortestRoutes(int n, int m, vector<vector<Flight>>& flights) {\n    // Initialize distances to infinity\n    vector<int> distances(n + 1, INT_MAX);\n\n    // Initialize distance from Syrj\u00e4l\u00e4 to itself as 0\n    distances[1] = 0;\n\n    // Priority queue to store cities and their current shortest distances\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n\n    // Push Syrj\u00e4l\u00e4 into the priority queue\n    pq.push({0, 1});\n\n    while (!pq.empty()) {\n        // Get the city with the shortest distance\n        int currentDistance = pq.top().first;\n        int currentCity = pq.top().second;\n        pq.pop();\n\n        // If the current distance is greater than the known shortest distance, skip\n        if (currentDistance > distances[currentCity]) {\n            continue;\n        }\n\n        // Iterate through all flights from the current city\n        for (auto flight : flights[currentCity]) {\n            // Calculate the distance to the destination city\n            int newDistance = currentDistance + flight.length;\n\n            // If the new distance is shorter than the current shortest distance, update the shortest distance and push the destination city into the priority queue\n            if (newDistance < distances[flight.destination]) {\n                distances[flight.destination] = newDistance;\n                pq.push({newDistance, flight.destination});\n            }\n        }\n    }\n\n    return distances;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    // Adjacency list to represent flight connections\n    vector<vector<Flight>> flights(n + 1);\n\n    // Read flight connections\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        flights[a].push_back({b, c});\n    }\n\n    // Find the shortest routes\n    vector<int> shortestRouteLengths = shortestRoutes(n, m, flights);\n\n    // Print shortest routes for each city\n    for (int i = 1; i <= n; i++) {\n        cout << shortestRouteLengths[i] << \" \";\n    }\n\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Shortest Routes II",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\n\nvector<vector<pair<int, int>>> adj;\n\nvoid dijkstra(int start, vector<int>& dist) {\n  priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n  dist[start] = 0;\n  pq.push({0, start});\n\n  while (!pq.empty()) {\n    int u = pq.top().second;\n    int d = pq.top().first;\n    pq.pop();\n\n    if (d > dist[u]) continue;\n\n    for (auto [v, w] : adj[u]) {\n      if (dist[u] + w < dist[v]) {\n        dist[v] = dist[u] + w;\n        pq.push({dist[v], v});\n      }\n    }\n  }\n}\n\nint main() {\n  int n, m, q;\n  cin >> n >> m >> q;\n\n  adj.resize(n + 1);\n\n  for (int i = 0; i < m; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    adj[a].push_back({b, c});\n    adj[b].push_back({a, c});\n  }\n\n  for (int i = 0; i < q; i++) {\n    int a, b;\n    cin >> a >> b;\n\n    vector<int> dist(n + 1, INF);\n    dijkstra(a, dist);\n\n    if (dist[b] == INF) {\n      cout << -1 << endl;\n    } else {\n      cout << dist[b] << endl;\n    }\n  }\n\n  return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 15,
            "mean_time_taken": 0.7343762556711833,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                5,
                6,
                7,
                9,
                11,
                13,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Shortest Subsequence",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  string s;\n  cin >> s;\n\n  // Find the first character that is not in the string.\n  char missing = 'A';\n  for (char c : s) {\n    if (c == missing) {\n      missing++;\n    }\n  }\n\n  // If all characters are in the string, then the shortest subsequence that is not a subsequence is \"AAA\".\n  if (missing == 'T' + 1) {\n    cout << \"AAA\" << endl;\n  } else {\n    // Otherwise, the shortest subsequence that is not a subsequence is the missing character repeated three times.\n    cout << string(3, missing) << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 10,
            "mean_time_taken": 0.23055877685546874,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Signal Processing",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  vector<int> a(n), b(m);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  for (int i = 0; i < m; i++) {\n    cin >> b[i];\n  }\n\n  // Calculate the sum of products for each mask position\n  for (int i = 0; i < n + m - 1; i++) {\n    int sum = 0;\n    // Iterate through the overlapping part of the signal and mask\n    for (int j = max(0, i - m + 1); j <= min(i, n - 1); j++) {\n      sum += a[j] * b[i - j];\n    }\n    cout << sum << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 6,
            "mean_time_taken": 0.7338437636693319,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sliding Window Cost",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int n, k;\n  cin >> n >> k;\n\n  vector<int> arr(n);\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n  }\n\n  // Calculate the cost for the first window\n  long long cost = 0;\n  for (int i = 0; i < k; i++) {\n    cost += abs(arr[i] - arr[k / 2]);\n  }\n\n  // Store the calculated costs for each window\n  vector<long long> costs(n - k + 1);\n  costs[0] = cost;\n\n  // Iterate through the remaining windows\n  for (int i = 1; i < n - k + 1; i++) {\n    // Remove the cost of the element leaving the window\n    cost -= abs(arr[i - 1] - arr[k / 2 + i - 1]);\n    // Add the cost of the element entering the window\n    cost += abs(arr[i + k - 1] - arr[k / 2 + i - 1]);\n    // Store the calculated cost for the current window\n    costs[i] = cost;\n  }\n\n  // Output the costs for each window\n  for (int i = 0; i < n - k + 1; i++) {\n    cout << costs[i] << \" \";\n  }\n\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 21,
            "total_test_cases": 34,
            "mean_time_taken": 0.12755935332354376,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                5,
                8,
                9,
                11,
                12,
                22,
                25,
                28,
                29,
                30,
                31,
                32,
                34
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sliding Window Median",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n, k;\n  cin >> n >> k;\n\n  vector<int> arr(n);\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n  }\n\n  // Create two priority queues:\n  // 'minHeap' stores the larger half of the window elements (with the smallest element at the top)\n  // 'maxHeap' stores the smaller half of the window elements (with the largest element at the top)\n  priority_queue<int, vector<int>, greater<int>> minHeap;\n  priority_queue<int> maxHeap;\n\n  // Process the first window\n  for (int i = 0; i < k; i++) {\n    if (maxHeap.empty() || arr[i] <= maxHeap.top()) {\n      maxHeap.push(arr[i]);\n    } else {\n      minHeap.push(arr[i]);\n    }\n    // Balance the heaps\n    if (maxHeap.size() > minHeap.size() + 1) {\n      minHeap.push(maxHeap.top());\n      maxHeap.pop();\n    } else if (minHeap.size() > maxHeap.size()) {\n      maxHeap.push(minHeap.top());\n      minHeap.pop();\n    }\n  }\n\n  // Output the median of the first window\n  cout << (maxHeap.size() > minHeap.size() ? maxHeap.top() : minHeap.top()) << \" \";\n\n  // Process the remaining windows\n  for (int i = k; i < n; i++) {\n    // Remove the leftmost element from the window\n    if (arr[i - k] <= maxHeap.top()) {\n      maxHeap.pop();\n    } else {\n      minHeap.pop();\n    }\n\n    // Add the new element to the right of the window\n    if (maxHeap.empty() || arr[i] <= maxHeap.top()) {\n      maxHeap.push(arr[i]);\n    } else {\n      minHeap.push(arr[i]);\n    }\n\n    // Balance the heaps\n    if (maxHeap.size() > minHeap.size() + 1) {\n      minHeap.push(maxHeap.top());\n      maxHeap.pop();\n    } else if (minHeap.size() > maxHeap.size()) {\n      maxHeap.push(minHeap.top());\n      minHeap.pop();\n    }\n\n    // Output the median of the current window\n    cout << (maxHeap.size() > minHeap.size() ? maxHeap.top() : minHeap.top()) << \" \";\n  }\n\n  cout << endl;\n  return 0;\n}",
            "passed_test_cases": 20,
            "total_test_cases": 40,
            "mean_time_taken": 0.22821223139762878,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                6,
                8,
                9,
                12,
                15,
                18,
                20,
                21,
                22,
                25,
                28,
                30,
                31,
                33,
                34,
                35,
                38
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sorting Methods",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to count inversions in a given array using merge sort\nlong long merge_and_count(vector<int>& arr, int left, int mid, int right) {\n    long long inversions = 0;\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n    vector<int> left_arr(n1);\n    vector<int> right_arr(n2);\n    for (int i = 0; i < n1; i++) {\n        left_arr[i] = arr[left + i];\n    }\n    for (int i = 0; i < n2; i++) {\n        right_arr[i] = arr[mid + 1 + i];\n    }\n    int i = 0, j = 0, k = left;\n    while (i < n1 && j < n2) {\n        if (left_arr[i] <= right_arr[j]) {\n            arr[k++] = left_arr[i++];\n        } else {\n            arr[k++] = right_arr[j++];\n            inversions += (n1 - i);\n        }\n    }\n    while (i < n1) {\n        arr[k++] = left_arr[i++];\n    }\n    while (j < n2) {\n        arr[k++] = right_arr[j++];\n    }\n    return inversions;\n}\n\n// Function to count inversions in a given array\nlong long count_inversions(vector<int>& arr, int left, int right) {\n    if (left >= right) {\n        return 0;\n    }\n    int mid = left + (right - left) / 2;\n    long long left_inversions = count_inversions(arr, left, mid);\n    long long right_inversions = count_inversions(arr, mid + 1, right);\n    long long merge_inversions = merge_and_count(arr, left, mid, right);\n    return left_inversions + right_inversions + merge_inversions;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> permutation(n);\n    for (int i = 0; i < n; i++) {\n        cin >> permutation[i];\n    }\n\n    // Method 1: Adjacent Swaps\n    long long inversions = count_inversions(permutation, 0, n - 1);\n\n    // Method 2: Any Two Swaps\n    long long misplaced_elements = 0;\n    for (int i = 0; i < n; i++) {\n        if (permutation[i] != i + 1) {\n            misplaced_elements++;\n        }\n    }\n\n    // Method 3: Move to Another Position\n    long long moves_to_position = misplaced_elements;\n\n    // Method 4: Move to Front\n    long long moves_to_front = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (permutation[j] < permutation[i]) {\n                moves_to_front++;\n            }\n        }\n    }\n\n    cout << inversions << \" \" << misplaced_elements << \" \" << moves_to_position << \" \" << moves_to_front << endl;\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 10,
            "mean_time_taken": 0.643241572380066,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Special Substrings",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <unordered_map>\n#include <string>\n\nusing namespace std;\n\nint countSpecialSubstrings(string s) {\n    int n = s.length();\n    int count = 0; // Initialize count of special substrings\n    unordered_map<char, int> freq; // Map to store character frequencies\n\n    // Sliding window\n    for (int left = 0, right = 0; right < n; ++right) {\n        freq[s[right]]++;\n\n        // Check if the current window is special\n        bool isSpecial = true;\n        for (auto it : freq) {\n            if (it.second != freq[s[right]]) {\n                isSpecial = false;\n                break;\n            }\n        }\n        if (isSpecial) {\n            count++;\n        }\n\n        // Shrink the window\n        while (left < right) {\n            freq[s[left]]--;\n            // Check if the smaller window is special\n            isSpecial = true;\n            for (auto it : freq) {\n                if (it.second != freq[s[right]]) {\n                    isSpecial = false;\n                    break;\n                }\n            }\n            if (isSpecial) {\n                count++;\n            }\n            left++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    int result = countSpecialSubstrings(s);\n    cout << result << endl;\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 8,
            "mean_time_taken": 0.5169090032577515,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Stack Weights",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n  vector<int> left, right;\n\n  for (int i = 0; i < n; i++) {\n    int c, s;\n    cin >> c >> s;\n\n    if (s == 1) { // Move to left stack\n      left.push_back(c);\n    } else { // Move to right stack\n      right.push_back(c);\n    }\n\n    // Determine the heavier stack\n    if (left.size() > 0 && right.size() > 0) {\n      if (left.back() > right.back()) {\n        cout << \">\" << endl;\n      } else if (left.back() < right.back()) {\n        cout << \"<\" << endl;\n      } else {\n        cout << \"?\" << endl;\n      }\n    } else if (left.size() > 0) {\n      cout << \">\" << endl;\n    } else if (right.size() > 0) {\n      cout << \"<\" << endl;\n    } else {\n      cout << \"?\" << endl;\n    }\n  }\n\n  return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 5,
            "mean_time_taken": 0.25123186111450196,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Stair Game",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<int> p(n);\n    for (int i = 0; i < n; i++) {\n      cin >> p[i];\n    }\n    // If the second player can win immediately, then he wins.\n    if (n == 1 || (n == 2 && p[1] == 0)) {\n      cout << \"second\" << endl;\n      continue;\n    }\n    // If the first player can win immediately, then he wins.\n    bool first_can_win = false;\n    for (int i = 2; i < n; i++) {\n      if (p[i] > 0) {\n        first_can_win = true;\n        break;\n      }\n    }\n    if (first_can_win) {\n      cout << \"first\" << endl;\n      continue;\n    }\n    // Otherwise, the game is a bit more complicated.\n    // We can reduce the game to a simpler game.\n    // If the first player can move some balls to the second stair, then he can force a win.\n    // Otherwise, the second player can win.\n    bool can_move_to_second = false;\n    for (int i = 2; i < n; i++) {\n      if (p[i] > 0) {\n        can_move_to_second = true;\n        break;\n      }\n    }\n    if (can_move_to_second) {\n      cout << \"first\" << endl;\n    } else {\n      cout << \"second\" << endl;\n    }\n  }\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 7,
            "mean_time_taken": 0.4041637693132673,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Static Range Minimum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N = 2e5;\n\n// Segment tree node structure\nstruct Node {\n    int minVal; // Minimum value in the range\n    int start, end; // Range of the node\n};\n\n// Array to store the segment tree\nNode tree[4 * MAX_N];\n\n// Function to build the segment tree\nvoid buildTree(int node, int start, int end, vector<int>& arr) {\n    tree[node].start = start;\n    tree[node].end = end;\n    if (start == end) {\n        tree[node].minVal = arr[start];\n        return;\n    }\n    int mid = (start + end) / 2;\n    buildTree(2 * node, start, mid, arr);\n    buildTree(2 * node + 1, mid + 1, end, arr);\n    tree[node].minVal = min(tree[2 * node].minVal, tree[2 * node + 1].minVal);\n}\n\n// Function to query the minimum value in the range [a, b]\nint query(int node, int a, int b) {\n    if (a <= tree[node].start && b >= tree[node].end) {\n        return tree[node].minVal;\n    }\n    if (tree[node].end < a || tree[node].start > b) {\n        return INT_MAX;\n    }\n    int mid = (tree[node].start + tree[node].end) / 2;\n    return min(query(2 * node, a, b), query(2 * node + 1, a, b));\n}\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    // Build the segment tree\n    buildTree(1, 0, n - 1, arr);\n    // Process the queries\n    while (q--) {\n        int a, b;\n        cin >> a >> b;\n        cout << query(1, a - 1, b - 1) << endl; // Adjust for 1-based indexing\n    }\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Static Range Sum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n\n  // Read the array\n  vector<int> arr(n);\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n  }\n\n  // Calculate prefix sums\n  vector<long long> prefix_sums(n + 1, 0);\n  for (int i = 1; i <= n; i++) {\n    prefix_sums[i] = prefix_sums[i - 1] + arr[i - 1];\n  }\n\n  // Process queries\n  for (int i = 0; i < q; i++) {\n    int a, b;\n    cin >> a >> b;\n\n    // Calculate the sum of the range [a, b]\n    long long sum = prefix_sums[b + 1] - prefix_sums[a];\n\n    cout << sum << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 2,
            "mean_time_taken": 0.2089242935180664,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Stick Divisions",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  long long x, n;\n  cin >> x >> n;\n\n  vector<long long> d(n);\n  for (int i = 0; i < n; i++) {\n    cin >> d[i];\n  }\n\n  // Sort the lengths in descending order\n  sort(d.rbegin(), d.rend());\n\n  // Initialize the total cost\n  long long cost = 0;\n\n  // Initialize the current length of the stick being divided\n  long long current_length = x;\n\n  // Iterate through the lengths\n  for (int i = 0; i < n; i++) {\n    // If the current length is greater than the desired length, divide the current stick\n    if (current_length > d[i]) {\n      cost += current_length;\n      current_length = d[i];\n    } else {\n      // If the current length is equal to the desired length, no need to divide\n      current_length = d[i];\n    }\n  }\n\n  cout << cost << endl;\n\n  return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 6,
            "mean_time_taken": 0.16738518079121908,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 19,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Stick Game",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int n, k;\n  cin >> n >> k;\n\n  vector<int> p(k);\n  for (int i = 0; i < k; i++) {\n    cin >> p[i];\n  }\n\n  // Sort the allowed moves in ascending order.\n  sort(p.begin(), p.end());\n\n  // Create a vector to store the winning/losing status for each number of sticks.\n  vector<char> dp(n + 1, 'L'); // Initialize all positions as losing\n\n  // Base case: The first player wins if there is only 1 stick left.\n  dp[1] = 'W';\n\n  // Iterate through the possible number of sticks.\n  for (int i = 2; i <= n; i++) {\n    // For each number of sticks, check if the player can make a move to a losing position.\n    for (int j = 0; j < k; j++) {\n      // If the current move is valid (i.e., it doesn't exceed the number of sticks)\n      if (i - p[j] >= 0 && dp[i - p[j]] == 'L') {\n        // If the player can make a move to a losing position, then the current position is a winning position.\n        dp[i] = 'W';\n        break; // No need to check further, this position is winning\n      }\n    }\n  }\n\n  // Print the winning/losing status for each number of sticks.\n  for (int i = 1; i <= n; i++) {\n    cout << dp[i];\n  }\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 6,
            "mean_time_taken": 0.44231557846069336,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 20,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Stick Lengths",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<int> sticks(n);\n  for (int i = 0; i < n; i++) {\n    cin >> sticks[i];\n  }\n\n  // Calculate the median length\n  sort(sticks.begin(), sticks.end());\n  int median = sticks[n / 2];\n\n  // Calculate the total cost\n  long long totalCost = 0;\n  for (int i = 0; i < n; i++) {\n    totalCost += abs(sticks[i] - median);\n  }\n\n  cout << totalCost << endl;\n\n  return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 11,
            "mean_time_taken": 0.12657256559892135,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "String Functions",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  string s;\n  cin >> s;\n  int n = s.size();\n\n  // Calculate z function\n  vector<int> z(n, 0);\n  int l = 0, r = 0;\n  for (int i = 2; i < n; i++) {\n    if (i > r) {\n      l = i;\n      r = i;\n      while (r < n && s[r - l] == s[r]) {\n        r++;\n      }\n      z[i] = r - l;\n      r--;\n    } else {\n      int k = i - l;\n      if (z[k] < r - i + 1) {\n        z[i] = z[k];\n      } else {\n        l = i;\n        while (r < n && s[r - l] == s[r]) {\n          r++;\n        }\n        z[i] = r - l;\n        r--;\n      }\n    }\n  }\n\n  // Calculate pi function\n  vector<int> pi(n, 0);\n  for (int i = 1; i < n; i++) {\n    int j = pi[i - 1];\n    while (j > 0 && s[i] != s[j]) {\n      j = pi[j - 1];\n    }\n    if (s[i] == s[j]) {\n      j++;\n    }\n    pi[i] = j;\n  }\n\n  // Print results\n  for (int i = 0; i < n; i++) {\n    cout << z[i] << \" \";\n  }\n  cout << endl;\n  for (int i = 0; i < n; i++) {\n    cout << pi[i] << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 5,
            "mean_time_taken": 0.2632152557373047,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                5
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 21,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "String Matching",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Function to compute the failure function for the pattern\nvector<int> computeLPSArray(string pattern) {\n    int m = pattern.length();\n    vector<int> lps(m, 0);\n    int length = 0;\n    lps[0] = 0; // Base case: First character has no prefix\n\n    for (int i = 1; i < m; i++) {\n        while (length > 0 && pattern[i] != pattern[length]) {\n            length = lps[length - 1];\n        }\n        if (pattern[i] == pattern[length]) {\n            length++;\n        }\n        lps[i] = length;\n    }\n    return lps;\n}\n\n// Function to count the occurrences of the pattern in the string\nint countOccurrences(string text, string pattern) {\n    int n = text.length();\n    int m = pattern.length();\n    vector<int> lps = computeLPSArray(pattern);\n    int j = 0; // Index for the pattern\n    int count = 0; // Count of occurrences\n\n    for (int i = 0; i < n; i++) {\n        while (j > 0 && text[i] != pattern[j]) {\n            j = lps[j - 1]; // Move pattern to the right using failure function\n        }\n        if (text[i] == pattern[j]) {\n            j++;\n        }\n        if (j == m) {\n            count++; // Match found\n            j = lps[j - 1]; // Move pattern to the right based on failure function\n        }\n    }\n    return count;\n}\n\nint main() {\n    string text, pattern;\n    getline(cin, text);\n    getline(cin, pattern);\n    cout << countOccurrences(text, pattern) << endl;\n    return 0;\n}",
            "passed_test_cases": 37,
            "total_test_cases": 37,
            "mean_time_taken": 0.11816331502553579,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "String Removals",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main() {\n    string s;\n    cin >> s;\n\n    int n = s.size();\n    long long dp[n + 1]; // Using long long to handle large numbers\n    dp[0] = 1;\n    dp[1] = 1;\n\n    for (int i = 2; i <= n; ++i) {\n        dp[i] = dp[i - 1]; // Include s[i]\n        if (s[i - 1] == s[i - 2]) { // Exclude s[i] if possible\n            dp[i] = (dp[i] + dp[i - 2]) % MOD; \n        }\n    }\n\n    cout << dp[n] << endl;\n    return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 7,
            "mean_time_taken": 0.10874768665858678,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "String Reorder",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    string s;\n    cin >> s;\n\n    // Calculate character frequencies\n    map<char, int> freq;\n    for (char c : s) {\n        freq[c]++;\n    }\n\n    // Sort characters lexicographically\n    vector<char> chars;\n    for (auto it : freq) {\n        chars.push_back(it.first);\n    }\n    sort(chars.begin(), chars.end());\n\n    // Build the output string\n    string output = \"\";\n    for (char c : chars) {\n        // Place character as many times as possible while valid\n        int count = freq[c];\n        while (count > 0 && (output.empty() || output.back() != c)) {\n            output += c;\n            count--;\n        }\n        // Check for validity\n        if (count > 0 && output.back() == c) {\n            cout << \"-1\" << endl;\n            return 0;\n        }\n    }\n\n    cout << output << endl;\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 15,
            "mean_time_taken": 0.3240228017171224,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                6,
                7,
                8,
                9,
                12,
                13,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "String Transform",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  string s;\n  cin >> s;\n\n  // Remove '#' character\n  s.erase(s.begin() + s.size() - 1);\n\n  // Generate all rotations of the string\n  string rotations[s.size()];\n  for (int i = 0; i < s.size(); i++) {\n    rotations[i] = s.substr(i) + s.substr(0, i);\n  }\n\n  // Sort the rotations in increasing order\n  sort(rotations, rotations + s.size());\n\n  // Construct the new string from the last character of each rotation\n  string result;\n  for (int i = 0; i < s.size(); i++) {\n    result += rotations[i][rotations[i].size() - 1];\n  }\n\n  cout << result << endl;\n  return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 6,
            "mean_time_taken": 0.29699933528900146,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Strongly Connected Edges",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> graph;\nvector<int> dfs_num, dfs_low;\nvector<bool> visited;\nvector<pair<int, int>> edges;\nint timer = 0;\n\nvoid dfs(int node, int parent) {\n    visited[node] = true;\n    dfs_num[node] = dfs_low[node] = timer++;\n    for (int neighbor : graph[node]) {\n        if (neighbor == parent) continue;\n        if (!visited[neighbor]) {\n            dfs(neighbor, node);\n            dfs_low[node] = min(dfs_low[node], dfs_low[neighbor]);\n            if (dfs_low[neighbor] > dfs_num[node]) {\n                // Bridge edge\n                return;\n            }\n        } else {\n            // Back edge\n            dfs_low[node] = min(dfs_low[node], dfs_num[neighbor]);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    graph.resize(n + 1);\n    visited.assign(n + 1, false);\n    dfs_num.assign(n + 1, 0);\n    dfs_low.assign(n + 1, 0);\n    edges.resize(m);\n    \n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n        edges[i] = {a, b};\n    }\n\n    // Find articulation points (cut vertices)\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            dfs(i, -1);\n        }\n    }\n\n    // Check for bridge edges (cut edges)\n    bool has_bridge = false;\n    for (int i = 0; i < m; i++) {\n        if (dfs_low[edges[i].second] > dfs_num[edges[i].first]) {\n            has_bridge = true;\n            break;\n        }\n    }\n\n    if (has_bridge) {\n        cout << \"IMPOSSIBLE\" << endl;\n        return 0;\n    }\n\n    // Orient edges to make the graph strongly connected\n    for (int i = 0; i < m; i++) {\n        int a = edges[i].first;\n        int b = edges[i].second;\n        if (dfs_num[a] < dfs_num[b]) {\n            cout << a << \" \" << b << endl;\n        } else {\n            cout << b << \" \" << a << endl;\n        }\n    }\n\n    return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 11,
            "mean_time_taken": 0.33546330712058325,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                6,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 22,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Distinct Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint main() {\n  int n, k;\n  cin >> n >> k;\n\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n\n  unordered_map<int, int> freq;\n  int left = 0, right = 0;\n  int distinct = 0;\n  long long count = 0;\n\n  while (right < n) {\n    if (freq[a[right]] == 0) {\n      distinct++;\n    }\n    freq[a[right]]++;\n    right++;\n\n    while (distinct > k) {\n      freq[a[left]]--;\n      if (freq[a[left]] == 0) {\n        distinct--;\n      }\n      left++;\n    }\n\n    count += right - left;\n  }\n\n  cout << count << endl;\n\n  return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 10,
            "mean_time_taken": 0.18627357482910156,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Subarray Divisibility",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n\n  // Calculate prefix sums\n  vector<int> prefix_sums(n + 1, 0);\n  for (int i = 1; i <= n; i++) {\n    prefix_sums[i] = prefix_sums[i - 1] + a[i - 1];\n  }\n\n  // Calculate modulo remainders and count occurrences\n  vector<int> remainders(n, 0);\n  for (int i = 1; i <= n; i++) {\n    remainders[((prefix_sums[i] % n) + n) % n]++;\n  }\n\n  // Count subarrays with sum divisible by n\n  long long count = 0;\n  for (int i = 0; i < n; i++) {\n    count += remainders[i] * (remainders[i] - 1) / 2;\n  }\n\n  cout << count << endl;\n  return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 10,
            "mean_time_taken": 0.2109229326248169,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                7,
                8,
                9,
                10
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Squares",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int n, k;\n  cin >> n >> k;\n\n  vector<int> arr(n);\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n  }\n\n  // DP table: dp[i][j] is the minimum cost to divide the first i elements into j subarrays\n  vector<vector<int>> dp(n + 1, vector<int>(k + 1, INT_MAX));\n\n  // Base case: if we have 0 elements, the cost is 0 regardless of the number of subarrays\n  for (int j = 0; j <= k; j++) {\n    dp[0][j] = 0;\n  }\n\n  // Fill the DP table\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= min(i, k); j++) {\n      // Calculate the cost of the current subarray ending at index i\n      int subarraySum = 0;\n      for (int m = i; m > 0; m--) {\n        subarraySum += arr[m - 1];\n        // Find the minimum cost to divide the first m - 1 elements into j - 1 subarrays\n        // and add the cost of the current subarray\n        dp[i][j] = min(dp[i][j], dp[m - 1][j - 1] + subarraySum * subarraySum);\n      }\n    }\n  }\n\n  // The minimum total cost is stored in dp[n][k]\n  cout << dp[n][k] << endl;\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Subarray Sum Queries",
            "category": "Range Queries",
            "solution": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  vector<int> a(n + 1);\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n  }\n\n  // Calculate the prefix sums\n  vector<long long> prefix_sum(n + 1, 0);\n  for (int i = 1; i <= n; i++) {\n    prefix_sum[i] = prefix_sum[i - 1] + a[i];\n  }\n\n  // Calculate the maximum subarray sum\n  long long max_sum = 0;\n  for (int i = 1; i <= n; i++) {\n    for (int j = i; j <= n; j++) {\n      max_sum = max(max_sum, prefix_sum[j] - prefix_sum[i - 1]);\n    }\n  }\n  cout << max_sum << endl;\n\n  // Process the updates\n  for (int i = 0; i < m; i++) {\n    int k, x;\n    cin >> k >> x;\n\n    // Update the array\n    a[k] = x;\n\n    // Update the prefix sums\n    prefix_sum[k] = prefix_sum[k - 1] + a[k];\n    for (int j = k + 1; j <= n; j++) {\n      prefix_sum[j] = prefix_sum[j - 1] + a[j];\n    }\n\n    // Calculate the maximum subarray sum\n    max_sum = 0;\n    for (int i = 1; i <= n; i++) {\n      for (int j = i; j <= n; j++) {\n        max_sum = max(max_sum, prefix_sum[j] - prefix_sum[i - 1]);\n      }\n    }\n    cout << max_sum << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 0.5858353614807129,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Sums I",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nint main() {\n  int n, x;\n  cin >> n >> x;\n\n  int a[n];\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n\n  // Calculate prefix sums\n  long long prefix_sum[n + 1];\n  prefix_sum[0] = 0;\n  for (int i = 1; i <= n; ++i) {\n    prefix_sum[i] = prefix_sum[i - 1] + a[i - 1];\n  }\n\n  // Count subarrays with sum x\n  unordered_map<long long, int> count;\n  int ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    long long required_sum = prefix_sum[i] - x;\n    if (count.find(required_sum) != count.end()) {\n      ans += count[required_sum];\n    }\n    count[prefix_sum[i]]++;\n  }\n\n  cout << ans << endl;\n  return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 12,
            "mean_time_taken": 0.3839173714319865,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                5,
                6,
                7,
                8,
                11
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subarray Sums II",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    long long a[n];\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    // Calculate prefix sums\n    long long prefix_sum[n + 1];\n    prefix_sum[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        prefix_sum[i] = prefix_sum[i - 1] + a[i - 1];\n    }\n\n    // Count subarrays using a hash map\n    unordered_map<long long, int> count;\n    int subarray_count = 0;\n    for (int i = 0; i <= n; i++) {\n        // Check if a previous prefix sum exists that results in a target sum\n        if (count.find(prefix_sum[i] - x) != count.end()) {\n            subarray_count += count[prefix_sum[i] - x];\n        }\n        // Increment the count for the current prefix sum\n        count[prefix_sum[i]]++; \n    }\n\n    cout << subarray_count << endl;\n    return 0;\n}",
            "passed_test_cases": 25,
            "total_test_cases": 27,
            "mean_time_taken": 0.2648751205868191,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Subordinates",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n  vector<int> boss(n + 1, 0); // boss[i] is the direct boss of employee i.\n  vector<int> subordinates(n + 1, 0); // subordinates[i] is the number of subordinates of employee i.\n\n  // Read the boss of each employee\n  for (int i = 2; i <= n; i++) {\n    cin >> boss[i];\n  }\n\n  // Calculate the number of subordinates for each employee\n  for (int i = 2; i <= n; i++) {\n    subordinates[boss[i]]++;\n  }\n\n  // Print the number of subordinates for each employee\n  for (int i = 1; i <= n; i++) {\n    cout << subordinates[i] << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 12,
            "mean_time_taken": 0.1959157387415568,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                7,
                8,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Substring Distribution",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <unordered_set>\n\nusing namespace std;\n\nint main() {\n  string s;\n  cin >> s;\n  int n = s.length();\n\n  for (int i = 1; i <= n; i++) {\n    unordered_set<string> substrings;\n    for (int j = 0; j <= n - i; j++) {\n      substrings.insert(s.substr(j, i));\n    }\n    cout << substrings.size() << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 9,
            "mean_time_taken": 1.183141099082099,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Substring Order I",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nint main() {\n  string s;\n  int k;\n  cin >> s >> k;\n\n  // Create a set to store distinct substrings.\n  set<string> substrings;\n\n  // Generate all substrings.\n  for (int i = 0; i < s.length(); ++i) {\n    for (int j = i + 1; j <= s.length(); ++j) {\n      substrings.insert(s.substr(i, j - i));\n    }\n  }\n\n  // Get the kth smallest substring.\n  auto it = substrings.begin();\n  advance(it, k - 1);\n\n  cout << *it << endl;\n\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 9,
            "mean_time_taken": 0.7573014365302192,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Substring Order II",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  string s;\n  int k;\n\n  cin >> s >> k;\n\n  // Create a vector of all substrings\n  vector<string> substrings;\n  for (int i = 0; i < s.length(); i++) {\n    for (int j = i + 1; j <= s.length(); j++) {\n      substrings.push_back(s.substr(i, j - i));\n    }\n  }\n\n  // Sort the substrings lexicographically\n  sort(substrings.begin(), substrings.end());\n\n  // Print the kth smallest substring\n  cout << substrings[k - 1] << endl;\n\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 9,
            "mean_time_taken": 0.3402567174699571,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                7,
                8,
                9
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Substring Reversals",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  string s;\n  cin >> s;\n\n  // Create a vector to store the operations\n  vector<pair<int, int>> operations(m);\n  for (int i = 0; i < m; i++) {\n    cin >> operations[i].first >> operations[i].second;\n  }\n\n  // Perform the operations in reverse order\n  for (int i = m - 1; i >= 0; i--) {\n    int a = operations[i].first;\n    int b = operations[i].second;\n\n    // Reverse the substring from a to b\n    reverse(s.begin() + a - 1, s.begin() + b);\n  }\n\n  cout << s << endl;\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Subtree Queries",
            "category": "Tree Algorithms",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\n\nvector<int> adj[MAXN];\nint n, q, val[MAXN], subtree_sum[MAXN];\n\nvoid dfs(int u, int p) {\n  subtree_sum[u] = val[u];\n  for (int v : adj[u]) {\n    if (v != p) {\n      dfs(v, u);\n      subtree_sum[u] += subtree_sum[v];\n    }\n  }\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n\n  cin >> n >> q;\n  for (int i = 1; i <= n; i++) {\n    cin >> val[i];\n  }\n\n  for (int i = 1; i < n; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n\n  dfs(1, 0);\n\n  while (q--) {\n    int type, s, x;\n    cin >> type >> s;\n\n    if (type == 1) {\n      cin >> x;\n      val[s] = x;\n      subtree_sum[s] = x;\n      for (int v : adj[s]) {\n        if (v != s) {\n          subtree_sum[s] += subtree_sum[v];\n        }\n      }\n    } else if (type == 2) {\n      cout << subtree_sum[s] << endl;\n    }\n  }\n\n  return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 13,
            "mean_time_taken": 0.3880966626680814,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sum of Divisors",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nconst long long MOD = 1e9 + 7;\n\nlong long sumOfDivisors(long long n) {\n  long long sum = 0;\n  for (long long i = 1; i * i <= n; i++) {\n    if (n % i == 0) {\n      sum = (sum + i + n / i) % MOD;\n      // Handle case when i == n/i (perfect square)\n      if (i * i == n) {\n        sum = (sum - i) % MOD;\n      }\n    }\n  }\n  return sum;\n}\n\nint main() {\n  long long n;\n  cin >> n;\n\n  long long result = 0;\n  for (long long i = 1; i <= n; i++) {\n    result = (result + sumOfDivisors(i)) % MOD;\n  }\n\n  cout << result << endl;\n  return 0;\n}",
            "passed_test_cases": 11,
            "total_test_cases": 18,
            "mean_time_taken": 0.6888978613747491,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                8,
                12,
                14,
                16,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sum of Four Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint main() {\n  int n, x;\n  cin >> n >> x;\n\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n\n  // Create a map to store pairs of values and their indices.\n  unordered_map<int, pair<int, int>> mp;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      mp[a[i] + a[j]] = make_pair(i, j);\n    }\n  }\n\n  // Iterate through the array again, looking for complementary pairs.\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      int target = x - (a[i] + a[j]);\n      if (mp.count(target)) {\n        // Found a solution!\n        pair<int, int> indices = mp[target];\n        if (indices.first != i && indices.first != j && indices.second != i && indices.second != j) {\n          cout << i + 1 << \" \" << j + 1 << \" \" << indices.first + 1 << \" \" << indices.second + 1 << endl;\n          return 0;\n        }\n      }\n    }\n  }\n\n  // No solution found.\n  cout << \"IMPOSSIBLE\" << endl;\n\n  return 0;\n}",
            "passed_test_cases": 12,
            "total_test_cases": 28,
            "mean_time_taken": 0.15084351812090194,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                7,
                9,
                11,
                12,
                15,
                16,
                18,
                20,
                21,
                22,
                26,
                27,
                28
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sum of Three Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int n, x;\n  cin >> n >> x;\n\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n\n  // Sort the array for efficient searching\n  sort(a.begin(), a.end());\n\n  // Iterate through the array\n  for (int i = 0; i < n - 2; i++) {\n    // Use two pointers to find the remaining two values\n    int left = i + 1;\n    int right = n - 1;\n    while (left < right) {\n      int sum = a[i] + a[left] + a[right];\n      // If the sum is equal to the target, we found the solution\n      if (sum == x) {\n        cout << i + 1 << \" \" << left + 1 << \" \" << right + 1 << endl;\n        return 0;\n      } \n      // If the sum is less than the target, move the left pointer to the right\n      else if (sum < x) {\n        left++;\n      } \n      // If the sum is greater than the target, move the right pointer to the left\n      else {\n        right--;\n      }\n    }\n  }\n\n  // If no solution is found, print IMPOSSIBLE\n  cout << \"IMPOSSIBLE\" << endl;\n  return 0;\n}",
            "passed_test_cases": 15,
            "total_test_cases": 27,
            "mean_time_taken": 0.1291202704111735,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                6,
                8,
                12,
                13,
                16,
                18,
                21,
                22,
                23,
                24,
                26,
                27
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Sum of Two Values",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nint main() {\n  int n, x;\n  cin >> n >> x;\n  unordered_map<int, int> seen;\n  for (int i = 1; i <= n; i++) {\n    int a;\n    cin >> a;\n    if (seen.count(x - a)) {\n      cout << seen[x - a] << \" \" << i << endl;\n      return 0;\n    }\n    seen[a] = i;\n  }\n  cout << \"IMPOSSIBLE\" << endl;\n  return 0;\n}",
            "passed_test_cases": 18,
            "total_test_cases": 27,
            "mean_time_taken": 0.1995529775266294,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                3,
                4,
                9,
                10,
                11,
                21,
                22,
                24,
                25
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Swap Game",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n// Structure to represent a state of the grid\nstruct State {\n  vector<vector<int>> grid;\n  int moves;\n\n  // Constructor to initialize a state\n  State(const vector<vector<int>>& grid, int moves) : grid(grid), moves(moves) {}\n};\n\n// Function to check if the given grid is in the desired final state\nbool isSolved(const vector<vector<int>>& grid) {\n  for (int i = 0; i < 3; ++i) {\n    for (int j = 0; j < 3; ++j) {\n      if (grid[i][j] != (i * 3 + j + 1)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n// Function to generate all possible moves from a given state\nvector<State> generateMoves(const State& state) {\n  vector<State> moves;\n  for (int i = 0; i < 3; ++i) {\n    for (int j = 0; j < 3; ++j) {\n      // Check for horizontal moves\n      if (j < 2) {\n        vector<vector<int>> newGrid = state.grid;\n        swap(newGrid[i][j], newGrid[i][j + 1]);\n        moves.push_back(State(newGrid, state.moves + 1));\n      }\n      // Check for vertical moves\n      if (i < 2) {\n        vector<vector<int>> newGrid = state.grid;\n        swap(newGrid[i][j], newGrid[i + 1][j]);\n        moves.push_back(State(newGrid, state.moves + 1));\n      }\n    }\n  }\n  return moves;\n}\n\nint main() {\n  // Input the initial grid\n  vector<vector<int>> grid(3, vector<int>(3));\n  for (int i = 0; i < 3; ++i) {\n    for (int j = 0; j < 3; ++j) {\n      cin >> grid[i][j];\n    }\n  }\n\n  // Initialize the starting state\n  State startState(grid, 0);\n\n  // Use a queue to perform a breadth-first search\n  queue<State> states;\n  states.push(startState);\n\n  // Keep track of visited states to avoid cycles\n  vector<vector<vector<int>>> visited(3, vector<vector<int>>(3, vector<int>(10)));\n\n  while (!states.empty()) {\n    State current = states.front();\n    states.pop();\n\n    // Check if we have reached the solved state\n    if (isSolved(current.grid)) {\n      cout << current.moves << endl;\n      return 0;\n    }\n\n    // Generate all possible moves from the current state\n    vector<State> moves = generateMoves(current);\n\n    // Add valid moves to the queue\n    for (const State& move : moves) {\n      // Check if the move has been visited before\n      if (!visited[move.grid[0][0]][move.grid[1][0]][move.grid[2][0]]) {\n        states.push(move);\n        visited[move.grid[0][0]][move.grid[1][0]][move.grid[2][0]] = 1;\n      }\n    }\n  }\n\n  // If no solution is found\n  cout << \"-1\" << endl;\n  return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 19,
            "mean_time_taken": 0.1589846360056024,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Swap Round Sorting",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> parent, cycle_length;\n\n// Find the parent of a node using path compression\nint find(int u) {\n  if (parent[u] != u) {\n    parent[u] = find(parent[u]);\n  }\n  return parent[u];\n}\n\n// Union of two sets\nvoid merge(int u, int v) {\n  int pu = find(u), pv = find(v);\n  if (pu != pv) {\n    parent[pv] = pu;\n  }\n}\n\nint main() {\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n\n  // Initialize parent array and cycle lengths\n  parent.resize(n + 1);\n  cycle_length.assign(n + 1, 0);\n  for (int i = 1; i <= n; ++i) {\n    parent[i] = i;\n  }\n\n  // Construct cycles using the permutation\n  for (int i = 1; i <= n; ++i) {\n    merge(i, a[i - 1]);\n  }\n\n  // Find cycle lengths\n  for (int i = 1; i <= n; ++i) {\n    if (parent[i] == i) {\n      cycle_length[i]++;\n      for (int j = a[i - 1]; j != i; j = a[j - 1]) {\n        cycle_length[i]++;\n      }\n    }\n  }\n\n  // Find the length of the longest cycle\n  int max_cycle = *max_element(cycle_length.begin(), cycle_length.end());\n  // Minimum rounds\n  int rounds = max_cycle - 1;\n  cout << rounds << endl;\n\n  // Print swap pairs for each round\n  vector<pair<int, int>> swaps;\n  for (int i = 1; i <= n; ++i) {\n    if (parent[i] == i) {\n      int cycle_start = i;\n      int current = a[i - 1];\n      int count = 1;\n\n      while (current != i) {\n        swaps.push_back({i, current});\n        count++;\n        current = a[current - 1];\n      }\n\n      // Perform swaps in groups of two for each round\n      for (int j = 0; j < count - 1; j += 2) {\n        cout << 2 << endl;\n        cout << swaps[j].first << \" \" << swaps[j].second << endl;\n        cout << swaps[j + 1].first << \" \" << swaps[j + 1].second << endl;\n        swaps.erase(swaps.begin() + j, swaps.begin() + j + 2);\n        j -= 2;\n      }\n      // Handle odd number of elements in a cycle\n      if (count % 2 == 1) {\n        cout << 1 << endl;\n        cout << swaps[0].first << \" \" << swaps[0].second << endl;\n        swaps.erase(swaps.begin());\n      }\n    }\n  }\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 15,
            "mean_time_taken": 1.045528030395508,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Task Assignment",
            "category": "Advanced Techniques",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<vector<int>> costs(n, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      cin >> costs[i][j];\n    }\n  }\n\n  // Hungarian Algorithm\n  vector<int> assignment(n, -1);\n  vector<int> u(n, 0);\n  vector<int> v(n, 0);\n  vector<bool> visited(n, false);\n\n  // Calculate initial u and v\n  for (int i = 0; i < n; i++) {\n    int min_cost = costs[i][0];\n    for (int j = 1; j < n; j++) {\n      min_cost = min(min_cost, costs[i][j]);\n    }\n    u[i] = min_cost;\n  }\n\n  // Find optimal assignment\n  for (int i = 0; i < n; i++) {\n    visited.assign(n, false);\n    if (find_path(i, u, v, costs, assignment, visited)) {\n      // Update u and v\n      for (int j = 0; j < n; j++) {\n        if (visited[j]) {\n          int delta = u[i] + v[j] - costs[i][j];\n          u[i] -= delta;\n          v[j] += delta;\n        }\n      }\n    }\n  }\n\n  // Calculate minimum total cost\n  int min_cost = 0;\n  for (int i = 0; i < n; i++) {\n    min_cost += costs[i][assignment[i]];\n  }\n\n  // Print minimum cost and assignment\n  cout << min_cost << endl;\n  for (int i = 0; i < n; i++) {\n    cout << i + 1 << \" \" << assignment[i] + 1 << endl;\n  }\n\n  return 0;\n}\n\nbool find_path(int i, vector<int>& u, vector<int>& v, vector<vector<int>>& costs, vector<int>& assignment, vector<bool>& visited) {\n  visited[i] = true;\n  for (int j = 0; j < costs[i].size(); j++) {\n    if (u[i] + v[j] == costs[i][j] && !visited[j]) {\n      if (assignment[j] == -1 || find_path(assignment[j], u, v, costs, assignment, visited)) {\n        assignment[j] = i;\n        return true;\n      }\n    }\n  }\n  return false;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Tasks and Deadlines",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<pair<int, int>> tasks(n);\n  for (int i = 0; i < n; i++) {\n    cin >> tasks[i].first >> tasks[i].second;\n  }\n\n  // Sort tasks by deadline (ascending order)\n  sort(tasks.begin(), tasks.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n    return a.second < b.second;\n  });\n\n  // Initialize variables\n  long long reward = 0;\n  int current_time = 0;\n\n  // Process tasks in sorted order\n  for (int i = 0; i < n; i++) {\n    // Calculate finishing time\n    current_time += tasks[i].first;\n\n    // Calculate reward for the current task\n    reward += (tasks[i].second - current_time);\n  }\n\n  // Output the maximum reward\n  cout << reward << endl;\n\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 6,
            "mean_time_taken": 0.6621497869491577,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                4,
                5,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Teleporters Path",
            "category": "Graph Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_map>\nusing namespace std;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  // Adjacency list to represent the teleporters\n  unordered_map<int, vector<int>> graph;\n  for (int i = 0; i < m; ++i) {\n    int a, b;\n    cin >> a >> b;\n    graph[a].push_back(b);\n  }\n\n  // Initialize the queue with the starting level 1\n  queue<int> q;\n  q.push(1);\n\n  // Keep track of visited teleporters\n  vector<bool> visited(m + 1, false);\n\n  // Keep track of the path taken\n  vector<int> path;\n\n  while (!q.empty()) {\n    int currentLevel = q.front();\n    q.pop();\n    path.push_back(currentLevel);\n\n    // Iterate through the teleporters from the current level\n    for (int i = 0; i < graph[currentLevel].size(); ++i) {\n      int nextLevel = graph[currentLevel][i];\n\n      // If the teleporter hasn't been visited, mark it as visited and add the next level to the queue\n      if (!visited[i]) {\n        visited[i] = true;\n        q.push(nextLevel);\n      }\n    }\n  }\n\n  // Check if all teleporters were visited\n  if (path.size() == m + 1) {\n    // Print the path\n    for (int level : path) {\n      cout << level << \" \";\n    }\n  } else {\n    // Print IMPOSSIBLE if a solution wasn't found\n    cout << \"IMPOSSIBLE\" << endl;\n  }\n\n  return 0;\n}",
            "passed_test_cases": 6,
            "total_test_cases": 18,
            "mean_time_taken": 0.16000909275478786,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                4,
                5,
                7,
                9,
                10,
                11,
                12,
                13,
                15,
                16,
                18
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Throwing Dice",
            "category": "Mathematics",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst long long MOD = 1e9 + 7;\n\nint main() {\n  long long n;\n  cin >> n;\n\n  // Initialize a vector to store the number of ways to get a sum up to n\n  vector<long long> dp(n + 1, 0);\n\n  // Base case: there is 1 way to get a sum of 0 (no dice thrown)\n  dp[0] = 1;\n\n  // Iterate through all possible sums from 1 to n\n  for (long long i = 1; i <= n; ++i) {\n    // Iterate through the possible values of each die (1 to 6)\n    for (long long j = 1; j <= 6 && j <= i; ++j) {\n      // Add the number of ways to get the previous sum (i - j) to the current sum (i)\n      dp[i] = (dp[i] + dp[i - j]) % MOD;\n    }\n  }\n\n  // Print the number of ways to get the sum n\n  cout << dp[n] << endl;\n\n  return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 32,
            "mean_time_taken": 0.22660746425390244,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                6,
                7,
                8,
                10,
                11,
                13,
                15,
                16,
                17,
                21,
                23,
                25,
                26,
                27,
                28,
                29,
                30,
                32
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 23,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tower of Hanoi",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nvoid towerOfHanoi(int n, char from_rod, char to_rod, char aux_rod) {\n    if (n == 1) {\n        cout << from_rod << \" \" << to_rod << endl;\n        return;\n    }\n    towerOfHanoi(n - 1, from_rod, aux_rod, to_rod);\n    cout << from_rod << \" \" << to_rod << endl;\n    towerOfHanoi(n - 1, aux_rod, to_rod, from_rod);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    cout << (1 << n) - 1 << endl; // The minimum number of moves is 2^n - 1\n    towerOfHanoi(n, '1', '3', '2');\n    return 0;\n}",
            "passed_test_cases": 16,
            "total_test_cases": 16,
            "mean_time_taken": 0.12787304818630219,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Towers",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<int> cubes(n);\n  for (int i = 0; i < n; i++) {\n    cin >> cubes[i];\n  }\n\n  // We use a stack to keep track of the topmost cubes in each tower.\n  vector<int> stack;\n\n  // We iterate through the cubes in the given order.\n  for (int i = 0; i < n; i++) {\n    // If the current cube is smaller than the topmost cube of the stack, we can place it on top of that tower.\n    if (!stack.empty() && cubes[i] < stack.back()) {\n      stack.push_back(cubes[i]);\n    } else {\n      // Otherwise, we need to start a new tower.\n      stack.push_back(cubes[i]);\n    }\n  }\n\n  // The number of towers is equal to the size of the stack.\n  cout << stack.size() << endl;\n\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 12,
            "mean_time_taken": 0.13233256340026855,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                3,
                4,
                5,
                6,
                7,
                9,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Traffic Lights",
            "category": "Sorting and Searching",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int x, n;\n  cin >> x >> n;\n\n  vector<int> trafficLights(n);\n  for (int i = 0; i < n; i++) {\n    cin >> trafficLights[i];\n  }\n\n  sort(trafficLights.begin(), trafficLights.end());\n\n  // Initial longest passage without traffic lights\n  int longestPassage = max(trafficLights[0] - 0, x - trafficLights[n - 1]);\n\n  cout << longestPassage << \" \";\n\n  for (int i = 1; i < n; i++) {\n    // Calculate the length of the current passage\n    int currentPassage = trafficLights[i] - trafficLights[i - 1] - 1;\n\n    // Update longestPassage if necessary\n    longestPassage = max(longestPassage, currentPassage);\n\n    cout << longestPassage << \" \";\n  }\n\n  cout << endl;\n  return 0;\n}",
            "passed_test_cases": 2,
            "total_test_cases": 12,
            "mean_time_taken": 0.22964447736740112,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                10,
                11,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 24,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Trailing Zeros",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n  long long n;\n  cin >> n;\n\n  // The number of trailing zeros is equal to the number of factors of 5 in n!\n  // Every multiple of 5 contributes one factor of 5\n  // Every multiple of 25 contributes an additional factor of 5, and so on\n  long long count = 0;\n  for (long long i = 5; n / i >= 1; i *= 5) {\n    count += n / i;\n  }\n\n  cout << count << endl;\n\n  return 0;\n}",
            "passed_test_cases": 13,
            "total_test_cases": 13,
            "mean_time_taken": 0.11566468385549691,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Tree Diameter",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<int> dist;\n\nvoid dfs(int node, int parent) {\n  for (int neighbor : adj[node]) {\n    if (neighbor != parent) {\n      dist[neighbor] = dist[node] + 1;\n      dfs(neighbor, node);\n    }\n  }\n}\n\nint main() {\n  int n;\n  cin >> n;\n  adj.resize(n + 1);\n  dist.resize(n + 1, 0);\n\n  for (int i = 0; i < n - 1; ++i) {\n    int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n\n  // Find the node farthest from node 1.\n  dfs(1, -1);\n  int farthest_node = max_element(dist.begin() + 1, dist.end()) - dist.begin();\n\n  // Find the node farthest from the farthest node.\n  dist.assign(n + 1, 0);\n  dfs(farthest_node, -1);\n\n  // The diameter is the maximum distance found.\n  int diameter = *max_element(dist.begin() + 1, dist.end());\n  cout << diameter << endl;\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Tree Distances I",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\n\nvector<int> adj[MAXN];\nint depth[MAXN];\nint furthest_node;\nint diameter;\n\nvoid dfs(int node, int parent, int d) {\n  depth[node] = d;\n  if (d > depth[furthest_node]) {\n    furthest_node = node;\n  }\n  for (int next : adj[node]) {\n    if (next != parent) {\n      dfs(next, node, d + 1);\n    }\n  }\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  // Read the tree edges\n  for (int i = 0; i < n - 1; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n\n  // Calculate depth and furthest node from the root\n  dfs(1, -1, 0);\n\n  // Calculate diameter\n  diameter = depth[furthest_node];\n\n  // Calculate maximum distance for each node\n  for (int i = 1; i <= n; i++) {\n    cout << max(depth[i] + diameter, depth[furthest_node] - depth[i]) << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 3,
            "total_test_cases": 15,
            "mean_time_taken": 0.38020641009012857,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                5,
                6,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Distances II",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nvector<int> adj[MAXN];\nint sz[MAXN], dist[MAXN], total[MAXN];\nint n;\n\nvoid dfs1(int u, int p) {\n  sz[u] = 1;\n  dist[u] = 0;\n  for (int v : adj[u]) {\n    if (v != p) {\n      dfs1(v, u);\n      sz[u] += sz[v];\n      dist[u] += dist[v] + sz[v];\n    }\n  }\n}\n\nvoid dfs2(int u, int p) {\n  total[u] = dist[u];\n  for (int v : adj[u]) {\n    if (v != p) {\n      dfs2(v, u);\n      total[u] += total[v] + (n - sz[v]) * dist[v] + sz[v] * dist[u]; \n    }\n  }\n}\n\nint main() {\n  cin >> n;\n  for (int i = 0; i < n - 1; ++i) {\n    int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n\n  dfs1(1, 0);\n  dfs2(1, 0);\n\n  for (int i = 1; i <= n; ++i) {\n    cout << total[i] << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 14,
            "mean_time_taken": 0.1859811885016305,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Isomorphism I",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if two trees are isomorphic\nbool isIsomorphic(vector<vector<int>>& tree1, vector<vector<int>>& tree2, int node1, int node2) {\n  // Base case: If both nodes are null, they are isomorphic\n  if (tree1[node1].empty() && tree2[node2].empty()) {\n    return true;\n  }\n\n  // If one node is null and the other is not, they are not isomorphic\n  if (tree1[node1].empty() || tree2[node2].empty()) {\n    return false;\n  }\n\n  // Sort the children of both nodes\n  sort(tree1[node1].begin(), tree1[node1].end());\n  sort(tree2[node2].begin(), tree2[node2].end());\n\n  // If the number of children is different, they are not isomorphic\n  if (tree1[node1].size() != tree2[node2].size()) {\n    return false;\n  }\n\n  // Recursively check if the children are isomorphic\n  for (int i = 0; i < tree1[node1].size(); ++i) {\n    if (!isIsomorphic(tree1, tree2, tree1[node1][i], tree2[node2][i])) {\n      return false;\n    }\n  }\n\n  // If all children are isomorphic, the trees are isomorphic\n  return true;\n}\n\nint main() {\n  int t;\n  cin >> t;\n\n  while (t--) {\n    int n;\n    cin >> n;\n\n    // Create adjacency lists for the two trees\n    vector<vector<int>> tree1(n + 1), tree2(n + 1);\n    for (int i = 0; i < n - 1; ++i) {\n      int u, v;\n      cin >> u >> v;\n      tree1[u].push_back(v);\n    }\n    for (int i = 0; i < n - 1; ++i) {\n      int u, v;\n      cin >> u >> v;\n      tree2[u].push_back(v);\n    }\n\n    // Check if the trees are isomorphic\n    if (isIsomorphic(tree1, tree2, 1, 1)) {\n      cout << \"YES\" << endl;\n    } else {\n      cout << \"NO\" << endl;\n    }\n  }\n\n  return 0;\n}",
            "passed_test_cases": 8,
            "total_test_cases": 15,
            "mean_time_taken": 0.27161914507548013,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                5,
                8,
                9,
                10,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Isomorphism II",
            "category": "Additional Problems",
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nvector<int> adj[MAXN];\nvector<int> adj2[MAXN];\nint deg[MAXN];\nint deg2[MAXN];\n\nbool cmp(pair<int, int> a, pair<int, int> b) {\n  if (a.first != b.first) {\n    return a.first < b.first;\n  }\n  return a.second < b.second;\n}\n\nbool isomorphic(int n) {\n  vector<pair<int, int>> v, v2;\n  for (int i = 1; i <= n; ++i) {\n    v.push_back({deg[i], i});\n    v2.push_back({deg2[i], i});\n  }\n  sort(v.begin(), v.end(), cmp);\n  sort(v2.begin(), v2.end(), cmp);\n  if (v != v2) {\n    return false;\n  }\n  for (int i = 0; i < n - 1; ++i) {\n    vector<int> neighbors, neighbors2;\n    for (int j : adj[v[i].second]) {\n      neighbors.push_back(j);\n    }\n    for (int j : adj2[v2[i].second]) {\n      neighbors2.push_back(j);\n    }\n    sort(neighbors.begin(), neighbors.end());\n    sort(neighbors2.begin(), neighbors2.end());\n    if (neighbors != neighbors2) {\n      return false;\n    }\n  }\n  return true;\n}\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; ++i) {\n      adj[i].clear();\n      adj2[i].clear();\n      deg[i] = 0;\n      deg2[i] = 0;\n    }\n    for (int i = 0; i < n - 1; ++i) {\n      int u, v;\n      cin >> u >> v;\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n      deg[u]++;\n      deg[v]++;\n    }\n    for (int i = 0; i < n - 1; ++i) {\n      int u, v;\n      cin >> u >> v;\n      adj2[u].push_back(v);\n      adj2[v].push_back(u);\n      deg2[u]++;\n      deg2[v]++;\n    }\n    if (isomorphic(n)) {\n      cout << \"YES\" << endl;\n    } else {\n      cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}",
            "passed_test_cases": 5,
            "total_test_cases": 14,
            "mean_time_taken": 0.22577616146632604,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                5,
                7,
                8,
                9,
                11,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Matching",
            "category": "Tree Algorithms",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> adj[200005];\n\nint dfs(int node, int parent) {\n  int count = 0;\n  for (int child : adj[node]) {\n    if (child != parent) {\n      count += dfs(child, node);\n    }\n  }\n  return max(count, 1);\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  for (int i = 0; i < n - 1; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n\n  cout << dfs(1, 0) << endl;\n\n  return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 13,
            "mean_time_taken": 0.1716608084165133,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Tree Traversals",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Node structure for the binary tree\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;\n\n    Node(int val) : data(val), left(nullptr), right(nullptr) {}\n};\n\n// Function to build the tree from preorder and inorder traversals\nNode* buildTree(vector<int> &preorder, vector<int> &inorder, int preStart, int preEnd, int inStart, int inEnd) {\n    if (preStart > preEnd || inStart > inEnd) {\n        return nullptr;\n    }\n\n    // Find the root in preorder\n    int rootData = preorder[preStart];\n    int rootIndex = -1;\n\n    // Find the root in inorder\n    for (int i = inStart; i <= inEnd; i++) {\n        if (inorder[i] == rootData) {\n            rootIndex = i;\n            break;\n        }\n    }\n\n    // Create the root node\n    Node* root = new Node(rootData);\n\n    // Recursively build the left and right subtrees\n    root->left = buildTree(preorder, inorder, preStart + 1, preStart + (rootIndex - inStart), inStart, rootIndex - 1);\n    root->right = buildTree(preorder, inorder, preStart + (rootIndex - inStart) + 1, preEnd, rootIndex + 1, inEnd);\n\n    return root;\n}\n\n// Function to perform postorder traversal\nvoid postorderTraversal(Node* root) {\n    if (root == nullptr) {\n        return;\n    }\n\n    postorderTraversal(root->left);\n    postorderTraversal(root->right);\n    cout << root->data << \" \";\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> preorder(n), inorder(n);\n\n    // Input preorder and inorder traversals\n    for (int i = 0; i < n; i++) {\n        cin >> preorder[i];\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> inorder[i];\n    }\n\n    // Build the tree\n    Node* root = buildTree(preorder, inorder, 0, n - 1, 0, n - 1);\n\n    // Perform postorder traversal\n    postorderTraversal(root);\n\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 12,
            "mean_time_taken": 0.20706442991892496,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                2,
                12
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Two Knights",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  for (int k = 1; k <= n; k++) {\n    long long total = k * k * (k * k - 1); // Total possible placements\n    long long invalid = 0; // Number of invalid placements\n\n    // Corner cases\n    invalid += 4 * 2; // 4 corners with 2 invalid \"L\" shapes each\n\n    // Edge cases\n    invalid += 4 * (k - 2) * 3; // 4 edges with (k-2) knights each with 3 invalid \"L\" shapes\n\n    // Middle cases\n    invalid += (k - 2) * (k - 2) * 8; // (k-2) * (k-2) middle knights with 8 invalid \"L\" shapes each\n\n    // Correct for double counting\n    invalid /= 2;\n\n    cout << total - invalid << \" \"; \n  }\n\n  cout << endl;\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 3,
            "mean_time_taken": 0.9566885630289713,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Two Sets",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  // Calculate the sum of all numbers\n  int totalSum = n * (n + 1) / 2;\n\n  // If the sum is odd, then the division is not possible\n  if (totalSum % 2 != 0) {\n    cout << \"NO\" << endl;\n    return 0;\n  }\n\n  // Create a vector to store the numbers\n  vector<int> numbers(n);\n  for (int i = 0; i < n; i++) {\n    numbers[i] = i + 1;\n  }\n\n  // Sort the numbers in descending order\n  sort(numbers.begin(), numbers.end(), greater<int>());\n\n  // Initialize the two sets\n  vector<int> set1;\n  vector<int> set2;\n\n  // Divide the numbers into two sets\n  int set1Sum = 0;\n  int set2Sum = 0;\n  for (int i = 0; i < n; i++) {\n    if (set1Sum <= set2Sum) {\n      set1.push_back(numbers[i]);\n      set1Sum += numbers[i];\n    } else {\n      set2.push_back(numbers[i]);\n      set2Sum += numbers[i];\n    }\n  }\n\n  // Print the result\n  cout << \"YES\" << endl;\n  cout << set1.size() << endl;\n  for (int i = 0; i < set1.size(); i++) {\n    cout << set1[i] << \" \";\n  }\n  cout << endl;\n  cout << set2.size() << endl;\n  for (int i = 0; i < set2.size(); i++) {\n    cout << set2[i] << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 20,
            "total_test_cases": 23,
            "mean_time_taken": 0.11601376533508301,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                9,
                16,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Two Sets II",
            "category": "Dynamic Programming",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n;\n    cin >> n;\n\n    // Calculate the total sum\n    int totalSum = n * (n + 1) / 2;\n\n    // Initialize dp table\n    vector<vector<int>> dp(n + 1, vector<int>(totalSum * 2 + 1, 0));\n\n    // Base case\n    dp[0][totalSum] = 1;\n\n    // Dynamic programming\n    for (int i = 1; i <= n; ++i) {\n        for (int j = -totalSum; j <= totalSum; ++j) {\n            if (j + i <= totalSum) {\n                dp[i][j + i] = (dp[i][j + i] + dp[i - 1][j]) % MOD;\n            }\n            if (j - i >= -totalSum) {\n                dp[i][j - i] = (dp[i][j - i] + dp[i - 1][j]) % MOD;\n            }\n        }\n    }\n\n    cout << dp[n][totalSum] << endl;\n    return 0;\n}",
            "passed_test_cases": 10,
            "total_test_cases": 24,
            "mean_time_taken": 0.3370739122231801,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "free(): invalid next size (normal)\n",
                "Failed",
                "Failed",
                "free(): invalid next size (normal)\n",
                "Failed",
                "double free or corruption (out)\n",
                "munmap_chunk(): invalid pointer\n",
                "Failed",
                "double free or corruption (out)\n",
                "Failed",
                "Failed",
                "free(): invalid next size (normal)\n"
            ],
            "failed_test_cases": [
                1,
                3,
                5,
                8,
                10,
                12,
                13,
                14,
                15,
                17,
                18,
                20,
                21,
                24
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Two Stacks Sorting",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<int> input_list(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> input_list[i];\n  }\n\n  stack<int> stack1, stack2;\n  vector<int> output_list;\n\n  for (int num : input_list) {\n    if (stack1.empty() || num >= stack1.top()) {\n      stack1.push(num);\n    } else if (stack2.empty() || num >= stack2.top()) {\n      stack2.push(num);\n    } else {\n      cout << \"IMPOSSIBLE\" << endl;\n      return 0;\n    }\n\n    if (!stack1.empty() && stack1.top() == input_list.front()) {\n      output_list.push_back(stack1.top());\n      stack1.pop();\n    } else if (!stack2.empty() && stack2.top() == input_list.front()) {\n      output_list.push_back(stack2.top());\n      stack2.pop();\n    }\n  }\n\n  for (int i = 0; i < n; ++i) {\n    if (i > 0) {\n      cout << \" \";\n    }\n    if (output_list[i] == stack1.top()) {\n      cout << \"1\";\n      stack1.pop();\n    } else {\n      cout << \"2\";\n      stack2.pop();\n    }\n  }\n\n  cout << endl;\n  return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 14,
            "mean_time_taken": 0.3412824869155884,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13,
                14
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Visiting Cities",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  // Adjacency list to store the flights.\n  vector<vector<pair<int, int>>> adj(n + 1);\n  for (int i = 0; i < m; ++i) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    adj[a].push_back({b, c});\n  }\n\n  // Dijkstra's algorithm to find the shortest path from Syrj\u00e4l\u00e4 (city 1) to Lehm\u00e4l\u00e4 (city n).\n  vector<long long> dist(n + 1, LLONG_MAX);\n  priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\n  dist[1] = 0;\n  pq.push({0, 1});\n\n  while (!pq.empty()) {\n    auto [d, u] = pq.top();\n    pq.pop();\n\n    if (d > dist[u]) {\n      continue;\n    }\n\n    for (auto [v, w] : adj[u]) {\n      if (dist[u] + w < dist[v]) {\n        dist[v] = dist[u] + w;\n        pq.push({dist[v], v});\n      }\n    }\n  }\n\n  // Find the cities that are certainly in the route.\n  vector<int> cities;\n  for (int i = 1; i <= n; ++i) {\n    if (dist[i] != LLONG_MAX) {\n      cities.push_back(i);\n    }\n  }\n\n  // Print the number of cities and the cities in increasing order.\n  cout << cities.size() << endl;\n  sort(cities.begin(), cities.end());\n  for (int city : cities) {\n    cout << city << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 25,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Weird Algorithm",
            "category": "Introductory Problems",
            "solution": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n  long long n;\n  cin >> n;\n\n  cout << n << \" \"; // Print the initial value\n\n  while (n != 1) { // Loop until n becomes 1\n    if (n % 2 == 0) { // If n is even\n      n /= 2;\n    } else { // If n is odd\n      n = n * 3 + 1;\n    }\n    cout << n << \" \"; // Print the current value of n\n  }\n\n  return 0;\n}",
            "passed_test_cases": 14,
            "total_test_cases": 14,
            "mean_time_taken": 0.0954294034412929,
            "mean_memory_used": 0.0,
            "failure_reasons": [],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": true,
            "shots_info": {
                "shot": 1,
                "status": "passed"
            }
        },
        {
            "title": "Word Combinations",
            "category": "String Algorithms",
            "solution": "#include <iostream>\n#include <set>\n#include <string>\n\nusing namespace std;\n\nconst long long MOD = 1e9 + 7;\n\nint main() {\n  string s;\n  cin >> s;\n\n  int k;\n  cin >> k;\n\n  set<string> dict;\n  for (int i = 0; i < k; ++i) {\n    string word;\n    cin >> word;\n    dict.insert(word);\n  }\n\n  int n = s.length();\n  long long dp[n + 1];\n  dp[0] = 1; // Base case: empty string can be formed in one way\n\n  for (int i = 1; i <= n; ++i) {\n    dp[i] = 0; // Initialize dp[i] to 0\n\n    for (auto word : dict) {\n      if (i >= word.length() && s.substr(i - word.length(), word.length()) == word) {\n        // If the word is a prefix of the substring ending at index i-1\n        dp[i] = (dp[i] + dp[i - word.length()]) % MOD;\n      }\n    }\n  }\n\n  cout << dp[n] << endl; // Number of ways to form the entire string\n  return 0;\n}",
            "passed_test_cases": 4,
            "total_test_cases": 6,
            "mean_time_taken": 1.1199456453323364,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                4,
                6
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Writing Numbers",
            "category": "Additional Problems",
            "solution": "#include <iostream>\nusing namespace std;\n\nint main() {\n    long long n;\n    cin >> n;\n\n    long long totalDigits = n * 10;  // Total digits available\n    long long maxOnes = totalDigits; // We can use all digits for '1' initially\n\n    // We need to figure out if we can write all '1's\n    // If not, we have to add '2's\n    long long onesUsed = min(totalDigits, (long long)9 * n); // We can use at most 9 '1's per digit\n    long long twosUsed = totalDigits - onesUsed;   // Remaining digits for '2'\n\n    // Construct the largest number\n    string result = \"\";\n    for (int i = 0; i < onesUsed; i++) {\n        result += '1';\n    }\n    for (int i = 0; i < twosUsed; i++) {\n        result += '2';\n    }\n\n    cout << result << endl;\n    return 0;\n}",
            "passed_test_cases": 0,
            "total_test_cases": 21,
            "mean_time_taken": 0.6342257204509917,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n",
                "Failed",
                "terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        },
        {
            "title": "Xor Pyramid",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n\n  // The topmost number is the xor of all the numbers in the bottom row.\n  int top = 0;\n  for (int i = 0; i < n; i++) {\n    top ^= a[i];\n  }\n\n  cout << top << endl;\n\n  return 0;\n}",
            "passed_test_cases": 1,
            "total_test_cases": 8,
            "mean_time_taken": 0.1179286539554596,
            "mean_memory_used": 0.0,
            "failure_reasons": [
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed",
                "Failed"
            ],
            "failed_test_cases": [
                1,
                2,
                3,
                4,
                6,
                7,
                8
            ],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 26,
            "passed": false,
            "shots_info": {
                "shot": 1,
                "status": "failed"
            }
        }
    ],
    "total_passed_problems": 26,
    "initial_config": {
        "ignore_time_limits": false,
        "model": "gemini-1.5-flash-latest",
        "provider": "google",
        "categories": [],
        "shots": 1
    }
}