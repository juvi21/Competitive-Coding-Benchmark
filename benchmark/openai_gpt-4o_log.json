{
    "problems": [
        {
            "title": "Acyclic Graph Edges",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> adj(n + 1);  // adjacency list for the graph\n    vector<int> in_degree(n + 1, 0); // in-degree of each node\n    vector<pair<int, int>> edges;    // store the edges\n\n    // Read edges and build the undirected graph\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n        edges.push_back({a, b});\n    }\n\n    // Kahn's algorithm for topological sort\n    queue<int> q;\n    vector<int> topo_order;\n\n    // We need to use a visited array for undirected graph to treat it as directed for topological sort\n    vector<bool> visited(n + 1, false);\n\n    for (int i = 1; i <= n; ++i) {\n        if (!visited[i]) {\n            q.push(i);\n            visited[i] = true;\n\n            while (!q.empty()) {\n                int node = q.front();\n                q.pop();\n                topo_order.push_back(node);\n\n                for (int neighbor : adj[node]) {\n                    if (!visited[neighbor]) {\n                        visited[neighbor] = true;\n                        q.push(neighbor);\n                    }\n                }\n            }\n        }\n    }\n\n    // Map to store the position of each node in topo_order\n    vector<int> position(n + 1);\n    for (int i = 0; i < topo_order.size(); ++i) {\n        position[topo_order[i]] = i;\n    }\n\n    // Direct edges according to topological order\n    for (auto edge : edges) {\n        int a = edge.first;\n        int b = edge.second;\n        if (position[a] < position[b]) {\n            cout << a << \" \" << b << endl;\n        } else {\n            cout << b << \" \" << a << endl;\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    solve();\n\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shot": 1
        },
        {
            "title": "Advertisement",
            "category": "Additional Problems",
            "solution": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> heights(n);\n    for (int i = 0; i < n; i++) {\n        cin >> heights[i];\n    }\n\n    stack<int> s;\n    int max_area = 0;\n    int i = 0;\n\n    while (i < n) {\n        if (s.empty() || heights[s.top()] <= heights[i]) {\n            s.push(i++);\n        } else {\n            int tp = s.top();\n            s.pop();\n            int area = heights[tp] * (s.empty() ? i : i - s.top() - 1);\n            max_area = max(max_area, area);\n        }\n    }\n\n    while (!s.empty()) {\n        int tp = s.top();\n        s.pop();\n        int area = heights[tp] * (s.empty() ? i : i - s.top() - 1);\n        max_area = max(max_area, area);\n    }\n\n    cout << max_area << endl;\n    return 0;\n}\n",
            "passed_test_cases": 0,
            "total_test_cases": 0,
            "mean_time_taken": 0,
            "mean_memory_used": 0,
            "failure_reasons": [
                "Compilation failed"
            ],
            "failed_test_cases": [],
            "exceeded_time_count": 0,
            "exceeded_memory_count": 0,
            "total_problems_passed": 0,
            "passed": false,
            "shot": 1
        }
    ],
    "total_passed_problems": 0,
    "initial_config": {
        "ignore_time_limits": false,
        "model": "gpt-4o",
        "provider": "openai",
        "categories": [],
        "shots": 1
    }
}